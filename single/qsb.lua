Lib = {
    Loader = {
        Paths = {
            -- Search in script directory
            "script/",
        },

        Version = "LIB 1.0.3",
        Root = "libertica",
        IsLocalEnv = GUI ~= nil,
        IsHistoryEdition = false,

        Sources = {},
        Loaded = {},
    },
};
-- Prevent the null reference bug
if Framework and Network then
    -- Search for files in map file
    local Name = Framework.GetCurrentMapName();
    table.insert(Lib.Loader.Paths, 1, "maps/externalmap/" ..Name.. "/");
    -- Check for History Edition
    Lib.Loader.IsHistoryEdition = Network.IsNATReady ~= nil;
end

API = {};
QSB = {};

--- @diagnostic disable: cast-local-type
--- @diagnostic disable: duplicate-set-field
--- @diagnostic disable: missing-return-value

function Lib.Loader.PushPath(_Path)
end

function Lib.Loader.Require(_Path)
end
Lib.Require = Lib.Loader.Require;

function Lib.Loader.Register(_Path)
end
Lib.Register = Lib.Loader.Register;

function Lib.Loader.LoadSourceFile(_Source, _Path)
end

Lib.Register("comfort/CopyTable");

function CopyTable(_Source, _Dest)
    local Result = _Dest or {};
    assert(type(_Source) == "table", "CopyTable: Source is nil!");
    assert(type(Result) == "table");
    -- Amend array part
    local LastIndex = 0;
    for i= 1, #_Source do
        LastIndex = LastIndex + 1;
        if type(_Source[i]) == "table" then
            table.insert(Result, CopyTable(_Source[i]));
        else
            table.insert(Result, _Source[i]);
        end
    end
    -- Overwrite associative part
    for k,v in pairs(_Source) do
        if type(k) == "number" then
            if k <= 0 or k > LastIndex then
                if type(v) == "table" then
                    Result[k] = Result[k] or CopyTable(v);
                else
                    Result[k] = Result[k] or v;
                end
            end
        else
            if type(v) == "table" then
                Result[k] = Result[k] or CopyTable(v);
            else
                Result[k] = Result[k] or v;
            end
        end
    end
    return Result;
end
API.CopyTable = CopyTable;

Lib.Register("comfort/GetCategoriesOfType");

function GetCategoriesOfType(_Type)
    local Categories = {};
    for k, v in pairs(EntityCategories) do
        if Logic.IsEntityTypeInCategory(_Type, v) == 1 then
            table.insert(Categories, v);
        end
    end
    return Categories;
end

Lib.Require("comfort/GetCategoriesOfType");
Lib.Register("comfort/GetCategoriesOfEntity");

function GetCategoriesOfEntity(_Entity)
    local Type = Logic.GetEntityType(_Entity);
    return GetCategoriesOfType(Type);
end

Lib.Register("comfort/GetActivePlayers");

function GetActivePlayers()
    local PlayerList = {};
    for i= 1, 8 do
        if Network.IsNetworkSlotIDUsed(i) then
            local PlayerID = Logic.GetSlotPlayerID(i);
            if Logic.PlayerGetIsHumanFlag(PlayerID) and Logic.PlayerGetGameState(PlayerID) ~= 0 then
                table.insert(PlayerList, PlayerID);
            end
        end
    end
    return PlayerList;
end
API.GetActivePlayers = GetActivePlayers;

Lib.Require("comfort/GetActivePlayers");
Lib.Register("comfort/GetDelayedPlayers");

function GetDelayedPlayers()
    local PlayerList = {};
    for k, v in pairs(GetActivePlayers()) do
        if Network.IsWaitingForNetworkSlotID(API.GetPlayerSlotID(v)) then
            table.insert(PlayerList, v);
        end
    end
    return PlayerList;
end
API.GetDelayedPlayers = GetDelayedPlayers;

Lib.Register("comfort/GetPlayerAtSlot");

function GetPlayerAtSlot(_SlotID)
    if Network.IsNetworkSlotIDUsed(_SlotID) then
        local CurrentPlayerID = Logic.GetSlotPlayerID(_SlotID);
        if Logic.PlayerGetIsHumanFlag(CurrentPlayerID)  then
            return CurrentPlayerID;
        end
    end
    return 0;
end
API.GetSlotPlayerID = GetPlayerAtSlot;

Lib.Register("comfort/GetSoldiersOfGroup");

function GetSoldiersOfGroup(_Leader)
    local SoldierList = {};
    local EntityID = GetID(_Leader);
    assert(EntityID ~= 0, "Entity does not exist.");
    if Logic.IsLeader(EntityID) == 1 then
        local SoldierTable = {Logic.GetSoldiersAttachedToLeader(EntityID)};
        for i= 2, SoldierTable[1]+1 do
            table.insert(SoldierList, SoldierTable[i]);
        end
    end
    return SoldierList;
end
API.GetSoldiersOfGroup = GetSoldiersOfGroup;

Lib.Register("comfort/IsLocalScript");

function IsLocalScript()
    return GUI ~= nil;
end
API.IsLocalScript = IsLocalScript;

Lib.Register("comfort/KeyOf");

function KeyOf(_wert, _table)
    if _table == nil then
        return false;
    end
    for k, v in pairs(_table) do
        if v == _wert then
            return k;
        end
    end
end
API.KeyOf = KeyOf;

Lib.Register("comfort/ToBoolean");

function ToBoolean(_Input)
    if type(_Input) == "boolean" then
        return _Input;
    end
    if type(_Input) == "number" then
        return _Input == 1;
    end
    if string.find(string.lower(tostring(_Input)), "^[1tjy\\+].*$") then
        return true;
    end
    return false;
end
API.ToBoolean = ToBoolean;

Lib.Register("comfort/DumpTable");

function DumpTable(_Table, _Name)
    local Start = "{";
    if _Name then
        Start = _Name.. " = \n" ..Start;
    end
    Framework.WriteToLog(Start);

    for k, v in pairs(_Table) do
        if type(v) == "table" then
            Framework.WriteToLog("[" ..k.. "] = ");
            DumpTable(v);
        elseif type(v) == "string" then
            Framework.WriteToLog("[" ..k.. "] = \"" ..v.. "\"");
        else
            Framework.WriteToLog("[" ..k.. "] = " ..tostring(v));
        end
    end
    Framework.WriteToLog("}");
end
API.DumpTable = DumpTable;

Lib.Register("comfort/GetPosition");

function GetPosition(_Entity)
    if not _Entity then
        return {X= 0, Y= 0, Z= 0};
    end
    if type(_Entity) == "table" and _Entity.X and _Entity.Y then
        _Entity.Z = _Entity.Z or 0;
        return _Entity;
    end
    assert(IsExisting(_Entity), "Entity does not exist.");
    local x, y, z = Logic.EntityGetPos(GetID(_Entity));
    return {X= x, Y= y, Z= z};
end
API.GetPosition = GetPosition;

Lib.Require("comfort/GetPosition");
Lib.Register("comfort/GetDistance");

function GetDistance(_Pos1, _Pos2, _NoSqrt)
    if (type(_Pos1) == "string") or (type(_Pos1) == "number") then
        _Pos1 = GetPosition(_Pos1);
    end
    if (type(_Pos2) == "string") or (type(_Pos2) == "number") then
        _Pos2 = GetPosition(_Pos2);
    end
    assert(type(_Pos1) == "table", "Invalid frist position.");
    assert(type(_Pos2) == "table", "Invalid second position.");
    local xDistance = (_Pos1.X - _Pos2.X);
    local yDistance = (_Pos1.Y - _Pos2.Y);
    if _NoSqrt then
        return (xDistance^2) + (yDistance^2);
    end
    return math.sqrt((xDistance^2) + (yDistance^2));
end
API.GetDistance = GetDistance;

Lib.Register("comfort/IsMultiplayer");

function IsMultiplayer()
    return Framework.IsNetworkGame();
end
API.IsMultiplayer = IsMultiplayer;

Lib.Register("comfort/IsValidPosition");

function IsValidPosition(_Pos)
    if type(_Pos) == "table" then
        if (_Pos.X ~= nil and type(_Pos.X) == "number") and (_Pos.Y ~= nil and type(_Pos.Y) == "number") then
            local world = {Logic.WorldGetSize()};
            if not _Pos.Z or _Pos.Z >= 0 then
                if _Pos.X < world[1] and _Pos.X > 0 and _Pos.Y < world[2] and _Pos.Y > 0 then
                    return true;
                end
            end
        end
    end
    return false;
end
API.IsValidPosition = IsValidPosition;

Lib.Require("comfort/IsValidPosition");
Lib.Register("comfort/GetCirclePosition");

function GetCirclePosition(_Target, _Distance, _Angle)
    if not IsValidPosition(_Target) and not IsExisting(_Target) then
        error(false, "Target does not exist or is invalid position!");
    end

    local Position = _Target;
    local Orientation = 0+ (_Angle or 0);
    if type(_Target) ~= "table" then
        local EntityID = GetID(_Target);
        Orientation = Logic.GetEntityOrientation(EntityID)+(_Angle or 0);
        Position = GetPosition(EntityID);
    end

    local Result = {
        X= Position.X+_Distance * math.cos(math.rad(Orientation)),
        Y= Position.Y+_Distance * math.sin(math.rad(Orientation)),
        Z= Position.Z
    };
    return Result;
end
API.GetRelatiePos = GetCirclePosition;

Lib.Require("comfort/GetPosition");
Lib.Register("comfort/GetGeometricFocus");

function GetGeometricFocus(...)
    local arg = {...}
    local PositionData = {X= 0, Y= 0, Z= 0};
    local ValidEntryCount = 0;
    for i= 1, #arg do
        local Position = GetPosition(arg[i]);
        if Position then
            PositionData.X = PositionData.X + Position.X;
            PositionData.Y = PositionData.Y + Position.Y;
            PositionData.Z = PositionData.Z + (Position.Z or 0);
            ValidEntryCount = ValidEntryCount +1;
        end
    end
    return {
        X= PositionData.X * (1/ValidEntryCount);
        Y= PositionData.Y * (1/ValidEntryCount);
        Z= PositionData.Z * (1/ValidEntryCount);
    }
end
API.GetGeometricFocus = GetGeometricFocus;

Lib.Register("comfort/GetSiegecartTypeByEngineType");

if Entities then
    CONST_CART_TO_ENGINE = {
        [Entities.U_MilitaryBatteringRam] = Entities.U_BatteringRamCart,
        [Entities.U_MilitaryCatapult] = Entities.U_CatapultCart,
        [Entities.U_MilitarySiegeTower] = Entities.U_SiegeTowerCart,
        -- TODO: Add CP types
    };
end

function GetSiegecartTypeByEngineType(_Type)
    return CONST_CART_TO_ENGINE[_Type];
end

Lib.Register("comfort/GetTerritoryID");

function GetTerritoryID(_Name)
    for _, TerritoryID in ipairs{Logic.GetTerritories()} do
        if _Name == Logic.GetTerritoryName(TerritoryID) then
            return TerritoryID;
        end
    end
    return 0;
end
API.GetTerritoryID = GetTerritoryID;

Lib.Register("comfort/IsHistoryEdition");

function IsHistoryEdition()
    return Network.IsNATReady ~= nil;
end
API.IsHistoryEdition = IsHistoryEdition;

Lib.Register("comfort/IsMultiplayerReady");

function IsMultiplayerReady()
    return Framework.IsNetworkGame() and Network.SessionHaveAllPlayersFinishedLoading() == true;
end
API.IsMultiplayerReady = IsMultiplayerReady;

Lib.Register("comfort/Round");

function Round(_Value, _Decimals)
    _Decimals = math.ceil(_Decimals or 0);
    if _Decimals <= 0 then
        return math.floor(_Value + 0.5);
    end
    return tonumber(string.format("%." .._Decimals.. "f", _Value));
end
API.Round = Round;

Lib.Require("comfort/GetPosition");
Lib.Register("comfort/GetAngleBetween");

function GetAngleBetween(_Pos1, _Pos2)
	local delta_X = 0;
	local delta_Y = 0;
	local alpha   = 0;
	if type (_Pos1) == "string" or type (_Pos1) == "number" then
		_Pos1 = GetPosition(GetID(_Pos1));
	end
	if type (_Pos2) == "string" or type (_Pos2) == "number" then
		_Pos2 = GetPosition(GetID(_Pos2));
	end
    assert(_Pos1 ~= nil);
    assert(_Pos2 ~= nil);
	delta_X = _Pos1.X - _Pos2.X;
	delta_Y = _Pos1.Y - _Pos2.Y;
	if delta_X == 0 and delta_Y == 0 then
		return 0;
	end
	alpha = math.deg(math.asin(math.abs(delta_X)/(math.sqrt((delta_X % 2)+(delta_Y % 2)))));
	if delta_X >= 0 and delta_Y > 0 then
		alpha = 270 - alpha ;
	elseif delta_X < 0 and delta_Y > 0 then
		alpha = 270 + alpha;
	elseif delta_X < 0 and delta_Y <= 0 then
		alpha = 90  - alpha;
	elseif delta_X >= 0 and delta_Y <= 0 then
		alpha = 90  + alpha;
	end
	return alpha;
end
API.GetAngleBetween = GetAngleBetween;

Lib.Require("comfort/GetDistance");
Lib.Register("comfort/GetClosestToTarget");

function GetClosestToTarget(_Target, _List)
    local ClosestToTarget = 0;
    local ClosestToTargetDistance = Logic.WorldGetSize() ^ 2;
    for i= 1, #_List, 1 do
        assert(type(_List[i]) ~= "table", "Invalid entity.");
        local DistanceBetween = GetDistance(_List[i], _Target, true);
        if DistanceBetween < ClosestToTargetDistance then
            ClosestToTargetDistance = DistanceBetween;
            ClosestToTarget = _List[i];
        end
    end
    return ClosestToTarget;
end
API.GetClosestToTarget = GetClosestToTarget;

Lib.Register("comfort/GetHealth");

function GetHealth(_Entity)
    local EntityID = GetID(_Entity);
    if IsExisting(EntityID) then
        local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
        local Health    = Logic.GetEntityHealth(EntityID);
        return (Health/MaxHealth) * 100;
    end
    return 0;
end
API.GetHealth = GetHealth;

Lib.Register("comfort/GetSiegeengineTypeByCartType");

if Entities then
    CONST_CART_TO_ENGINE = {
        [Entities.U_BatteringRamCart] = Entities.U_MilitaryBatteringRam,
        [Entities.U_CatapultCart] = Entities.U_MilitaryCatapult,
        [Entities.U_SiegeTowerCart] = Entities.U_MilitarySiegeTower,
        -- TODO: Add CP types
    };
end

function GetSiegeengineTypeByCartType(_Type)
    return CONST_CART_TO_ENGINE[_Type];
end

Lib.Require("comfort/GetAngleBetween");
Lib.Require("comfort/GetDistance");
Lib.Register("comfort/IsInCone");

function IsInCone(_Target, _Center, _Length, _Rotation, _Width)
    local Distance = GetDistance(_Center, _Target)
    if Distance > _Length then
        return false;
    end
    local a = GetAngleBetween(_Center, _Target);
    local lb = _Rotation - _Width;
    local hb = _Rotation + _Width;
    return a >= lb and a <= hb;
end
API.IsInCone = IsInCone;

Lib.Register("comfort/SerializeTable");

function SerializeTable(_Table)
    local String = "{";
    for k, v in pairs(_Table) do
        local key = (type(k) == "string" and k) or ("[" .. k .. "]");
        if type(v) == "table" then
            String = String .. key .. " = " .. SerializeTable(v) .. ", ";
        elseif type(v) == "number" then
            String = String .. key .. " = " .. v .. ", ";
        elseif type(v) == "string" then
            String = String .. key .. " = \"" .. v .. "\", ";
        elseif type(v) == "boolean" or type(v) == "nil" then
            String = String .. key .. " = " .. tostring(v) .. ", ";
        else
            String = String .. key .. " = \"" .. tostring(v) .. "\", ";
        end
    end
    String = String .. "}";
    return String;
end
API.SerializeTable = SerializeTable;

Lib.Register("comfort/CreateCartByGoodType");

function CreateCartByGoodType(_PlayerID, _Position, _GoodType, _Orientation, _CartOverlay)
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    _Orientation = _Orientation or 0;
    local ID = 0;
    local Position = GetID(_Position);
    assert(Position ~= 0, "Entity does not exist.");

    local x,y,z = Logic.EntityGetPos(Position);
    if Logic.IsBuilding(Position) == 1 then
        x,y = Logic.GetBuildingApproachPosition(Position);
        _Orientation = Logic.GetEntityOrientation(Position)-90;
    end

    local ResourceCategory = Logic.GetGoodCategoryForGoodType(_GoodType);
    if ResourceCategory == GoodCategories.GC_Resource then
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_ResourceMerchant, x, y, _Orientation, _PlayerID);
    elseif _GoodType == Goods.G_Medicine then
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Medicus, x, y, _Orientation,_PlayerID);
    elseif _GoodType == Goods.G_Gold or _GoodType == Goods.G_None or _GoodType == Goods.G_Information then
        if _CartOverlay then
            ID = Logic.CreateEntityOnUnblockedLand(_CartOverlay, x, y, _Orientation, _PlayerID);
        else
            ID = Logic.CreateEntityOnUnblockedLand(Entities.U_GoldCart, x, y, _Orientation, _PlayerID);
        end
    else
        ID = Logic.CreateEntityOnUnblockedLand(Entities.U_Marketer, x, y, _Orientation, _PlayerID);
    end
    return ID;
end
API.CreateCartByGoodType = CreateCartByGoodType;

Lib.Register("comfort/CreateEntityName");

CreateEntityName_Sequence_ID = 0;

function CreateEntityName(_EntityID)
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    if type(_EntityID) == "string" then
        return _EntityID;
    else
        assert(type(_EntityID) == "number", "Invalid entity ID.");
        local name = Logic.GetEntityName(_EntityID);
        if (type(name) ~= "string" or name == "" ) then
            CreateEntityName_Sequence_ID = CreateEntityName_Sequence_ID + 1;
            name = "AutomaticScriptName_"..CreateEntityName_Sequence_ID;
            Logic.SetEntityName(_EntityID, name);
        end
        return name;
    end
end
API.CreateEntityName = CreateEntityName;

Lib.Register("comfort/CreateStock");

function CreateStock(_PlayerID, _GoodType)
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    local ResourceCategory = Logic.GetGoodCategoryForGoodType(_GoodType);
    if ResourceCategory == GoodCategories.GC_Resource or _GoodType == Goods.G_None then
        local StoreID = Logic.GetStoreHouse(_PlayerID);
        local CastleID = Logic.GetHeadquarters(_PlayerID);
        if StoreID ~= 0 and Logic.GetIndexOnInStockByGoodType(StoreID, _GoodType) == -1 then
            if _GoodType ~= Goods.G_Gold or (_GoodType == Goods.G_Gold and CastleID == 0) then
                Logic.AddGoodToStock(StoreID, _GoodType, 0, true, true);
            end
        end
    end
end
API.CreateStock = CreateStock;

Lib.Register("comfort/GetQuestID");

function GetQuestID(_Name)
    if type(_Name) == "number" then
        return _Name;
    end
    for k, v in pairs(Quests) do
        if v and k > 0 then
            if v.Identifier == _Name then
                return k;
            end
        end
    end
    return -1;
end
API.GetQuestID = GetQuestID;

Lib.Register("comfort/GetRandomSettlerType");

CONST_RANDOM_SETTLER_TYPES = {
    Male = {
        Entities.U_BannerMaker,
        Entities.U_Baker,
        Entities.U_Barkeeper,
        Entities.U_Blacksmith,
        Entities.U_Butcher,
        Entities.U_BowArmourer,
        Entities.U_BowMaker,
        Entities.U_CandleMaker,
        Entities.U_Carpenter,
        Entities.U_DairyWorker,
        Entities.U_Pharmacist,
        Entities.U_Tanner,
        Entities.U_SmokeHouseWorker,
        Entities.U_Soapmaker,
        Entities.U_SwordSmith,
        Entities.U_Weaver,
    },
    Female = {
        Entities.U_BathWorker,
        Entities.U_SpouseS01,
        Entities.U_SpouseS02,
        Entities.U_SpouseS03,
        Entities.U_SpouseF01,
        Entities.U_SpouseF02,
        Entities.U_SpouseF03,
    }
}

function GetRandomSettlerType()
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    local Gender = (math.random(1, 2) == 1 and "Male") or "Female";
    local Type   = math.random(1, #CONST_RANDOM_SETTLER_TYPES[Gender]);
    return CONST_RANDOM_SETTLER_TYPES[Gender][Type];
end
API.GetRandomSettlerType = GetRandomSettlerType;

function GetRandomMaleSettlerType()
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    local Type = math.random(1, #CONST_RANDOM_SETTLER_TYPES.Male);
    return CONST_RANDOM_SETTLER_TYPES.Male[Type];
end
API.GetRandomMaleSettlerType = GetRandomMaleSettlerType;

function GetRandomFemaleSettlerType()
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    local Type = math.random(1, #CONST_RANDOM_SETTLER_TYPES.Female);
    return CONST_RANDOM_SETTLER_TYPES.Female[Type];
end
API.GetRandomFemaleSettlerType = GetRandomFemaleSettlerType;

Lib.Require("comfort/GetQuestID");
Lib.Register("comfort/IsValidQuest");

function IsValidQuest(_QuestID)
    return Quests[_QuestID] ~= nil or Quests[GetQuestID(_QuestID)] ~= nil;
end
API.IsValidQuest = IsValidQuest;

Lib.Register("comfort/IsValidQuestName");

CONST_REGEX_QUEST_NAME = "^[A-Za-z0-9_ @ÄÖÜäöüß]+$";

function IsValidQuestName(_Name)
    return string.find(_Name, CONST_REGEX_QUEST_NAME) ~= nil;
end
API.IsValidQuestName = IsValidQuestName;

Lib.Require("comfort/IsValidPosition");
Lib.Register("comfort/LookAt");

function LookAt(_Entity, _Target)
    local ID1 = GetID(_Entity);
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    assert(ID1 ~= 0, "Looking entity does not exist!");
    local x1,y1,z1 = Logic.EntityGetPos(ID1);
    local ID2;
    local x2, y2, z2;
    if type(_Target) == "table" then
        x2 = _Target.X;
        y2 = _Target.Y;
        z2 = _Target.Z;
    else
        ID2 = GetID(_Target);
        assert(ID2 ~= 0, "Target entity does not exist!");
        x2,y2,z2 = Logic.EntityGetPos(ID2);
    end

    assert(IsValidPosition({X= x1, Y= y1, Z= z1}), "Invalid looking position!");
    assert(IsValidPosition({X= x2, Y= y2, Z= z2}), "Invalid target position!");
    Angle = math.deg(math.atan2((y2 - y1), (x2 - x1)));
    Angle = (Angle < 0 and Angle + 360) or Angle;

    if Logic.IsLeader(ID1) == 1 then
        local Soldiers = {Logic.GetSoldiersAttachedToLeader(ID1)};
        for i= 2, Soldiers[1]+1 do
            Logic.SetOrientation(Soldiers[i], Angle);
        end
    end
    Logic.SetOrientation(ID1, Angle);
end
API.LookAt = LookAt;

Lib.Register("comfort/Move");

function Move(_Entity, _Target, _IgnoreBlocking)
    local ID = GetID(_Entity);
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    assert(ID ~= 0, "Moving entity does not exist!");

    local Target;
    if type(_Target) ~= "table" then
        local ID2 = GetID(_Target);
        local x,y,z = Logic.EntityGetPos(ID2);
        Target = {X= x, Y= y};
    else
        Target = _Target;
    end

    if _IgnoreBlocking then
        Logic.MoveEntity(ID, Target.X, Target.Y);
        if Logic.IsSettler(ID) == 1 then
            Logic.SetTaskList(ID, TaskLists.TL_NPC_WALK);
        end
    else
        Logic.MoveSettler(ID, Target.X, Target.Y);
    end

    StartSimpleJobEx(function(_ID, _Target)
        if not IsExisting(_ID) then
            return true;
        end
        if Logic.IsEntityMoving(_ID) == false then
            if Logic.IsSettler(_ID) == 1 then
                Logic.SetTaskList(_ID, TaskLists.TL_NPC_IDLE);
            end
            return true;
        end
    end, ID, Target);
end
API.Move = Move;

Lib.Register("comfort/ReplaceEntity");

function ReplaceEntity(_Entity, _Type, _NewOwner)
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    local ID1 = GetID(_Entity);
    if ID1 == 0 then
        return 0;
    end
    local pos = GetPosition(ID1);
    local player = _NewOwner or Logic.EntityGetPlayer(ID1);
    local orientation = Logic.GetEntityOrientation(ID1);
    local name = Logic.GetEntityName(ID1);
    DestroyEntity(ID1);
    local ID2 = Logic.CreateEntity(_Type, pos.X, pos.Y, orientation, player);
    Logic.SetEntityName(ID2, name);
    if Logic.IsSettler(ID2) == 1 then
        Logic.SetTaskList(ID2, TaskLists.TL_NPC_IDLE);
    end
    return ID2;
end
API.ReplaceEntity = ReplaceEntity;

Lib.Require("comfort/CreateStock");
Lib.Require("comfort/CreateCartByGoodType");
Lib.Register("comfort/SendCart");

function SendCart(_Position, _PlayerID, _GoodType, _Amount, _CartOverlay, _IgnoreReservation, _Overtake)
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    local OriginalID = GetID(_Position);
    if not IsExisting(OriginalID) then
        return 0;
    end
    local Orientation = Logic.GetEntityOrientation(OriginalID);
    local ScriptName = Logic.GetEntityName(OriginalID);
    local ID = CreateCartByGoodType(_PlayerID, OriginalID, _GoodType, Orientation, _CartOverlay);
    assert(ID ~= 0, "Cart was not created properly.");
    CreateStock(_PlayerID, _GoodType);
    Logic.HireMerchant(ID, _PlayerID, _GoodType, _Amount, _PlayerID, _IgnoreReservation);
    if _Overtake and Logic.IsBuilding(OriginalID) == 0 then
        Logic.SetEntityName(ID, ScriptName);
        DestroyEntity(OriginalID);
    end
    return ID;
end
API.SendCart = SendCart;

Lib.Register("comfort/SetHealth");

function SetHealth(_Entity, _Health)
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    assert(type(_Health) == "number" and _Health >= 0);

    local EntityID = GetID(_Entity);
    assert(EntityID ~= 0, "Entity does not exist.");
    assert(Logic.IsLeader(EntityID) == 0, "Can not be used on groups.");
    local MaxHealth = Logic.GetEntityMaxHealth(EntityID);
    local Health = math.max(math.min(_Health, MaxHealth), 0);
    local OldHealth = Logic.GetEntityHealth(EntityID);
    local NewHealth = math.ceil((MaxHealth) * (Health/100));

    if NewHealth > OldHealth then
        Logic.HealEntity(EntityID, NewHealth - OldHealth);
    elseif NewHealth < OldHealth then
        Logic.HurtEntity(EntityID, OldHealth - NewHealth);
    end
end
API.SetHealth = SetHealth;

Lib.Require("comfort/GetSoldiersOfGroup");
Lib.Require("comfort/GetPosition");
Lib.Require("comfort/IsValidPosition");
Lib.Register("comfort/SetPosition");

function SetPosition(_Entity, _Target)
    assert(Lib.Loader.IsLocalEnv == false, "Can only be used in global script.");
    local ID = GetID(_Entity);
    if not ID then
        return;
    end
    local Target = GetPosition(_Target);
    assert(IsValidPosition(Target), "Invalid position.");
    for k,v in pairs(GetSoldiersOfGroup(ID)) do
        SetPosition(v, _Target);
    end
    Logic.DEBUG_SetSettlerPosition(ID, Target.X, Target.Y);
end
API.SetPosition = SetPosition;

Lib.Register("core/QSB");

--- @diagnostic disable: cast-local-type
--- @diagnostic disable: duplicate-set-field
--- @diagnostic disable: missing-return-value

ParameterType = ParameterType or {};
Report = Report or {};

g_QuestBehaviorVersion = 1;
g_QuestBehaviorTypes = {};

g_GameExtraNo = 0;
if Framework then
    g_GameExtraNo = Framework.GetGameExtraNo();
elseif MapEditor then
    g_GameExtraNo = MapEditor.GetGameExtraNo();
end

function LoadBehaviors()
    for i= 1, #g_QuestBehaviorTypes, 1 do
        local Behavior = g_QuestBehaviorTypes[i];

        if not _G["B_" .. Behavior.Name].new then
            _G["B_" .. Behavior.Name].new = function(self, ...)
                local parameter = {...};
                local behavior = table.copy(self);
                -- Raw parameters
                behavior.i47ya_6aghw_frxil = {};
                -- Overhead parameters
                behavior.v12ya_gg56h_al125 = {};
                for j= 1, #parameter, 1 do
                    table.insert(behavior.v12ya_gg56h_al125, parameter[j]);
                    if self.Parameter and self.Parameter[j] ~= nil then
                        behavior:AddParameter(j-1, parameter[j]);
                    else
                        table.insert(behavior.i47ya_6aghw_frxil, parameter[j]);
                    end
                end
                return behavior;
            end
        end
    end
end

function RegisterBehavior(_Behavior)
    if GUI ~= nil then
        return;
    end
    if type(_Behavior) ~= "table" or _Behavior.Name == nil then
        assert(false, "Behavior is invalid!");
        return;
    end
    if _Behavior.RequiresExtraNo and _Behavior.RequiresExtraNo > g_GameExtraNo then
        return;
    end
    if not _G["B_" .. _Behavior.Name] then
        error(string.format("Behavior %s does not exist!", _Behavior.Name));
        return;
    end

    for i= 1, #g_QuestBehaviorTypes, 1 do
        if g_QuestBehaviorTypes[i].Name == _Behavior.Name then
            return;
        end
    end
    table.insert(g_QuestBehaviorTypes, _Behavior);
end

if not MapEditor and GUI then
    return;
end

Lib.Register("core/Core_Behavior");

function Reward_DEBUG(_Assertions, _CheckAtRun, _DevelopingCheats, _DevelopingShell, _TraceQuests)
    return B_Reward_DEBUG:new(_Assertions, _CheckAtRun, _DevelopingCheats, _DevelopingShell, _TraceQuests);
end

B_Reward_DEBUG = {
    Name = "Reward_DEBUG",
    Description = {
        en = "Reward: Start the debug mode. See documentation for more information.",
        de = "Lohn: Startet den Debug-Modus. Für mehr Informationen siehe Dokumentation.",
        fr = "Récompense: Démarre le mode de débug. Pour plus d'informations, voir la documentation.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Activate script errors",     de = "Skriptfeleranzeige nutzen",  fr = "Afficher les erreurs de script" },
        { ParameterType.Custom, en = "Check quest while runtime",  de = "Quests zur Laufzeit prüfen", fr = "Vérifier les quêtes au cours de l'exécution" },
        { ParameterType.Custom, en = "Activate developing cheats", de = "Cheats aktivieren",          fr = "Activer les cheats" },
        { ParameterType.Custom, en = "Activate developing shell",  de = "Eingabe aktivieren",         fr = "Activer la saisie" },
        { ParameterType.Custom, en = "Use quest trace",            de = "Questverfolgung",            fr = "Suivi de quête" },
    },
}

function B_Reward_DEBUG:GetRewardTable(_Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

function B_Reward_DEBUG:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.DisplayScriptErrors = ToBoolean(_Parameter);
    elseif (_Index == 1) then
        self.CheckWhileRuntime = ToBoolean(_Parameter);
    elseif (_Index == 2) then
        self.DevelopingCheats = ToBoolean(_Parameter);
    elseif (_Index == 3) then
        self.DevelopingShell = ToBoolean(_Parameter);
    elseif (_Index == 4) then
        self.UseQuestTrace = ToBoolean(_Parameter);
    end
end

function B_Reward_DEBUG:CustomFunction(_Quest)
    ActivateDebugMode(self.DisplayScriptErrors, self.CheckWhileRuntime, self.DevelopingCheats, self.DevelopingShell, self.UseQuestTrace );
end

function B_Reward_DEBUG:GetCustomData(_Index)
    return {"true","false"};
end

RegisterBehavior(B_Reward_DEBUG);

-- -------------------------------------------------------------------------- --

function Goal_ActivateObject(...)
    return B_Goal_ActivateObject:new(...);
end

B_Goal_ActivateObject = {
    Name = "Goal_ActivateObject",
    Description = {
        en = "Goal: Activate an interactive object",
        de = "Ziel: Aktiviere ein interaktives Objekt",
        fr = "Objectif: activer un objet interactif",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Object name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_ActivateObject:GetGoalTable()
    return {Objective.Object, { self.ScriptName } }
end

function B_Goal_ActivateObject:AddParameter(_Index, _Parameter)
   if _Index == 0 then
        self.ScriptName = _Parameter
   end
end

function B_Goal_ActivateObject:GetMsgKey()
    return "Quest_Object_Activate"
end

RegisterBehavior(B_Goal_ActivateObject);

-- -------------------------------------------------------------------------- --

function Goal_Deliver(...)
    return B_Goal_Deliver:new(...)
end

B_Goal_Deliver = {
    Name = "Goal_Deliver",
    Description = {
        en = "Goal: Deliver goods to quest giver or to another player.",
        de = "Ziel: Liefere Waren zum Auftraggeber oder zu einem anderen Spieler.",
        fr = "Objectif: livrer des marchandises au mandant ou à un autre joueur.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type of good", de = "Ressourcentyp", fr = "Type de ressources" },
        { ParameterType.Number, en = "Amount of good", de = "Ressourcenmenge", fr = "Quantité de ressources" },
        { ParameterType.Custom, en = "To different player", de = "Anderer Empfänger", fr = "Autre bénéficiaire" },
        { ParameterType.Custom, en = "Ignore capture", de = "Abfangen ignorieren", fr = "Ignorer une interception" },
    },
}

function B_Goal_Deliver:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Deliver, GoodType, self.GoodAmount, self.OverrideTarget, self.IgnoreCapture }
end

function B_Goal_Deliver:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    elseif (_Index == 2) then
        self.OverrideTarget = tonumber(_Parameter)
    elseif (_Index == 3) then
        self.IgnoreCapture = ToBoolean(_Parameter)
    end
end

function B_Goal_Deliver:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        table.insert( Data, "-" )
        for i = 1, 8 do
            table.insert( Data, i )
        end
    elseif _Index == 3 then
        table.insert( Data, "true" )
        table.insert( Data, "false" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_Deliver:GetMsgKey()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    local GC = Logic.GetGoodCategoryForGoodType( GoodType )

    local tMapping = {
        [GoodCategories.GC_Clothes] = "Quest_Deliver_GC_Clothes",
        [GoodCategories.GC_Entertainment] = "Quest_Deliver_GC_Entertainment",
        [GoodCategories.GC_Food] = "Quest_Deliver_GC_Food",
        [GoodCategories.GC_Gold] = "Quest_Deliver_GC_Gold",
        [GoodCategories.GC_Hygiene] = "Quest_Deliver_GC_Hygiene",
        [GoodCategories.GC_Medicine] = "Quest_Deliver_GC_Medicine",
        [GoodCategories.GC_Water] = "Quest_Deliver_GC_Water",
        [GoodCategories.GC_Weapon] = "Quest_Deliver_GC_Weapon",
        [GoodCategories.GC_Resource] = "Quest_Deliver_Resources",
    }

    if GC then
        local Key = tMapping[GC]
        if Key then
            return Key
        end
    end
    return "Quest_Deliver_Goods"
end

RegisterBehavior(B_Goal_Deliver);

-- -------------------------------------------------------------------------- --

function Goal_Diplomacy(...)
    return B_Goal_Diplomacy:new(...);
end

B_Goal_Diplomacy = {
    Name = "Goal_Diplomacy",
    Description = {
        en = "Goal: A diplomatic state must b reached. Can be lower than current state or higher.",
        de = "Ziel: Die Beziehungen zu einem Spieler müssen entweder verbessert oder verschlechtert werden.",
        fr = "Objectif: les relations avec un joueur doivent être soit améliorées, soit détériorées.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Party", de = "Partei", fr = "Faction" },
        { ParameterType.Custom,   en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Custom,   en = "Diplomacy state", de = "Diplomatische Beziehung", fr = "Relations diplomatiques" },
    },
    TextPattern = {
        de = "DIPLOMATIESTATUS ERREICHEN {cr}{cr}Status: %s{cr}Zur Partei: %s",
        en = "DIPLOMATIC STATE {cr}{cr}State: %s{cr}To player: %s",
        fr = "ATTEINDRE LE STATUT DE DIPLOMATIQUE {cr}{cr}Statut : %s{cr}Avec la faction : %s",
    },
}

function B_Goal_Diplomacy:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_Diplomacy:GetDiplomacyMapping()
    return {
        [DiplomacyStates.Allied]             = {de = "Verbündeter",    en = "Allied",               fr = "Allié"},
        [DiplomacyStates.TradeContact]       = {de = "Handelspartner", en = "Trade Contact",        fr = "Partenaire commercial"},
        [DiplomacyStates.EstablishedContact] = {de = "Bekannt",        en = "Established Contact",  fr = "Contact établi"},
        [DiplomacyStates.Undecided]          = {de = "Unbekannt",      en = "Undecided",            fr = "Inconnu"},
        [DiplomacyStates.Enemy]              = {de = "Feind",          en = "Enemy",                fr = "Ennemi"},
    };
end

function B_Goal_Diplomacy:ChangeCaption(_Quest)
    local DiplomacyMap = self:GetDiplomacyMapping();
    local PlayerName = GetPlayerName(self.PlayerID) or "";
    local Text = string.format(
        Localize(self.TextPattern),
        Localize(DiplomacyMap[self.DiplState]),
        PlayerName
    );
    Lib.Core.Quest:ChangeCustomQuestCaptionText(Text, _Quest);
end

function B_Goal_Diplomacy:CustomFunction(_Quest)
    self:ChangeCaption(_Quest);
    if self.Relation == "<=" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) <= self.DiplState then
            return true;
        end
    elseif self.Relation == ">=" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) >= self.DiplState then
            return true;
        end
    else
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) == self.DiplState then
            return true;
        end
    end
end

function B_Goal_Diplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Relation = _Parameter;
    elseif (_Index == 2) then
        self.DiplState = DiplomacyStates[_Parameter];
    end
end

function B_Goal_Diplomacy:GetIcon()
    return {6, 3};
end

function B_Goal_Diplomacy:GetCustomData(_Index)
    if _Index == 1 then
        return {">=", "<=", "=="};
    elseif _Index == 2 then
        return {"Allied", "TradeContact", "EstablishedContact", "Undecided", "Enemy"};
    end
end

RegisterBehavior(B_Goal_Diplomacy);

-- -------------------------------------------------------------------------- --

function Goal_DiscoverPlayer(...)
    return B_Goal_DiscoverPlayer:new(...);
end

B_Goal_DiscoverPlayer = {
    Name = "Goal_DiscoverPlayer",
    Description = {
        en = "Goal: Discover the home territory of another player.",
        de = "Ziel: Entdecke das Heimatterritorium eines Spielers.",
        fr = "Objectif: Découvrir le territoire d'origine d'un joueur.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DiscoverPlayer:GetGoalTable()
    return {Objective.Discover, 2, { self.PlayerID } }
end

function B_Goal_DiscoverPlayer:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DiscoverPlayer:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_Discover",
        [PlayerCategories.City] = "Quest_Discover_City",
        [PlayerCategories.Cloister] = "Quest_Discover_Cloister",
        [PlayerCategories.Harbour] = "Quest_Discover",
        [PlayerCategories.Village] = "Quest_Discover_Village",
    }
    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_Discover"
end

RegisterBehavior(B_Goal_DiscoverPlayer);

-- -------------------------------------------------------------------------- --

function Goal_DiscoverTerritory(...)
    return B_Goal_DiscoverTerritory:new(...);
end

B_Goal_DiscoverTerritory = {
    Name = "Goal_DiscoverTerritory",
    Description = {
        en = "Goal: Discover a territory",
        de = "Ziel: Entdecke ein Territorium",
        fr = "Objectif : Découvrir un territoire",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", fr = "Territoire" },
    },
}

function B_Goal_DiscoverTerritory:GetGoalTable()
    return { Objective.Discover, 1, { self.TerritoryID  } }
end

function B_Goal_DiscoverTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
        assert( self.TerritoryID > 0 )
    end
end

function B_Goal_DiscoverTerritory:GetMsgKey()
    return "Quest_Discover_Territory"
end

RegisterBehavior(B_Goal_DiscoverTerritory);

-- -------------------------------------------------------------------------- --

function Goal_DestroyPlayer(...)
    return B_Goal_DestroyPlayer:new(...);
end

B_Goal_DestroyPlayer = {
    Name = "Goal_DestroyPlayer",
    Description = {
        en = "Goal: Destroy a player (destroy a main building)",
        de = "Ziel: Zerstöre einen Spieler (ein Hauptgebäude muss zerstört werden).",
        fr = "Objectif : Détruire un joueur (un bâtiment principal doit être détruit).",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DestroyPlayer:GetGoalTable()
    assert( self.PlayerID <= 8 and self.PlayerID >= 1, "Error in " .. self.Name .. ": GetGoalTable: PlayerID is invalid")
    return { Objective.DestroyPlayers, self.PlayerID }
end

function B_Goal_DestroyPlayer:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DestroyPlayer:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",
        [PlayerCategories.City] = "Quest_DestroyPlayers_City",
        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",
        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",
        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",
    }

    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_DestroyEntities_Building"
end

RegisterBehavior(B_Goal_DestroyPlayer)

-- -------------------------------------------------------------------------- --

function Goal_StealInformation(...)
    return B_Goal_StealInformation:new(...);
end

B_Goal_StealInformation = {
    Name = "Goal_StealInformation",
    Description = {
        en = "Goal: Steal information from another players castle",
        de = "Ziel: Stehle Informationen aus der Burg eines Spielers",
        fr = "Objectif : voler des informations du château d'un joueur",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_StealInformation:GetGoalTable()

    local Target = Logic.GetHeadquarters(self.PlayerID)
    if not Target or Target == 0 then
        Target = Logic.GetStoreHouse(self.PlayerID)
    end
    assert( Target and Target ~= 0 )
    return {Objective.Steal, 1, { Target } }

end

function B_Goal_StealInformation:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end

end

function B_Goal_StealInformation:GetMsgKey()
    return "Quest_Steal_Info"

end

RegisterBehavior(B_Goal_StealInformation);

-- -------------------------------------------------------------------------- --

function Goal_DestroyAllPlayerUnits(...)
    return B_Goal_DestroyAllPlayerUnits:new(...);
end

B_Goal_DestroyAllPlayerUnits = {
    Name = "Goal_DestroyAllPlayerUnits",
    Description = {
        en = "Goal: Destroy all units owned by player (be careful with script entities)",
        de = "Ziel: Zerstöre alle Einheiten eines Spielers (vorsicht mit Script-Entities)",
        fr = "Objectif: Détruire toutes les unités d'un joueur (attention aux entités de script)",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DestroyAllPlayerUnits:GetGoalTable()
    return { Objective.DestroyAllPlayerUnits, self.PlayerID }
end

function B_Goal_DestroyAllPlayerUnits:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DestroyAllPlayerUnits:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",
        [PlayerCategories.City] = "Quest_DestroyPlayers_City",
        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",
        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",
        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",
    }

    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_DestroyEntities"
end

RegisterBehavior(B_Goal_DestroyAllPlayerUnits);

-- -------------------------------------------------------------------------- --

function Goal_DestroyScriptEntity(...)
    return B_Goal_DestroyScriptEntity:new(...);
end

B_Goal_DestroyScriptEntity = {
    Name = "Goal_DestroyScriptEntity",
    Description = {
        en = "Goal: Destroy an entity",
        de = "Ziel: Zerstöre eine Entität",
        fr = "Objectif : Détruire une entité",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_DestroyScriptEntity:GetGoalTable()
    return {Objective.DestroyEntities, 1, { self.ScriptName } }
end

function B_Goal_DestroyScriptEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Goal_DestroyScriptEntity:GetMsgKey()
    if Logic.IsEntityAlive(self.ScriptName) then
        local ID = GetID(self.ScriptName)
        if ID and ID ~= 0 then
            ID = Logic.GetEntityType( ID )
            if ID and ID ~= 0 then
                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
                    return "Quest_DestroyEntities_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then
                    return "Quest_DestroyEntities_Predators"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
                    return "Quest_Destroy_Leader"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1
                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1
                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then

                    return "Quest_DestroyEntities_Unit"
                end
            end
        end
    end
    return "Quest_DestroyEntities"
end

RegisterBehavior(B_Goal_DestroyScriptEntity);

-- -------------------------------------------------------------------------- --

function Goal_DestroyType(...)
    return B_Goal_DestroyType:new(...);
end

B_Goal_DestroyType = {
    Name = "Goal_DestroyType",
    Description = {
        en = "Goal: Destroy entity types",
        de = "Ziel: Zerstöre Entitätstypen",
        fr = "Objectif: Détruire les types d'entités",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung", fr = "Désignation du type" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.Custom, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DestroyType:GetGoalTable()
    return {Objective.DestroyEntities, 2, Entities[self.EntityName], self.Amount, self.PlayerID }
end

function B_Goal_DestroyType:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
        self.DestroyTypeAmount = self.Amount
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DestroyType:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Entities ) do
            if string.find( k, "^[ABU]_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        for i = 0, 8 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function B_Goal_DestroyType:GetMsgKey()
    local ID = self.EntityName
    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
        return "Quest_DestroyEntities_Building"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then
        return "Quest_DestroyEntities_Predators"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
        return "Quest_Destroy_Leader"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then

        return "Quest_DestroyEntities_Unit"
    end
    return "Quest_DestroyEntities"
end

RegisterBehavior(B_Goal_DestroyType);

-- -------------------------------------------------------------------------- --

function Goal_EntityDistance(...)
    return B_Goal_EntityDistance:new(...);
end

B_Goal_EntityDistance = {
    Name = "Goal_EntityDistance",
    Description = {
        en = "Goal: Distance between two entities",
        de = "Ziel: Zwei Entities sollen zueinander eine Entfernung über- oder unterschreiten.",
        fr = "Objectif: deux entités doivent se trouver à une distance supérieure ou inférieure l'une de l'autre.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1", fr = "Entité 1" },
        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2", fr = "Entité 2" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number, en = "Distance", de = "Entfernung", fr = "Distance" },
    },
}

function B_Goal_EntityDistance:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_EntityDistance:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity1 = _Parameter
    elseif (_Index == 1) then
        self.Entity2 = _Parameter
    elseif (_Index == 2) then
        self.bRelSmallerThan = _Parameter == "<"
    elseif (_Index == 3) then
        self.Distance = _Parameter * 1
    end
end

function B_Goal_EntityDistance:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.Entity1 ) or Logic.IsEntityDestroyed( self.Entity2 ) then
        return false
    end
    local ID1 = GetID( self.Entity1 )
    local ID2 = GetID( self.Entity2 )
    local InRange = Logic.CheckEntitiesDistance( ID1, ID2, self.Distance )
    if ( self.bRelSmallerThan and InRange ) or ( not self.bRelSmallerThan and not InRange ) then
        return true
    end
end

function B_Goal_EntityDistance:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        table.insert( Data, ">" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_EntityDistance:Debug(_Quest)
    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": At least 1 of the entities for distance check don't exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_EntityDistance);

-- -------------------------------------------------------------------------- --

function Goal_KnightDistance(...)
    return B_Goal_KnightDistance:new(...);
end

B_Goal_KnightDistance = {
    Name = "Goal_KnightDistance",
    Description = {
        en = "Goal: Bring the knight close to a given entity. If the distance is left at 0 it will automatically set to 2500.",
        de = "Ziel: Bringe den Ritter nah an eine bestimmte Entität. Wird die Entfernung 0 gelassen, ist sie automatisch 2500.",
        fr = "Objectif : Rapproche le chevalier d'une entité donnée. Si la distance est laissée à 0, elle est automatiquement de 2500.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target", de = "Ziel", fr = "Cible" },
        { ParameterType.Number, en = "Distance", de = "Entfernung", fr = "Distance" },
    },
}

function B_Goal_KnightDistance:GetGoalTable()
    return {Objective.Distance, -65566, self.Target, self.Distance, true}
end

function B_Goal_KnightDistance:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Target = _Parameter;
    elseif (_Index == 1) then
        if _Parameter == nil or _Parameter == "" then
            _Parameter = 0;
        end
        self.Distance = _Parameter * 1;
        if self.Distance == 0 then
            self.Distance = 2500;
        end
    end
end

RegisterBehavior(B_Goal_KnightDistance);

-- -------------------------------------------------------------------------- --

function Goal_UnitsOnTerritory(...)
    return B_Goal_UnitsOnTerritory:new(...);
end

B_Goal_UnitsOnTerritory = {
    Name = "Goal_UnitsOnTerritory",
    Description = {
        en = "Goal: Place a certain amount of units on a territory",
        de = "Ziel: Platziere eine bestimmte Anzahl Einheiten auf einem Gebiet",
        fr = "Objectif: placer un certain nombre d'unités sur un territoire",
    },
    Parameter = {
        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium", fr = "Territoire" },
        { ParameterType.Custom,  en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Custom,  en = "Category", de = "Kategorie", fr = "Catégorie" },
        { ParameterType.Custom,  en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number,  en = "Number of units", de = "Anzahl Einheiten", fr = "Quantité d'unitées" },
    },
}

function B_Goal_UnitsOnTerritory:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_UnitsOnTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if self.TerritoryID == nil then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    elseif (_Index == 1) then
        self.PlayerID = tonumber(_Parameter) * 1
    elseif (_Index == 2) then
        self.Category = _Parameter
    elseif (_Index == 3) then
        self.bRelSmallerThan = (tostring(_Parameter) == "true" or tostring(_Parameter) == "<")
    elseif (_Index == 4) then
        self.NumberOfUnits = _Parameter * 1
    end
end

function B_Goal_UnitsOnTerritory:CustomFunction(_Quest)
    local PlayerEntities = self:GetEntities(self.TerritoryID, self.PlayerID, EntityCategories[self.Category]);
    if self.bRelSmallerThan == false and #PlayerEntities >= self.NumberOfUnits then
        return true;
    elseif self.bRelSmallerThan == true and #PlayerEntities < self.NumberOfUnits then
        return true;
    end
end

function B_Goal_UnitsOnTerritory:GetEntities(_TerritoryID, _PlayerID, _Category)
    local PlayerEntities = {};
    local Units = {};
    if (_PlayerID == -1) then
        for i=0,8 do
            local NumLast = 0;
            repeat
                Units = {Logic.GetEntitiesOfCategoryInTerritory(_TerritoryID, i, _PlayerID, NumLast)};
                PlayerEntities = Array_Append(PlayerEntities, Units);
                NumLast = NumLast + #Units;
            until #Units == 0;
        end
    else
        local NumLast = 0;
        repeat
            Units = { Logic.GetEntitiesOfCategoryInTerritory(_TerritoryID, _PlayerID, _Category, NumLast)};
            PlayerEntities = Array_Append(PlayerEntities, Units);
            NumLast = NumLast + #Units;
        until #Units == 0;
    end
    return PlayerEntities;
end

function B_Goal_UnitsOnTerritory:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, -1 )
        for i = 1, 8 do
            table.insert( Data, i )
        end
    elseif _Index == 2 then
        for k, v in pairs( EntityCategories ) do
            if not string.find( k, "^G_" ) and k ~= "SheepPasture" then
                table.insert( Data, k )
            end
        end
        table.sort( Data );
    elseif _Index == 3 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_UnitsOnTerritory:Debug(_Quest)
    local territories = {Logic.GetTerritories()}
    if tonumber(self.TerritoryID) == nil or self.TerritoryID < 0 or not table.contains(territories, self.TerritoryID) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid territoryID!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 0 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    elseif not EntityCategories[self.Category] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid entity category!");
        return true;
    elseif tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": amount is negative or nil!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_UnitsOnTerritory);

-- -------------------------------------------------------------------------- --

function Goal_ActivateBuff(...)
    return B_Goal_ActivateBuff:new(...);
end

B_Goal_ActivateBuff = {
    Name = "Goal_ActivateBuff",
    Description = {
        en = "Goal: Activate a buff",
        de = "Ziel: Aktiviere einen Buff",
        fr = "Objectif: Activer un bonus",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Custom, en = "Buff", de = "Buff", fr = "Bonus" },
    },
}

function B_Goal_ActivateBuff:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_ActivateBuff:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.BuffName = _Parameter
        self.Buff = Buffs[_Parameter]
    end
end

function B_Goal_ActivateBuff:CustomFunction(_Quest)
   if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local tMapping = CopyTable(Lib.Core.Quest.Text.ActivateBuff.BuffsVanilla);
        if g_GameExtraNo >= 1 then
            tMapping = CopyTable(Lib.Core.Quest.Text.ActivateBuff.BuffsEx1, tMapping);
        end
        Lib.Core.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Localize(Lib.Core.Quest.Text.ActivateBuff.Pattern),
                Localize(tMapping[self.BuffName])
            ),
            _Quest
        );
    end

    local Buff = Logic.GetBuff( self.PlayerID, self.Buff )
    if Buff and Buff ~= 0 then
        return true
    end
end

function B_Goal_ActivateBuff:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        Data = {
            "Buff_Spice",
            "Buff_Colour",
            "Buff_Entertainers",
            "Buff_FoodDiversity",
            "Buff_ClothesDiversity",
            "Buff_HygieneDiversity",
            "Buff_EntertainmentDiversity",
            "Buff_Sermon",
            "Buff_Festival",
            "Buff_ExtraPayment",
            "Buff_HighTaxes",
            "Buff_NoPayment",
            "Buff_NoTaxes"
        }

        if g_GameExtraNo >= 1 then
            table.insert(Data, "Buff_Gems")
            table.insert(Data, "Buff_MusicalInstrument")
            table.insert(Data, "Buff_Olibanum")
        end

        table.sort( Data )
    else
        assert( false )
    end
    return Data
end

function B_Goal_ActivateBuff:GetIcon()
    local tMapping = {
        [Buffs.Buff_Spice]                  = "Goods.G_Salt",
        [Buffs.Buff_Colour]                 = "Goods.G_Dye",
        [Buffs.Buff_Entertainers]           = "Entities.U_Entertainer_NA_FireEater", --{5, 12},
        [Buffs.Buff_FoodDiversity]          = "Needs.Nutrition", --{1, 1},
        [Buffs.Buff_ClothesDiversity]       = "Needs.Clothes", --{1, 2},
        [Buffs.Buff_HygieneDiversity]       = "Needs.Hygiene", --{16, 1},
        [Buffs.Buff_EntertainmentDiversity] = "Needs.Entertainment", --{1, 4},
        [Buffs.Buff_Sermon]                 = "Technologies.R_Sermon", --{4, 14},
        [Buffs.Buff_Festival]               = "Technologies.R_Festival", --{4, 15},
        [Buffs.Buff_ExtraPayment]           = {1,8},
        [Buffs.Buff_HighTaxes]              = {1,6},
        [Buffs.Buff_NoPayment]              = {1,8},
        [Buffs.Buff_NoTaxes]                = {1,6},
    }
    if g_GameExtraNo and g_GameExtraNo >= 1 then
        tMapping[Buffs.Buff_Gems] = "Goods.G_Gems"
        tMapping[Buffs.Buff_MusicalInstrument] = "Goods.G_MusicalInstrument"
        tMapping[Buffs.Buff_Olibanum] = "Goods.G_Olibanum"
    end
    return tMapping[self.Buff]
end

function B_Goal_ActivateBuff:Debug(_Quest)
    if not self.Buff then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": buff '" ..self.BuffName.. "' does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_ActivateBuff);

-- -------------------------------------------------------------------------- --

function Goal_BuildRoad(...)
    return B_Goal_BuildRoad:new(...)
end

B_Goal_BuildRoad = {
    Name = "Goal_BuildRoad",
    Description = {
        en = "Goal: Connect two points with a street or a road",
        de = "Ziel: Verbinde zwei Punkte mit einer Strasse oder einem Weg.",
        fr = "Objectif: Relier deux points par une route ou un chemin.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity 1",       de = "Entity 1",     fr = "Entité 1" },
        { ParameterType.ScriptName, en = "Entity 2",       de = "Entity 2",     fr = "Entité 2" },
        { ParameterType.Custom,     en = "Only roads",     de = "Nur Strassen", fr = "Que des Routes" },
    },
}

function B_Goal_BuildRoad:GetGoalTable()
    -- {BehaviorType, {EntityID1, EntityID2, BeSmalerThan, Length, RoadsOnly}}
    -- -> Length wird nicht mehr benutzt. Sorgte für Promleme im Spiel
    return { Objective.BuildRoad, { GetID( self.Entity1 ), GetID( self.Entity2 ), false, 0, self.bRoadsOnly } }
end

function B_Goal_BuildRoad:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity1 = _Parameter
    elseif (_Index == 1) then
        self.Entity2 = _Parameter
    elseif (_Index == 2) then
        self.bRoadsOnly = ToBoolean(_Parameter)
    end
end

function B_Goal_BuildRoad:GetCustomData( _Index )
    local Data
    if _Index == 2 then
        Data = {"true","false"}
    end
    return Data
end

function B_Goal_BuildRoad:Debug(_Quest)
    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": first or second entity does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_BuildRoad);

-- -------------------------------------------------------------------------- --

function Goal_BuildWall(...)
    return B_Goal_BuildWall:new(...)
end

B_Goal_BuildWall = {
    Name = "Goal_BuildWall",
    Description = {
        en = "Goal: Build a wall between 2 positions bo stop the movement of an (hostile) player.",
        de = "Ziel: Baue eine Mauer zwischen 2 Punkten, die die Bewegung eines (feindlichen) Spielers zwischen den Punkten verhindert.",
        fr = "Objectif: Construire un mur entre 2 points qui empêche le déplacement d'un joueur (ennemi) entre les points.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Enemy", de = "Feind", fr = "Ennemi" },
        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1", fr = "Entité 1" },
        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2", fr = "Entité 2" },
    },
}

function B_Goal_BuildWall:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_BuildWall:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.EntityName1 = _Parameter
    elseif (_Index == 2) then
        self.EntityName2 = _Parameter
    end
end

function B_Goal_BuildWall:CustomFunction(_Quest)
    local eID1 = GetID(self.EntityName1)
    local eID2 = GetID(self.EntityName2)

    if not IsExisting(eID1) then
        return false
    end
    if not IsExisting(eID2) then
        return false
    end
    local x,y,z = Logic.EntityGetPos(eID1)
    if Logic.IsBuilding(eID1) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID1)
    end
    local Sector1 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)
    local x,y,z = Logic.EntityGetPos(eID2)
    if Logic.IsBuilding(eID2) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID2)
    end
    local Sector2 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)
    if Sector1 ~= Sector2 then
        return true
    end
    return nil
end

function B_Goal_BuildWall:GetMsgKey()
    return "Quest_Create_Wall"
end

function B_Goal_BuildWall:GetIcon()
    return {3,9}
end

function B_Goal_BuildWall:Debug(_Quest)
    if not IsExisting(self.EntityName1) or not IsExisting(self.EntityName2) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": first or second entity does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end

    if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) > -1 and not self.WarningPrinted then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": player %d is neighter enemy or unknown to quest receiver!");
        self.WarningPrinted = true;
    end
    return false;
end

RegisterBehavior(B_Goal_BuildWall);

-- -------------------------------------------------------------------------- --

function Goal_Claim(...)
    return B_Goal_Claim:new(...)
end

B_Goal_Claim = {
    Name = "Goal_Claim",
    Description = {
        en = "Goal: Claim a territory",
        de = "Ziel: Erobere ein Territorium",
        fr = "Objectif: Conquérir un territoire",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", fr = "Territoire" },
    },
}

function B_Goal_Claim:GetGoalTable()
    return { Objective.Claim, 1, self.TerritoryID }
end

function B_Goal_Claim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    end
end

function B_Goal_Claim:GetMsgKey()
    return "Quest_Claim_Territory"
end

RegisterBehavior(B_Goal_Claim);

-- -------------------------------------------------------------------------- --

function Goal_ClaimXTerritories(...)
    return B_Goal_ClaimXTerritories:new(...)
end

B_Goal_ClaimXTerritories = {
    Name = "Goal_ClaimXTerritories",
    Description = {
        en = "Goal: Claim the given number of territories, all player territories are counted",
        de = "Ziel: Erobere die angegebene Anzahl Territorien, alle spielereigenen Territorien werden gezählt",
        fr = "Objectif: conquérir le nombre de territoires indiqué, tous les territoires des joueurs sont comptabilisés.",
    },
    Parameter = {
        { ParameterType.Number, en = "Territories" , de = "Territorien", fr = "Territoire" }
    },
}

function B_Goal_ClaimXTerritories:GetGoalTable()
    return { Objective.Claim, 2, self.TerritoriesToClaim }
end

function B_Goal_ClaimXTerritories:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoriesToClaim = _Parameter * 1
    end
end

function B_Goal_ClaimXTerritories:GetMsgKey()
    return "Quest_Claim_Territory"
end

RegisterBehavior(B_Goal_ClaimXTerritories);

-- -------------------------------------------------------------------------- --

function Goal_Create(...)
    return B_Goal_Create:new(...);
end

B_Goal_Create = {
    Name = "Goal_Create",
    Description = {
        en = "Goal: Create Buildings/Units on a specified territory",
        de = "Ziel: Erstelle Einheiten/Gebäude auf einem bestimmten Territorium.",
        fr = "Objectif: créer des unités/bâtiments sur un territoire donné.",
    },
    Parameter = {
        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung", fr = "Désignation du type" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium", fr = "Territoire" },
    },
}

function B_Goal_Create:GetGoalTable()
    return { Objective.Create, assert( Entities[self.EntityName] ), self.Amount, self.TerritoryID }
end

function B_Goal_Create:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    elseif (_Index == 2) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    end
end

function B_Goal_Create:GetMsgKey()
    return Logic.IsEntityTypeInCategory( Entities[self.EntityName], EntityCategories.AttackableBuilding ) == 1 and "Quest_Create_Building" or "Quest_Create_Unit"
end

RegisterBehavior(B_Goal_Create);

-- -------------------------------------------------------------------------- --

function Goal_Produce(...)
    return B_Goal_Produce:new(...);
end

B_Goal_Produce = {
    Name = "Goal_Produce",
    Description = {
        en = "Goal: Produce an amount of goods",
        de = "Ziel: Produziere eine Anzahl einer bestimmten Ware.",
        fr = "Objectif: produire un certain nombre d'une marchandise donnée."
    },
    Parameter = {
        { ParameterType.RawGoods, en = "Type of good", de = "Ressourcentyp", fr = "Type de ressources" },
        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Ressource", fr = "Quantité de ressources" },
    },
}

function B_Goal_Produce:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Produce, GoodType, self.GoodAmount }
end

function B_Goal_Produce:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    end
end

function B_Goal_Produce:GetMsgKey()
    return "Quest_Produce"
end

RegisterBehavior(B_Goal_Produce);

-- -------------------------------------------------------------------------- --

function Goal_GoodAmount(...)
    return B_Goal_GoodAmount:new(...);
end

B_Goal_GoodAmount = {
    Name = "Goal_GoodAmount",
    Description = {
        en = "Goal: Obtain an amount of goods - either by trading or producing them",
        de = "Ziel: Beschaffe eine Anzahl Waren - entweder durch Handel oder durch eigene Produktion.",
        fr = "Objectif: Se procurer un certain nombre de marchandises - soit par le commerce, soit par sa propre production."
    },
    Parameter = {
        { ParameterType.Custom, en = "Type of good", de = "Warentyp", fr = "TYpe de marchandises" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
    },
}

function B_Goal_GoodAmount:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Produce, GoodType, self.GoodAmount, self.bRelSmallerThan }
end

function B_Goal_GoodAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    elseif  (_Index == 2) then
        self.bRelSmallerThan = _Parameter == "<" or tostring(_Parameter) == "true"
    end
end

function B_Goal_GoodAmount:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

RegisterBehavior(B_Goal_GoodAmount);

-- -------------------------------------------------------------------------- --

function Goal_SatisfyNeed(...)
    return B_Goal_SatisfyNeed:new(...);
end

B_Goal_SatisfyNeed = {
    Name = "Goal_SatisfyNeed",
    Description = {
        en = "Goal: Satisfy a need",
        de = "Ziel: Erfuelle ein Beduerfnis",
        fr = "Objectif: Répondre à un besoin",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Need, en = "Need", de = "Beduerfnis", fr = "Besoin" },
    },
}

function B_Goal_SatisfyNeed:GetGoalTable()
    return { Objective.SatisfyNeed, Needs[self.Need], self.PlayerID }

end

function B_Goal_SatisfyNeed:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Need = _Parameter
    end

end

function B_Goal_SatisfyNeed:GetMsgKey()
    local tMapping = {
        [Needs.Clothes] = "Quest_SatisfyNeed_Clothes",
        [Needs.Entertainment] = "Quest_SatisfyNeed_Entertainment",
        [Needs.Nutrition] = "Quest_SatisfyNeed_Food",
        [Needs.Hygiene] = "Quest_SatisfyNeed_Hygiene",
        [Needs.Medicine] = "Quest_SatisfyNeed_Medicine",
    }

    local Key = tMapping[Needs[self.Need]]
    if Key then
        return Key
    end

    -- No default message
end

RegisterBehavior(B_Goal_SatisfyNeed);

-- -------------------------------------------------------------------------- --

function Goal_SettlersNumber(...)
    return B_Goal_SettlersNumber:new(...);
end

B_Goal_SettlersNumber = {
    Name = "Goal_SettlersNumber",
    Description = {
        en = "Goal: Get a given amount of settlers",
        de = "Ziel: Erreiche eine bestimmte Anzahl Siedler.",
        fr = "Objectif: atteindre un certain nombre de Settlers.",
    },
    Parameter = {
        { ParameterType.Number,   en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_SettlersNumber:GetGoalTable()
    return {Objective.SettlersNumber, self.PlayerID or 1, self.SettlersAmount };
end

function B_Goal_SettlersNumber:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SettlersAmount = _Parameter * 1;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    end
end

function B_Goal_SettlersNumber:GetMsgKey()
    return "Quest_NumberSettlers";
end

RegisterBehavior(B_Goal_SettlersNumber);

-- -------------------------------------------------------------------------- --

function Goal_Spouses(...)
    return B_Goal_Spouses:new(...);
end

B_Goal_Spouses = {
    Name = "Goal_Spouses",
    Description = {
        en = "Goal: Get a given amount of spouses",
        de = "Ziel: Erreiche eine bestimmte Ehefrauenanzahl",
        fr = "Objectif: Atteindre un certain nombre d'épouses",
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
    },
}

function B_Goal_Spouses:GetGoalTable()
    return {Objective.Spouses, self.SpousesAmount }
end

function B_Goal_Spouses:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SpousesAmount = _Parameter * 1
    end
end

function B_Goal_Spouses:GetMsgKey()
    return "Quest_NumberSpouses"
end

RegisterBehavior(B_Goal_Spouses);

-- -------------------------------------------------------------------------- --

function Goal_SoldierCount(...)
    return B_Goal_SoldierCount:new(...);
end

B_Goal_SoldierCount = {
    Name = "Goal_SoldierCount",
    Description = {
        en = "Goal: Create a specified number of soldiers",
        de = "Ziel: Erreiche eine Anzahl grösser oder kleiner der angegebenen Menge Soldaten.",
        fr = "Objectif: Atteindre un nombre de soldats supérieur ou inférieur à la quantité indiquée.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten", fr = "Nombre de soldats" },
    },
}

function B_Goal_SoldierCount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_SoldierCount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.bRelSmallerThan = tostring(_Parameter) == "true" or tostring(_Parameter) == "<"
    elseif (_Index == 2) then
        self.NumberOfUnits = _Parameter * 1
    end
end

function B_Goal_SoldierCount:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local Relation = tostring(self.bRelSmallerThan);
        local PlayerName = GetPlayerName(self.PlayerID) or "";
        Lib.Core.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Localize(Lib.Core.Quest.Text.SoldierCount.Pattern),
                PlayerName,
                Localize(Lib.Core.Quest.Text.SoldierCount.Relation[Relation]),
                self.NumberOfUnits
            ),
            _Quest
        );
    end

    local NumSoldiers = Logic.GetCurrentSoldierCount( self.PlayerID )
    if ( self.bRelSmallerThan and NumSoldiers < self.NumberOfUnits ) then
        return true
    elseif ( not self.bRelSmallerThan and NumSoldiers >= self.NumberOfUnits ) then
        return true
    end
    return nil
end

function B_Goal_SoldierCount:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then

        table.insert( Data, ">=" )
        table.insert( Data, "<" )

    else
        assert( false )
    end
    return Data
end

function B_Goal_SoldierCount:GetIcon()
    return {7,11}
end

function B_Goal_SoldierCount:GetMsgKey()
    return "Quest_Create_Unit"
end

function B_Goal_SoldierCount:Debug(_Quest)
    if tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": amount can not be below 0!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_SoldierCount);

-- -------------------------------------------------------------------------- --

function Goal_KnightTitle(...)
    return B_Goal_KnightTitle:new(...);
end

B_Goal_KnightTitle = {
    Name = "Goal_KnightTitle",
    Description = {
        en = "Goal: Reach a specified knight title",
        de = "Ziel: Erreiche einen vorgegebenen Titel",
        fr = "Objectif: atteindre un titre donné",
    },
    Parameter = {
        { ParameterType.Custom, en = "Knight title", de = "Titel", fr = "Titre" },
    },
}

function B_Goal_KnightTitle:GetGoalTable()
    return {Objective.KnightTitle, assert( KnightTitles[self.KnightTitle] ) }
end

function B_Goal_KnightTitle:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.KnightTitle = _Parameter
    end
end

function B_Goal_KnightTitle:GetMsgKey()
    return "Quest_KnightTitle"
end

function B_Goal_KnightTitle:GetCustomData( _Index )
    return {"Knight", "Mayor", "Baron", "Earl", "Marquees", "Duke", "Archduke"}
end

RegisterBehavior(B_Goal_KnightTitle);

-- -------------------------------------------------------------------------- --

function Goal_Festivals(...)
    return B_Goal_Festivals:new(...);
end

B_Goal_Festivals = {
    Name = "Goal_Festivals",
    Description = {
        en = "Goal: The player has to start the given number of festivals.",
        de = "Ziel: Der Spieler muss eine gewisse Anzahl Feste gestartet haben.",
        fr = "Objectif: Le joueur doit avoir lancé un certain nombre de festivités."
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Number, en = "Number of festivals", de = "Anzahl Feste", fr = "Nombre de festivités" }
    }
};

function B_Goal_Festivals:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_Festivals:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.PlayerID = tonumber(_Parameter);
    else
        assert(_Index == 1, "Error in " .. self.Name .. ": AddParameter: Index is invalid.");
        self.NeededFestivals = tonumber(_Parameter);
    end
end

function B_Goal_Festivals:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local PlayerName = GetPlayerName(self.PlayerID) or "";
        Lib.Core.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Localize(Lib.Core.Quest.Text.Festivals.Pattern),
                PlayerName, self.NeededFestivals
            ), 
            _Quest
        );
    end

    if Logic.GetStoreHouse( self.PlayerID ) == 0  then
        return false
    end
    local tablesOnFestival = {Logic.GetPlayerEntities(self.PlayerID, Entities.B_TableBeer, 5,0)}
    local amount = 0
    for k=2, #tablesOnFestival do
        local tableID = tablesOnFestival[k]
        if Logic.GetIndexOnOutStockByGoodType(tableID, Goods.G_Beer) ~= -1 then
            local goodAmountOnMarketplace = Logic.GetAmountOnOutStockByGoodType(tableID, Goods.G_Beer)
            amount = amount + goodAmountOnMarketplace
        end
    end
    if not self.FestivalStarted and amount > 0 then
        self.FestivalStarted = true
        self.FestivalCounter = (self.FestivalCounter and self.FestivalCounter + 1) or 1
        if self.FestivalCounter >= self.NeededFestivals then
            self.FestivalCounter = nil
            return true
        end
    elseif amount == 0 then
        self.FestivalStarted = false
    end
end

function B_Goal_Festivals:Debug(_Quest)
    if Logic.GetStoreHouse( self.PlayerID ) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead :-(")
        return true
    elseif GetPlayerCategoryType(self.PlayerID) ~= PlayerCategories.City then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ":  Player "..  self.PlayerID .. " is no city")
        return true
    elseif self.NeededFestivals < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Festivals is negative")
        return true
    end
    return false
end

function B_Goal_Festivals:Reset()
    self.FestivalCounter = nil
    self.FestivalStarted = nil
end

function B_Goal_Festivals:GetIcon()
    return {4,15}
end

RegisterBehavior(B_Goal_Festivals)

-- -------------------------------------------------------------------------- --

function Goal_Capture(...)
    return B_Goal_Capture:new(...)
end

B_Goal_Capture = {
    Name = "Goal_Capture",
    Description = {
        en = "Goal: Capture a cart.",
        de = "Ziel: Ein Karren muss erobert werden.",
        fr = "Objectif: un chariot doit être conquis.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_Capture:GetGoalTable()
    return { Objective.Capture, 1, { self.ScriptName } }
end

function B_Goal_Capture:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Goal_Capture:GetMsgKey()
   local ID = GetID(self.ScriptName)
   if Logic.IsEntityAlive(ID) then
        ID = Logic.GetEntityType( ID )
        if ID and ID ~= 0 then
            if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
                return "Quest_Capture_Cart"

            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then
                return "Quest_Capture_SiegeEngine"

            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1
                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1
                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then

                return "Quest_Capture_VIPOfPlayer"

            end
        end
    end
end

RegisterBehavior(B_Goal_Capture);

-- -------------------------------------------------------------------------- --

function Goal_CaptureType(...)
    return B_Goal_CaptureType:new(...)
end

B_Goal_CaptureType = {
    Name = "Goal_CaptureType",
    Description = {
        en = "Goal: Capture specified entity types",
        de = "Ziel: Nimm bestimmte Entitätstypen gefangen",
        fr = "Objectif: capturer certains types d'entités",
    },
    Parameter = {
        { ParameterType.Custom,     en = "Type name",   de = "Typbezeichnung",  fr = "Désignation du type" },
        { ParameterType.Number,     en = "Amount",      de = "Anzahl",          fr = "Quantité" },
        { ParameterType.PlayerID,   en = "Player",      de = "Spieler",         fr = "Joueur" },
    },
}

function B_Goal_CaptureType:GetGoalTable()
    return { Objective.Capture, 2, Entities[self.EntityName], self.Amount, self.PlayerID }
end

function B_Goal_CaptureType:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_CaptureType:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Entities ) do
            if string.find( k, "^U_.+Cart" ) or Logic.IsEntityTypeInCategory( v, EntityCategories.AttackableMerchant ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        for i = 0, 8 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function B_Goal_CaptureType:GetMsgKey()

    local ID = self.EntityName
    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
        return "Quest_Capture_Cart"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then
        return "Quest_Capture_SiegeEngine"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then

        return "Quest_Capture_VIPOfPlayer"
    end
end

RegisterBehavior(B_Goal_CaptureType);

-- -------------------------------------------------------------------------- --

function Goal_Protect(...)
    return B_Goal_Protect:new(...)
end

B_Goal_Protect = {
    Name = "Goal_Protect",
    Description = {
        en = "Goal: Protect an entity (entity needs a script name",
        de = "Ziel: Beschütze eine Entität (Entität benötigt einen Skriptnamen)",
        fr = "Objectif : Protéger une entité (l'entité nécessite un nom de script)"
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_Protect:GetGoalTable()
    return {Objective.Protect, { self.ScriptName }}
end

function B_Goal_Protect:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Goal_Protect:GetMsgKey()
    if Logic.IsEntityAlive(self.ScriptName) then
        local ID = GetID(self.ScriptName)
        if ID and ID ~= 0 then
            ID = Logic.GetEntityType( ID )
            if ID and ID ~= 0 then
                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
                    return "Quest_Protect_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SpecialBuilding ) == 1 then
                    local tMapping = {
                        [PlayerCategories.City]        = "Quest_Protect_City",
                        [PlayerCategories.Cloister]    = "Quest_Protect_Cloister",
                        [PlayerCategories.Village]    = "Quest_Protect_Village",
                    }
                    local PlayerCategory = GetPlayerCategoryType( Logic.EntityGetPlayer(GetID(self.ScriptName)) )
                    if PlayerCategory then
                        local Key = tMapping[PlayerCategory]
                        if Key then
                            return Key
                        end
                    end
                    return "Quest_Protect_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
                    return "Quest_Protect_Knight"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
                    return "Quest_Protect_Cart"
                end
            end
        end
    end
    return "Quest_Protect"
end

RegisterBehavior(B_Goal_Protect);

-- -------------------------------------------------------------------------- --

function Goal_Refill(...)
    return B_Goal_Refill:new(...)
end

B_Goal_Refill = {
    Name = "Goal_Refill",
    Description = {
        en = "Goal: Refill an object using a geologist",
        de = "Ziel: Eine Mine soll durch einen Geologen wieder aufgefuellt werden.",
        fr = "Objectif: Une mine doit être réalimentée par un géologue.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
   RequiresExtraNo = 1,
}

function B_Goal_Refill:GetGoalTable()
    return { Objective.Refill, { GetID(self.ScriptName) } }
end

function B_Goal_Refill:GetIcon()
    return {8,1,1}
end

function B_Goal_Refill:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

if g_GameExtraNo > 0 then
    RegisterBehavior(B_Goal_Refill);
end

-- -------------------------------------------------------------------------- --

function Goal_ResourceAmount(...)
    return B_Goal_ResourceAmount:new(...)
end

B_Goal_ResourceAmount = {
    Name = "Goal_ResourceAmount",
    Description = {
        en = "Goal: Reach a specified amount of resources in a doodad",
        de = "Ziel: In einer Mine soll weniger oder mehr als eine angegebene Anzahl an Rohstoffen sein.",
        fr = "Objectif: Dans une mine, il doit y avoir moins ou plus de matières premières qu'un nombre indiqué.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité" },
    },
}

function B_Goal_ResourceAmount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_ResourceAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.bRelSmallerThan = _Parameter == "<"
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1
    end
end

function B_Goal_ResourceAmount:CustomFunction(_Quest)
    local ID = GetID(self.ScriptName)
    if ID and ID ~= 0 and Logic.GetResourceDoodadGoodType(ID) ~= 0 then
        local HaveAmount = Logic.GetResourceDoodadGoodAmount(ID)
        if ( self.bRelSmallerThan and HaveAmount < self.Amount ) or ( not self.bRelSmallerThan and HaveAmount >= self.Amount ) then
            return true
        end
    end
    return nil
end

function B_Goal_ResourceAmount:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_ResourceAmount:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": entity '" ..self.ScriptName.. "' does not exist!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": error at amount! (nil or below 0)");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_ResourceAmount);

-- -------------------------------------------------------------------------- --

function Goal_InstantFailure()
    return B_Goal_InstantFailure:new()
end

B_Goal_InstantFailure = {
    Name = "Goal_InstantFailure",
    Description = {
        en = "Goal: Instant failure, the goal returns false.",
        de = "Ziel: Direkter Misserfolg, das Goal sendet false.",
        fr = "Objectif: échec direct, le goal envoie false.",
    },
}

function B_Goal_InstantFailure:GetGoalTable()
    return {Objective.DummyFail};
end

RegisterBehavior(B_Goal_InstantFailure);

-- -------------------------------------------------------------------------- --

function Goal_InstantSuccess()
    return B_Goal_InstantSuccess:new()
end

B_Goal_InstantSuccess = {
    Name = "Goal_InstantSuccess",
    Description = {
        en = "Goal: Instant success, the goal returns true.",
        de = "Ziel: Direkter Erfolg, das Goal sendet true.",
        fr = "Objectif: succès direct, le goal envoie false."
    },
}

function B_Goal_InstantSuccess:GetGoalTable()
    return {Objective.Dummy};
end

RegisterBehavior(B_Goal_InstantSuccess);

-- -------------------------------------------------------------------------- --

function Goal_NoChange()
    return B_Goal_NoChange:new()
end

B_Goal_NoChange = {
    Name = "Goal_NoChange",
    Description = {
        en = "Goal: The quest state doesn't change. Use reward functions of other quests to change the state of this quest.",
        de = "Ziel: Der Questzustand wird nicht verändert. Ein Reward einer anderen Quest sollte den Zustand dieser Quest verändern.",
        fr = "Objectif: L'état de la quête n'est pas modifié. Une récompense d'une autre quête doit modifier l'état de cette quête.",
    },
}

function B_Goal_NoChange:GetGoalTable()
    return { Objective.NoChange }
end

RegisterBehavior(B_Goal_NoChange);

-- -------------------------------------------------------------------------- --

function Goal_MapScriptFunction(...)
    return B_Goal_MapScriptFunction:new(...);
end

B_Goal_MapScriptFunction = {
    Name = "Goal_MapScriptFunction",
    Description = {
        en = "Goal: Calls a function within the global map script. Return 'true' means success, 'false' means failure and 'nil' doesn't change anything.",
        de = "Ziel: Ruft eine Funktion im globalen Skript auf, die einen Wahrheitswert zurueckgibt. Rueckgabe 'true' gilt als erfuellt, 'false' als gescheitert und 'nil' ändert nichts.",
        fr = "Objectif: Appelle une fonction dans le script global qui renvoie une valeur de vérité. Le retour 'true' est considéré comme rempli, 'false' comme échoué et 'nil' ne change rien.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname", fr = "Nom de la fonction" },
    },
}

function B_Goal_MapScriptFunction:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_MapScriptFunction:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.FuncName = _Parameter
    end
end

function B_Goal_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        return self.FuncName(unpack(self.i47ya_6aghw_frxil));
    end
    return _G[self.FuncName](self, _Quest);
end

function B_Goal_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_MapScriptFunction);

-- -------------------------------------------------------------------------- --

function Goal_CustomVariables(...)
    return B_Goal_CustomVariables:new(...);
end

B_Goal_CustomVariables = {
    Name = "Goal_CustomVariables",
    Description = {
        en = "Goal: A customised variable has to assume a certain value.",
        de = "Ziel: Eine benutzerdefinierte Variable muss einen bestimmten Wert annehmen.",
        fr = "Objectif: une variable définie par l'utilisateur doit prendre une certaine valeur.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of Variable", de = "Variablenname", fr = "Nom de la variable" },
        { ParameterType.Custom,  en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Default, en = "Value or variable", de = "Wert oder Variable", fr = "Valeur ou variable" }
    }
};

function B_Goal_CustomVariables:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Relation = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        self.Value = (value == nil and tostring(_Parameter)) or value;
    end
end

function B_Goal_CustomVariables:CustomFunction()
    local Value1 = ObtainCustomVariable("BehaviorVariable_" ..self.VariableName, 0);
    local Value2 = self.Value;
    if type(self.Value) == "string" then
        Value2 = ObtainCustomVariable("BehaviorVariable_" ..self.Value, 0);
    end

    if self.Relation == "==" then
        if Value1 == Value2 then
            return true;
        end
    elseif self.Relation == "~=" then
        if Value1 == Value2 then
            return true;
        end
    elseif self.Relation == "<" then
        if Value1 < Value2 then
            return true;
        end
    elseif self.Relation == "<=" then
        if Value1 <= Value2 then
            return true;
        end
    elseif self.Relation == ">=" then
        if Value1 >= Value2 then
            return true;
        end
    else
        if Value1 > Value2 then
            return true;
        end
    end
    return nil;
end

function B_Goal_CustomVariables:GetCustomData( _Index )
    return {"==", "~=", "<=", "<", ">", ">="};
end

function B_Goal_CustomVariables:Debug(_Quest)
    local relations = {"==", "~=", "<=", "<", ">", ">="}
    local results    = {true, false, nil}

    if not ObtainCustomVariable("BehaviorVariable_" ..self.VariableName) then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": variable '"..self.VariableName.."' do not exist!");
    end
    if not table.contains(relations, self.Relation) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.Relation.."' is an invalid relation!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_CustomVariables)

-- -------------------------------------------------------------------------- --

function Goal_TributeDiplomacy(...)
    return B_Goal_TributeDiplomacy:new(...);
end

B_Goal_TributeDiplomacy = {
    Name = "Goal_TributeDiplomacy",
    Description = {
        en = "Goal: AI requests periodical tribute for better Diplomacy",
        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer bessere Diplomatie. Der Questgeber ist der fordernde Spieler.",
        fr = "Objectif: L'IA demande un tribut régulier pour une meilleure diplomatie. Le donneur de quête est le joueur qui exige."
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité", },
        { ParameterType.Number, en = "Time till next peyment in seconds", de = "Zeit bis zur Forderung in Sekunden", fr = "Temps jusqu'à la demande en secondes", },
        { ParameterType.Number, en = "Time to pay tribute in seconds", de = "Zeit bis zur Zahlung in Sekunden", fr = "Délai avant paiement en secondes", },
        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", fr = "Message de début de quête de tribut", },
        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", fr = "Message de réussite de la quête de tribut", },
        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", fr = "Message de défaite de la quête de tribut", },
        { ParameterType.Custom, en = "Restart if failed to pay", de = "Nicht-bezahlen beendet die Quest", fr = "Ne pas payer met fin à la quête", },
    },
}

function B_Goal_TributeDiplomacy:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_TributeDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 1) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 2) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 3) then
        self.StartMsg = _Parameter;
    elseif (_Index == 4) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 5) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 6) then
        self.RestartAtFailure = ToBoolean(_Parameter);
    end
end

function B_Goal_TributeDiplomacy:GetTributeQuest(_Quest)
    if not self.InternTributeQuest then
        local Language = CONST_LANGUAGE;
        local StartMsg = self.StartMsg;
        if type(StartMsg) == "table" then
            StartMsg = StartMsg[Language];
        end
        local SuccessMsg = self.SuccessMsg;
        if type(SuccessMsg) == "table" then
            SuccessMsg = SuccessMsg[Language];
        end
        local FailureMsg = self.FailureMsg;
        if type(FailureMsg) == "table" then
            FailureMsg = FailureMsg[Language];
        end

        Lib.Core.Quest.QuestCounter = Lib.Core.Quest.QuestCounter+1;

        local QuestID, Quest = QuestTemplate:New (
            _Quest.Identifier.."_TributeDiplomacyQuest_" ..Lib.Core.Quest.QuestCounter,
            _Quest.SendingPlayer,
            _Quest.ReceivingPlayer,
            {{ Objective.Deliver, {Goods.G_Gold, self.Amount}}},
            {{ Triggers.Time, 0 }},
            self.TributTime, nil, nil, nil, nil, true, true, nil,
            StartMsg,
            SuccessMsg,
            FailureMsg
        );
        self.InternTributeQuest = Quest;
    end
end

function B_Goal_TributeDiplomacy:CheckTributeQuest(_Quest)
    if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Over and not self.RestartQuest then
        if self.InternTributeQuest.Result ~= QuestResult.Success then
            SetDiplomacyState( _Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.Enemy);
            if not self.RestartAtFailure then
                return false;
            end
        else
            SetDiplomacyState(_Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.TradeContact);
        end
        self.RestartQuest = true;
        self.Time = Logic.GetTime();
    end
end

function B_Goal_TributeDiplomacy:CheckTributePlayer(_Quest)
    local storeHouse = Logic.GetStoreHouse(_Quest.SendingPlayer);
    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then
        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        return true;
    end
end

function B_Goal_TributeDiplomacy:TributQuestRestarter(_Quest)
    if self.InternTributeQuest and self.Time and self.RestartQuest and ((Logic.GetTime() - self.Time) >= self.PeriodLength) then
        self.InternTributeQuest.Objectives[1].Completed = nil;
        self.InternTributeQuest.Objectives[1].Data[3] = nil;
        self.InternTributeQuest.Objectives[1].Data[4] = nil;
        self.InternTributeQuest.Objectives[1].Data[5] = nil;
        self.InternTributeQuest.Result = nil;
        self.InternTributeQuest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");
        StartSimpleJobEx(_G[QuestTemplate.Loop], self.InternTributeQuest.QueueID);
        self.RestartQuest = nil;
    end
end

function B_Goal_TributeDiplomacy:CustomFunction(_Quest)
    -- Tribut Quest erzeugen
    self:GetTributeQuest(_Quest);
    -- Status des Tributes prüfen.
    if self:CheckTributeQuest(_Quest) == false then
        return false;
    end
    -- Status des fordernden Spielers prüfen.
    if self:CheckTributePlayer(_Quest) == true then
        return true;
    end
    -- Quest neu starten, falls nötig.
    self:TributQuestRestarter(_Quest);
end

function B_Goal_TributeDiplomacy:Debug(_Quest)
    if self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Amount is negative!");
        return true;
    end
    if self.PeriodLength < self.TributTime then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": TributTime too long!");
        return true;
    end
end

function B_Goal_TributeDiplomacy:Reset(_Quest)
    self.Time = nil;
    self.InternTributeQuest = nil;
    self.RestartQuest = nil;
end

function B_Goal_TributeDiplomacy:Interrupt(_Quest)
    if self.InternTributeQuest ~= nil then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
    end
end

function B_Goal_TributeDiplomacy:GetCustomData(_Index)
    if (_Index == 6) then
        return {"true", "false"};
    end
end

RegisterBehavior(B_Goal_TributeDiplomacy);

-- -------------------------------------------------------------------------- --

function Goal_TributeClaim(...)
    return B_Goal_TributeClaim:new(...);
end

B_Goal_TributeClaim = {
    Name = "Goal_TributeClaim",
    Description = {
        en = "Goal: AI requests periodical tribute for a specified territory. The quest sender is the demanding player.",
        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer ein Territorium. Der Questgeber ist der fordernde Spieler.",
        fr = "Objectif: L'IA demande un tribut régulier pour un territoire. Le donneur de quête est le joueur qui exige.",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", fr = "Territoire", },
        { ParameterType.PlayerID, en = "PlayerID", de = "PlayerID", fr = "PlayerID", },
        { ParameterType.Custom, en = "Good Type", de = "Warentyp", fr = "Type de biens", },
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité", },
        { ParameterType.Number, en = "Length of Period in seconds", de = "Sekunden bis zur nächsten Forderung", fr = "secondes jusqu'à la prochaine demande", },
        { ParameterType.Number, en = "Time to pay Tribut in seconds", de = "Zeit bis zur Zahlung in Sekunden", fr = "Délai avant paiement en secondes", },
        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", fr = "Message de début de quête de tribut", },
        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", fr = "Message de réussite de la quête de tribut", },
        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", fr = "Message de défaite de la quête de tribut", },
        { ParameterType.Number, en = "How often to pay (0 = forerver)", de = "Anzahl der Tributquests (0 = unendlich)", fr = "Nombre de quêtes de tribut (0 = infini)", },
        { ParameterType.Custom, en = "Other Owner cancels the Quest", de = "Anderer Spieler kann Quest beenden", fr = "Un autre joueur peut terminer une quête", },
        { ParameterType.Custom, en = "About if a rate is not payed", de = "Nicht-bezahlen beendet die Quest", fr = "Ne pas payer met fin à la quête", },
    },
}

function B_Goal_TributeClaim:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_TributeClaim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        if type(_Parameter) == "string" then
            _Parameter = GetTerritoryIDByName(_Parameter);
        end
        self.TerritoryID = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        self.GoodType = Goods[_Parameter or "G_Gold"];
    elseif (_Index == 3) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 4) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 5) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 6) then
        self.StartMsg = _Parameter;
    elseif (_Index == 7) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 8) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 9) then
        self.HowOften = _Parameter * 1;
    elseif (_Index == 10) then
        self.OtherOwnerCancels = ToBoolean(_Parameter);
    elseif (_Index == 11) then
        self.DontPayCancels = ToBoolean(_Parameter);
    end
end

function B_Goal_TributeClaim:CureOutpost(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if IsExisting(Outpost) and GetHealth(Outpost) < 25 and Logic.IsBuildingBeingKnockedDown(Outpost) == false then
        while (Logic.GetEntityHealth(Outpost) < Logic.GetEntityMaxHealth(Outpost) * 0.6) do
            Logic.HealEntity(Outpost, 1);
        end
    end
end

function B_Goal_TributeClaim:RestartTributeQuest(_Quest)
    if self.InternTributeQuest then
        self.InternTributeQuest.Objectives[1].Completed = nil;
        self.InternTributeQuest.Objectives[1].Data[3] = nil;
        self.InternTributeQuest.Objectives[1].Data[4] = nil;
        self.InternTributeQuest.Objectives[1].Data[5] = nil;
        self.InternTributeQuest.Result = nil;
        self.InternTributeQuest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");
        StartSimpleJobEx(_G[QuestTemplate.Loop], self.InternTributeQuest.QueueID);
    end
end

function B_Goal_TributeClaim:CreateTributeQuest(_Quest)
    if not self.InternTributeQuest then
        local Language = CONST_LANGUAGE;
        local StartMsg = self.StartMsg;
        if type(StartMsg) == "table" then
            StartMsg = StartMsg[Language];
        end
        local SuccessMsg = self.SuccessMsg;
        if type(SuccessMsg) == "table" then
            SuccessMsg = SuccessMsg[Language];
        end
        local FailureMsg = self.FailureMsg;
        if type(FailureMsg) == "table" then
            FailureMsg = FailureMsg[Language];
        end

        Lib.Core.Quest.QuestCounter = Lib.Core.Quest.QuestCounter+1;

        local OnFinished = function()
            self.Time = Logic.GetTime();
        end
        local QuestID, Quest = QuestTemplate:New(
            _Quest.Identifier.."_TributeClaimQuest" ..Lib.Core.Quest.QuestCounter,
            self.PlayerID,
            _Quest.ReceivingPlayer,
            {{ Objective.Deliver, {self.GoodType, self.Amount}}},
            {{ Triggers.Time, 0 }},
            self.TributTime, nil, nil, OnFinished, nil, true, true, nil,
            StartMsg,
            SuccessMsg,
            FailureMsg
        );
        self.InternTributeQuest = Quest;
    end
end

function B_Goal_TributeClaim:OnTributeFailed(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if IsExisting(Outpost) then
        Logic.ChangeEntityPlayerID(Outpost, self.PlayerID);
    end
    Logic.SetTerritoryPlayerID(self.TerritoryID, self.PlayerID);
    self.InternTributeQuest.State = false;
    self.Time = nil;

    if self.DontPayCancels then
        _Quest:Interrupt();
    end
end

function B_Goal_TributeClaim:OnTributePaid(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if self.InternTributeQuest.Result == QuestResult.Success then
        if Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then
            if IsExisting(Outpost) then
                Logic.ChangeEntityPlayerID(Outpost, _Quest.ReceivingPlayer);
            end
            Logic.SetTerritoryPlayerID(self.TerritoryID, _Quest.ReceivingPlayer);
        end
    end
    if self.Time and Logic.GetTime() >= self.Time + self.PeriodLength then
        if self.HowOften and self.HowOften ~= 0 then
            self.TributeCounter = (self.TributeCounter or 0) +1;
            if self.TributeCounter >= self.HowOften then
                return false;
            end
        end
        self:RestartTributeQuest();
        self.Time = nil;
    end
end

function B_Goal_TributeClaim:CustomFunction(_Quest)
    self:CreateTributeQuest(_Quest);
    self:CureOutpost(_Quest);

    if Logic.GetTerritoryPlayerID(self.TerritoryID) == _Quest.ReceivingPlayer
    or Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then
        if self.OtherOwner then
            self:RestartTributeQuest();
            self.OtherOwner = nil;
        end

        -- Quest abgeschlossen
        if self.InternTributeQuest.State == QuestState.Over then
            if self.InternTributeQuest.Result == QuestResult.Failure then
                self:OnTributeFailed(_Quest);
            else
                self:OnTributePaid(_Quest);
            end

        elseif self.InternTributeQuest.State == false then
            if self.Time and Logic.GetTime() >= self.Time + self.PeriodLength then
                self:RestartTributeQuest(_Quest);
            end
        end

    -- Keiner besitzt das Territorium -> Abbruch
    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) == 0 and self.InternTributeQuest then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end

    -- Anderer Besitzer -> Abbruch
    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) ~= self.PlayerID then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        if self.OtherOwnerCancels then
            _Quest:Interrupt();
        end
        self.OtherOwner = true;
    end

    --Fordernder Spieler existiert nicht -> Abbruch
    local storeHouse = Logic.GetStoreHouse(self.PlayerID);
    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then
        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        return true;
    end
end

function B_Goal_TributeClaim:Debug(_Quest)
    if self.TerritoryID == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Unknown Territory");
        return true;
    end
    if not self.Quest and Logic.GetStoreHouse(self.PlayerID) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(");
        return true;
    end
    if self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Amount is negative");
        return true;
    end
    if self.PeriodLength < self.TributTime or self.PeriodLength < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Period Length is wrong");
        return true;
    end
    if self.HowOften < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": HowOften is negative");
        return true;
    end
end

function B_Goal_TributeClaim:Reset(_Quest)
    self.InternTributeQuest = nil;
    self.Time = nil;
    self.OtherOwner = nil;
end

function B_Goal_TributeClaim:Interrupt(_Quest)
    if type(self.InternTributeQuest) == "table" then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
    end
end

function B_Goal_TributeClaim:GetCustomData(_Index)
    if _Index == 2 then
        local Data = {};
        for k, v in pairs(Goods) do
            if string.find(k, "^G_") then
                table.insert(Data, k);
            end
        end
        table.sort(Data);
        return Data;
    elseif (_Index == 10) or (_Index == 11) then
        return {"false", "true"};
    end
end

RegisterBehavior(B_Goal_TributeClaim);

-- -------------------------------------------------------------------------- --

function Reprisal_ObjectDeactivate(...)
    return B_Reprisal_InteractiveObjectDeactivate:new(...);
end

B_Reprisal_InteractiveObjectDeactivate = {
    Name = "Reprisal_InteractiveObjectDeactivate",
    Description = {
        en = "Reprisal: Deactivates an interactive object",
        de = "Vergeltung: Deaktiviert ein interaktives Objekt",
        fr = "Rétribution: désactive un objet interactif",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object", de = "Interaktives Objekt", fr = "Object interactif" },
    },
}

function B_Reprisal_InteractiveObjectDeactivate:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_InteractiveObjectDeactivate:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.ScriptName = _Parameter
    end

end

function B_Reprisal_InteractiveObjectDeactivate:CustomFunction(_Quest)
    InteractiveObjectDeactivate(self.ScriptName);
end

function B_Reprisal_InteractiveObjectDeactivate:Debug(_Quest)
    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");
        self.WarningPrinted = true;
    end
    local eID = GetID(self.ScriptName);
    if CONST_INITIALIZED_OBJECTS[eID] and CONST_INITIALIZED_OBJECTS[eID] == _Quest.Identifier then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": you can not deactivate in the same quest the object is initalized!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_InteractiveObjectDeactivate);

-- -------------------------------------------------------------------------- --

function Reprisal_ObjectActivate(...)
    return B_Reprisal_InteractiveObjectActivate:new(...);
end

B_Reprisal_InteractiveObjectActivate = {
    Name = "Reprisal_InteractiveObjectActivate",
    Description = {
        en = "Reprisal: Activates an interactive object",
        de = "Vergeltung: Aktiviert ein interaktives Objekt",
        fr = "Retribution : active un objet interactif",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object",  de = "Interaktives Objekt", fr = "Object interactif" },
        { ParameterType.Custom,     en = "Availability",        de = "Nutzbarkeit",         fr = "Utilisabilité" },
    },
}

function B_Reprisal_InteractiveObjectActivate:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_InteractiveObjectActivate:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        local parameter = 0
        if _Parameter == "Always" or 1 then
            parameter = 1
        end
        self.UsingState = parameter * 1
    end
end

function B_Reprisal_InteractiveObjectActivate:CustomFunction(_Quest)
    InteractiveObjectActivate(self.ScriptName, self.UsingState);
end

function B_Reprisal_InteractiveObjectActivate:GetCustomData( _Index )
    if _Index == 1 then
        return {"Knight only", "Always"}
    end
end

function B_Reprisal_InteractiveObjectActivate:Debug(_Quest)
    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");
        self.WarningPrinted = true;
    end
    local eID = GetID(self.ScriptName);
    if CONST_INITIALIZED_OBJECTS[eID] and CONST_INITIALIZED_OBJECTS[eID] == _Quest.Identifier then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": you can not activate in the same quest the object is initalized!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_InteractiveObjectActivate);

-- -------------------------------------------------------------------------- --

function Reprisal_DiplomacyDecrease()
    return B_Reprisal_SlightlyDiplomacyDecrease:new();
end

B_Reprisal_SlightlyDiplomacyDecrease = {
    Name = "Reprisal_SlightlyDiplomacyDecrease",
    Description = {
        en = "Reprisal: Diplomacy decreases slightly to another player.",
        de = "Vergeltung: Der Diplomatiestatus zum Auftraggeber wird um eine Stufe verringert.",
        fr = "Rétribution: le statut diplomatique avec le mandant est réduit d'un niveau.",
    },
}

function B_Reprisal_SlightlyDiplomacyDecrease:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_SlightlyDiplomacyDecrease:CustomFunction(_Quest)
    local Sender = _Quest.SendingPlayer;
    local Receiver = _Quest.ReceivingPlayer;
    local State = GetDiplomacyState(Receiver, Sender);
    if State > -2 then
        SetDiplomacyState(Receiver, Sender, State-1);
    end
end

function B_Reprisal_SlightlyDiplomacyDecrease:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

RegisterBehavior(B_Reprisal_SlightlyDiplomacyDecrease);

-- -------------------------------------------------------------------------- --

function Reprisal_Diplomacy(...)
    return B_Reprisal_Diplomacy:new(...);
end

B_Reprisal_Diplomacy = {
    Name = "Reprisal_Diplomacy",
    Description = {
        en = "Reprisal: Sets Diplomacy state of two Players to a stated value.",
        de = "Vergeltung: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.",
        fr = "Rétribution: Définit le statut diplomatique de deux joueurs sur la valeur indiquée.",
    },
    Parameter = {
        { ParameterType.PlayerID,         en = "PlayerID 1", de = "Spieler 1", fr = "Joueur 1" },
        { ParameterType.PlayerID,         en = "PlayerID 2", de = "Spieler 2", fr = "Joueur 2" },
        { ParameterType.DiplomacyState,   en = "Relation",   de = "Beziehung", fr = "Relation diplomatique" },
    },
}

function B_Reprisal_Diplomacy:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_Diplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID1 = _Parameter * 1
    elseif (_Index == 1) then
        self.PlayerID2 = _Parameter * 1
    elseif (_Index == 2) then
        self.Relation = DiplomacyStates[_Parameter]
    end
end

function B_Reprisal_Diplomacy:CustomFunction(_Quest)
    SetDiplomacyState(self.PlayerID1, self.PlayerID2, self.Relation);
end

function B_Reprisal_Diplomacy:Debug(_Quest)
    if not tonumber(self.PlayerID1) or self.PlayerID1 < 1 or self.PlayerID1 > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": PlayerID 1 is invalid!");
        return true;
    elseif not tonumber(self.PlayerID2) or self.PlayerID2 < 1 or self.PlayerID2 > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": PlayerID 2 is invalid!");
        return true;
    elseif not tonumber(self.Relation) or self.Relation < -2 or self.Relation > 2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": '"..self.Relation.."' is a invalid diplomacy state!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_Diplomacy);

-- -------------------------------------------------------------------------- --

function Reprisal_DestroyEntity(...)
    return B_Reprisal_DestroyEntity:new(...);
end

B_Reprisal_DestroyEntity = {
    Name = "Reprisal_DestroyEntity",
    Description = {
        en = "Reprisal: Replaces an entity with an invisible script entity, which retains the entities name.",
        de = "Vergeltung: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.",
        fr = "Rétribution: remplace une entité par une entité de script invisible qui prend son nom.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity", de = "Entity", fr = "Entité" },
    },
}

function B_Reprisal_DestroyEntity:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_DestroyEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Reprisal_DestroyEntity:CustomFunction(_Quest)
    ReplaceEntity(self.ScriptName, Entities.XD_ScriptEntity);
end

function B_Reprisal_DestroyEntity:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        warn(false, _Quest.Identifier .. ": " ..self.Name..": '" ..self.ScriptName.. "' is already destroyed!");
        self.WarningPrinted = true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_DestroyEntity);

-- -------------------------------------------------------------------------- --

function Reprisal_DestroyEffect(...)
    return B_Reprisal_DestroyEffect:new(...);
end

B_Reprisal_DestroyEffect = {
    Name = "Reprisal_DestroyEffect",
    Description = {
        en = "Reprisal: Destroys an effect",
        de = "Vergeltung: Zerstört einen Effekt",
        fr = "Rétribution: détruit un effet",
    },
    Parameter = {
        { ParameterType.Default, en = "Effect name", de = "Effektname", fr = "Nom de l'effet" },
    }
}

function B_Reprisal_DestroyEffect:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.EffectName = _Parameter;
    end
end

function B_Reprisal_DestroyEffect:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } };
end

function B_Reprisal_DestroyEffect:CustomFunction(_Quest)
    if not CONST_EFFECT_NAME_TO_ID[self.EffectName] or not Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName]) then
        return;
    end
    Logic.DestroyEffect(CONST_EFFECT_NAME_TO_ID[self.EffectName]);
end

function B_Reprisal_DestroyEffect:Debug(_Quest)
    if not CONST_EFFECT_NAME_TO_ID[self.EffectName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Effect " .. self.EffectName .. " never created")
    end
    return false;
end

RegisterBehavior(B_Reprisal_DestroyEffect);

-- -------------------------------------------------------------------------- --

function Reprisal_Defeat()
    return B_Reprisal_Defeat:new()
end

B_Reprisal_Defeat = {
    Name = "Reprisal_Defeat",
    Description = {
        en = "Reprisal: The player loses the game.",
        de = "Vergeltung: Der Spieler verliert das Spiel.",
        fr = "Rétribution: le joueur perd la partie.",
    },
}

function B_Reprisal_Defeat:GetReprisalTable()
    return {Reprisal.Defeat};
end

RegisterBehavior(B_Reprisal_Defeat);

-- -------------------------------------------------------------------------- --

function Reprisal_FakeDefeat()
    return B_Reprisal_FakeDefeat:new();
end

B_Reprisal_FakeDefeat = {
    Name = "Reprisal_FakeDefeat",
    Description = {
        en = "Reprisal: Displays a defeat icon for a quest",
        de = "Vergeltung: Zeigt ein Niederlage Icon fuer eine Quest an",
        fr = "Rétribution: affiche une icône de défaite pour une quête",
    },
}

function B_Reprisal_FakeDefeat:GetReprisalTable()
    return { Reprisal.FakeDefeat }
end

RegisterBehavior(B_Reprisal_FakeDefeat);

-- -------------------------------------------------------------------------- --

function Reprisal_ReplaceEntity(...)
    return B_Reprisal_ReplaceEntity:new(...);
end

B_Reprisal_ReplaceEntity = {
    Name = "Reprisal_ReplaceEntity",
    Description = {
        en = "Reprisal: Replaces an entity with a new one of a different type. The playerID can be changed too.",
        de = "Vergeltung: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.",
        fr = "Rétribution: remplace une entité par une nouvelle entité d'un autre type. Il est également possible de changer l'appartenance d'un joueur.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target", de = "Ziel", fr = "Cible" },
        { ParameterType.Custom, en = "New Type", de = "Neuer Typ", fr = "Nouveau type" },
        { ParameterType.Custom, en = "New playerID", de = "Neue Spieler ID", fr = "Nouvelle ID de joueur" },
    },
}

function B_Reprisal_ReplaceEntity:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_ReplaceEntity:AddParameter(_Index, _Parameter)
   if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.NewType = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = tonumber(_Parameter);
    end
end

function B_Reprisal_ReplaceEntity:CustomFunction(_Quest)
    local eID = GetID(self.ScriptName);
    local pID = self.PlayerID;
    if pID == Logic.EntityGetPlayer(eID) then
        pID = nil;
    end
    ReplaceEntity(self.ScriptName, Entities[self.NewType], pID);
end

function B_Reprisal_ReplaceEntity:GetCustomData(_Index)
    local Data = {}
    if _Index == 1 then
        for k, v in pairs( Entities ) do
            local name = {"^M_","^XS_","^X_","^XT_","^Z_", "^XB_"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        Data = {"-","0","1","2","3","4","5","6","7","8",}
    end
    return Data
end

function B_Reprisal_ReplaceEntity:Debug(_Quest)
    if not Entities[self.NewType] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid entity type!");
        return true;
    elseif self.PlayerID ~= nil and (self.PlayerID < 1 or self.PlayerID > 8) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end

    if not IsExisting(self.ScriptName) then
        self.WarningPrinted = true;
        warn(false, _Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' does not exist!");
    end
    return false;
end

RegisterBehavior(B_Reprisal_ReplaceEntity);

-- -------------------------------------------------------------------------- --

function Reprisal_QuestRestart(...)
    return B_Reprisal_QuestRestart:new(...)
end

B_Reprisal_QuestRestart = {
    Name = "Reprisal_QuestRestart",
    Description = {
        en = "Reprisal: Restarts a (completed) quest so it can be triggered and completed again",
        de = "Vergeltung: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann",
        fr = "Rétribution : relance une quête (terminée) pour qu'elle puisse être redéclenchée et terminée à nouveau",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestRestart:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestRestart:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestRestart:CustomFunction(_Quest)
    RestartQuest(self.QuestName, true);
end

function B_Reprisal_QuestRestart:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestRestart);

-- -------------------------------------------------------------------------- --

function Reprisal_QuestFailure(...)
    return B_Reprisal_QuestFailure:new(...)
end

B_Reprisal_QuestFailure = {
    Name = "Reprisal_QuestFailure",
    Description = {
        en = "Reprisal: Lets another active quest fail",
        de = "Vergeltung: Lässt eine andere aktive Quest fehlschlagen",
        fr = "Rétribution: fait échouer une autre quête active",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestFailure:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestFailure:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestFailure:CustomFunction(_Quest)
    FailQuest(self.QuestName, true);
end

function B_Reprisal_QuestFailure:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid quest!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestFailure);

-- -------------------------------------------------------------------------- --

function Reprisal_QuestSuccess(...)
    return B_Reprisal_QuestSuccess:new(...)
end

B_Reprisal_QuestSuccess = {
    Name = "Reprisal_QuestSuccess",
    Description = {
        en = "Reprisal: Completes another active quest successfully",
        de = "Vergeltung: Beendet eine andere aktive Quest erfolgreich",
        fr = "Rétribution: Réussir une autre quête active",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestSuccess:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestSuccess:CustomFunction(_Quest)
    WinQuest(self.QuestName, true);
end

function B_Reprisal_QuestSuccess:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestSuccess);

-- -------------------------------------------------------------------------- --

function Reprisal_QuestActivate(...)
    return B_Reprisal_QuestActivate:new(...)
end

B_Reprisal_QuestActivate = {
    Name = "Reprisal_QuestActivate",
    Description = {
        en = "Reprisal: Activates another quest that is not triggered yet.",
        de = "Vergeltung: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.",
        fr = "Rétribution: Active une autre quête qui n'a pas encore été déclenchée.",
    },
    Parameter = {
        {ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête", },
    },
}

function B_Reprisal_QuestActivate:GetReprisalTable()
    return {Reprisal.Custom, {self, self.CustomFunction} }
end

function B_Reprisal_QuestActivate:AddParameter(_Index, _Parameter)
    if (_Index==0) then
        self.QuestName = _Parameter
    else
        assert(false, "Error in " .. self.Name .. ": AddParameter: Index is invalid")
    end
end

function B_Reprisal_QuestActivate:CustomFunction(_Quest)
    StartQuest(self.QuestName, true);
end

function B_Reprisal_QuestActivate:Debug(_Quest)
    if not IsValidQuest(self.QuestName) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Quest: "..  self.QuestName .. " does not exist");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestActivate)

-- -------------------------------------------------------------------------- --

function Reprisal_QuestInterrupt(...)
    return B_Reprisal_QuestInterrupt:new(...)
end

B_Reprisal_QuestInterrupt = {
    Name = "Reprisal_QuestInterrupt",
    Description = {
        en = "Reprisal: Interrupts another active quest without success or failure",
        de = "Vergeltung: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg",
        fr = "Rétribution : termine une autre quête active sans succès ni échec",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestInterrupt:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestInterrupt:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestInterrupt:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then

        local QuestID = GetQuestID(self.QuestName)
        local Quest = Quests[QuestID]
        if Quest.State == QuestState.Active then
            StopQuest(self.QuestName, true);
        end
    end
end

function B_Reprisal_QuestInterrupt:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestInterrupt);

-- -------------------------------------------------------------------------- --

function Reprisal_QuestForceInterrupt(...)
    return B_Reprisal_QuestForceInterrupt:new(...)
end

B_Reprisal_QuestForceInterrupt = {
    Name = "Reprisal_QuestForceInterrupt",
    Description = {
        en = "Reprisal: Interrupts another quest (even when it isn't active yet) without success or failure",
        de = "Vergeltung: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg",
        fr = "Rétribution: Termine une autre quête, même si elle n'est pas encore active, sans succès ni échec.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
        { ParameterType.Custom, en = "Ended quests", de = "Beendete Quests", fr = "Quêtes terminées" },
    },
}

function B_Reprisal_QuestForceInterrupt:GetReprisalTable()

    return { Reprisal.Custom,{self, self.CustomFunction} }

end

function B_Reprisal_QuestForceInterrupt:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.InterruptEnded = ToBoolean(_Parameter)
    end

end

function B_Reprisal_QuestForceInterrupt:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reprisal_QuestForceInterrupt:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then

        local QuestID = GetQuestID(self.QuestName)
        local Quest = Quests[QuestID]
        if self.InterruptEnded or Quest.State ~= QuestState.Over then
            Quest:Interrupt();
        end
    end
end

function B_Reprisal_QuestForceInterrupt:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestForceInterrupt);

-- -------------------------------------------------------------------------- --

function Reprisal_CustomVariables(...)
    return B_Reprisal_CustomVariables:new(...);
end

B_Reprisal_CustomVariables = {
    Name = "Reprisal_CustomVariables",
    Description = {
        en = "Reprisal: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.",
        de = "Vergeltung: Führt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.",
        fr = "Rétribution: effectue une opération mathématique sur la variable. L'autre opérateur peut être un nombre ou une variable personnalisée.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of variable", de = "Variablenname", fr = "Nom de la variable" },
        { ParameterType.Custom,  en = "Operator", de = "Operator", fr = "Operateur" },
        { ParameterType.Default,  en = "Value or variable", de = "Wert oder Variable", fr = "Valeur ou variable" }
    }
};

function B_Reprisal_CustomVariables:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} };
end

function B_Reprisal_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Operator = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        self.Value = (value == nil and tostring(_Parameter)) or value;
    end
end

function B_Reprisal_CustomVariables:CustomFunction()
    local Value1 = ObtainCustomVariable("BehaviorVariable_" ..self.VariableName, 0);
    local Value2 = self.Value;
    if type(self.Value) == "string" then
        Value2 = ObtainCustomVariable("BehaviorVariable_" ..self.Value, 0);
    end

    if self.Operator == "=" then
        Value1 = Value2;
    elseif self.Operator == "+" then
        Value1 = Value1 + Value2;
    elseif self.Operator == "-" then
        Value1 = Value1 - Value2;
    elseif self.Operator == "*" then
        Value1 = Value1 * Value2;
    elseif self.Operator == "/" then
        Value1 = Value1 / Value2;
    elseif self.Operator == "^" then
        Value1 = Value1 % Value2;
    end
    SaveCustomVariable("BehaviorVariable_"..self.VariableName, Value1);
end

function B_Reprisal_CustomVariables:GetCustomData( _Index )
    return {"=", "+", "-", "*", "/", "^"};
end

function B_Reprisal_CustomVariables:Debug(_Quest)
    local operators = {"=", "+", "-", "*", "/", "^"};
    if not table.contains(operators, self.Operator) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid operator!");
        return true;
    elseif self.VariableName == "" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": missing name for variable!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_CustomVariables)

-- -------------------------------------------------------------------------- --

function Reprisal_MapScriptFunction(...)
    return B_Reprisal_MapScriptFunction:new(...);
end

B_Reprisal_MapScriptFunction = {
    Name = "Reprisal_MapScriptFunction",
    Description = {
        en = "Reprisal: Calls a function within the global map script if the quest has failed.",
        de = "Vergeltung: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.",
        fr = "Rétribution: lance une fonction dans le script global de la carte en cas d'échec de la quête.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname", fr = "Nom de la fonction" },
    },
}

function B_Reprisal_MapScriptFunction:GetReprisalTable()
    return {Reprisal.Custom, {self, self.CustomFunction}};
end

function B_Reprisal_MapScriptFunction:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.FuncName = _Parameter;
    end
end

function B_Reprisal_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        self.FuncName(unpack(self.i47ya_6aghw_frxil));
        return;
    end
    _G[self.FuncName](self, _Quest);
end

function B_Reprisal_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_MapScriptFunction);

-- -------------------------------------------------------------------------- --

function Reprisal_Technology(...)
    return B_Reprisal_Technology:new(...);
end

B_Reprisal_Technology = {
    Name = "Reprisal_Technology",
    Description = {
        en = "Reprisal: Locks or unlocks a technology for the given player",
        de = "Vergeltung: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player",
        fr = "Rétribution: bloque ou autorise une technologie pour le joueur spécifié",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "PlayerID", de = "SpielerID", fr = "PlayerID" },
        { ParameterType.Custom,   en = "Un / Lock", de = "Sperren/Erlauben", fr = "Bloquer/Autoriser" },
        { ParameterType.Custom,   en = "Technology", de = "Technologie"; fr = "Technologie" },
    },
}

function B_Reprisal_Technology:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} }
end

function B_Reprisal_Technology:AddParameter(_Index, _Parameter)
    if (_Index ==0) then
        self.PlayerID = _Parameter*1
    elseif (_Index == 1) then
        self.LockType = _Parameter == "Lock"
    elseif (_Index == 2) then
        self.Technology = _Parameter
    end
end

function B_Reprisal_Technology:CustomFunction(_Quest)
    if self.PlayerID
    and Logic.GetStoreHouse(self.PlayerID) ~= 0
    and Technologies[self.Technology]
    then
        if self.LockType  then
            LockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        else
            UnLockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        end
    else
        return false
    end
end

function B_Reprisal_Technology:GetCustomData(_Index)
    local Data = {}
    if (_Index == 1) then
        Data[1] = "Lock"
        Data[2] = "UnLock"
    elseif (_Index == 2) then
        for k, v in pairs( Technologies ) do
            table.insert( Data, k )
        end
    end
    return Data
end

function B_Reprisal_Technology:Debug(_Quest)
    if not Technologies[self.Technology] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid technology type!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_Technology);

-- -------------------------------------------------------------------------- --

function Reward_ObjectDeactivate(...)
    return B_Reward_InteractiveObjectDeactivate:new(...);
end

B_Reward_InteractiveObjectDeactivate = CopyTable(B_Reprisal_InteractiveObjectDeactivate);
B_Reward_InteractiveObjectDeactivate.Name             = "Reward_InteractiveObjectDeactivate";
B_Reward_InteractiveObjectDeactivate.Description.en   = "Reward: Deactivates an interactive object";
B_Reward_InteractiveObjectDeactivate.Description.de   = "Lohn: Deaktiviert ein interaktives Objekt";
B_Reward_InteractiveObjectDeactivate.Description.fr   = "Récompense: Désactive un objet interactif";
B_Reward_InteractiveObjectDeactivate.GetReprisalTable = nil;

B_Reward_InteractiveObjectDeactivate.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_InteractiveObjectDeactivate);

-- -------------------------------------------------------------------------- --

function Reward_ObjectActivate(...)
    return B_Reward_InteractiveObjectActivate:new(...);
end

B_Reward_InteractiveObjectActivate = CopyTable(B_Reprisal_InteractiveObjectActivate);
B_Reward_InteractiveObjectActivate.Name             = "Reward_InteractiveObjectActivate";
B_Reward_InteractiveObjectActivate.Description.en   = "Reward: Activates an interactive object";
B_Reward_InteractiveObjectActivate.Description.de   = "Lohn: Aktiviert ein interaktives Objekt";
B_Reward_InteractiveObjectActivate.Description.fr   = "Récompense: Active un objet interactif";
B_Reward_InteractiveObjectActivate.GetReprisalTable = nil;

B_Reward_InteractiveObjectActivate.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} };
end

RegisterBehavior(B_Reward_InteractiveObjectActivate);

-- -------------------------------------------------------------------------- --

function Reward_ObjectInit(...)
    return B_Reward_ObjectInit:new(...);
end

B_Reward_ObjectInit = {
    Name = "Reward_ObjectInit",
    Description = {
        en = "Reward: Setup an interactive object with costs and rewards.",
        de = "Lohn: Initialisiert ein interaktives Objekt mit seinen Kosten und Schätzen.",
        fr = "Récompense: Initialise un objet interactif avec ses coûts et ses trésors.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object", de = "Interaktives Objekt",  fr = "Obejct interactif" },
        { ParameterType.Number,     en = "Distance to use",    de = "Nutzungsentfernung",   fr = "Distance d'utilisation" },
        { ParameterType.Number,     en = "Waittime",           de = "Wartezeit",            fr = "Temps d'attente" },
        { ParameterType.Custom,     en = "Reward good",        de = "Belohnungsware",       fr = "Produits de récompense" },
        { ParameterType.Number,     en = "Reward amount",      de = "Anzahl",               fr = "Quantité" },
        { ParameterType.Custom,     en = "Cost good 1",        de = "Kostenware 1",         fr = "Marchandise de coût 1" },
        { ParameterType.Number,     en = "Cost amount 1",      de = "Anzahl 1",             fr = "Quantité 1" },
        { ParameterType.Custom,     en = "Cost good 2",        de = "Kostenware 2",         fr = "Marchandise de coût 2" },
        { ParameterType.Number,     en = "Cost amount 2",      de = "Anzahl 2",             fr = "Quantité 2" },
        { ParameterType.Custom,     en = "Availability",       de = "Verfügbarkeit",        fr = "Disponibilité" },
    },
}

function B_Reward_ObjectInit:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_ObjectInit:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.Distance = _Parameter * 1
    elseif (_Index == 2) then
        self.Waittime = _Parameter * 1
    elseif (_Index == 3) then
        self.RewardType = _Parameter
    elseif (_Index == 4) then
        self.RewardAmount = _Parameter * 1
    elseif (_Index == 5) then
        self.FirstCostType = _Parameter
    elseif (_Index == 6) then
        self.FirstCostAmount = _Parameter * 1
    elseif (_Index == 7) then
        self.SecondCostType = _Parameter
    elseif (_Index == 8) then
        self.SecondCostAmount = _Parameter * 1
    elseif (_Index == 9) then
        local parameter = nil
        if _Parameter == "Always" or _Parameter == 1 then
            parameter = 1
        elseif _Parameter == "Never" or _Parameter == 2 then
            parameter = 2
        elseif _Parameter == "Knight only" or _Parameter == 0 then
            parameter = 0
        end
        self.UsingState = parameter
    end
end

function B_Reward_ObjectInit:CustomFunction(_Quest)
    local eID = GetID(self.ScriptName);
    if eID == 0 then
        return;
    end
    CONST_INITIALIZED_OBJECTS[eID] = _Quest.Identifier;

    Logic.InteractiveObjectClearCosts(eID);
    Logic.InteractiveObjectClearRewards(eID);

    Logic.InteractiveObjectSetInteractionDistance(eID, self.Distance);
    Logic.InteractiveObjectSetTimeToOpen(eID, self.Waittime);

    if self.RewardType and self.RewardType ~= "-" then
        Logic.InteractiveObjectAddRewards(eID, Goods[self.RewardType], self.RewardAmount);
    end
    if self.FirstCostType and self.FirstCostType ~= "-" then
        Logic.InteractiveObjectAddCosts(eID, Goods[self.FirstCostType], self.FirstCostAmount);
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        Logic.InteractiveObjectAddCosts(eID, Goods[self.SecondCostType], self.SecondCostAmount);
    end

    Logic.InteractiveObjectSetAvailability(eID,true);
    if self.UsingState then
        for i=1, 8 do
            Logic.InteractiveObjectSetPlayerState(eID,i, self.UsingState);
        end
    end

    Logic.InteractiveObjectSetRewardResourceCartType(eID,Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetRewardGoldCartType(eID,Entities.U_GoldCart);
    Logic.InteractiveObjectSetCostResourceCartType(eID,Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetCostGoldCartType(eID, Entities.U_GoldCart);
    RemoveInteractiveObjectFromOpenedList(eID);
    table.insert(HiddenTreasures,eID);
end

function B_Reward_ObjectInit:GetCustomData( _Index )
    if _Index == 3 or _Index == 5 or _Index == 7 then
        local Data = {
            "-",
            "G_Beer",
            "G_Bread",
            "G_Broom",
            "G_Carcass",
            "G_Cheese",
            "G_Clothes",
            "G_Dye",
            "G_Gold",
            "G_Grain",
            "G_Herb",
            "G_Honeycomb",
            "G_Iron",
            "G_Leather",
            "G_Medicine",
            "G_Milk",
            "G_RawFish",
            "G_Salt",
            "G_Sausage",
            "G_SmokedFish",
            "G_Soap",
            "G_Stone",
            "G_Water",
            "G_Wood",
            "G_Wool",
        }

        if g_GameExtraNo >= 1 then
            Data[#Data+1] = "G_Gems"
            Data[#Data+1] = "G_MusicalInstrument"
            Data[#Data+1] = "G_Olibanum"
        end
        return Data
    elseif _Index == 9 then
        return {"-", "Knight only", "Always", "Never",}
    end
end

function B_Reward_ObjectInit:Debug(_Quest)
    if Logic.IsInteractiveObject(GetID(self.ScriptName)) == false then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.ScriptName.."' is not a interactive object!");
        return true;
    end
    if self.UsingState ~= 1 and self.Distance < 50 then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": distance is maybe too short!");
    end
    if self.Waittime < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waittime must be equal or greater than 0!");
        return true;
    end
    if self.RewardType and self.RewardType ~= "-" then
        if not Goods[self.RewardType] then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.RewardType.."' is invalid good type!");
            return true;
        elseif self.RewardAmount < 1 then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    if self.FirstCostType and self.FirstCostType ~= "-" then
        if not Goods[self.FirstCostType] then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.FirstCostType.."' is invalid good type!");
            return true;
        elseif self.FirstCostAmount < 1 then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        if not Goods[self.SecondCostType] then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.SecondCostType.."' is invalid good type!");
            return true;
        elseif self.SecondCostAmount < 1 then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    return false;
end

RegisterBehavior(B_Reward_ObjectInit);

-- -------------------------------------------------------------------------- --

function Reward_Diplomacy(...)
    return B_Reward_Diplomacy:new(...);
end

B_Reward_Diplomacy = CopyTable(B_Reprisal_Diplomacy);
B_Reward_Diplomacy.Name             = "Reward_Diplomacy";
B_Reward_Diplomacy.Description.en   = "Reward: Sets Diplomacy state of two Players to a stated value.";
B_Reward_Diplomacy.Description.de   = "Lohn: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.";
B_Reward_Diplomacy.Description.fr   = "Récompense: Définit le statut diplomatique de deux joueurs sur la valeur indiquée.";
B_Reward_Diplomacy.GetReprisalTable = nil;

B_Reward_Diplomacy.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_Diplomacy);

-- -------------------------------------------------------------------------- --

function Reward_DiplomacyIncrease()
    return B_Reward_SlightlyDiplomacyIncrease:new();
end

B_Reward_SlightlyDiplomacyIncrease = {
    Name = "Reward_SlightlyDiplomacyIncrease",
    Description = {
        en = "Reward: Diplomacy increases slightly to another player",
        de = "Lohn: Verbesserung des Diplomatiestatus zu einem anderen Spieler",
        fr = "Récompense: Amélioration du statut diplomatique avec un autre joueur",
    },
}

function B_Reward_SlightlyDiplomacyIncrease:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_SlightlyDiplomacyIncrease:CustomFunction(_Quest)
    local Sender = _Quest.SendingPlayer;
    local Receiver = _Quest.ReceivingPlayer;
    local State = GetDiplomacyState(Receiver, Sender);
    if State < 2 then
        SetDiplomacyState(Receiver, Sender, State+1);
    end
end

function B_Reward_SlightlyDiplomacyIncrease:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

RegisterBehavior(B_Reward_SlightlyDiplomacyIncrease);

-- -------------------------------------------------------------------------- --

function Reward_TradePost(...)
    return B_Reward_TradePost:new(...);
end

B_Reward_TradePost= {
    Name = "B_Reward_TradePost",
    Description = {
        en = "Sets options for a Tradepost and deactivates it.",
        de = "Stellt einen Handelsposten ein und deaktiviert ihn.",
        fr = "",
    },
    Parameter = {
        {ParameterType.ScriptName, en = "ScriptName", de = "ScriptName" },
        {ParameterType.PlayerID, en = "PlayerID", de = "PlayerID" },
        {ParameterType.Custom, en = "Type of good to pay 1", de = "Resourcentyp Bezahlung 1", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to get 1", de = "Resourcentyp Angebot 1", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource" },
        {ParameterType.Custom, en = "Type of good to pay 2", de = "Resourcentyp Bezahlung 2", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to get 2", de = "Resourcentyp Angebot 2", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to pay 3", de = "Resourcentyp Bezahlung 3", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to get 3", de = "Resourcentyp Angebot 3", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to pay 4", de = "Resourcentyp Bezahlung 4", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to get 4", de = "Resourcentyp Angebot 4", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
    },
}

function B_Reward_TradePost:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction}};
end
function B_Reward_TradePost:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 3) then
        self.PayType1 = _Parameter;
    elseif (_Index == 4) then
        self.PayAmount1 = _Parameter * 1;
    elseif (_Index == 5) then
        self.OfferType1 = _Parameter;
    elseif (_Index == 6) then
        self.OfferAmount1 = _Parameter * 1;
    elseif (_Index == 7) then
        self.PayType2 = _Parameter;
    elseif (_Index == 8) then
        self.PayAmount2 = _Parameter * 1;
    elseif (_Index == 9) then
        self.OfferType2 = _Parameter;
    elseif (_Index == 10) then
        self.OfferAmount2 = _Parameter * 1;
    elseif (_Index == 11) then
        self.PayType3 = _Parameter;
    elseif (_Index == 12) then
        self.PayAmount3 = _Parameter * 1;
    elseif (_Index == 13) then
        self.OfferType3 = _Parameter;
    elseif (_Index == 14) then
        self.OfferAmount3 = _Parameter * 1;
    elseif (_Index == 15) then
        self.PayType4 = _Parameter;
    elseif (_Index == 16) then
        self.PayAmount4 = _Parameter * 1;
    elseif (_Index == 17) then
        self.OfferType4 = _Parameter;
    elseif (_Index == 18) then
        self.OfferAmount4 = _Parameter * 1;
    end
end

function B_Reward_TradePost:CustomFunction(_Quest)
    local OfferCount = 0;
    for i = 1, 4 do
        if self["PayAmount"..i] and self["PayAmount"..i] > 0 and self["OfferAmount"..i] and self["OfferAmount"..i] > 0 then
            OfferCount = i;
        else
            break;
        end
    end
    debug(IsExisting(self.ScriptName), _Quest.Identifier .. ": Error in " .. self.Name .. ": CustomFunction: Tradepost is missing");
    local TradepostID = GetID(self.ScriptName);
    if OfferCount > 0 then
        Logic.TradePost_SetTradePartnerGenerateGoodsFlag(TradepostID, true);
        Logic.TradePost_SetTradePartnerPlayerID(TradepostID, self.PlayerID);
        for i = 1, OfferCount do
            for j = 1, OfferCount do
                Logic.TradePost_SetTradeDefinition(
                    TradepostID,
                    (j-1),
                    Goods[self["PayType"..j]],
                    self["PayAmount"..j],
                    Goods[self["OfferType"..j]],
                    self["OfferAmount"..j]
                );
            end
        end
        Logic.TradePost_SetActiveTradeSlot(TradepostID, 0);
        Logic.InteractiveObjectSetAvailability(TradepostID, false);
        for PlayerID = 1, 8 do
            Logic.InteractiveObjectSetPlayerState(TradepostID, PlayerID, 2);
        end
    end
end

function B_Reward_TradePost:DEBUG(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        debug(false, _Quest.Identifier .. ":  Error in " .. self.Name ..": Player " .. self.PlayerID .. " is dead :-(");
        return true;
    elseif not IsExisting(self.ScriptName) then
        debug(false, _Quest.Identifier .. ":  Error in " .. self.Name ..": No TradePost found");
        return true;
    end
    for i = 1, 4 do
        if  self["PayAmount"..i]
        and self["OfferAmount"..i]
        and self["PayAmount"..i] > 0
        and self["OfferAmount"..i] > 0
        and (not Goods[self["PayType"..i]] or
             not Goods[self["OfferType"..i]])
        then
            debug(false, _Quest.Identifier .. ":  Error in " .. self.Name ..": Offer type or pay type in Slot " .. i .. " is wrong")
            return true
        end
    end
end

function B_Reward_TradePost:GetCustomData(_index)
    if _index >= 2 and _index <= 16 and _index % 2 == 0 then
        return {
            "G_Carcass",
            "G_Grain",
            "G_Herb",
            "G_Honeycomb",
            "G_Iron",
            "G_Milk",
            "G_RawFish",
            "G_Stone",
            "G_Wood",
            "G_Wool",
            "G_Salt",
            "G_Dye",
            "G_Olibanum",
            "G_Gems",
            "G_MusicalInstrument",
        };
    end
end

if g_GameExtraNo and g_GameExtraNo >= 1 then
    RegisterBehavior(B_Reward_TradePost);
end

-- -------------------------------------------------------------------------- --

function Reward_TradeOffers(...)
    return B_Reward_Merchant:new(...);
end

B_Reward_Merchant = {
    Name = "Reward_Merchant",
    Description = {
        en = "Reward: Deletes all existing offers for a merchant and sets new offers, if given",
        de = "Lohn: Löscht alle Angebote eines Händlers und setzt neue, wenn angegeben",
        fr = "Récompense: Supprime toutes les offres d'un commerçant et en place de nouvelles si elles sont indiquées.",
    },
    Parameter = {
        { ParameterType.Custom, en = "PlayerID", de = "PlayerID",  fr = "PlayerID" },
        { ParameterType.Custom, en = "Amount 1", de = "Menge 1",   fr = "Quantité 1" },
        { ParameterType.Custom, en = "Offer 1",  de = "Angebot 1", fr = "Offre 1" },
        { ParameterType.Custom, en = "Amount 2", de = "Menge 2",   fr = "Quantité 2" },
        { ParameterType.Custom, en = "Offer 2",  de = "Angebot 2", fr = "Offre 2" },
        { ParameterType.Custom, en = "Amount 3", de = "Menge 3",   fr = "Quantité 3" },
        { ParameterType.Custom, en = "Offer 3",  de = "Angebot 3", fr = "Offr 3e" },
        { ParameterType.Custom, en = "Amount 4", de = "Menge 4",   fr = "Quantité 4" },
        { ParameterType.Custom, en = "Offer 4",  de = "Angebot 4", fr = "Offre 4" },
    },
}

function B_Reward_Merchant:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_Merchant:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 1) then
        _Parameter = _Parameter or 0;
        self.AmountOffer1 = _Parameter * 1;
    elseif (_Index == 2) then
        self.Offer1 = _Parameter
    elseif (_Index == 3) then
        _Parameter = _Parameter or 0;
        self.AmountOffer2 = _Parameter * 1;
    elseif (_Index == 4) then
        self.Offer2 = _Parameter
    elseif (_Index == 5) then
        _Parameter = _Parameter or 0;
        self.AmountOffer3 = _Parameter * 1;
    elseif (_Index == 6) then
        self.Offer3 = _Parameter
    elseif (_Index == 7) then
        _Parameter = _Parameter or 0;
        self.AmountOffer4 = _Parameter * 1;
    elseif (_Index == 8) then
        self.Offer4 = _Parameter
    end
end

function B_Reward_Merchant:CustomFunction()
    if (self.PlayerID > 1) and (self.PlayerID < 9) then
        local Storehouse = Logic.GetStoreHouse(self.PlayerID)
        Logic.RemoveAllOffers(Storehouse)
        for i =  1,4 do
            if self["Offer"..i] and self["Offer"..i] ~= "-" then
                if Goods[self["Offer"..i]] then
                    AddOffer(Storehouse, self["AmountOffer"..i], Goods[self["Offer"..i]])
                elseif Logic.IsEntityTypeInCategory(Entities[self["Offer"..i]], EntityCategories.Military) == 1 then
                    AddMercenaryOffer(Storehouse, self["AmountOffer"..i], Entities[self["Offer"..i]])
                else
                    AddEntertainerOffer (Storehouse , Entities[self["Offer"..i]])
                end
            end
        end
    end
end

function B_Reward_Merchant:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID ) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(")
        return true
    end
end

function B_Reward_Merchant:GetCustomData(_Index)
    local Players = { 1,2,3,4,5,6,7,8 }
    local Amount = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }
    local Offers = {"-",
                    "G_Beer",
                    "G_Bow",
                    "G_Bread",
                    "G_Broom",
                    "G_Candle",
                    "G_Carcass",
                    "G_Cheese",
                    "G_Clothes",
                    "G_Cow",
                    "G_Grain",
                    "G_Herb",
                    "G_Honeycomb",
                    "G_Iron",
                    "G_Leather",
                    "G_Medicine",
                    "G_Milk",
                    "G_RawFish",
                    "G_Sausage",
                    "G_Sheep",
                    "G_SmokedFish",
                    "G_Soap",
                    "G_Stone",
                    "G_Sword",
                    "G_Wood",
                    "G_Wool",
                    "G_Salt",
                    "G_Dye",
                    "U_AmmunitionCart",
                    "U_BatteringRamCart",
                    "U_CatapultCart",
                    "U_SiegeTowerCart",
                    "U_MilitaryBandit_Melee_ME",
                    "U_MilitaryBandit_Melee_SE",
                    "U_MilitaryBandit_Melee_NA",
                    "U_MilitaryBandit_Melee_NE",
                    "U_MilitaryBandit_Ranged_ME",
                    "U_MilitaryBandit_Ranged_NA",
                    "U_MilitaryBandit_Ranged_NE",
                    "U_MilitaryBandit_Ranged_SE",
                    "U_MilitaryBow_RedPrince",
                    "U_MilitaryBow",
                    "U_MilitarySword_RedPrince",
                    "U_MilitarySword",
                    "U_Entertainer_NA_FireEater",
                    "U_Entertainer_NA_StiltWalker",
                    "U_Entertainer_NE_StrongestMan_Barrel",
                    "U_Entertainer_NE_StrongestMan_Stone",
                    }
    if g_GameExtraNo and g_GameExtraNo >= 1 then
        table.insert(Offers, "G_Gems")
        table.insert(Offers, "G_Olibanum")
        table.insert(Offers, "G_MusicalInstrument")
        table.insert(Offers, "G_MilitaryBandit_Ranged_AS")
        table.insert(Offers, "G_MilitaryBandit_Melee_AS")
        table.insert(Offers, "U_MilitarySword_Khana")
        table.insert(Offers, "U_MilitaryBow_Khana")
    end
    if (_Index == 0) then
        return Players
    elseif (_Index == 1) or (_Index == 3) or (_Index == 5) or (_Index == 7) then
        return Amount
    elseif (_Index == 2) or (_Index == 4) or (_Index == 6) or (_Index == 8) then
        return Offers
    end
end

RegisterBehavior(B_Reward_Merchant)

-- -------------------------------------------------------------------------- --

function Reward_DestroyEntity(...)
    return B_Reward_DestroyEntity:new(...);
end

B_Reward_DestroyEntity = CopyTable(B_Reprisal_DestroyEntity);
B_Reward_DestroyEntity.Name = "Reward_DestroyEntity";
B_Reward_DestroyEntity.Description.en = "Reward: Replaces an entity with an invisible script entity, which retains the entities name.";
B_Reward_DestroyEntity.Description.de = "Lohn: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.";
B_Reward_DestroyEntity.Description.fr = "Récompense: Remplace une entité par une entité de script invisible qui prend le nom.";
B_Reward_DestroyEntity.GetReprisalTable = nil;

B_Reward_DestroyEntity.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_DestroyEntity);

-- -------------------------------------------------------------------------- --

function Reward_DestroyEffect(...)
    return B_Reward_DestroyEffect:new(...);
end

B_Reward_DestroyEffect = CopyTable(B_Reprisal_DestroyEffect);
B_Reward_DestroyEffect.Name = "Reward_DestroyEffect";
B_Reward_DestroyEffect.Description.en = "Reward: Destroys an effect.";
B_Reward_DestroyEffect.Description.de = "Lohn: Zerstört einen Effekt.";
B_Reward_DestroyEffect.Description.fr = "Récompense: Détruit un effet.";
B_Reward_DestroyEffect.GetReprisalTable = nil;

B_Reward_DestroyEffect.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

RegisterBehavior(B_Reward_DestroyEffect);

-- -------------------------------------------------------------------------- --

function Reward_CreateBattalion(...)
    return B_Reward_CreateBattalion:new(...);
end

B_Reward_CreateBattalion = {
    Name = "Reward_CreateBattalion",
    Description = {
        en = "Reward: Replaces a script entity with a battalion, which retains the entities name",
        de = "Lohn: Ersetzt eine Script-Entity durch ein Bataillon, welches den Namen der Script-Entity übernimmt",
        fr = "Récompense: Remplace une entité de script par un bataillon qui prend le nom de l'entité de script.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Entité de script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Désignation du type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Number,     en = "Number of soldiers",          de = "Anzahl Soldaten",         fr = "Nombre de Soldats" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'IA" },
    },
}

function B_Reward_CreateBattalion:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateBattalion:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 4) then
        self.SoldierCount = _Parameter * 1
    elseif (_Index == 5) then
        self.HideFromAI = ToBoolean(_Parameter)
    end
end

function B_Reward_CreateBattalion:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, self.SoldierCount )
    local posID = GetID(self.ScriptNameEntity)
    if Logic.IsBuilding(posID) == 0 then
        DestroyEntity(self.ScriptNameEntity)
        Logic.SetEntityName( NewID, self.ScriptNameEntity )
    end
    if self.HideFromAI then
        AICore.HideEntityFromAI( self.PlayerID, NewID, true )
    end
end

function B_Reward_CreateBattalion:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        for k, v in pairs( Entities ) do
            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 5 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_CreateBattalion:Debug(_Quest)
    if not Entities[self.UnitKey] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": playerID is wrong!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": you can not create a empty batallion!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_CreateBattalion);

-- -------------------------------------------------------------------------- --

function Reward_CreateSeveralBattalions(...)
    return B_Reward_CreateSeveralBattalions:new(...);
end

B_Reward_CreateSeveralBattalions = {
    Name = "Reward_CreateSeveralBattalions",
    Description = {
        en = "Reward: Creates a given amount of battalions",
        de = "Lohn: Erstellt eine gegebene Anzahl Bataillone",
        fr = "Récompense: Crée un nombre donné de bataillons",
    },
    Parameter = {
        { ParameterType.Number,     en = "Amount",                      de = "Anzahl",                  fr = "Quantité" },
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Quentité de Script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Désignation de type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Number,     en = "Number of soldiers",          de = "Anzahl Soldaten",         fr = "Nombre de soldats" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'AI" },
    },
}

function B_Reward_CreateSeveralBattalions:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateSeveralBattalions:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1
    elseif (_Index == 1) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 3) then
        self.UnitKey = _Parameter
    elseif (_Index == 4) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 5) then
        self.SoldierCount = _Parameter * 1
    elseif (_Index == 6) then
        self.HideFromAI = ToBoolean(_Parameter)
    end
end

function B_Reward_CreateSeveralBattalions:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local tID = GetID(self.ScriptNameEntity)
    local x,y,z = Logic.EntityGetPos(tID);
    if Logic.IsBuilding(tID) == 1 then
        x,y = Logic.GetBuildingApproachPosition(tID)
    end

    for i=1, self.Amount do
        local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], x, y, self.Orientation, self.PlayerID, self.SoldierCount )
        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )
        if self.HideFromAI then
            AICore.HideEntityFromAI( self.PlayerID, NewID, true )
        end
    end
end

function B_Reward_CreateSeveralBattalions:GetCustomData( _Index )
    local Data = {}
    if _Index == 3 then
        for k, v in pairs( Entities ) do
            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 6 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_CreateSeveralBattalions:Debug(_Quest)
    if not Entities[self.UnitKey] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": playerDI is wrong!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": you can not create a empty batallion!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_CreateSeveralBattalions);

-- -------------------------------------------------------------------------- --

function Reward_CreateEffect(...)
    return B_Reward_CreateEffect:new(...);
end

B_Reward_CreateEffect = {
    Name = "Reward_CreateEffect",
    Description = {
        en = "Reward: Creates an effect at a specified position",
        de = "Lohn: Erstellt einen Effekt an der angegebenen Position",
        fr = "Récompense: Crée un effet à la position indiquée",
    },
    Parameter = {
        { ParameterType.Default,    en = "Effect name", de = "Effektname",      fr = "Nom de l'effet" },
        { ParameterType.Custom,     en = "Type name",   de = "Typbezeichnung",  fr = "Designation de type" },
        { ParameterType.PlayerID,   en = "Player",      de = "Spieler",         fr = "Joueur" },
        { ParameterType.ScriptName, en = "Location",    de = "Ort",             fr = "Lieu" },
        { ParameterType.Number,     en = "Orientation (in degrees)(-1: from locating entity)", de = "Ausrichtung (in Grad)(-1: von Positionseinheit)", fr = "Orientation (en degrés)(-1 : de l'unité de position)" },
    }
}

function B_Reward_CreateEffect:AddParameter(_Index, _Parameter)

    if _Index == 0 then
        self.EffectName = _Parameter;
    elseif _Index == 1 then
        self.Type = EGL_Effects[_Parameter];
    elseif _Index == 2 then
        self.PlayerID = _Parameter * 1;
    elseif _Index == 3 then
        self.Location = _Parameter;
    elseif _Index == 4 then
        self.Orientation = _Parameter * 1;
    end

end

function B_Reward_CreateEffect:GetRewardTable()
    return { Reward.Custom, { self, self.CustomFunction } };
end

function B_Reward_CreateEffect:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed(self.Location) then
        return;
    end
    local entity = assert(GetID(self.Location), _Quest.Identifier .. "Error in " .. self.Name .. ": CustomFunction: Entity is invalid");
    if CONST_EFFECT_NAME_TO_ID[self.EffectName] and Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName]) then
        return;
    end

    local posX, posY = Logic.GetEntityPosition(entity);
    local orientation = tonumber(self.Orientation);
    local effect = Logic.CreateEffectWithOrientation(self.Type, posX, posY, orientation, self.PlayerID);
    if self.EffectName ~= "" then
        CONST_EFFECT_NAME_TO_ID[self.EffectName] = effect;
    end
end

function B_Reward_CreateEffect:Debug(_Quest)
    if CONST_EFFECT_NAME_TO_ID[self.EffectName] and Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName]) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": effect already exists!");
        return true;
    elseif not IsExisting(self.Location) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": location '" ..self.Location.. "' is missing!");
        return true;
    elseif self.PlayerID and (self.PlayerID < 0 or self.PlayerID > 8) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid playerID!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid orientation!");
        return true;
    end
end

function B_Reward_CreateEffect:GetCustomData(_Index)
    assert(_Index == 1, "Error in " .. self.Name .. ": GetCustomData: Index is invalid.");
    local types = {};
    for k, v in pairs(EGL_Effects) do
        table.insert(types, k);
    end
    table.sort(types);
    return types;
end

RegisterBehavior(B_Reward_CreateEffect);

-- -------------------------------------------------------------------------- --

function Reward_CreateEntity(...)
    return B_Reward_CreateEntity:new(...);
end

B_Reward_CreateEntity = {
    Name = "Reward_CreateEntity",
    Description = {
        en = "Reward: Replaces an entity by a new one of a given type",
        de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs",
        fr = "Récompense: Remplace une entité par une nouvelle entité de type donné",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Entité de script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Désignation de type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'AI" },
    },
}

function B_Reward_CreateEntity:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 4) then
        self.HideFromAI = ToBoolean(_Parameter)
    end
end

function B_Reward_CreateEntity:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID;
    if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then
        NewID     = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )
        local l,s = Logic.GetSoldiersAttachedToLeader(NewID)
        Logic.SetOrientation(s, math.floor(self.Orientation + 0.5))
    else
        NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )
    end
    local posID = GetID(self.ScriptNameEntity)
    if Logic.IsBuilding(posID) == 0 then
        DestroyEntity(self.ScriptNameEntity)
        Logic.SetEntityName( NewID, self.ScriptNameEntity )
    end
    if self.HideFromAI then
        AICore.HideEntityFromAI( self.PlayerID, NewID, true )
    end
end

function B_Reward_CreateEntity:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        for k, v in pairs( Entities ) do
            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )

    elseif _Index == 4 or _Index == 5 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_CreateEntity:Debug(_Quest)
    if not Entities[self.UnitKey] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 0 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": playerID is not valid!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_CreateEntity);

-- -------------------------------------------------------------------------- --

-- Kompatibelität
B_Reward_CreateSettler = CopyTable(B_Reward_CreateEntity);
B_Reward_CreateSettler.Name = "Reward_CreateSettler";
B_Reward_CreateSettler.Description.en = "Reward: Replaces an entity by a new one of a given type";
B_Reward_CreateSettler.Description.de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs";
B_Reward_CreateSettler.Description.fr = "Récompense: Remplace une entité par une nouvelle entité de type donné";
RegisterBehavior(B_Reward_CreateSettler);

-- -------------------------------------------------------------------------- --

function Reward_CreateSeveralEntities(...)
    return B_Reward_CreateSeveralEntities:new(...);
end

B_Reward_CreateSeveralEntities = {
    Name = "Reward_CreateSeveralEntities",
    Description = {
        en = "Reward: Creating serveral battalions at the position of a entity. They retains the entities name and a _[index] suffix",
        de = "Lohn: Erzeugt mehrere Entities an der Position der Entity. Sie übernimmt den Namen der Script Entity und den Suffix _[index]",
        fr = "Récompense: Crée plusieurs Entities à la position de l'Entity. Elle reprend le nom de l'entité script et le suffixe _[index].",
    },
    Parameter = {
        { ParameterType.Number,     en = "Amount",                      de = "Anzahl",                  fr = "Quantité" },
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Entité de script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Designation de type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'AI" },
    },
}

function B_Reward_CreateSeveralEntities:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateSeveralEntities:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1
    elseif (_Index == 1) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 3) then
        self.UnitKey = _Parameter
    elseif (_Index == 4) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 5) then
        self.HideFromAI = ToBoolean(_Parameter)
    end
end

function B_Reward_CreateSeveralEntities:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID;
    for i=1, self.Amount do
        if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then
            NewID     = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )
            local l,s = Logic.GetSoldiersAttachedToLeader(NewID)
            Logic.SetOrientation(s, math.floor(self.Orientation + 0.5))
        else
            NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )
        end
        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )
        if self.HideFromAI then
            AICore.HideEntityFromAI( self.PlayerID, NewID, true )
        end
    end
end

function B_Reward_CreateSeveralEntities:GetCustomData( _Index )
    local Data = {}
    if _Index == 3 then
        for k, v in pairs( Entities ) do
            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )

    elseif _Index == 5 or _Index == 6 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data

end

function B_Reward_CreateSeveralEntities:Debug(_Quest)
    if not Entities[self.UnitKey] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_CreateSeveralEntities);

-- -------------------------------------------------------------------------- --

function Reward_MoveSettler(...)
    return B_Reward_MoveSettler:new(...);
end

B_Reward_MoveSettler = {
    Name = "Reward_MoveSettler",
    Description = {
        en = "Reward: Moves a (NPC) settler to a destination. Must not be AI controlled, or it won't move",
        de = "Lohn: Bewegt einen (NPC) Siedler zu einem Zielort. Darf keinem KI Spieler gehören, ansonsten wird sich der Siedler nicht bewegen",
        fr = "Récompense: Déplace un settler (NPC) vers une destination. Ne doit pas appartenir à un joueur IA, sinon le settler ne se déplacera pas.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Settler", de = "Siedler", fr = "Settler" },
        { ParameterType.ScriptName, en = "Destination", de = "Ziel", fr = "Destination" },
    },
}

function B_Reward_MoveSettler:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_MoveSettler:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameUnit = _Parameter
    elseif (_Index == 1) then
        self.ScriptNameDest = _Parameter
    end
end

function B_Reward_MoveSettler:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.ScriptNameUnit ) or Logic.IsEntityDestroyed( self.ScriptNameDest ) then
        return false
    end
    local DestID = GetID( self.ScriptNameDest )
    local DestX, DestY = Logic.GetEntityPosition( DestID )
    if Logic.IsBuilding( DestID ) == 1 then
        DestX, DestY = Logic.GetBuildingApproachPosition( DestID )
    end
    Logic.MoveSettler( GetID( self.ScriptNameUnit ), DestX, DestY )
end

function B_Reward_MoveSettler:Debug(_Quest)
    if not IsExisting(self.ScriptNameUnit) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": mover entity does not exist!");
        return true;
    elseif not IsExisting(self.ScriptNameDest) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": destination does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_MoveSettler);

-- -------------------------------------------------------------------------- --

function Reward_Victory()
    return B_Reward_Victory:new()
end

B_Reward_Victory = {
    Name = "Reward_Victory",
    Description = {
        en = "Reward: The player wins the game.",
        de = "Lohn: Der Spieler gewinnt das Spiel.",
        fr = "Récompense: Le Joueur gagne la partie.",
    },
}

function B_Reward_Victory:GetRewardTable()
    return {Reward.Victory};
end

RegisterBehavior(B_Reward_Victory);

-- -------------------------------------------------------------------------- --

function Reward_Defeat()
    return B_Reward_Defeat:new()
end

B_Reward_Defeat = {
    Name = "Reward_Defeat",
    Description = {
        en = "Reward: The player loses the game.",
        de = "Lohn: Der Spieler verliert das Spiel.",
        fr = "Récompense: le Joueur perd la partie.",
    },
}

function B_Reward_Defeat:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function B_Reward_Defeat:CustomFunction(_Quest)
    _Quest:TerminateEventsAndStuff()
    Logic.ExecuteInLuaLocalState("GUI_Window.MissionEndScreenSetVictoryReasonText(".. g_VictoryAndDefeatType.DefeatMissionFailed ..")")
    Defeated(_Quest.ReceivingPlayer)
end

RegisterBehavior(B_Reward_Defeat);

-- -------------------------------------------------------------------------- --

function Reward_FakeVictory()
    return B_Reward_FakeVictory:new();
end

B_Reward_FakeVictory = {
    Name = "Reward_FakeVictory",
    Description = {
        en = "Reward: Display a victory icon for a quest",
        de = "Lohn: Zeigt ein Siegesicon fuer diese Quest",
        fr = "Récompense: Affiche une icône de victoire pour cette quête",
    },
}

function B_Reward_FakeVictory:GetRewardTable()
    return { Reward.FakeVictory }
end

RegisterBehavior(B_Reward_FakeVictory);

-- -------------------------------------------------------------------------- --

function Reward_AI_SpawnAndAttackTerritory(...)
    return B_Reward_AI_SpawnAndAttackTerritory:new(...);
end

B_Reward_AI_SpawnAndAttackTerritory = {
    Name = "Reward_AI_SpawnAndAttackTerritory",
    Description = {
        en = "Reward: Spawns AI troops and attacks a territory (Hint: Use for hidden quests as a surprise)",
        de = "Lohn: Erstellt KI Truppen und greift ein Territorium an (Tipp: Fuer eine versteckte Quest als Ueberraschung verwenden)",
        fr = "Récompense: Créez des troupes d'IA et attaquez un territoire (astuce : utilisez une surprise pour une quête cachée).",
    },
    Parameter = {
        { ParameterType.PlayerID,       en = "AI Player",       de = "KI Spieler",                  fr = "Joueur AI" },
        { ParameterType.ScriptName,     en = "Spawn point",     de = "Erstellungsort",              fr = "Lieu de création" },
        { ParameterType.TerritoryName,  en = "Territory",       de = "Territorium",                 fr = "Territoire" },
        { ParameterType.Number,         en = "Sword",           de = "Schwert",                     fr = "Épéiste" },
        { ParameterType.Number,         en = "Bow",             de = "Bogen",                       fr = "Archer" },
        { ParameterType.Number,         en = "Catapults",       de = "Katapulte",                   fr = "Catapultes" },
        { ParameterType.Number,         en = "Siege towers",    de = "Belagerungstuerme",           fr = "Tours de siège" },
        { ParameterType.Number,         en = "Rams",            de = "Rammen",                      fr = "Bélier" },
        { ParameterType.Number,         en = "Ammo carts",      de = "Munitionswagen",              fr = "Chariot à munitions" },
        { ParameterType.Custom,         en = "Soldier type",    de = "Soldatentyp",                 fr = "Type de soldat" },
        { ParameterType.Custom,         en = "Reuse troops",    de = "Verwende bestehende Truppen", fr = "Utiliser les troupes existantes" },
    },
}

function B_Reward_AI_SpawnAndAttackTerritory:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SpawnAndAttackTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    elseif (_Index == 3) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 4) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 5) then
        self.NumCatapults = _Parameter * 1
    elseif (_Index == 6) then
        self.NumSiegeTowers = _Parameter * 1
    elseif (_Index == 7) then
        self.NumRams = _Parameter * 1
    elseif (_Index == 8) then
        self.NumAmmoCarts = _Parameter * 1
    elseif (_Index == 9) then
        if _Parameter == "Normal" or _Parameter == false then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == true then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 10) then
        self.ReuseTroops = ToBoolean(_Parameter)
    end
end

function B_Reward_AI_SpawnAndAttackTerritory:GetCustomData( _Index )
    local Data = {}
    if _Index == 9 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end
    elseif _Index == 10 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_AI_SpawnAndAttackTerritory:CustomFunction(_Quest)
    local TargetID = Logic.GetTerritoryAcquiringBuildingID( self.TerritoryID )
    if TargetID ~= 0 then
        AIScript_SpawnAndAttackCity(
            self.AIPlayerID,
            TargetID,
            self.Spawnpoint,
            self.NumSword,
            self.NumBow,
            self.NumCatapults,
            self.NumSiegeTowers,
            self.NumRams,
            self.NumAmmoCarts,
            self.TroopType,
            self.ReuseTroops
        )
    end
end

function B_Reward_AI_SpawnAndAttackTerritory:Debug(_Quest)
    if self.AIPlayerID < 2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif self.TerritoryID == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Territory unknown")
        return true
    elseif self.NumSword < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    elseif self.NumCatapults < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Catapults is negative")
        return true
    elseif self.NumSiegeTowers < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": SiegeTowers is negative")
        return true
    elseif self.NumRams < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Rams is negative")
        return true
    elseif self.NumAmmoCarts < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": AmmoCarts is negative")
        return true
    end
    return false;
end

RegisterBehavior(B_Reward_AI_SpawnAndAttackTerritory);

-- -------------------------------------------------------------------------- --

function Reward_AI_SpawnAndAttackArea(...)
    return B_Reward_AI_SpawnAndAttackArea:new(...);
end

B_Reward_AI_SpawnAndAttackArea = {
    Name = "Reward_AI_SpawnAndAttackArea",
    Description = {
        en = "Reward: Spawns AI troops and attacks everything within the specified area, except the players main buildings",
        de = "Lohn: Erstellt KI Truppen und greift ein angegebenes Gebiet an, aber nicht die Hauptgebauede eines Spielers",
        fr = "Récompense: Crée des troupes IA et attaque une zone spécifiée, mais pas les bâtiments principaux d'un joueur.",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "AI Player",       de = "KI Spieler",                  fr = "Joueur AI" },
        { ParameterType.ScriptName, en = "Spawn point",     de = "Erstellungsort",              fr = "Lieu de création" },
        { ParameterType.ScriptName, en = "Target",          de = "Ziel",                        fr = "Cible" },
        { ParameterType.Number,     en = "Radius",          de = "Radius",                      fr = "Rayon" },
        { ParameterType.Number,     en = "Sword",           de = "Schwert",                     fr = "Épéiste" },
        { ParameterType.Number,     en = "Bow",             de = "Bogen",                       fr = "Archer" },
        { ParameterType.Custom,     en = "Soldier type",    de = "Soldatentyp",                 fr = "Type de soldats" },
        { ParameterType.Custom,     en = "Reuse troops",    de = "Verwende bestehende Truppen", fr = "Utiliser des troupes existantes" },
    },
}

function B_Reward_AI_SpawnAndAttackArea:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SpawnAndAttackArea:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TargetName = _Parameter
    elseif (_Index == 3) then
        self.Radius = _Parameter * 1
    elseif (_Index == 4) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 5) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 6) then
        if _Parameter == "Normal" or _Parameter == false then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == true then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 7) then
        self.ReuseTroops = ToBoolean(_Parameter)
    end
end

function B_Reward_AI_SpawnAndAttackArea:GetCustomData( _Index )
    local Data = {}
    if _Index == 6 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end
    elseif _Index == 7 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_AI_SpawnAndAttackArea:CustomFunction(_Quest)
    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then
        local TargetID = GetID( self.TargetName )
        AIScript_SpawnAndRaidSettlement(
            self.AIPlayerID,
            TargetID,
            self.Spawnpoint,
            self.Radius,
            self.NumSword,
            self.NumBow,
            self.TroopType,
            self.ReuseTroops
        )
    end
end

function B_Reward_AI_SpawnAndAttackArea:Debug(_Quest)
    if self.AIPlayerID < 2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif Logic.IsEntityDestroyed(self.TargetName) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.TargetName .. " is missing")
        return true
    elseif self.Radius < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Radius is to small or negative")
        return true
    elseif self.NumSword < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    end
    return false;
end

RegisterBehavior(B_Reward_AI_SpawnAndAttackArea);

-- -------------------------------------------------------------------------- --

function Reward_AI_SpawnAndProtectArea(...)
    return B_Reward_AI_SpawnAndProtectArea:new(...);
end

B_Reward_AI_SpawnAndProtectArea = {
    Name = "Reward_AI_SpawnAndProtectArea",
    Description = {
        en = "Reward: Spawns AI troops and defends a specified area",
        de = "Lohn: Erstellt KI Truppen und verteidigt ein angegebenes Gebiet",
        fr = "Récompense: Crée des troupes d'IA et défend un territoire donné",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "AI Player",               de = "KI Spieler",                  fr = "Joueur AI" },
        { ParameterType.ScriptName, en = "Spawn point",             de = "Erstellungsort",              fr = "Lieu de création" },
        { ParameterType.ScriptName, en = "Target",                  de = "Ziel",                        fr = "Cible" },
        { ParameterType.Number,     en = "Radius",                  de = "Radius",                      fr = "Rayon" },
        { ParameterType.Number,     en = "Time (-1 for infinite)",  de = "Zeit (-1 fuer unendlich)",    fr = "Temps (-1 pour infini)" },
        { ParameterType.Number,     en = "Sword",                   de = "Schwert",                     fr = "Épéiste" },
        { ParameterType.Number,     en = "Bow",                     de = "Bogen",                       fr = "Archer" },
        { ParameterType.Custom,     en = "Capture tradecarts",      de = "Handelskarren angreifen",     fr = "Attaquer les chariots de commerce" },
        { ParameterType.Custom,     en = "Soldier type",            de = "Soldatentyp",                 fr = "Type de soldat" },
        { ParameterType.Custom,     en = "Reuse troops",            de = "Verwende bestehende Truppen", fr = "Utiliser les troupes existantes" },
    },
}

function B_Reward_AI_SpawnAndProtectArea:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SpawnAndProtectArea:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TargetName = _Parameter
    elseif (_Index == 3) then
        self.Radius = _Parameter * 1
    elseif (_Index == 4) then
        self.Time = _Parameter * 1
    elseif (_Index == 5) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 6) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 7) then
        self.CaptureTradeCarts = ToBoolean(_Parameter)
    elseif (_Index == 8) then
        if _Parameter == "Normal" or _Parameter == true then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == false then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 9) then
        self.ReuseTroops = ToBoolean(_Parameter)
    end

end

function B_Reward_AI_SpawnAndProtectArea:GetCustomData( _Index )

    local Data = {}
    if _Index == 7 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    elseif _Index == 8 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end

    elseif _Index == 9 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )

    else
        assert( false )
    end

    return Data

end

function B_Reward_AI_SpawnAndProtectArea:CustomFunction(_Quest)
    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then
        local TargetID = GetID( self.TargetName )
        AIScript_SpawnAndProtectArea(
            self.AIPlayerID,
            TargetID,
            self.Spawnpoint,
            self.Radius,
            self.NumSword,
            self.NumBow,
            self.Time,
            self.TroopType,
            self.ReuseTroops,
            self.CaptureTradeCarts
        )
    end
end

function B_Reward_AI_SpawnAndProtectArea:Debug(_Quest)
    if self.AIPlayerID < 2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif Logic.IsEntityDestroyed(self.TargetName) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.TargetName .. " is missing")
        return true
    elseif self.Radius < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Radius is to small or negative")
        return true
    elseif self.Time < -1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Time is smaller than -1")
        return true
    elseif self.NumSword < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    end
    return false;
end

RegisterBehavior(B_Reward_AI_SpawnAndProtectArea);

-- -------------------------------------------------------------------------- --

function Reward_AI_SetNumericalFact(...)
    return B_Reward_AI_SetNumericalFact:new(...);
end

B_Reward_AI_SetNumericalFact = {
    Name = "Reward_AI_SetNumericalFact",
    Description = {
        en = "Reward: Sets a numerical fact for the AI player",
        de = "Lohn: Setzt eine Verhaltensregel fuer den KI-Spieler. ",
        fr = "Récompense: Définit une règle de comportement pour le joueur IA.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player",      de = "KI Spieler",         fr = "Joueur AI" },
        { ParameterType.Custom,   en = "Numerical Fact", de = "Verhaltensregel",    fr = "Règle de conduite" },
        { ParameterType.Number,   en = "Value",          de = "Wert",               fr = "Valeur" },
    },
}

function B_Reward_AI_SetNumericalFact:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SetNumericalFact:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        -- mapping of numerical facts
        local fact = {
            ["Courage"]               = "FEAR",
            ["Reconstruction"]        = "BARB",
            ["Build Order"]           = "BPMX",
            ["Conquer Outposts"]      = "FCOP",
            ["Mount Outposts"]        = "FMOP",
            ["max. Bowmen"]           = "FMBM",
            ["max. Swordmen"]         = "FMSM",
            ["max. Rams"]             = "FMRA",
            ["max. Catapults"]        = "FMCA",
            ["max. Ammunition Carts"] = "FMAC",
            ["max. Siege Towers"]     = "FMST",
            ["max. Wall Catapults"]   = "FMBA",
            ["FEAR"]                  = "FEAR", -- > 0
            ["BARB"]                  = "BARB", -- 1 or 0
            ["BPMX"]                  = "BPMX", -- >= 0
            ["FCOP"]                  = "FCOP", -- 1 or 0
            ["FMOP"]                  = "FMOP", -- 1 or 0
            ["FMBM"]                  = "FMBM", -- >= 0
            ["FMSM"]                  = "FMSM", -- >= 0
            ["FMRA"]                  = "FMRA", -- >= 0
            ["FMCA"]                  = "FMCA", -- >= 0
            ["FMAC"]                  = "FMAC", -- >= 0
            ["FMST"]                  = "FMST", -- >= 0
            ["FMBA"]                  = "FMBA", -- >= 0
        }
        self.NumericalFact = fact[_Parameter]
    elseif (_Index == 2) then
        self.Value = _Parameter * 1
    end
end

function B_Reward_AI_SetNumericalFact:CustomFunction(_Quest)
    if self.NumericalFact ~= nil then
        AICore.SetNumericalFact(self.AIPlayerID, self.NumericalFact, self.Value)
    end
end

function B_Reward_AI_SetNumericalFact:GetCustomData(_Index)
    if (_Index == 1) then
        return {
            "Courage",
            "Reconstruction",
            "Build Order",
            "Conquer Outposts",
            "Mount Outposts",
            "max. Bowmen",
            "max. Swordmen",
            "max. Rams",
            "max. Catapults",
            "max. Ammunition Carts",
            "max. Siege Towers",
            "max. Wall Catapults",
        };
    end
end

function B_Reward_AI_SetNumericalFact:Debug(_Quest)
    if Logic.GetStoreHouse(self.AIPlayerID) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong or dead!");
        return true;
    elseif not self.NumericalFact then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": invalid numerical fact choosen!");
        return true;
    else
        if self.NumericalFact == "BARB" or self.NumericalFact == "FCOP" or self.NumericalFact == "FMOP" then
            if self.Value ~= 0 and self.Value ~= 1 then
                debug(false, _Quest.Identifier.. ": " ..self.Name .. ": BARB, FCOP, FMOP: value must be 1 or 0!");
                return true;
            end
        elseif self.NumericalFact == "FEAR" then
            if self.Value <= 0 then
                debug(false, _Quest.Identifier.. ": " ..self.Name .. ": FEAR: value must greater than 0!");
                return true;
            end
        else
            if self.Value < 0 then
                debug(false, _Quest.Identifier.. ": " ..self.Name .. ": value must always greater than or equal 0!");
                return true;
            end
        end
    end
    return false
end

RegisterBehavior(B_Reward_AI_SetNumericalFact);

-- -------------------------------------------------------------------------- --

function Reward_AI_Aggressiveness(...)
    return B_Reward_AI_Aggressiveness:new(...);
end

B_Reward_AI_Aggressiveness = {
    Name = "Reward_AI_Aggressiveness",
    Description = {
        en = "Reward: Sets the AI player's aggressiveness.",
        de = "Lohn: Setzt die Aggressivität des KI-Spielers fest.",
        fr = "Récompense: Définit l'agressivité du joueur IA.",
    },
    Parameter =
    {
        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler", fr = "Joueur AI" },
        { ParameterType.Custom, en = "Aggressiveness (1-3)", de = "Aggressivität (1-3)", fr = "Agressivité (1-3)" }
    }
};

function B_Reward_AI_Aggressiveness:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction} };
end

function B_Reward_AI_Aggressiveness:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.AIPlayer = _Parameter * 1;
    elseif _Index == 1 then
        self.Aggressiveness = tonumber(_Parameter);
    end
end

function B_Reward_AI_Aggressiveness:CustomFunction()
    local player = (PlayerAIs[self.AIPlayer]
        or AIPlayerTable[self.AIPlayer]
        or AIPlayer:new(self.AIPlayer, AIPlayerProfile_City));
    assert(player ~= nil);
    PlayerAIs[self.AIPlayer] = player;
    if self.Aggressiveness >= 2 then
        player.ProfileLoop = AIProfile_Skirmish;
        player.Skirmish = player.Skirmish or {};
        player.Skirmish.Claim_MinTime = SkirmishDefault.Claim_MinTime + (self.Aggressiveness - 2) * 390;
        player.Skirmish.Claim_MaxTime = player.Skirmish.Claim_MinTime * 2;
    else
        player.ProfileLoop = AIPlayerProfile_City;
    end
end

function B_Reward_AI_Aggressiveness:Debug(_Quest)
    if self.AIPlayer < 1 or Logic.GetStoreHouse(self.AIPlayer) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayer .. " is wrong");
        return true;
    end
end

function B_Reward_AI_Aggressiveness:GetCustomData(_Index)
    return { "1", "2", "3" };
end

RegisterBehavior(B_Reward_AI_Aggressiveness)

-- -------------------------------------------------------------------------- --

function Reward_AI_SetEnemy(...)
    return B_Reward_AI_SetEnemy:new(...);
end

B_Reward_AI_SetEnemy = {
    Name = "Reward_AI_SetEnemy",
    Description = {
        en = "Reward:Sets the enemy of an AI player (the AI only handles one enemy properly).",
        de = "Lohn: Legt den Feind eines KI-Spielers fest (die KI behandelt nur einen Feind korrekt).",
        fr = "Récompense: Définit l'ennemi d'un joueur IA (l'IA ne traite correctement qu'un seul ennemi).",
    },
    Parameter =
    {
        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler", fr = "Joueur AI" },
        { ParameterType.PlayerID, en = "Enemy", de = "Feind", fr = "Ennemi" }
    }
};

function B_Reward_AI_SetEnemy:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction} };
end

function B_Reward_AI_SetEnemy:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.AIPlayer = _Parameter * 1;
    elseif _Index == 1 then
        self.Enemy = _Parameter * 1;
    end
end

function B_Reward_AI_SetEnemy:CustomFunction()
    local player = PlayerAIs[self.AIPlayer];
    if player and player.Skirmish then
        player.Skirmish.Enemy = self.Enemy;
    end
end

function B_Reward_AI_SetEnemy:Debug(_Quest)
    if self.AIPlayer < 1 or self.AIPlayer > 8 or Logic.PlayerGetIsHumanFlag(self.AIPlayer) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayer .. " is wrong");
        return true;
    end
    return false;
end
RegisterBehavior(B_Reward_AI_SetEnemy)

-- -------------------------------------------------------------------------- --

function Reward_ReplaceEntity(...)
    return B_Reward_ReplaceEntity:new(...);
end

B_Reward_ReplaceEntity = CopyTable(B_Reprisal_ReplaceEntity);
B_Reward_ReplaceEntity.Name = "Reward_ReplaceEntity";
B_Reward_ReplaceEntity.Description.en = "Reward: Replaces an entity with a new one of a different type. The playerID can be changed too.";
B_Reward_ReplaceEntity.Description.de = "Lohn: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.";
B_Reward_ReplaceEntity.Description.fr = "Récompense: Remplace une entité par une nouvelle entité d'un autre type. Il est également possible de changer l'appartenance d'un joueur.";
B_Reward_ReplaceEntity.GetReprisalTable = nil;

B_Reward_ReplaceEntity.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_ReplaceEntity);

-- -------------------------------------------------------------------------- --

function Reward_SetResourceAmount(...)
    return B_Reward_SetResourceAmount:new(...);
end

B_Reward_SetResourceAmount = {
    Name = "Reward_SetResourceAmount",
    Description = {
        en = "Reward: Set the current and maximum amount of a resource doodad (the amount can also set to 0)",
        de = "Lohn: Setzt die aktuellen sowie maximalen Resourcen in einem Doodad (auch 0 ist möglich)",
        fr = "Récompense: Définit les ressources actuelles ainsi que les ressources maximales dans un Doodad (0 est également possible)",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Ressource", de = "Resource", fr = "Ressources" },
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité" },
    },
}

function B_Reward_SetResourceAmount:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_SetResourceAmount:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    end

end

function B_Reward_SetResourceAmount:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.ScriptName ) then
        return false
    end
    local EntityID = GetID( self.ScriptName )
    if Logic.GetResourceDoodadGoodType( EntityID ) == 0 then
        return false
    end
    Logic.SetResourceDoodadGoodAmount( EntityID, self.Amount )
end

function B_Reward_SetResourceAmount:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": resource entity does not exist!")
        return true
    elseif not type(self.Amount) == "number" or self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": resource amount can not be negative!")
        return true
    end
    return false;
end

RegisterBehavior(B_Reward_SetResourceAmount);

-- -------------------------------------------------------------------------- --

function Reward_Resources(...)
    return B_Reward_Resources:new(...);
end

B_Reward_Resources = {
    Name = "Reward_Resources",
    Description = {
        en = "Reward: The player receives a given amount of Goods in his store.",
        de = "Lohn: Legt der Partei die angegebenen Rohstoffe ins Lagerhaus.",
        fr = "Récompense: Placez les matières premières indiquées dans l'entrepôt de la faction.",
    },
    Parameter = {
        { ParameterType.RawGoods,   en = "Type of good",    de = "Resourcentyp",        fr = "Type de ressources" },
        { ParameterType.Number,     en = "Amount of good",  de = "Anzahl der Resource", fr = "Nombre de ressources" },
    },
}

function B_Reward_Resources:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    end
end

function B_Reward_Resources:GetRewardTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Reward.Resources, GoodType, self.GoodAmount }
end

RegisterBehavior(B_Reward_Resources);

-- -------------------------------------------------------------------------- --

function Reward_SendCart(...)
    return B_Reward_SendCart:new(...);
end

B_Reward_SendCart = {
    Name = "Reward_SendCart",
    Description = {
        en = "Reward: Sends a cart to a player. It spawns at a building or by replacing an entity. The cart can replace the entity if it's not a building.",
        de = "Lohn: Sendet einen Karren zu einem Spieler. Der Karren wird an einem Gebäude oder einer Entity erstellt. Er ersetzt die Entity, wenn diese kein Gebäude ist.",
        fr = "Récompense: Envoie un chariot à un joueur. Le chariot est créé sur un bâtiment ou une entité. Elle remplace l'entité si celle-ci n'est pas un bâtiment.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity",           de = "Script Entity",               fr = "Entité de Script" },
        { ParameterType.PlayerID,   en = "Owning player",           de = "Besitzer",                    fr = "Propriétaire" },
        { ParameterType.Custom,     en = "Type name",               de = "Typbezeichnung",              fr = "Désignation du type" },
        { ParameterType.Custom,     en = "Good type",               de = "Warentyp",                    fr = "Type de marchandise" },
        { ParameterType.Number,     en = "Amount",                  de = "Anzahl",                      fr = "Quantité" },
        { ParameterType.Custom,     en = "Override target player",  de = "Anderer Zielspieler",         fr = "Autre joueur destinataire" },
        { ParameterType.Custom,     en = "Ignore reservations",     de = "Ignoriere Reservierungen",    fr = "Ignorer les réservations" },
        { ParameterType.Custom,     en = "Replace entity",          de = "Entity ersetzen",             fr = "Remplacer une entité" },
    },
}

function B_Reward_SendCart:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_SendCart:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.GoodType = _Parameter
    elseif (_Index == 4) then
        self.GoodAmount = _Parameter * 1
    elseif (_Index == 5) then
        self.OverrideTargetPlayer = tonumber(_Parameter)
    elseif (_Index == 6) then
        self.IgnoreReservation = ToBoolean(_Parameter)
    elseif (_Index == 7) then
        self.ReplaceEntity = ToBoolean(_Parameter)
    end
end

function B_Reward_SendCart:CustomFunction(_Quest)

    if not IsExisting( self.ScriptNameEntity ) then
        return false;
    end

    local ID = SendCart(self.ScriptNameEntity, self.PlayerID, Goods[self.GoodType], self.GoodAmount, Entities[self.UnitKey], self.IgnoreReservation);

    if self.ReplaceEntity and Logic.IsBuilding(GetID(self.ScriptNameEntity)) == 0 then
        DestroyEntity(self.ScriptNameEntity);
        Logic.SetEntityName(ID, self.ScriptNameEntity);
    end
    if self.OverrideTargetPlayer then
        Logic.ResourceMerchant_OverrideTargetPlayerID(ID,self.OverrideTargetPlayer);
    end
end

function B_Reward_SendCart:GetCustomData( _Index )
    local Data = {};
    if _Index == 2 then
        Data = { "U_ResourceMerchant", "U_Medicus", "U_Marketer", "U_ThiefCart", "U_GoldCart", "U_Noblemen_Cart", "U_RegaliaCart" };
    elseif _Index == 3 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k );
            end
        end
        table.sort( Data );
    elseif _Index == 5 then
        table.insert( Data, "-" );
        for i = 1, 8 do
            table.insert( Data, i );
        end
    elseif _Index == 6 then
        table.insert( Data, "false" );
        table.insert( Data, "true" );
    elseif _Index == 7 then
        table.insert( Data, "false" );
        table.insert( Data, "true" );
    end
    return Data;
end

function B_Reward_SendCart:Debug(_Quest)
    if not IsExisting(self.ScriptNameEntity) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": got a invalid playerID!");
        return true;
    elseif not Entities[self.UnitKey] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": entity type '"..self.UnitKey.."' is invalid!");
        return true;
    elseif not Goods[self.GoodType] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": good type '"..self.GoodType.."' is invalid!");
        return true;
    elseif not tonumber(self.GoodAmount) or self.GoodAmount < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": good amount can not be below 1!");
        return true;
    elseif tonumber(self.OverrideTargetPlayer) and (self.OverrideTargetPlayer < 1 or self.OverrideTargetPlayer > 8) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": overwrite target player with invalid playerID!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_SendCart);

-- -------------------------------------------------------------------------- --

function Reward_Units(...)
    return B_Reward_Units:new(...)
end

B_Reward_Units = {
    Name = "Reward_Units",
    Description = {
        en = "Reward: Creates units for the quest receiver.",
        de = "Lohn: Erzeugt einige Einheiten für den Auftragnehmer.",
        fr = "Récompense: Unités",
    },
    Parameter = {
        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung", fr ="Désignation de type" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr ="Quantité" },
    },
}

function B_Reward_Units:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    end
end

function B_Reward_Units:GetRewardTable()
    return { Reward.Units, assert( Entities[self.EntityName] ), self.Amount }
end

RegisterBehavior(B_Reward_Units);

-- -------------------------------------------------------------------------- --

function Reward_QuestRestart(...)
    return B_Reward_QuestRestart:new(...)
end

B_Reward_QuestRestart = CopyTable(B_Reprisal_QuestRestart);
B_Reward_QuestRestart.Name = "Reward_QuestRestart";
B_Reward_QuestRestart.Description.en = "Reward: Restarts a (completed) quest so it can be triggered and completed again.";
B_Reward_QuestRestart.Description.de = "Lohn: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann.";
B_Reward_QuestRestart.Description.fr = "Récompense: Redémarre une quête (terminée) pour qu'elle puisse être redéclenchée et terminée.";
B_Reward_QuestRestart.GetReprisalTable = nil;

B_Reward_QuestRestart.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestRestart);

-- -------------------------------------------------------------------------- --

function Reward_QuestFailure(...)
    return B_Reward_QuestFailure:new(...)
end

B_Reward_QuestFailure = CopyTable(B_Reprisal_QuestFailure);
B_Reward_QuestFailure.Name = "Reward_QuestFailure";
B_Reward_QuestFailure.Description.en = "Reward: Lets another active quest fail.";
B_Reward_QuestFailure.Description.de = "Lohn: Lässt eine andere aktive Quest fehlschlagen.";
B_Reward_QuestFailure.Description.fr = "Récompense: Fait échouer une autre quête active.";
B_Reward_QuestFailure.GetReprisalTable = nil;

B_Reward_QuestFailure.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestFailure);

-- -------------------------------------------------------------------------- --

function Reward_QuestSuccess(...)
    return B_Reward_QuestSuccess:new(...)
end

B_Reward_QuestSuccess = CopyTable(B_Reprisal_QuestSuccess);
B_Reward_QuestSuccess.Name = "Reward_QuestSuccess";
B_Reward_QuestSuccess.Description.en = "Reward: Completes another active quest successfully.";
B_Reward_QuestSuccess.Description.de = "Lohn: Beendet eine andere aktive Quest erfolgreich.";
B_Reward_QuestSuccess.Description.fr = "Récompense: Termine avec succès une autre quête active.";
B_Reward_QuestSuccess.GetReprisalTable = nil;

B_Reward_QuestSuccess.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestSuccess);

-- -------------------------------------------------------------------------- --

function Reward_QuestActivate(...)
    return B_Reward_QuestActivate:new(...)
end

B_Reward_QuestActivate = CopyTable(B_Reprisal_QuestActivate);
B_Reward_QuestActivate.Name = "Reward_QuestActivate";
B_Reward_QuestActivate.Description.en = "Reward: Activates another quest that is not triggered yet.";
B_Reward_QuestActivate.Description.de = "Lohn: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.";
B_Reward_QuestActivate.Description.fr = "Récompense: Active une autre quête qui n'a pas encore été déclenchée.";
B_Reward_QuestActivate.GetReprisalTable = nil;

B_Reward_QuestActivate.GetRewardTable = function(self, _Quest)
    return {Reward.Custom, {self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestActivate)

-- -------------------------------------------------------------------------- --

function Reward_QuestInterrupt(...)
    return B_Reward_QuestInterrupt:new(...)
end

B_Reward_QuestInterrupt = CopyTable(B_Reprisal_QuestInterrupt);
B_Reward_QuestInterrupt.Name = "Reward_QuestInterrupt";
B_Reward_QuestInterrupt.Description.en = "Reward: Interrupts another active quest without success or failure.";
B_Reward_QuestInterrupt.Description.de = "Lohn: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg.";
B_Reward_QuestInterrupt.Description.fr = "Récompense: Termine une autre quête active sans succès ni échec.";
B_Reward_QuestInterrupt.GetReprisalTable = nil;

B_Reward_QuestInterrupt.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestInterrupt);

-- -------------------------------------------------------------------------- --

function Reward_QuestForceInterrupt(...)
    return B_Reward_QuestForceInterrupt:new(...)
end

B_Reward_QuestForceInterrupt = CopyTable(B_Reprisal_QuestForceInterrupt);
B_Reward_QuestForceInterrupt.Name = "Reward_QuestForceInterrupt";
B_Reward_QuestForceInterrupt.Description.en = "Reward: Interrupts another quest (even when it isn't active yet) without success or failure.";
B_Reward_QuestForceInterrupt.Description.de = "Lohn: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg.";
B_Reward_QuestForceInterrupt.Description.fr = "Récompense: Termine une autre quête, même si elle n'est pas encore active, sans succès ni échec.";
B_Reward_QuestForceInterrupt.GetReprisalTable = nil;

B_Reward_QuestForceInterrupt.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestForceInterrupt);

-- -------------------------------------------------------------------------- --

function Reward_CustomVariables(...)
    return B_Reward_CustomVariables:new(...);
end

B_Reward_CustomVariables = CopyTable(B_Reprisal_CustomVariables);
B_Reward_CustomVariables.Name = "Reward_CustomVariables";
B_Reward_CustomVariables.Description.en = "Reward: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.";
B_Reward_CustomVariables.Description.de = "Lohn: Führt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.";
B_Reward_CustomVariables.Description.fr = "Récompense: Effectue une opération mathématique sur la variable. L'autre opérateur peut être un nombre ou une variable personnalisée.";
B_Reward_CustomVariables.GetReprisalTable = nil;

B_Reward_CustomVariables.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} };
end

RegisterBehavior(B_Reward_CustomVariables)

-- -------------------------------------------------------------------------- --

function Reward_MapScriptFunction(...)
    return B_Reward_MapScriptFunction:new(...);
end

B_Reward_MapScriptFunction = CopyTable(B_Reprisal_MapScriptFunction);
B_Reward_MapScriptFunction.Name = "Reward_MapScriptFunction";
B_Reward_MapScriptFunction.Description.en = "Reward: Calls a function within the global map script if the quest has failed.";
B_Reward_MapScriptFunction.Description.de = "Lohn: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.";
B_Reward_MapScriptFunction.Description.fr = "Récompense: Invoque une fonction dans le script global de la carte en cas d'échec de la quête.";
B_Reward_MapScriptFunction.GetReprisalTable = nil;

B_Reward_MapScriptFunction.GetRewardTable = function(self, _Quest)
    return {Reward.Custom, {self, self.CustomFunction}};
end

RegisterBehavior(B_Reward_MapScriptFunction);

-- -------------------------------------------------------------------------- --

function Reward_Technology(...)
    return B_Reward_Technology:new(...);
end

B_Reward_Technology = CopyTable(B_Reprisal_Technology);
B_Reward_Technology.Name = "Reward_Technology";
B_Reward_Technology.Description.en = "Reward: Locks or unlocks a technology for the given player.";
B_Reward_Technology.Description.de = "Lohn: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player.";
B_Reward_Technology.Description.fr = "Récompense: Bloque ou autorise une technologie pour le joueur spécifié.";
B_Reward_Technology.GetReprisalTable = nil;

B_Reward_Technology.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_Technology);

-- -------------------------------------------------------------------------- --

function Reward_PrestigePoints(...)
    return B_Reward_PrestigePoints:mew(...);
end

B_Reward_PrestigePoints  = {
    Name = "Reward_PrestigePoints",
    Description = {
        en = "Reward: Gives the quest receiver prestige.",
        de = "Lohn: Gibt dem Auftragnehmer Prestige.",
        fr = "Récompense: Prestige",
    },
    Parameter = {
        { ParameterType.Number, en = "Points", de = "Punkte", fr = "Points" },
    },
}

function B_Reward_PrestigePoints :AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Points = _Parameter
    end
end

function B_Reward_PrestigePoints :GetRewardTable()
    return { Reward.PrestigePoints, self.Points }
end

RegisterBehavior(B_Reward_PrestigePoints);

-- -------------------------------------------------------------------------- --

function Reward_AI_MountOutpost(...)
    return B_Reward_AI_MountOutpost:new(...);
end

B_Reward_AI_MountOutpost = {
    Name = "Reward_AI_MountOutpost",
    Description = {
        en = "Reward: Places a troop of soldiers on a named outpost.",
        de = "Lohn: Platziert einen Trupp Soldaten auf einem Aussenposten der KI.",
        fr = "Récompense: Place un groupe de soldats sur un avant-poste de l'IA.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name",   de = "Skriptname",  fr = "Nom de l'entité" },
        { ParameterType.Custom,     en = "Soldiers type", de = "Soldatentyp", fr = "Type de soldat" },
    },
}

function B_Reward_AI_MountOutpost:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_MountOutpost:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Scriptname = _Parameter
    else
        self.SoldiersType = _Parameter
    end
end

function B_Reward_AI_MountOutpost:CustomFunction(_Quest)
    local outpostID = assert(
        not Logic.IsEntityDestroyed(self.Scriptname) and GetID(self.Scriptname),
       _Quest.Identifier .. ": Error in " .. self.Name .. ": CustomFunction: Outpost is invalid"
    )
    local AIPlayerID = Logic.EntityGetPlayer(outpostID)
    local ax, ay = Logic.GetBuildingApproachPosition(outpostID)
    local TroopID = Logic.CreateBattalionOnUnblockedLand(Entities[self.SoldiersType], ax, ay, 0, AIPlayerID, 0)
    AICore.HideEntityFromAI(AIPlayerID, TroopID, true)
    Logic.CommandEntityToMountBuilding(TroopID, outpostID)
end

function B_Reward_AI_MountOutpost:GetCustomData(_Index)
    if _Index == 1 then
        local Data = {}
        for k,v in pairs(Entities) do
            if string.find(k, "U_MilitaryBandit") or string.find(k, "U_MilitarySword") or string.find(k, "U_MilitaryBow") then
                Data[#Data+1] = k
            end
        end
        return Data
    end
end

function B_Reward_AI_MountOutpost:Debug(_Quest)
    if Logic.IsEntityDestroyed(self.Scriptname) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Outpost " .. self.Scriptname .. " is missing")
        return true
    end
end

RegisterBehavior(B_Reward_AI_MountOutpost)

-- -------------------------------------------------------------------------- --

function Reward_QuestRestartForceActive(...)
    return B_Reward_QuestRestartForceActive:new(...);
end

B_Reward_QuestRestartForceActive = {
    Name = "Reward_QuestRestartForceActive",
    Description = {
        en = "Reward: Restarts a (completed) quest and triggers it immediately.",
        de = "Lohn: Startet eine (beendete) Quest neu und triggert sie sofort.",
        fr = "Récompense: Redémarre une quête (terminée) et la déclenche immédiatement.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la quête" },
    },
}

function B_Reward_QuestRestartForceActive:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_QuestRestartForceActive:AddParameter(_Index, _Parameter)
    self.QuestName = _Parameter
end

function B_Reward_QuestRestartForceActive:CustomFunction(_Quest)
    local QuestID, Quest = self:ResetQuest(_Quest);
    if QuestID then
        Quest:SetMsgKeyOverride();
        Quest:SetIconOverride();
        Quest:Trigger();
    end
end

B_Reward_QuestRestartForceActive.ResetQuest = B_Reward_QuestRestart.CustomFunction;
function B_Reward_QuestRestartForceActive:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Quest: "..  self.QuestName .. " does not exist");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_QuestRestartForceActive)

-- -------------------------------------------------------------------------- --

function Reward_UpgradeBuilding(...)
    return B_Reward_UpgradeBuilding:new(...);
end

B_Reward_UpgradeBuilding = {
    Name = "Reward_UpgradeBuilding",
    Description = {
        en = "Reward: Upgrades a building",
        de = "Lohn: Baut ein Gebäude aus",
        fr = "Récompense: Améliore un Bâtiment",
    },
    Parameter =    {
        { ParameterType.ScriptName, en = "Building", de = "Gebäude", fr = "Bâtiment" }
    }
};

function B_Reward_UpgradeBuilding:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction}};
end

function B_Reward_UpgradeBuilding:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Building = _Parameter;
    end
end

function B_Reward_UpgradeBuilding:CustomFunction(_Quest)
    local building = GetID(self.Building);
    if building ~= 0
    and Logic.IsBuilding(building) == 1
    and Logic.IsBuildingUpgradable(building, true)
    and Logic.IsBuildingUpgradable(building, false)
    then
        Logic.UpgradeBuilding(building);
    end
end

function B_Reward_UpgradeBuilding:Debug(_Quest)
    local building = GetID(self.Building);
    if not (building ~= 0
            and Logic.IsBuilding(building) == 1
            and Logic.IsBuildingUpgradable(building, true)
            and Logic.IsBuildingUpgradable(building, false) )
    then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Building is wrong")
        return true
    end
end

RegisterBehavior(B_Reward_UpgradeBuilding)

-- -------------------------------------------------------------------------- --

function Reward_SetBuildingUpgradeLevel(...)
    return B_Reward_SetBuildingUpgradeLevel:new(...);
end

B_Reward_SetBuildingUpgradeLevel = {
    Name = "Reward_SetBuildingUpgradeLevel",
    Description = {
        en = "Reward: Sets the upgrade level of the specified building.",
        de = "Lohn: Legt das Upgrade-Level eines Gebaeudes fest.",
        fr = "Récompense: Définit le niveau d'amélioration d'un bâtiment.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Building",        de = "Gebäude",         fr = "Bâtiment" },
        { ParameterType.Custom,     en = "Upgrade level",   de = "Upgrade-Level",   fr = "Niveau d'amélioration" },
    }
};

function B_Reward_SetBuildingUpgradeLevel:GetRewardTable()
    return {Reward.Custom, self, self.CustomFunction};
end

function B_Reward_SetBuildingUpgradeLevel:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Building = _Parameter;
    elseif _Index == 1 then
        self.UpgradeLevel = tonumber(_Parameter);
    end
end

function B_Reward_SetBuildingUpgradeLevel:CustomFunction()
    local building = Logic.GetEntityIDByName(self.Building);
    local upgradeLevel = Logic.GetUpgradeLevel(building);
    local maxUpgradeLevel = Logic.GetMaxUpgradeLevel(building);
    if building ~= 0 
    and Logic.IsBuilding(building) == 1
    and (Logic.IsBuildingUpgradable(building, true)
    or (maxUpgradeLevel ~= 0 
    and maxUpgradeLevel == upgradeLevel))
    then
        Logic.SetUpgradableBuildingState(building, math.min(self.UpgradeLevel, maxUpgradeLevel), 0);
    end
end

function B_Reward_SetBuildingUpgradeLevel:Debug(_Quest)
    local building = Logic.GetEntityIDByName( self.Building )
    if not building or Logic.IsBuilding(building) == 0  then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Building " .. self.Building .. " is missing or no building.")
        return true
    elseif not self.UpgradeLevel or self.UpgradeLevel < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Upgrade level is wrong")
        return true
    end
end

function B_Reward_SetBuildingUpgradeLevel:GetCustomData(_Index)
    if _Index == 1 then
        return { "0", "1", "2", "3" };
    end
end

RegisterBehavior(B_Reward_SetBuildingUpgradeLevel);

-- -------------------------------------------------------------------------- --

function Trigger_PlayerDiscovered(...)
    return B_Trigger_PlayerDiscovered:new(...);
end

B_Trigger_PlayerDiscovered = {
    Name = "Trigger_PlayerDiscovered",
    Description = {
        en = "Trigger: if a given player has been discovered",
        de = "Auslöser: wenn ein angegebener Spieler entdeckt wurde",
        fr = "Déclencheur: lorsqu'un joueur spécifié est découvert",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Trigger_PlayerDiscovered:GetTriggerTable()
    return {Triggers.PlayerDiscovered, self.PlayerID}
end

function B_Trigger_PlayerDiscovered:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1;
    end
end

RegisterBehavior(B_Trigger_PlayerDiscovered);

-- -------------------------------------------------------------------------- --

function Trigger_OnDiplomacy(...)
    return B_Trigger_OnDiplomacy:new(...);
end

B_Trigger_OnDiplomacy = {
    Name = "Trigger_OnDiplomacy",
    Description = {
        en = "Trigger: if diplomatic relations have been established with a player",
        de = "Auslöser: wenn ein angegebener Diplomatie-Status mit einem Spieler erreicht wurde.",
        fr = "Déclencheur: lorsqu'un statut diplomatique spécifié a été atteint avec un joueur.",
    },
    Parameter = {
        { ParameterType.PlayerID,       en = "Player",      de = "Spieler",     fr = "Joueur" },
        { ParameterType.DiplomacyState, en = "Relation",    de = "Beziehung",   fr = "Relation diplomatique" },
    },
}

function B_Trigger_OnDiplomacy:GetTriggerTable()
    return {Triggers.Diplomacy, self.PlayerID, assert( DiplomacyStates[self.DiplState] ) }
end

function B_Trigger_OnDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.DiplState = _Parameter
    end
end

RegisterBehavior(B_Trigger_OnDiplomacy);

-- -------------------------------------------------------------------------- --

function Trigger_OnNeedUnsatisfied(...)
    return B_Trigger_OnNeedUnsatisfied:new(...);
end

B_Trigger_OnNeedUnsatisfied = {
    Name = "Trigger_OnNeedUnsatisfied",
    Description = {
        en = "Trigger: if a specified need is unsatisfied",
        de = "Auslöser: wenn ein bestimmtes Beduerfnis nicht befriedigt ist.",
        fr = "Déclencheur: lorsqu'un certain besoin n'est pas satisfait.",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "Player",              de = "Spieler",             fr = "Joueur" },
        { ParameterType.Need,       en = "Need",                de = "Beduerfnis",          fr = "Besoin" },
        { ParameterType.Number,     en = "Workers on strike",   de = "Streikende Arbeiter", fr = "Travailleurs en grève" },
    },
}

function B_Trigger_OnNeedUnsatisfied:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnNeedUnsatisfied:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Need = _Parameter
    elseif (_Index == 2) then
        self.WorkersOnStrike = _Parameter * 1
    end
end

function B_Trigger_OnNeedUnsatisfied:CustomFunction(_Quest)
    return Logic.GetNumberOfStrikingWorkersPerNeed( self.PlayerID, Needs[self.Need] ) >= self.WorkersOnStrike
end

function B_Trigger_OnNeedUnsatisfied:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": " .. self.PlayerID .. " does not exist.")
        return true
    elseif not Needs[self.Need] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": " .. self.Need .. " does not exist.")
        return true
    elseif self.WorkersOnStrike < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": WorkersOnStrike value negative")
        return true
    end
    return false;
end

RegisterBehavior(B_Trigger_OnNeedUnsatisfied);

-- -------------------------------------------------------------------------- --

function Trigger_OnResourceDepleted(...)
    return B_Trigger_OnResourceDepleted:new(...);
end

B_Trigger_OnResourceDepleted = {
    Name = "Trigger_OnResourceDepleted",
    Description = {
        en = "Trigger: if a resource is (temporarily) depleted",
        de = "Auslöser: wenn eine Ressource (zeitweilig) verbraucht ist",
        fr = "Déclencheur: lorsqu'une ressource est (temporairement) consommée",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de script" },
    },
}

function B_Trigger_OnResourceDepleted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnResourceDepleted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Trigger_OnResourceDepleted:CustomFunction(_Quest)
    local ID = GetID(self.ScriptName)
    return not ID or ID == 0 or Logic.GetResourceDoodadGoodType(ID) == 0 or Logic.GetResourceDoodadGoodAmount(ID) == 0
end

RegisterBehavior(B_Trigger_OnResourceDepleted);

-- -------------------------------------------------------------------------- --

function Trigger_OnAmountOfGoods(...)
    return B_Trigger_OnAmountOfGoods:new(...);
end

B_Trigger_OnAmountOfGoods = {
    Name = "Trigger_OnAmountOfGoods",
    Description = {
        en = "Trigger: if the player has gathered a given amount of resources in his storehouse",
        de = "Auslöser: wenn der Spieler eine bestimmte Menge einer Ressource in seinem Lagerhaus hat",
        fr = "Déclencheur: lorsque le joueur a une certaine quantité d'une ressource dans son entrepôt",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "Player",          de = "Spieler",             fr = "Joueur" },
        { ParameterType.RawGoods,   en = "Type of good",    de = "Resourcentyp",        fr = "Type de ressources" },
        { ParameterType.Number,     en = "Amount of good",  de = "Anzahl der Resource", fr = "Quantité de ressources" },
    },
}

function B_Trigger_OnAmountOfGoods:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnAmountOfGoods:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 2) then
        self.GoodAmount = _Parameter * 1
    end
end

function B_Trigger_OnAmountOfGoods:CustomFunction(_Quest)
    local StoreHouseID = Logic.GetStoreHouse(self.PlayerID)
    if (StoreHouseID == 0) then
        return false
    end
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    local GoodAmount = Logic.GetAmountOnOutStockByGoodType(StoreHouseID, GoodType)
    if (GoodAmount >= self.GoodAmount)then
        return true
    end
    return false
end

function B_Trigger_OnAmountOfGoods:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": " .. self.PlayerID .. " does not exist.")
        return true
    elseif not Goods[self.GoodTypeName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Good type is wrong.")
        return true
    elseif self.GoodAmount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Good amount is negative.")
        return true
    end
    return false;
end

RegisterBehavior(B_Trigger_OnAmountOfGoods);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestActive(...)
    return B_Trigger_OnQuestActiveWait:new(...);
end
Trigger_OnQuestActiveWait = Trigger_OnQuestActive;

B_Trigger_OnQuestActiveWait = {
    Name = "Trigger_OnQuestActiveWait",
    Description = {
        en = "Trigger: if a given quest has been activated. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest aktiviert wurde. Optional mit Wartezeit",
        fr = "Déclencheur: lorsqu'une quête indiquée a été activée. En option avec délai d'attente",
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente" },
    },
}

function B_Trigger_OnQuestActiveWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestActiveWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestActiveWait:CustomFunction(_Quest)
    local QuestID = GetQuestID(self.QuestName)
    if QuestID ~= nil then
        assert(type(QuestID) == "number");

        if (Quests[QuestID].State == QuestState.Active) then
            self.WasActivated = self.WasActivated or true;
        end
        if self.WasActivated then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestActiveWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestActiveWait:Interrupt(_Quest)
    -- does this realy matter after interrupt?
    -- self.WaitTimeTimer = nil;
    -- self.WasActivated = nil;
end

function B_Trigger_OnQuestActiveWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
    self.WasActivated = nil;
end

RegisterBehavior(B_Trigger_OnQuestActiveWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestActive = CopyTable(B_Trigger_OnQuestActiveWait);
B_Trigger_OnQuestActive.Name = "Trigger_OnQuestActive";
B_Trigger_OnQuestActive.Description.en = "Trigger: Starts the quest after another has been activated.";
B_Trigger_OnQuestActive.Description.de = "Auslöser: Startet den Quest, wenn ein anderer aktiviert wird.";
B_Trigger_OnQuestActive.Description.fr = "Déclencheur: Démarre la quête lorsqu'une autre est activée.";
B_Trigger_OnQuestActive.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestActive:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

RegisterBehavior(B_Trigger_OnQuestActive);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestFailure(...)
    return B_Trigger_OnQuestFailureWait:new(...);
end
Trigger_OnQuestFailureWait = Trigger_OnQuestFailure;

B_Trigger_OnQuestFailureWait = {
    Name = "Trigger_OnQuestFailureWait",
    Description = {
        en = "Trigger: if a given quest has failed. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest fehlgeschlagen ist. Optional mit Wartezeit",
        fr = "Déclencheur: lorsqu'une quête indiquée a échoué. En option avec délai d'attente",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,    en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente" },
    },
}

function B_Trigger_OnQuestFailureWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestFailureWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestFailureWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].Result == QuestResult.Failure) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestFailureWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestFailureWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestFailureWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

RegisterBehavior(B_Trigger_OnQuestFailureWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestFailure = CopyTable(B_Trigger_OnQuestFailureWait);
B_Trigger_OnQuestFailure.Name = "Trigger_OnQuestFailure";
B_Trigger_OnQuestFailure.Description.en = "Trigger: Starts the quest after another has failed.";
B_Trigger_OnQuestFailure.Description.de = "Auslöser: Startet den Quest, wenn ein anderer fehlschlägt.";
B_Trigger_OnQuestFailure.Description.fr = "Déclencheur: Lance la quête lorsqu'une autre échoue.";
B_Trigger_OnQuestFailure.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestFailure:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

RegisterBehavior(B_Trigger_OnQuestFailure);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestNotTriggered(...)
    return B_Trigger_OnQuestNotTriggered:new(...);
end

B_Trigger_OnQuestNotTriggered = {
    Name = "Trigger_OnQuestNotTriggered",
    Description = {
        en = "Trigger: if a given quest is not yet active. Should be used in combination with other triggers.",
        de = "Auslöser: wenn eine angegebene Quest noch inaktiv ist. Sollte mit weiteren Triggern kombiniert werden.",
        fr = "Déclencheur: lorsqu'une quête indiquée est encore inactive. Doit être combiné avec d'autres déclencheurs."
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
    },
}

function B_Trigger_OnQuestNotTriggered:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestNotTriggered:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Trigger_OnQuestNotTriggered:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.NotTriggered) then
            return true;
        end
    end
    return false;
end

function B_Trigger_OnQuestNotTriggered:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_OnQuestNotTriggered);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestInterrupted(...)
    return B_Trigger_OnQuestInterruptedWait:new(...);
end
Trigger_OnQuestInterruptedWait = Trigger_OnQuestInterrupted;

B_Trigger_OnQuestInterruptedWait = {
    Name = "Trigger_OnQuestInterruptedWait",
    Description = {
        en = "Trigger: if a given quest has been interrupted. Should be used in combination with other triggers.",
        de = "Auslöser: wenn eine angegebene Quest abgebrochen wurde. Sollte mit weiteren Triggern kombiniert werden.",
        fr = "Déclencheur: lorsqu'une quête indiquée a été interrompue. Doit être combiné avec d'autres déclencheurs."
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente"},
    },
}

function B_Trigger_OnQuestInterruptedWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestInterruptedWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestInterruptedWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result == QuestResult.Interrupted) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestInterruptedWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestInterruptedWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestInterruptedWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

RegisterBehavior(B_Trigger_OnQuestInterruptedWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestInterrupted = CopyTable(B_Trigger_OnQuestInterruptedWait);
B_Trigger_OnQuestInterrupted.Name = "Trigger_OnQuestInterrupted";
B_Trigger_OnQuestInterrupted.Description.en = "Trigger: Starts the quest after another is interrupted.";
B_Trigger_OnQuestInterrupted.Description.de = "Auslöser: Startet den Quest, wenn ein anderer abgebrochen wurde.";
B_Trigger_OnQuestInterrupted.Description.fr = "Déclencheur: Démarre la quête lorsqu'une autre a été annulée.";
B_Trigger_OnQuestInterrupted.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestInterrupted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

RegisterBehavior(B_Trigger_OnQuestInterrupted);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestOver(...)
    return B_Trigger_OnQuestOverWait:new(...);
end
Trigger_OnQuestOverWait = Trigger_OnQuestOver;

B_Trigger_OnQuestOverWait = {
    Name = "Trigger_OnQuestOverWait",
    Description = {
        en = "Trigger: if a given quest has been finished, regardless of its result. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest beendet wurde, unabhängig von deren Ergebnis. Wartezeit optional",
        fr = "Déclencheur: lorsqu'une quête indiquée est terminée, indépendamment de son résultat. Délai d'attente optionnel"
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente"},
    },
}

function B_Trigger_OnQuestOverWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestOverWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestOverWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestOverWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestOverWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestOverWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

RegisterBehavior(B_Trigger_OnQuestOverWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestOver = CopyTable(B_Trigger_OnQuestOverWait);
B_Trigger_OnQuestOver.Name = "Trigger_OnQuestOver";
B_Trigger_OnQuestOver.Description.en = "Trigger: Starts the quest after another finished.";
B_Trigger_OnQuestOver.Description.de = "Auslöser: Startet den Quest, wenn ein anderer abgeschlossen wurde.";
B_Trigger_OnQuestOver.Description.fr = "Déclencheur: Démarre la quête lorsqu'une autre est terminée.";
B_Trigger_OnQuestOver.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestOver:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

RegisterBehavior(B_Trigger_OnQuestOver);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestSuccess(...)
    return B_Trigger_OnQuestSuccessWait:new(...);
end
Trigger_OnQuestSuccessWait = Trigger_OnQuestSuccess;

B_Trigger_OnQuestSuccessWait = {
    Name = "Trigger_OnQuestSuccessWait",
    Description = {
        en = "Trigger: if a given quest has been finished successfully. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest erfolgreich abgeschlossen wurde. Wartezeit optional",
        fr = "Déclencheur: lorsqu'une quête indiquée a été accomplie avec succès. Délai d'attente optionnel",
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente" },
    },
}

function B_Trigger_OnQuestSuccessWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestSuccessWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestSuccessWait:CustomFunction()
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].Result == QuestResult.Success) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestSuccessWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waittime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestSuccessWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestSuccessWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

RegisterBehavior(B_Trigger_OnQuestSuccessWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestSuccess = CopyTable(B_Trigger_OnQuestSuccessWait);
B_Trigger_OnQuestSuccess.Name = "Trigger_OnQuestSuccess";
B_Trigger_OnQuestSuccess.Description.en = "Trigger: Starts the quest after another finished successfully.";
B_Trigger_OnQuestSuccess.Description.de = "Auslöser: Startet den Quest, wenn ein anderer erfolgreich abgeschlossen wurde.";
B_Trigger_OnQuestSuccess.Description.de = "Déclencheur: Démarre la quête lorsqu'une autre a été accomplie avec succès.";
B_Trigger_OnQuestSuccess.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

RegisterBehavior(B_Trigger_OnQuestSuccess);

-- -------------------------------------------------------------------------- --

function Trigger_CustomVariables(...)
    return B_Trigger_CustomVariables:new(...);
end

B_Trigger_CustomVariables = {
    Name = "Trigger_CustomVariables",
    Description = {
        en = "Trigger: if the variable has a certain value.",
        de = "Auslöser: wenn die Variable einen bestimmen Wert eingenommen hat.",
        fr = "Déclencheur: lorsque la variable a pris une valeur déterminée."
    },
    Parameter = {
        { ParameterType.Default, en = "Name of Variable",   de = "Variablennamen",  fr = "Noms de variables" },
        { ParameterType.Custom,  en = "Relation",           de = "Relation",        fr = "Relation" },
        { ParameterType.Default, en = "Value",              de = "Wert",            fr = "Valeur" }
    }
};

function B_Trigger_CustomVariables:GetTriggerTable()
    return { Triggers.Custom2, {self, self.CustomFunction} };
end

function B_Trigger_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Relation = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        value = (value ~= nil and value) or _Parameter;
        self.Value = value
    end
end

function B_Trigger_CustomVariables:CustomFunction()
    local Value1 = ObtainCustomVariable("BehaviorVariable_" ..self.VariableName, 0);
    local Value2 = self.Value;
    if type(self.Value) == "string" then
        Value2 = ObtainCustomVariable("BehaviorVariable_" ..self.Value, 0);
    end

    if self.Relation == "==" then
        return Value1 == Value2;
    elseif self.Relation ~= "~=" then
        return Value1 ~= Value2;
    elseif self.Relation == ">" then
        return Value1 > Value2;
    elseif self.Relation == ">=" then
        return Value1 >= Value2;
    elseif self.Relation == "<=" then
        return Value1 <= Value2;
    else
        return Value1 < Value2;
    end
    return false;
end

function B_Trigger_CustomVariables:GetCustomData( _Index )
    if _Index == 1 then
        return {"==", "~=", "<=", "<", ">", ">="};
    end
end

function B_Trigger_CustomVariables:Debug(_Quest)
    local relations = {"==", "~=", "<=", "<", ">", ">="}
    local results    = {true, false, nil}

    if not ObtainCustomVariable("BehaviorVariable_" ..self.VariableName) then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": variable '"..self.VariableName.."' do not exist!");
    end
    if not table.contains(relations, self.Relation) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.Relation.."' is an invalid relation!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_CustomVariables)

-- -------------------------------------------------------------------------- --

function Trigger_AlwaysActive()
    return B_Trigger_AlwaysActive:new()
end

B_Trigger_AlwaysActive = {
    Name = "Trigger_AlwaysActive",
    Description = {
        en = "Trigger: the map has been started.",
        de = "Auslöser: Start der Karte.",
        fr = "Déclencheur: Démarrage de la carte.",
    },
}

function B_Trigger_AlwaysActive:GetTriggerTable()
    return {Triggers.Time, 0 }
end

RegisterBehavior(B_Trigger_AlwaysActive);

-- -------------------------------------------------------------------------- --

function Trigger_OnMonth(...)
    return B_Trigger_OnMonth:new(...);
end

B_Trigger_OnMonth = {
    Name = "Trigger_OnMonth",
    Description = {
        en = "Trigger: a specified month",
        de = "Auslöser: ein bestimmter Monat",
        fr = "Déclencheur: un mois donné"
    },
    Parameter = {
        { ParameterType.Custom, en = "Month", de = "Monat", fr = "Mois" },
    },
}

function B_Trigger_OnMonth:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnMonth:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Month = _Parameter * 1
    end
end

function B_Trigger_OnMonth:CustomFunction(_Quest)
    return self.Month == Logic.GetCurrentMonth()
end

function B_Trigger_OnMonth:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for i = 1, 12 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function B_Trigger_OnMonth:Debug(_Quest)
    if self.Month < 1 or self.Month > 12 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Month has the wrong value")
        return true
    end
    return false;
end

RegisterBehavior(B_Trigger_OnMonth);

-- -------------------------------------------------------------------------- --

function Trigger_OnMonsoon()
    return B_Trigger_OnMonsoon:new();
end

B_Trigger_OnMonsoon = {
    Name = "Trigger_OnMonsoon",
    Description = {
        en = "Trigger: on monsoon.",
        de = "Auslöser: wenn der Monsun beginnt.",
        fr = "Déclencheur: lorsque la mousson commence.",
    },
    RequiresExtraNo = 1,
}

function B_Trigger_OnMonsoon:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnMonsoon:CustomFunction(_Quest)
    if Logic.GetWeatherDoesShallowWaterFlood(0) then
        return true
    end
end

RegisterBehavior(B_Trigger_OnMonsoon);

-- -------------------------------------------------------------------------- --

function Trigger_Time(...)
    return B_Trigger_Time:new(...);
end

B_Trigger_Time = {
    Name = "Trigger_Time",
    Description = {
        en = "Trigger: a given amount of time since map start",
        de = "Auslöser: eine gewisse Anzahl Sekunden nach Spielbeginn",
        fr = "Déclencheur: un certain nombre de secondes après le début du jeu",
    },
    Parameter = {
        { ParameterType.Number, en = "Time (sec.)", de = "Zeit (Sek.)", fr = "Temps (sec.)" },
    },
}

function B_Trigger_Time:GetTriggerTable()
    return {Triggers.Time, self.Time }
end

function B_Trigger_Time:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Time = _Parameter * 1
    end
end

RegisterBehavior(B_Trigger_Time);

-- -------------------------------------------------------------------------- --

function Trigger_OnWaterFreezes()
    return B_Trigger_OnWaterFreezes:new();
end

B_Trigger_OnWaterFreezes = {
    Name = "Trigger_OnWaterFreezes",
    Description = {
        en = "Trigger: if the water starts freezing",
        de = "Auslöser: wenn die Gewässer gefrieren",
        fr = "Déclencheur: lorsque les eaux gèlent",
    },
}

function B_Trigger_OnWaterFreezes:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnWaterFreezes:CustomFunction(_Quest)
    if Logic.GetWeatherDoesWaterFreeze(0) then
        return true
    end
end

RegisterBehavior(B_Trigger_OnWaterFreezes);

-- -------------------------------------------------------------------------- --

function Trigger_NeverTriggered()
    return B_Trigger_NeverTriggered:new();
end

B_Trigger_NeverTriggered = {
    Name = "Trigger_NeverTriggered",
    Description = {
        en = "Trigger: Never triggers a Quest. The quest may be set active by Reward_QuestActivate or Reward_QuestRestartForceActive",
        de = "Auslöser: Löst nie eine Quest aus. Die Quest kann von Reward_QuestActivate oder Reward_QuestRestartForceActive aktiviert werden.",
        fr = "Déclencheur: Ne déclenche jamais de quête. La quête peut être activée par Reward_QuestActivate ou Reward_QuestRestartForceActive.",
    },
}

function B_Trigger_NeverTriggered:GetTriggerTable()

    return {Triggers.Custom2, {self, function() end} }

end

RegisterBehavior(B_Trigger_NeverTriggered)

-- -------------------------------------------------------------------------- --

function Trigger_OnAtLeastOneQuestFailure(...)
    return B_Trigger_OnAtLeastOneQuestFailure:new(...);
end

B_Trigger_OnAtLeastOneQuestFailure = {
    Name = "Trigger_OnAtLeastOneQuestFailure",
    Description = {
        en = "Trigger: if one or both of the given quests have failed.",
        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge fehlgeschlagen sind.",
        fr = "Déclencheur: si l'une des quêtes indiquées ou les deux ont échoué.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2" },
    },
}

function B_Trigger_OnAtLeastOneQuestFailure:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnAtLeastOneQuestFailure:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnAtLeastOneQuestFailure:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure)
    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure) then
        return true;
    end
    return false;
end

function B_Trigger_OnAtLeastOneQuestFailure:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_OnAtLeastOneQuestFailure);

-- -------------------------------------------------------------------------- --

function Trigger_OnAtLeastOneQuestSuccess(...)
    return B_Trigger_OnAtLeastOneQuestSuccess:new(...);
end

B_Trigger_OnAtLeastOneQuestSuccess = {
    Name = "Trigger_OnAtLeastOneQuestSuccess",
    Description = {
        en = "Trigger: if one or both of the given quests are won.",
        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge gewonnen wurden.",
        fr = "Déclencheur : si une ou les deux missions indiquées ont été gagnées.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2" },
    },
}

function B_Trigger_OnAtLeastOneQuestSuccess:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnAtLeastOneQuestSuccess:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnAtLeastOneQuestSuccess:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success)
    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success) then
        return true;
    end
    return false;
end

function B_Trigger_OnAtLeastOneQuestSuccess:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_OnAtLeastOneQuestSuccess);

-- -------------------------------------------------------------------------- --

function Trigger_MapScriptFunction(...)
    return B_Trigger_MapScriptFunction:new(...);
end

B_Trigger_MapScriptFunction = {
    Name = "Trigger_MapScriptFunction",
    Description = {
        en = "Trigger: Calls a function within the global map script. If the function returns true the quest will be started",
        de = "Auslöser: Ruft eine Funktion im globalen Skript auf. Wenn sie true sendet, wird die Quest gestartet.",
        fr = "Déclencheur: Appelle une fonction dans le script global. Si elle envoie true, la quête est lancée.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname", fr = "Nom de la fonction" },
    },
}

function B_Trigger_MapScriptFunction:GetTriggerTable(_Quest)
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_MapScriptFunction:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.FuncName = _Parameter
    end
end

function B_Trigger_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        return self.FuncName(unpack(self.i47ya_6aghw_frxil));
    end
    return _G[self.FuncName](self, _Quest);
end

function B_Trigger_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_MapScriptFunction);

-- -------------------------------------------------------------------------- --

function Trigger_OnEffectDestroyed(...)
    return B_Trigger_OnEffectDestroyed:new(...);
end

B_Trigger_OnEffectDestroyed = {
    Name = "Trigger_OnEffectDestroyed",
    Description = {
        en = "Trigger: Starts a quest after an effect was destroyed",
        de = "Auslöser: Startet eine Quest, nachdem ein Effekt zerstoert wurde",
        fr = "Déclencheur: Démarre une quête après la destruction d'un effet.",
    },
    Parameter = {
        { ParameterType.Default, en = "Effect name", de = "Effektname", fr = "Nom de l'effet" },
    },
}

function B_Trigger_OnEffectDestroyed:GetTriggerTable()
    return { Triggers.Custom2, {self, self.CustomFunction} }
end

function B_Trigger_OnEffectDestroyed:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.EffectName = _Parameter
    end
end

function B_Trigger_OnEffectDestroyed:CustomFunction()
    return not CONST_EFFECT_NAME_TO_ID[self.EffectName] or not Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName]);
end

function B_Trigger_OnEffectDestroyed:Debug(_Quest)
    if not CONST_EFFECT_NAME_TO_ID[self.EffectName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Effect has never existed")
        return true
    end
end
RegisterBehavior(B_Trigger_OnEffectDestroyed)

-- -------------------------------------------------------------------------- --

Lib.Core = Lib.Core or {};
Lib.Core.Player = {}

CONST_PLAYER_NAMES = {};

Lib.Register("core/feature/Core_Player");

-- -------------------------------------------------------------------------- --

function Lib.Core.Player:Initialize()
    for PlayerID = 1, 8 do
        CONST_PLAYER_NAMES[PlayerID] = "";
    end
    self:OverwriteNamingComforts();
end

function Lib.Core.Player:OnSaveGameLoaded()
end

function Lib.Core.Player:OnReportReceived(_ID, ...)
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Player:OverwriteNamingComforts()
    GetPlayerName = function(_PlayerID)
        return Lib.Core.Player:GetPlayerName(_PlayerID);
    end

    SetPlayerName = function(_PlayerID, _Name)
        assert(type(_PlayerID) == "number");
        assert(type(_Name) == "string");
        if not IsLocalScript() then
            ExecuteLocal([[SetPlayerName(%d, "%s")]], _PlayerID, _Name);
        end
        return Lib.Core.Player:SetPlayerName(_PlayerID, _Name);
    end

    SetPlayerColor = function(_PlayerID, _Color, _Logo, _Pattern)
        error(not IsLocalScript(), "Player color must be set from logic!");
        Lib.Core.Player:SetPlayerColor(_PlayerID, _Color, _Logo, _Pattern);
    end

    GetTerritoryName = function(_TerritoryID)
        return Lib.Core.Player:GetTerritoryName(_TerritoryID);
    end
end

function SetPlayerPortrait(_PlayerID, _Portrait)
    error(_PlayerID >= 1 and _PlayerID <= 8, "Invalid player ID!");
    if not IsLocalScript() then
        local Portrait = (_Portrait ~= nil and "'" .._Portrait.. "'") or "nil";
        ExecuteLocal("SetPlayerPortrait(%d, %s)", _PlayerID, Portrait)
        return;
    end
    if _Portrait == nil then
        Lib.Core.Player:SetPlayerPortraitByPrimaryKnight(_PlayerID);
    elseif _Portrait ~= nil and IsExisting(_Portrait) then
        Lib.Core.Player:SetPlayerPortraitBySettler(_PlayerID, _Portrait);
    else
        Lib.Core.Player:SetPlayerPortraitByModelName(_PlayerID, _Portrait);
    end
end
API.SetPlayerPortrait = SetPlayerPortrait;

-- -------------------------------------------------------------------------- --

function Lib.Core.Player:GetPlayerName(_PlayerID)
    local PlayerName = Logic.GetPlayerName(_PlayerID);
    local name = CONST_PLAYER_NAMES[_PlayerID];
    if name ~= nil and name ~= "" then
        PlayerName = name;
    end

    local MapType = Framework.GetCurrentMapTypeAndCampaignName();
    local MapName = Framework.GetCurrentMapName();
    local MutliplayerMode = Framework.GetMultiplayerMapMode(MapName, MapType);

    if MutliplayerMode > 0 then
        return PlayerName;
    end
    if MapType == 1 or MapType == 3 then
        local PlayerNameTmp, _, _ = Framework.GetPlayerInfo(_PlayerID);
        if PlayerName ~= "" then
            return PlayerName;
        end
        return PlayerNameTmp;
    end
    return PlayerName;
end

function Lib.Core.Player:SetPlayerName(_PlayerID, _Name)
    CONST_PLAYER_NAMES[_PlayerID] = _Name;
    if IsLocalScript() then
        GUI_MissionStatistic.PlayerNames[_PlayerID] = _Name;
    end
end

function Lib.Core.Player:SetPlayerColor(_PlayerID, _Color, _Logo, _Pattern)
    g_ColorIndex["ExtraColor1"] = g_ColorIndex["ExtraColor1"] or 16;
    g_ColorIndex["ExtraColor2"] = g_ColorIndex["ExtraColor2"] or 17;

    local Col     = (type(_Color) == "string" and g_ColorIndex[_Color]) or _Color;
    local Logo    = _Logo or -1;
    local Pattern = _Pattern or -1;
    Logic.PlayerSetPlayerColor(_PlayerID, Col, Logo, Pattern);
    ExecuteLocal([[
        Display.UpdatePlayerColors()
        GUI.RebuildMinimapTerrain()
        GUI.RebuildMinimapTerritory()
    ]]);
end

function Lib.Core.Player:GetTerritoryName(_TerritoryID)
    local Name = Logic.GetTerritoryName(_TerritoryID);
    local MapType = Framework.GetCurrentMapTypeAndCampaignName();
    if MapType == 1 or MapType == 3 then
        return Name;
    end

    local MapName = Framework.GetCurrentMapName();
    local StringTable = "Map_" .. MapName;
    local TerritoryName = string.gsub(Name, " ","");
    TerritoryName = XGUIEng.GetStringTableText(StringTable .. "/Territory_" .. TerritoryName);
    if TerritoryName == "" then
        TerritoryName = Name .. "(key?)";
    end
    return TerritoryName;
end

function Lib.Core.Player:SetPlayerPortraitByPrimaryKnight(_PlayerID)
    local KnightID = Logic.GetKnightID(_PlayerID);
    local HeadModelName = "H_NPC_Generic_Trader";
    if KnightID ~= 0 then
        local KnightType = Logic.GetEntityType(KnightID);
        local KnightTypeName = Logic.GetEntityTypeName(KnightType);
        HeadModelName = "H" .. string.sub(KnightTypeName, 2, 8) .. "_" .. string.sub(KnightTypeName, 9);

        if not Models["Heads_" .. HeadModelName] then
            HeadModelName = "H_NPC_Generic_Trader";
        end
    end
    g_PlayerPortrait[_PlayerID] = HeadModelName;
end

function Lib.Core.Player:SetPlayerPortraitBySettler(_PlayerID, _Portrait)
    local PortraitMap = {
        ["U_KnightChivalry"]           = "H_Knight_Chivalry",
        ["U_KnightHealing"]            = "H_Knight_Healing",
        ["U_KnightPlunder"]            = "H_Knight_Plunder",
        ["U_KnightRedPrince"]          = "H_Knight_RedPrince",
        ["U_KnightSabatta"]            = "H_Knight_Sabatt",
        ["U_KnightSong"]               = "H_Knight_Song",
        ["U_KnightTrading"]            = "H_Knight_Trading",
        ["U_KnightWisdom"]             = "H_Knight_Wisdom",
        ["U_NPC_Amma_NE"]              = "H_NPC_Amma",
        ["U_NPC_Castellan_ME"]         = "H_NPC_Castellan_ME",
        ["U_NPC_Castellan_NA"]         = "H_NPC_Castellan_NA",
        ["U_NPC_Castellan_NE"]         = "H_NPC_Castellan_NE",
        ["U_NPC_Castellan_SE"]         = "H_NPC_Castellan_SE",
        ["U_MilitaryBandit_Ranged_ME"] = "H_NPC_Mercenary_ME",
        ["U_MilitaryBandit_Melee_NA"]  = "H_NPC_Mercenary_NA",
        ["U_MilitaryBandit_Melee_NE"]  = "H_NPC_Mercenary_NE",
        ["U_MilitaryBandit_Melee_SE"]  = "H_NPC_Mercenary_SE",
        ["U_NPC_Monk_ME"]              = "H_NPC_Monk_ME",
        ["U_NPC_Monk_NA"]              = "H_NPC_Monk_NA",
        ["U_NPC_Monk_NE"]              = "H_NPC_Monk_NE",
        ["U_NPC_Monk_SE"]              = "H_NPC_Monk_SE",
        ["U_NPC_Villager01_ME"]        = "H_NPC_Villager01_ME",
        ["U_NPC_Villager01_NA"]        = "H_NPC_Villager01_NA",
        ["U_NPC_Villager01_NE"]        = "H_NPC_Villager01_NE",
        ["U_NPC_Villager01_SE"]        = "H_NPC_Villager01_SE",
    }

    if g_GameExtraNo > 0 then
        PortraitMap["U_KnightPraphat"]           = "H_Knight_Praphat";
        PortraitMap["U_KnightSaraya"]            = "H_Knight_Saraya";
        PortraitMap["U_KnightKhana"]             = "H_Knight_Khana";
        PortraitMap["U_MilitaryBandit_Melee_AS"] = "H_NPC_Mercenary_AS";
        PortraitMap["U_NPC_Castellan_AS"]        = "H_NPC_Castellan_AS";
        PortraitMap["U_NPC_Villager_AS"]         = "H_NPC_Villager_AS";
        PortraitMap["U_NPC_Monk_AS"]             = "H_NPC_Monk_AS";
        PortraitMap["U_NPC_Monk_Khana"]          = "H_NPC_Monk_Khana";
    end

    local HeadModelName = "H_NPC_Generic_Trader";
    local EntityID = GetID(_Portrait);
    if EntityID ~= 0 then
        local EntityType = Logic.GetEntityType(EntityID);
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        HeadModelName = PortraitMap[EntityTypeName] or "H_NPC_Generic_Trader";
        if not HeadModelName then
            HeadModelName = "H_NPC_Generic_Trader";
        end
    end
    g_PlayerPortrait[_PlayerID] = HeadModelName;
end

function Lib.Core.Player:SetPlayerPortraitByModelName(_PlayerID, _Portrait)
    if not Models["Heads_" .. tostring(_Portrait)] then
        _Portrait = "H_NPC_Generic_Trader";
    end
    g_PlayerPortrait[_PlayerID] = _Portrait;
end

--- @diagnostic disable: param-type-mismatch
--- @diagnostic disable: return-type-mismatch

Lib.Core = Lib.Core or {};
Lib.Core.LuaExtension = {};

CONST_TO_LOWERCASE_LOOKUP = {
    ["À"] = "à", ["Á"] = "á", ["Â"] = "â", ["Ã"] = "ã", ["Ä"] = "ä", ["Å"] = "å", ["Æ"] = "æ", ["Ç"] = "ç",
    ["È"] = "è", ["É"] = "é", ["Ê"] = "ê", ["Ë"] = "ë", ["Ì"] = "ì", ["Í"] = "í", ["Î"] = "î", ["Ï"] = "ï",
    ["Ð"] = "ð", ["Ñ"] = "ñ", ["Ò"] = "ò", ["Ó"] = "ó", ["Ô"] = "ô", ["Õ"] = "õ", ["Ö"] = "ö", ["Ø"] = "ø",
    ["Ù"] = "ù", ["Ú"] = "ú", ["Û"] = "û", ["Ü"] = "ü", ["Ý"] = "ý", ["Þ"] = "þ", ["Ā"] = "ā", ["Ă"] = "ă",
    ["Ą"] = "ą", ["Ć"] = "ć", ["Ĉ"] = "ĉ", ["Ċ"] = "ċ", ["Č"] = "č", ["Ď"] = "ď", ["Đ"] = "đ", ["Ē"] = "ē",
    ["Ĕ"] = "ĕ", ["Ė"] = "ė", ["Ę"] = "ę", ["Ě"] = "ě", ["Ĝ"] = "ĝ", ["Ğ"] = "ğ", ["Ġ"] = "ġ", ["Ģ"] = "ģ",
    ["Ĥ"] = "ĥ", ["Ħ"] = "ħ", ["Ĩ"] = "ĩ", ["Ī"] = "ī", ["Ĭ"] = "ĭ", ["Į"] = "į", ["İ"] = "i", ["Ĳ"] = "ĳ",
    ["Ĵ"] = "ĵ", ["Ķ"] = "ķ", ["Ĺ"] = "ĺ", ["Ļ"] = "ļ", ["Ľ"] = "ľ", ["Ŀ"] = "ŀ", ["Ł"] = "ł", ["Ń"] = "ń",
    ["Ņ"] = "ņ", ["Ň"] = "ň", ["Ŋ"] = "ŋ", ["Ō"] = "ō", ["Ŏ"] = "ŏ", ["Ő"] = "ő", ["Œ"] = "œ", ["Ŕ"] = "ŕ",
    ["Ŗ"] = "ŗ", ["Ř"] = "ř", ["Ś"] = "ś", ["Ŝ"] = "ŝ", ["Ş"] = "ş", ["Š"] = "š", ["Ţ"] = "ţ", ["Ť"] = "ť",
    ["Ŧ"] = "ŧ", ["Ũ"] = "ũ", ["Ū"] = "ū", ["Ŭ"] = "ŭ", ["Ů"] = "ů", ["Ű"] = "ű", ["Ų"] = "ų", ["Ŵ"] = "ŵ",
    ["Ŷ"] = "ŷ", ["Ÿ"] = "ÿ", ["Ź"] = "ź", ["Ż"] = "ż", ["Ž"] = "ž", ["ß"] = "ß",
};

CONST_TO_UPPERCASE_LOOKUP = {
    ["à"] = "À", ["á"] = "Á", ["â"] = "Â", ["ã"] = "Ã", ["ä"] = "Ä", ["å"] = "Å", ["æ"] = "Æ", ["ç"] = "Ç",
    ["è"] = "È", ["é"] = "É", ["ê"] = "Ê", ["ë"] = "Ë", ["ì"] = "Ì", ["í"] = "Í", ["î"] = "Î", ["ï"] = "Ï",
    ["ð"] = "Ð", ["ñ"] = "Ñ", ["ò"] = "Ò", ["ó"] = "Ó", ["ô"] = "Ô", ["õ"] = "Õ", ["ö"] = "Ö", ["ø"] = "Ø",
    ["ù"] = "Ù", ["ú"] = "Ú", ["û"] = "Û", ["ü"] = "Ü", ["ý"] = "Ý", ["þ"] = "Þ", ["ā"] = "Ā", ["ă"] = "Ă",
    ["ą"] = "Ą", ["ć"] = "Ć", ["ĉ"] = "Ĉ", ["ċ"] = "Ċ", ["č"] = "Č", ["ď"] = "Ď", ["đ"] = "Đ", ["ē"] = "Ē",
    ["ĕ"] = "Ĕ", ["ė"] = "Ė", ["ę"] = "Ę", ["ě"] = "Ě", ["ĝ"] = "Ĝ", ["ğ"] = "Ğ", ["ġ"] = "Ġ", ["ģ"] = "Ģ",
    ["ĥ"] = "Ĥ", ["ħ"] = "Ħ", ["ĩ"] = "Ĩ", ["ī"] = "Ī", ["ĭ"] = "Ĭ", ["į"] = "Į", ["i"] = "İ", ["ĳ"] = "Ĳ",
    ["ĵ"] = "Ĵ", ["ķ"] = "Ķ", ["ĺ"] = "Ĺ", ["ļ"] = "Ļ", ["ľ"] = "Ľ", ["ŀ"] = "Ŀ", ["ł"] = "Ł", ["ń"] = "Ń",
    ["ņ"] = "Ņ", ["ň"] = "Ň", ["ŋ"] = "Ŋ", ["ō"] = "Ō", ["ŏ"] = "Ŏ", ["ő"] = "Ő", ["œ"] = "Œ", ["ŕ"] = "Ŕ",
    ["ŗ"] = "Ŗ", ["ř"] = "Ř", ["ś"] = "Ś", ["ŝ"] = "Ŝ", ["ş"] = "Ş", ["š"] = "Š", ["ţ"] = "Ţ", ["ť"] = "Ť",
    ["ŧ"] = "Ŧ", ["ũ"] = "Ũ", ["ū"] = "Ū", ["ŭ"] = "Ŭ", ["ů"] = "Ů", ["ű"] = "Ű", ["ų"] = "Ų", ["ŵ"] = "Ŵ",
    ["ŷ"] = "Ŷ", ["ÿ"] = "Ÿ", ["ź"] = "Ź", ["ż"] = "Ż", ["ž"] = "Ž", ["ß"] = "ß",
};

Lib.Require("comfort/CopyTable");
Lib.Require("comfort/SerializeTable");
Lib.Register("core/feature/Core_LuaExtension");

function Lib.Core.LuaExtension:Initialize()
    self:OverrideTable();
    self:OverrideString();
    self:OverrideMath();
end

function Lib.Core.LuaExtension:OnSaveGameLoaded()
    self:OverrideTable();
    self:OverrideString();
    self:OverrideMath();
end

function Lib.Core.LuaExtension:OnReportReceived(_ID, ...)
end

-- -------------------------------------------------------------------------- --

function Lib.Core.LuaExtension:OverrideTable()
    --- Compares two tables with a comperator function.
    --- @param t1 table First table
    --- @param t2 table Second table
    --- @param fx function Comparator function
    --- @return integer Result Comparison result
    table.compare = function(t1, t2, fx)
        assert(type(t1) == "table");
        assert(type(t2) == "table");
        fx = fx or function(t1, t2)
            return tostring(t1) < tostring(t2);
        end
        assert(type(fx) == "function");
        return fx(t1, t2);
    end

    --- Returns if two tables are equal.
    --- @param t1 table First table
    --- @param t2 table Second table
    --- @return boolean Equals Tables are equal
    table.equals = function(t1, t2)
        assert(type(t1) == "table");
        assert(type(t2) == "table");
        local fx = function(t1, t2)
            return table.tostring(t1) < table.tostring(t2);
        end
        assert(type(fx) == "function");
        return fx(t1, t2);
    end

    --- Returns if element is contained in table.
    --- @param t table Table to check
    --- @param e any Element to find
    --- @return boolean Found Element is contained
    table.contains = function (t, e)
        assert(type(t) == "table");
        for k, v in pairs(t) do
            if v == e then
                return true;
            end
        end
        return false;
    end

    --- Returns the size of the array.
    --- @param t table Table
    --- @return integer Length Length
    table.length = function(t)
        return #t;
    end

    --- Returns the amount of all elements.
    --- @param t table Table
    --- @return integer Size Element count
    table.size = function(t)
        local c = 0;
        for k, v in pairs(t) do
            -- Ignore n if set
            if k ~= "n" or (k == "n" and type(v) ~= "number") then
                c = c +1;
            end
        end
        return c;
    end

    --- Checks if table is empty
    --- @param t table Table
    --- @return boolean Empty Table is empty
    table.isEmpty = function(t)
        return table.size(t) == 0;
    end

    --- Clones a table or merges two tables.
    --- @param t1 table First table
    --- @param t2? table Second table
    --- @return table Clone Copied table
    table.copy = function (t1, t2)
        t2 = t2 or {};
        assert(type(t1) == "table");
        assert(type(t2) == "table");
        return CopyTable(t1, t2);
    end

    --- Returns a reversed array.
    --- @param t1 table Table
    --- @return table Invert Inverted table
    table.invert = function (t1)
        assert(type(t1) == "table");
        local t2 = {};
        for i= table.length(t1), 1, -1 do
            table.insert(t2, t1[i]);
        end
        return t2;
    end

    --- Adds an element in front.
    --- @param t table Table
    --- @param e any Element
    table.push = function (t, e)
        assert(type(t) == "table");
        table.insert(t, 1, e);
    end

    --- Removes the first element.
    --- @param t table Table
    --- @return any Element Element
    table.pop = function (t)
        assert(type(t) == "table");
        return table.remove(t, 1);
    end

    --- Returns the table as lua string.
    --- @param t table Table
    --- @return string Serialized Serialized table
    table.tostring = function(t)
        return SerializeTable(t);
    end
end

function Lib.Core.LuaExtension:OverrideString()
    --- Returns true if the partial string is found.
    --- @param self stringlib String to search
    --- @param s string       Partial string
    --- @return boolean Found Partial string found
    string.contains = function (self, s)
        return self:find(s) ~= nil;
    end

    --- Returns true if the partial string is found.
    --- @param self stringlib String to search
    --- @param s string       Partial string
    --- @return integer Begin Start of part
    --- @return integer End   End of part
    string.indexOf = function (self, s)
        return self:find(s);
    end

    --- Separates a string into multiple strings.
    --- @param self stringlib String to search
    --- @param _sep string    Separator string
    --- @return table List    List of partial strings
    string.slice = function(self, _sep)
        _sep = _sep or "%s";
        local t = {};
        if self then
            for str in self:gmatch("([^".._sep.."]+)") do
                table.insert(t, str);
            end
        end
        return t;
    end

    ---Concatinates a list of values to a single string.
    ---@param self stringlib String to search
    ---@param ... any        Values
    ---@return string String Resulting string
    string.join = function(self, ...)
        local s = "";
        local parts = {self, ...};
        for i= 1, #parts do
            if type(parts[i]) == "table" then
                s = s .. string.join(unpack(parts[i]));
            else
                s = s .. tostring(parts[i]);
            end
        end
        return s;
    end

    --- Replaces a substring with another once.
    --- @param self stringlib String to search
    --- @param p string       Pattern
    --- @param r string       Replacement
    --- @return string String New string
    string.replace = function(self, p, r)
        local s, c = self:gsub(p, r, 1);
        return s;
    end

    --- Replaces all occurances of a substring with another.
    --- @param self stringlib String to search
    --- @param p string       Pattern
    --- @param r string       Replacement
    --- @return string String New string
    string.replaceAll = function(self, p, r)
        local s, c = self:gsub(p, r);
        return s;
    end

    --- Converts a string to lower case and also resolves most umlauts.
    --- @param s string Input
    --- @return string String Converted string
    string.toLowerCase = function(s)
        local ms = string.gsub(s, ".", CONST_TO_LOWERCASE_LOOKUP);
        return ms;
    end

    --- Converts a string to upper case and also resolves most umlauts.
    --- @param s string Input
    --- @return string String Converted string
    function string.toUpperCase(s)
        local ms = string.gsub(s, ".", CONST_TO_UPPERCASE_LOOKUP);
        return ms;
    end
end

function Lib.Core.LuaExtension:OverrideMath()
    math.lerp = function(s, c, e)
        local f = (c - s) / e;
        return (f > 1 and 1) or f;
    end

    math.cerp = function(s, c, e)
        local f = (c - s) / e;
        local t = f * f * (3 - 2 * f);
        return (t > 1 and 1) or t;
    end

    math.qmod = function(a, b)
        return a - math.floor(a/b)*b;
    end

    math.factorial = function(n)
        return (n == 0 and 1) or n * math.factorial(n - 1);
    end
end


Lib.Core = Lib.Core or {};
Lib.Core.Report = {
    ScriptEventRegister = {},
    ScriptEventListener = {},

    ScriptCommandRegister = {},
    ScriptCommandSequence = 0,
};

Report = Report or {};
Command = Command or {};

Lib.Require("comfort/IsLocalScript");
Lib.Require("comfort/IsMultiplayer");
Lib.Require("comfort/IsHistoryEdition");
Lib.Require("core/feature/Core_LuaExtension");
Lib.Register("core/feature/Core_Report");

-- -------------------------------------------------------------------------- --

function Lib.Core.Report:Initialize()
    if not IsLocalScript() then
        self:OverrideSoldierPayment();

        Lib.Core.Report:CreateScriptCommand("Cmd_SendReportToGlobal", function(_ID, ...)
            SendReport(_ID, ...);
        end);
    end
end

function Lib.Core.Report:OnSaveGameLoaded()
end

function Lib.Core.Report:OnReportReceived(_ID, ...)
end

function Lib.Core.Report:OverrideSoldierPayment()
    GameCallback_SetSoldierPaymentLevel_Orig_Libertica = GameCallback_SetSoldierPaymentLevel;
    GameCallback_SetSoldierPaymentLevel = function(_PlayerID, _Level)
        if _Level <= 2 then
            return GameCallback_SetSoldierPaymentLevel_Orig_Libertica(_PlayerID, _Level);
        end
        Lib.Core.Event:ProcessScriptCommand(_PlayerID, _Level);
    end
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Report:ProcessScriptCommand(_PlayerID, _ID)
    assert(_ID and self.ScriptCommandRegister[_ID], "Commands is invalid.");
    local PlayerName = Logic.GetPlayerName(_PlayerID +4);
    local Parameters = self:DecodeScriptCommandParameters(PlayerName);
    self.ScriptCommandRegister[_ID][2](unpack(Parameters));
end

function Lib.Core.Report:CreateScriptCommand(_Name, _Function)
    assert(not IsLocalScript(), "Commands must be created in global script.");
    self.ScriptCommandSequence = self.ScriptCommandSequence +1;
    local ID = self.ScriptCommandSequence;
    local Name = _Name;
    if string.find(_Name, "^Cmd_") then
        Name = string.sub(_Name, 5);
    end
    self.ScriptCommandRegister[ID] = {Name, _Function};
    ExecuteLocal([[
        local ID, Name = %d, "%s"
        Lib.Core.Report.ScriptCommandRegister[ID] = Name
        Command[Name] = ID
    ]], ID, Name);
end

function Lib.Core.Report:DecodeScriptCommandParameters(_Query)
    local Parameters = {};
    for k, v in pairs(string.slice(_Query, "#")) do
        local Value = v;
        Value = Value:replaceAll("<<<HT>>>", '#');
        Value = Value:replaceAll("<<<QT>>>", '"');
        Value = Value:replaceAll("<<<ES>>>", '');
        if Value == nil then
            Value = nil;
        elseif Value == "true" or Value == "false" then
            Value = Value == "true";
        elseif string.indexOf(Value, "{") == 1 then
            ---@diagnostic disable-next-line: param-type-mismatch
            local ValueTable = string.slice(string.sub(Value, 2, string.len(Value)-1), ",");
            Value = {};
            for i= 1, #ValueTable do
                Value[i] = (tonumber(ValueTable[i]) ~= nil and tonumber(ValueTable[i]) or ValueTable);
            end
        elseif tonumber(Value) ~= nil then
            Value = tonumber(Value);
        end
        table.insert(Parameters, Value);
    end
    return Parameters;
end

function Lib.Core.Report:SendScriptCommand(_ID, ...)
    assert(IsLocalScript(), "Commands must be send in local script.");
    assert(_ID and self.ScriptCommandRegister[_ID], "Command is invalid.");
    local PlayerID = GUI.GetPlayerID();
    local NamePlayerID = PlayerID +4;
    local PlayerName = Logic.GetPlayerName(NamePlayerID);
    local Parameters = self:EncodeScriptCommandParameters(...);
    GUI.SetPlayerName(NamePlayerID, Parameters);
    if IsHistoryEdition() and IsMultiplayer() then
        GUI.SetSoldierPaymentLevel(_ID);
    else
        ExecuteGlobal([[Lib.Core.Report:ProcessScriptCommand(%d, %d)]], PlayerID, _ID);
    end
    GUI.SetPlayerName(NamePlayerID, PlayerName);
    GUI.SetSoldierPaymentLevel(PlayerSoldierPaymentLevel[PlayerID]);
end

function Lib.Core.Report:EncodeScriptCommandParameters(...)
    local Query = "";
    for i= 1, #arg do
        local Parameter = arg[i];
        if type(Parameter) == "string" then
            Parameter = Parameter:gsub('#', "<<<HT>>>");
            Parameter = Parameter:gsub('"', "<<<QT>>>");
            if Parameter:len() == 0 then
                Parameter = "<<<ES>>>";
            end
        elseif type(Parameter) == "table" then
            Parameter = "{" ..table.concat(Parameter, ",") .."}";
        end
        if string.len(Query) > 0 then
            Query = Query .. "#";
        end
        Query = Query .. tostring(Parameter);
    end
    return Query;
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Report:CreateReport(_Name)
    assert(type(_Name) == "string", "Report name must be a string.");
    for i= 1, #self.ScriptEventRegister, 1 do
        if self.ScriptEventRegister[i] == _Name then
            assert(false, "Report already exists");
            return 0;
        end
    end
    local ID = #self.ScriptEventRegister +1;
    self.ScriptEventRegister[ID] = _Name;
    self.ScriptEventListener[ID] = {SequenceID = 0};
    return ID;
end

function Lib.Core.Report:SendReport(_ID, ...)
    assert(self.ScriptEventRegister[_ID] ~= nil, "Report type does not exist.");
    ---@diagnostic disable-next-line: undefined-global
    if GameCallback_Lib_OnEventReceived then
        GameCallback_Lib_OnEventReceived(_ID, ...);
    end
    if self.ScriptEventListener[_ID] then
        for k, v in pairs(self.ScriptEventListener[_ID]) do
            if tonumber(k) then
                v(...);
            end
        end
    end
end

function Lib.Core.Report:CreateReportReceiver(_EventID, _Function)
    assert(type(_Function) == "function", "Listener must be a function.");
    assert(self.ScriptEventRegister[_EventID] ~= nil, "Event does not exist.");
    local Data = self.ScriptEventListener[_EventID];
    self.ScriptEventListener[_EventID].SequenceID = Data.SequenceID +1;
    self.ScriptEventListener[_EventID][Data.SequenceID] = _Function;
    return Data.IDSequence;
end

function Lib.Core.Report:RemoveReportReceiver(_EventID, _ID)
    assert(self.ScriptEventRegister[_EventID] ~= nil, "Event does not exist.");
    self.ScriptEventListener[_EventID][_ID] = nil;
end

-- -------------------------------------------------------------------------- --

function CreateReport(_Name)
    return Lib.Core.Report:CreateReport(_Name);
end
API.CreateScriptEvent = CreateReport;

function SendReport(_ID, ...)
    Lib.Core.Report:SendReport(_ID, ...);
end
API.SendScriptEvent = SendReport;

function SendReportToGlobal(_ID, ...)
    assert(IsLocalScript(), "Was called from global script.");
    Lib.Core.Report:SendScriptCommand(Command.SendReportToGlobal, _ID, ...);
end
API.SendScriptEventToGlobal = SendReportToGlobal;

function SendReportToLocal(_ID, ...)
    assert(not IsLocalScript(), "Was called from local script.");
    local arg = {...};
    if #arg > 0 then
        local Parameter = "";
        for i= 1, #arg do
            if i > 1 then
                Parameter = Parameter.. ",";
            end
            if type(arg[i]) == "string" then
                Parameter = Parameter.. "\"" ..arg[i].. "\"";
            elseif type(arg[i]) == "table" then
                Parameter = Parameter.. table.tostring(arg[i]);
            else
                Parameter = Parameter.. tostring(arg[i]);
            end
        end
        ExecuteLocal([[SendReport(%d, %s)]], _ID, Parameter);
    else
        ExecuteLocal([[SendReport(%d)]], _ID);
    end
end
API.SendScriptEventToLocal = SendReportToLocal;

function CreateReportReceiver(_EventID, _Function)
    return Lib.Core.Report:CreateReportReceiver(_EventID, _Function);
end
API.CreateScriptEventReceiver = CreateReportReceiver;

function RemoveReportReceiver(_EventID, _ID)
    Lib.Core.Report:RemoveReportReceiver(_EventID, _ID);
end
API.RemoveScriptEventReceiver = RemoveReportReceiver;

Lib.Core = Lib.Core or {};
Lib.Core.Quest = {
    QuestCounter = 0,
    Text = {
        ActivateBuff = {
            Pattern = {
                de = "BONUS AKTIVIEREN{cr}{cr}%s",
                en = "ACTIVATE BUFF{cr}{cr}%s",
                fr = "ACTIVER BONUS{cr}{cr}%s",
            },
            BuffsVanilla = {
                ["Buff_Spice"]                  = {de = "Salz", en = "Salt", fr = "Sel"},
                ["Buff_Colour"]                 = {de = "Farben", en = "Color", fr = "Couleurs"},
                ["Buff_Entertainers"]           = {de = "Entertainer", en = "Entertainer", fr = "Artistes"},
                ["Buff_FoodDiversity"]          = {de = "Vielfältige Nahrung", en = "Food diversity", fr = "Diversité alimentaire"},
                ["Buff_ClothesDiversity"]       = {de = "Vielfältige Kleidung", en = "Clothes diversity", fr = "Diversité vestimentaire"},
                ["Buff_HygieneDiversity"]       = {de = "Vielfältige Reinigung", en = "Hygiene diversity", fr = "Diversité hygiénique"},
                ["Buff_EntertainmentDiversity"] = {de = "Vielfältige Unterhaltung", en = "Entertainment diversity", fr = "Diversité des dievertissements"},
                ["Buff_Sermon"]                 = {de = "Predigt", en = "Sermon", fr = "Sermon"},
                ["Buff_Festival"]               = {de = "Fest", en = "Festival", fr = "Festival"},
                ["Buff_ExtraPayment"]           = {de = "Sonderzahlung", en = "Extra payment", fr = "Paiement supplémentaire"},
                ["Buff_HighTaxes"]              = {de = "Hohe Steuern", en = "High taxes", fr = "Hautes taxes"},
                ["Buff_NoPayment"]              = {de = "Kein Sold", en = "No payment", fr = "Aucun paiement"},
                ["Buff_NoTaxes"]                = {de = "Keine Steuern", en = "No taxes", fr = "Aucune taxes"},
            },
            BuffsEx1 = {
                ["Buff_Gems"]              = {de = "Edelsteine", en = "Gems", fr = "Gemmes"},
                ["Buff_MusicalInstrument"] = {de = "Musikinstrumente", en = "Musical instruments", fr = "Instruments musicaux"},
                ["Buff_Olibanum"]          = {de = "Weihrauch", en = "Olibanum", fr = "Encens"},
            }
        },
        SoldierCount = {
            Pattern = {
                de = "SOLDATENANZAHL {cr}Partei: %s{cr}{cr}%s %d",
                en = "SOLDIER COUNT {cr}Faction: %s{cr}{cr}%s %d",
                fr = "NOMBRE DE SOLDATS {cr}Faction: %s{cr}{cr}%s %d",
            },
            Relation = {
                ["true"]  = {de = "Weniger als ", en = "Less than ", fr = "Moins de"},
                ["false"] = {de = "Mindestens ", en = "At least ", fr = "Au moins"},
            }
        },
        Festivals = {
            Pattern = {
                de = "FESTE FEIERN {cr}{cr}Partei: %s{cr}{cr}Anzahl: %d",
                en = "HOLD PARTIES {cr}{cr}Faction: %s{cr}{cr}Amount: %d",
                fr = "FESTIVITÉS {cr}{cr}Faction: %s{cr}{cr}Nombre : %d",
            },
        }
    }
}

CONST_EFFECT_NAME_TO_ID = {};
CONST_INITIALIZED_OBJECTS = {};
CONST_REFILL_AMOUNT = {};

Lib.Require("comfort/IsLocalScript");
Lib.Require("comfort/ToBoolean");
Lib.Require("comfort/GetHealth");
Lib.Require("comfort/CopyTable");
Lib.Require("comfort/GetQuestID");
Lib.Require("comfort/IsValidQuest");
Lib.Require("comfort/SendCart");
Lib.Require("core/feature/Core_Report");
Lib.Register("core/feature/Core_Quest");

-- -------------------------------------------------------------------------- --

function SaveCustomVariable(_Name, _Value)
    Lib.Core.Quest:SetCustomVariable(_Name, _Value);
end

function ObtainCustomVariable(_Name, _Default)
    local Value = Lib.CustomVariable[_Name];
    if not Value and _Default then
        Value = _Default;
    end
    return Value;
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Quest:Initialize()
    Report.CustomValueChanged = CreateReport("Event_CustomValueChanged");

    Report.QuestFailure = CreateReport("Event_QuestFailure");
    Report.QuestInterrupt = CreateReport("Event_QuestInterrupt");
    Report.QuestReset = CreateReport("Event_QuestReset");
    Report.QuestSuccess = CreateReport("Event_QuestSuccess");
    Report.QuestTrigger = CreateReport("Event_QuestTrigger");

    if not IsLocalScript() then
        self:OverrideQuestSystemGlobal();
        self:OverrideQuestMarkers();
        self:OverwriteGeologistRefill();
    end
    if IsLocalScript() then
        self:OverrideDisplayQuestObjective();
    end
end

function Lib.Core.Quest:OnSaveGameLoaded()
end

function Lib.Core.Quest:OnReportReceived(_ID, ...)
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Quest:OverrideQuestMarkers()
    QuestTemplate.RemoveQuestMarkers = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[4] then
                    DestroyQuestMarker(self.Objectives[i].Data[2]);
                end
            end
        end
    end
    QuestTemplate.ShowQuestMarkers = function(self)
        for i=1, self.Objectives[0] do
            if self.Objectives[i].Type == Objective.Distance then
                if self.Objectives[i].Data[4] then
                    ShowQuestMarker(self.Objectives[i].Data[2]);
                end
            end
        end
    end

    function ShowQuestMarker(_Entity)
        local eID = GetID(_Entity);
        local x,y = Logic.GetEntityPosition(eID);
        local Marker = EGL_Effects.E_Questmarker_low;
        if Logic.IsBuilding(eID) == 1 then
            Marker = EGL_Effects.E_Questmarker;
        end
        DestroyQuestMarker(_Entity);
        Questmarkers[eID] = Logic.CreateEffect(Marker, x, y, 0);
    end
    function DestroyQuestMarker(_Entity)
        local eID = GetID(_Entity);
        if Questmarkers[eID] ~= nil then
            Logic.DestroyEffect(Questmarkers[eID]);
            Questmarkers[eID] = nil;
        end
    end
end

function Lib.Core.Quest:OverrideDisplayQuestObjective()
    GUI_Interaction.DisplayQuestObjective_Orig_Lib_Core = GUI_Interaction.DisplayQuestObjective
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        if QuestType == Objective.Distance then
            if Quest.Objectives[1].Data[1] == -65566 then
                Quest.Objectives[1].Data[1] = Logic.GetKnightID(Quest.ReceivingPlayer);
            end
        end
        GUI_Interaction.DisplayQuestObjective_Orig_Lib_Core(_QuestIndex, _MessageKey);
    end
end

function Lib.Core.Quest:IsQuestPositionReached(_Quest, _Objective)
    local IDdata2 = GetID(_Objective.Data[1]);
    if IDdata2 == -65566 then
        _Objective.Data[1] = Logic.GetKnightID(_Quest.ReceivingPlayer);
        IDdata2 = _Objective.Data[1];
    end
    local IDdata3 = GetID(_Objective.Data[2]);
    _Objective.Data[3] = _Objective.Data[3] or 2500;
    if not (Logic.IsEntityDestroyed(IDdata2) or Logic.IsEntityDestroyed(IDdata3)) then
        if Logic.GetDistanceBetweenEntities(IDdata2,IDdata3) <= _Objective.Data[3] then
            DestroyQuestMarker(IDdata3);
            return true;
        end
    else
        DestroyQuestMarker(IDdata3);
        return false;
    end
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Quest:OverwriteGeologistRefill()
    if Framework.GetGameExtraNo() >= 1 then
        GameCallback_OnGeologistRefill_Orig_Lib_Core = GameCallback_OnGeologistRefill;
        GameCallback_OnGeologistRefill = function(_PlayerID, _TargetID, _GeologistID)
            GameCallback_OnGeologistRefill_Orig_Lib_Core(_PlayerID, _TargetID, _GeologistID);
            if CONST_REFILL_AMOUNT[_TargetID] then
                local RefillAmount = CONST_REFILL_AMOUNT[_TargetID];
                local RefillRandom = RefillAmount + math.random(1, math.floor((RefillAmount * 0.2) + 0.5));
                Logic.SetResourceDoodadGoodAmount(_TargetID, RefillRandom);
                if RefillRandom > 0 then
                    if Logic.GetResourceDoodadGoodType(_TargetID) == Goods.G_Iron then
                        Logic.SetModel(_TargetID, Models.Doodads_D_SE_ResourceIron);
                    else
                        Logic.SetModel(_TargetID, Models.R_ResorceStone_Scaffold);
                    end
                end
            end
        end
    end
end

function Lib.Core.Quest:TriggerEntityKilledCallbacks(_Entity, _Attacker)
    local DefenderID = GetID(_Entity);
    local AttackerID = GetID(_Attacker or 0);
    if AttackerID == 0 or DefenderID == 0 or Logic.GetEntityHealth(DefenderID) > 0 then
        return;
    end
    local x, y, z     = Logic.EntityGetPos(DefenderID);
    local DefPlayerID = Logic.EntityGetPlayer(DefenderID);
    local DefType     = Logic.GetEntityType(DefenderID);
    local AttPlayerID = Logic.EntityGetPlayer(AttackerID);
    local AttType     = Logic.GetEntityType(AttackerID);

    GameCallback_EntityKilled(DefenderID, DefPlayerID, AttackerID, AttPlayerID, DefType, AttType);
    Logic.ExecuteInLuaLocalState(string.format(
        "GameCallback_Feedback_EntityKilled(%d, %d, %d, %d,%d, %d, %f, %f)",
        DefenderID, DefPlayerID, AttackerID, AttPlayerID, DefType, AttType, x, y
    ));
end

function Lib.Core.Quest:GetCustomVariable(_Name)
    return Lib.CustomVariable[_Name];
end

function Lib.Core.Quest:SetCustomVariable(_Name, _Value)
    self:UpdateCustomVariable(_Name, _Value);
    local Value = tostring(_Value);
    if type(_Value) ~= "number" then
        Value = [["]] ..Value.. [["]];
    end
    if not GUI then
        ExecuteLocal([[Lib.Core.Quest:UpdateCustomVariable("%s", %s)]], _Name, Value);
    end
end

function Lib.Core.Quest:UpdateCustomVariable(_Name, _Value)
    if Lib.CustomVariable[_Name] then
        local Old = Lib.CustomVariable[_Name];
        Lib.CustomVariable[_Name] = _Value;
        SendReport(Report.CustomValueChanged, _Name, Old, _Value);
    else
        Lib.CustomVariable[_Name] = _Value;
        SendReport(Report.CustomValueChanged, _Name, nil, _Value);
    end
end

-- -------------------------------------------------------------------------- --

function InteractiveObjectActivate(_ScriptName, _State)
    _State = _State or 0;
    if GUI or not IsExisting(_ScriptName) then
        return;
    end
    for i= 1, 8 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, _State);
    end
end
API.InteractiveObjectActivate = InteractiveObjectActivate;

function InteractiveObjectDeactivate(_ScriptName)
    if GUI or not IsExisting(_ScriptName) then
        return;
    end
    for i= 1, 8 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, 2);
    end
end
API.InteractiveObjectDeactivate = InteractiveObjectDeactivate;

-- -------------------------------------------------------------------------- --

function Lib.Core.Quest:OverrideQuestSystemGlobal()
    QuestTemplate.Trigger_Orig_QSB_Core = QuestTemplate.Trigger
    QuestTemplate.Trigger = function(this)
        QuestTemplate.Trigger_Orig_QSB_Core(this);
        local QuestID = GetQuestID(this.Identifier);
        for i=1,this.Objectives[0] do
            if this.Objectives[i].Type == Objective.Custom2 and this.Objectives[i].Data[1].SetDescriptionOverwrite then
                local Desc = this.Objectives[i].Data[1]:SetDescriptionOverwrite(this);
                Lib.Core.Quest:ChangeCustomQuestCaptionText(Desc, this);
                break;
            end
        end
        SendReport(Report.QuestTrigger, QuestID);
        SendReportToLocal(Report.QuestTrigger, QuestID);
    end

    QuestTemplate.Interrupt_Orig_QSB_Core = QuestTemplate.Interrupt;
    QuestTemplate.Interrupt = function(this)
        this.State = QuestState.Over;
        this.Result = QuestResult.Interrupted;
        this:RemoveQuestMarkers();
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..this.Index..")");

        local QuestID = GetQuestID(this.Identifier);
        for i=1, this.Objectives[0] do
            if this.Objectives[i].Type == Objective.Custom2 and this.Objectives[i].Data[1].Interrupt then
                this.Objectives[i].Data[1]:Interrupt(this, i);
            end
        end
        for i=1, this.Triggers[0] do
            if this.Triggers[i].Type == Triggers.Custom2 and this.Triggers[i].Data[1].Interrupt then
                this.Triggers[i].Data[1]:Interrupt(this, i);
            end
        end
        SendReport(Report.QuestInterrupt, QuestID);
        SendReportToLocal(Report.QuestInterrupt, QuestID);
    end

    QuestTemplate.Fail_Orig_QSB_Core = QuestTemplate.Fail;
    QuestTemplate.Fail = function(this)
        this.State = QuestState.Over;
        this.Result = QuestResult.Failure;
        this:RemoveQuestMarkers();
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..this.Index..")");

        local QuestID = GetQuestID(this.Identifier);
        SendReport(Report.QuestFailure, QuestID);
        SendReportToLocal(Report.QuestFailure, QuestID);
    end

    QuestTemplate.Success = function(this)
        this.State = QuestState.Over;
        this.Result = QuestResult.Success;
        this:RemoveQuestMarkers();
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..this.Index..")");

        local QuestID = GetQuestID(this.Identifier);
        SendReport(Report.QuestSuccess, QuestID);
        SendReportToLocal(Report.QuestSuccess, QuestID);
    end
end

function Lib.Core.Quest:ChangeCustomQuestCaptionText(_Text, _Quest)
    if _Quest and _Quest.Visible then
        _Quest.QuestDescription = _Text;
        ExecuteLocal([[
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/BGDeco",0)
            local identifier = "%s"
            for i=1, Quests[0] do
                if Quests[i].Identifier == identifier then
                    local text = Quests[i].QuestDescription
                    XGUIEng.SetText("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives/Custom/Text", "%s")
                    break
                end
            end
        ]], _Quest.Identifier, _Text);
    end
end

-- -------------------------------------------------------------------------- --

function SetResourceAmount(_Entity, _StartAmount, _RefillAmount)
    if GUI or not IsExisting(_Entity) then
        return;
    end
    assert(type(_StartAmount) == "number");
    assert(type(_RefillAmount) == "number");

    local EntityID = GetID(_Entity);
    if IsExisting(EntityID) and Logic.GetResourceDoodadGoodType(EntityID) ~= 0 then
        if Logic.GetResourceDoodadGoodAmount(EntityID) == 0 then
            EntityID = ReplaceEntity(EntityID, Logic.GetEntityType(EntityID));
        end
        Logic.SetResourceDoodadGoodAmount(EntityID, _StartAmount);
        CONST_REFILL_AMOUNT[EntityID] = _RefillAmount;
    end
end

function SetCustomBehaviorText(_QuestName, _Text)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    assert(Quest ~= nil, "Quest '" .._QuestName.. "' not found!");
    Lib.Core.Quest:ChangeCustomQuestCaptionText(_Text, Quest);
end
API.SetCustomBehaviorText = SetCustomBehaviorText;

function RestartQuest(_QuestName, _NoMessage)
    -- All changes on default behavior must be considered in this function.
    -- When a default behavior is changed in a module this function must be
    -- changed as well.

    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            Logic.DEBUG_AddNote("restart quest " .._QuestName);
        end

        if Quest.Objectives then
            local questObjectives = Quest.Objectives;
            for i = 1, questObjectives[0] do
                local objective = questObjectives[i];
                objective.Completed = nil
                local objectiveType = objective.Type;

                if objectiveType == Objective.Deliver then
                    local data = objective.Data;
                    data[3] = nil;
                    data[4] = nil;
                    data[5] = nil;
                    data[9] = nil;

                elseif g_GameExtraNo and g_GameExtraNo >= 1 and objectiveType == Objective.Refill then
                    objective.Data[2] = nil;

                elseif objectiveType == Objective.Protect or objectiveType == Objective.Object then
                    local data = objective.Data;
                    for j=1, data[0], 1 do
                        data[-j] = nil;
                    end

                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] == 2 and objective.DestroyTypeAmount then
                    objective.Data[3] = objective.DestroyTypeAmount;
                elseif objectiveType == Objective.DestroyEntities and objective.Data[1] == 3 then
                    objective.Data[4] = nil;
                    objective.Data[5] = nil;

                elseif objectiveType == Objective.Distance then
                    if objective.Data[1] == -65565 then
                        objective.Data[4].NpcInstance = nil;
                    end

                elseif objectiveType == Objective.Custom2 and objective.Data[1].Reset then
                    objective.Data[1]:Reset(Quest, i);
                end
            end
        end

        local function resetCustom(_type, _customType)
            local Quest = Quest;
            local behaviors = Quest[_type];
            if behaviors then
                for i = 1, behaviors[0] do
                    local behavior = behaviors[i];
                    if behavior.Type == _customType then
                        local behaviorDef = behavior.Data[1];
                        if behaviorDef and behaviorDef.Reset then
                            behaviorDef:Reset(Quest, i);
                        end
                    end
                end
            end
        end

        resetCustom("Triggers", Triggers.Custom2);
        resetCustom("Rewards", Reward.Custom);
        resetCustom("Reprisals", Reprisal.Custom);

        Quest.Result = nil;
        local OldQuestState = Quest.State;
        Quest.State = QuestState.NotTriggered;
        ExecuteLocal("LocalScriptCallback_OnQuestStatusChanged(%d)", Quest.Index);
        if OldQuestState == QuestState.Over then
            Quest.Job = Trigger.RequestTrigger(Events.LOGIC_EVENT_EVERY_SECOND, "", "Quest_Loop", 1, 0, {Quest.QueueID});
        end

        SendReport(Report.QuestReset, QuestID);
        SendReportToLocal(Report.QuestReset, QuestID);
    end
    return QuestID, Quest;
end
API.RestartQuest = RestartQuest;

function FailQuest(_QuestName, _NoMessage)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            Logic.DEBUG_AddNote("fail quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Fail();
    end
end
API.FailQuest = FailQuest;

function StartQuest(_QuestName, _NoMessage)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            Logic.DEBUG_AddNote("start quest " .._QuestName);
        end
        Quest:SetMsgKeyOverride();
        Quest:SetIconOverride();
        Quest:Trigger();
    end
end
API.StartQuest = StartQuest;

function StopQuest(_QuestName, _NoMessage)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            Logic.DEBUG_AddNote("interrupt quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Interrupt(-1);
    end
end
API.StopQuest = StopQuest;

function WinQuest(_QuestName, _NoMessage)
    local QuestID = GetQuestID(_QuestName);
    local Quest = Quests[QuestID];
    if Quest then
        if not _NoMessage then
            Logic.DEBUG_AddNote("win quest " .._QuestName);
        end
        Quest:RemoveQuestMarkers();
        Quest:Success();
    end
end
API.WinQuest = WinQuest;

Lib.Core = Lib.Core or {};
Lib.Core.Job = {
    EventJobMappingID = 0;
    EventJobMapping = {},
    EventJobs = {},

    SecondsSinceGameStart = 0;
    LastTimeStamp = 0;
}

Lib.Register("core/feature/Core_Job");

-- -------------------------------------------------------------------------- --

function Lib.Core.Job:Initialize()
    self:StartJobs();
end

function Lib.Core.Job:OnSaveGameLoaded()
end

function Lib.Core.Job:OnReportReceived(_ID, ...)
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Job:StartJobs()
    -- Update Real time variable
    self:CreateEventJob(
        Events.LOGIC_EVENT_EVERY_TURN,
        function()
            Lib.Core.Job:RealtimeController();
        end
    )
end

function Lib.Core.Job:CreateEventJob(_Type, _Function, ...)
    self.EventJobMappingID = self.EventJobMappingID +1;
    local ID = Trigger.RequestTrigger(
        _Type,
        "",
        "LiberticaCore_Job_EventJobExecutor",
        1,
        {},
        {self.EventJobMappingID}
    );
    self.EventJobs[ID] = {ID, true, _Function, arg};
    self.EventJobMapping[self.EventJobMappingID] = ID;
    return ID;
end

function Lib.Core.Job:EventJobExecutor(_MappingID)
    local ID = self.EventJobMapping[_MappingID];
    if ID and self.EventJobs[ID] and self.EventJobs[ID][2] then
        local Parameter = self.EventJobs[ID][4];
        if self.EventJobs[ID][3](unpack(Parameter)) then
            self.EventJobs[ID][2] = false;
        end
    end
end

function Lib.Core.Job:RealtimeController()
    if not self.LastTimeStamp then
        self.LastTimeStamp = math.floor(Framework.TimeGetTime());
    end
    local CurrentTimeStamp = math.floor(Framework.TimeGetTime());

    if self.LastTimeStamp ~= CurrentTimeStamp then
        self.LastTimeStamp = CurrentTimeStamp;
        self.SecondsSinceGameStart = self.SecondsSinceGameStart +1;
    end
end

-- -------------------------------------------------------------------------- --

function LiberticaCore_Job_EventJobExecutor(_MappingID)
    Lib.Core.Job:EventJobExecutor(_MappingID);
end

-- -------------------------------------------------------------------------- --

function RequestJobByEventType(_EventType, _Function, ...)
    local Function = _G[_Function] or _Function;
    assert(type(Function) == "function", "Function does not exist!");
    return Lib.Core.Job:CreateEventJob(_EventType, _Function, ...);
end
API.StartJobByEventType = RequestJobByEventType;

function RequestJob(_Function, ...)
    local Function = _G[_Function] or _Function;
    assert(type(Function) == "function", "Function does not exist!");
    return RequestJobByEventType(Events.LOGIC_EVENT_EVERY_SECOND, Function, ...);
end
API.StartJob = RequestJob;
StartSimpleJob = RequestJob;
StartSimpleJobEx = RequestJob;

function RequestHiResJob(_Function, ...)
    local Function = _G[_Function] or _Function;
    assert(type(Function) == "function", "Function does not exist!");
    return RequestJobByEventType(Events.LOGIC_EVENT_EVERY_TURN, Function, ...);
end
API.StartHiResJob = RequestHiResJob;
StartSimpleHiResJob = RequestHiResJob;
StartSimpleHiResJobEx = RequestHiResJob;

function RequestDelay(_Waittime, _Function, ...)
    local Function = _G[_Function] or _Function;
    assert(type(Function) == "function", "Function does not exist!");
    return RequestJob(
        function(_StartTime, _Delay, _Callback, _Arguments)
            if _StartTime + _Delay <= Logic.GetTime() then
                _Callback(unpack(_Arguments or {}));
                return true;
            end
        end,
        Logic.GetTime(),
        _Waittime,
        _Function,
        {...}
    );
end
API.StartDelay = RequestDelay;

function RequestHiResDelay(_Waittime, _Function, ...)
    local Function = _G[_Function] or _Function;
    assert(type(Function) == "function", "Function does not exist!");
    return RequestHiResJob(
        function(_StartTime, _Delay, _Callback, _Arguments)
            if _StartTime + _Delay <= Logic.GetCurrentTurn() then
                _Callback(unpack(_Arguments or {}));
                return true;
            end
        end,
        Logic.GetTime(),
        _Waittime,
        _Function,
        {...}
    );
end
API.StartHiResDelay = RequestHiResDelay;

function RequestRealTimeDelay(_Waittime, _Function, ...)
    local Function = _G[_Function] or _Function;
    assert(type(Function) == "function", "Function does not exist!");
    return RequestHiResJob(
        function(_StartTime, _Delay, _Callback, _Arguments)
            if (Lib.Core.Job.SecondsSinceGameStart >= _StartTime + _Delay) then
                _Callback(unpack(_Arguments or {}));
                return true;
            end
        end,
        Lib.Core.Job.SecondsSinceGameStart,
        _Waittime,
        _Function,
        {...}
    );
end
API.StartRealTimeDelay = RequestRealTimeDelay;

function StopJob(_JobID)
    if Lib.Core.Job.EventJobs[_JobID] then
        Trigger.UnrequestTrigger(Lib.Core.Job.EventJobs[_JobID][1]);
        Lib.Core.Job.EventJobs[_JobID] = nil;
        return;
    end
    EndJob(_JobID);
end
API.EndJob = StopJob;

function IsJobRunning(_JobID)
    if Lib.Core.Job.EventJobs[_JobID] then
        return Lib.Core.Job.EventJobs[_JobID][2] == true;
    end
    return JobIsRunning(_JobID);
end
API.JobIsRunning = IsJobRunning;

function ResumeJob(_JobID)
    if Lib.Core.Job.EventJobs[_JobID] then
        if Lib.Core.Job.EventJobs[_JobID][2] ~= true then
            Lib.Core.Job.EventJobs[_JobID][2] = true;
        end
        return;
    end
    assert(false, "Failed to resume job.");
end
API.ResumeJob = ResumeJob;

function YieldJob(_JobID)
    if Lib.Core.Job.EventJobs[_JobID] then
        if Lib.Core.Job.EventJobs[_JobID][2] == true then
            Lib.Core.Job.EventJobs[_JobID][2] = false;
        end
        return;
    end
    assert(false, "Failed to yield job.");
end
API.YieldJob = YieldJob;

function GetSecondsRealTime()
    return Lib.Core.Job.SecondsSinceGameStart;
end
API.GetSecondsRealTime = GetSecondsRealTime;

Lib.Core = Lib.Core or {};
Lib.Core.Save = {
    HistoryEditionQuickSave = false,
    SavingDisabled = false,
    LoadingDisabled = false,
};

Lib.Require("core/feature/Core_Report");
Lib.Require("core/feature/Core_Job");
Lib.Register("core/feature/Core_Save");

-- -------------------------------------------------------------------------- --

function DisableAutoSave(_Flag)
    if not IsLocalScript() then
        Lib.Core.Save.HistoryEditionQuickSave = _Flag == true;
        ExecuteLocal([[Lib.Core.Save.HistoryEditionQuickSave = %s]], tostring(_Flag == true))
    end
end
API.DisableAutoSave = DisableAutoSave;

function DisableSaving(_Flag)
    Lib.Core.Save:DisableSaving(_Flag);
end
API.DisableSaving = DisableSaving;

function DisableLoading(_Flag)
    Lib.Core.Save:DisableLoading(_Flag);
end
API.DisableLoading = DisableLoading;

-- -------------------------------------------------------------------------- --

function Lib.Core.Save:Initialize()
    Report.SaveGameLoaded = CreateReport("Event_SaveGameLoaded");

    self:SetupQuicksaveKeyCallback();
    self:SetupQuicksaveKeyTrigger();
end

function Lib.Core.Save:OnSaveGameLoaded()
    self:SetupQuicksaveKeyTrigger();
    self:UpdateLoadButtons();
    self:UpdateSaveButtons();

    SendReport(Report.SaveGameLoaded);
end

function Lib.Core.Save:OnReportReceived(_ID, ...)
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Save:SetupQuicksaveKeyTrigger()
    if IsLocalScript() then
        RequestHiResJob(
            function()
                Input.KeyBindDown(
                    Keys.ModifierControl + Keys.S,
                    "KeyBindings_SaveGame(true)",
                    2,
                    false
                );
                return true;
            end
        );
    end
end

function Lib.Core.Save:SetupQuicksaveKeyCallback()
    if IsLocalScript() then
        KeyBindings_SaveGame_Orig_Core = KeyBindings_SaveGame;
        KeyBindings_SaveGame = function(...)
            -- No quicksave if saving disabled
            if Lib.Core.Save.SavingDisabled then
                return;
            end
            -- No quicksave if forced by History Edition
            if not Lib.Core.Save.HistoryEditionQuickSave and not arg[1] then
                return;
            end
            -- Close script console
            if IsScriptConsoleShown() then
                HideScriptConsole();
            end
            -- Do quicksave
            KeyBindings_SaveGame_Orig_Core();
        end

        SaveDialog_SaveFile_Orig_Core = SaveDialog_SaveFile;
        SaveDialog_SaveFile = function(...)
            -- Close script console
            if IsScriptConsoleShown() then
                HideScriptConsole();
            end
            -- Do save
            SaveDialog_SaveFile_Orig_Core();
        end

        self.Orig_GUI_Window_MainMenuSaveClicked = GUI_Window.MainMenuSaveClicked;
        GUI_Window.MainMenuSaveClicked = function()
            -- Close script console
            if IsScriptConsoleShown() then
                HideScriptConsole();
            end
            -- Do save
            Lib.Core.Save.Orig_GUI_Window_MainMenuSaveClicked();
        end

        self.Orig_GUI_Window_MainMenuExit = GUI_Window.MainMenuExit;
        GUI_Window.MainMenuExit = function()
            -- Close script console
            if IsScriptConsoleShown() then
                HideScriptConsole();
            end
            -- Close game
            Lib.Core.Save.Orig_GUI_Window_MainMenuExit();
        end
    end
end

function Lib.Core.Save:DisableSaving(_Flag)
    self.SavingDisabled = _Flag == true;
    if not IsLocalScript() then
        ExecuteLocal([[Lib.Core.Save:DisableSaving(%s)]],tostring(_Flag));
    else
        self:UpdateSaveButtons();
    end
end

function Lib.Core.Save:UpdateSaveButtons()
    if IsLocalScript() then
        local VisibleFlag = (self.SavingDisabled and 0) or 1;
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickSave", VisibleFlag);
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/SaveGame", VisibleFlag);
    end
end

function Lib.Core.Save:DisableLoading(_Flag)
    self.LoadingDisabled = _Flag == true;
    if not IsLocalScript() then
        ExecuteLocal([[Lib.Core.Save:DisableLoading(%s)]],tostring(_Flag));
    else
        self:UpdateLoadButtons();
    end
end

function Lib.Core.Save:UpdateLoadButtons()
    if IsLocalScript() then
        local VisibleFlag = (self.LoadingDisabled and 0) or 1;
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/LoadGame", VisibleFlag);
        XGUIEng.ShowWidget("/InGame/InGame/MainMenu/Container/QuickLoad", VisibleFlag);
    end
end

Lib.Core = Lib.Core or {};
Lib.Core.Text = {
    Languages = {
        {"de", "Deutsch", "en"},
        {"en", "English", "en"},
        {"fr", "Français", "en"},
    },

    Colors = {
        red     = "{@color:255,80,80,255}",
        blue    = "{@color:104,104,232,255}",
        yellow  = "{@color:255,255,80,255}",
        green   = "{@color:80,180,0,255}",
        white   = "{@color:255,255,255,255}",
        black   = "{@color:0,0,0,255}",
        grey    = "{@color:140,140,140,255}",
        azure   = "{@color:0,160,190,255}",
        orange  = "{@color:255,176,30,255}",
        amber   = "{@color:224,197,117,255}",
        violet  = "{@color:180,100,190,255}",
        pink    = "{@color:255,170,200,255}",
        scarlet = "{@color:190,0,0,255}",
        magenta = "{@color:190,0,89,255}",
        olive   = "{@color:74,120,0,255}",
        celeste = "{@color:145,170,210,255}",
        tooltip = "{@color:51,51,120,255}",
        none    = "{@color:none}"
    },

    Letters = {
        [4] = "ABCDEFGHKLMNOPQRSTUVWXYZÄÖÜÁÂÃÅÇÈÉÊËÐÐÑÒÓÔÕÖØÙÚÛÜÝ",
        [3] = "abcdeghkmnopqsuvwxyzäöüßIJÆÌÍÎÏÞàáâãåæçèéêëìíîïðñòóôõ÷øùúûüýþÿ",
        [2] = "\"#+*~_\\§$%&=?@fijlft",
        [1] = "!-/()?',.|[]{}",
    },

    StringTables = {},

    Placeholders = {
        Names = {},
        EntityTypes = {},
    },
}

CONST_LANGUAGE = "de";

Lib.Require("comfort/IsLocalScript");
Lib.Require("core/feature/Core_Report");
Lib.Register("core/feature/Core_Text");

-- -------------------------------------------------------------------------- --

function Lib.Core.Text:Initialize()
    Report.LanguageChanged = CreateReport("Event_LanguageChanged");

    self:DetectLanguage();
    if IsLocalScript() then
        self:OverwriteGetStringTableText();
    end
end

function Lib.Core.Text:OnSaveGameLoaded()
    if IsLocalScript() then
        self:OverwriteGetStringTableText();
    end
end

function Lib.Core.Text:OnReportReceived(_ID, ...)
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Text:OverwriteGetStringTableText()
    XGUIEng.GetStringTableText_Orig_Core = XGUIEng.GetStringTableText;
    XGUIEng.GetStringTableText = function(_key)
        return Lib.Core.Text:GetStringTableOverwrite(_key)
    end
end

function Lib.Core.Text:AddStringTableOverwrite(_Key, _Text)
    local i = string.find(_Key, "/[^/]*$");
    local File = _Key:sub(1, i-1):lower();
    local Key = _Key:sub(i+1):lower();
    self.StringTables[File] = self.StringTables[File] or {};
    self.StringTables[File][Key] = _Text;
end

function Lib.Core.Text:DeleteStringTableOverwrite(_Key)
    local i = string.find(_Key, "/[^/]*$");
    local File = _Key:sub(1, i-1):lower();
    local Key = _Key:sub(i+1):lower();
    self.StringTables[File] = self.StringTables[File] or {};
    self.StringTables[File][Key] = nil;
end

function Lib.Core.Text:GetStringTableOverwrite(_Key)
    local i = string.find(_Key, "/[^/]*$");
    local File = _Key:sub(1, i-1):lower();
    local Key = _Key:sub(i+1):lower();
    self.StringTables[File] = self.StringTables[File] or {};
    if self.StringTables[File][Key] then
        local Text = self.StringTables[File][Key];
        if type(Text) == "string" and Text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
            Text = XGUIEng.GetStringTableText_Orig_Core(Text);
        end
        return ConvertPlaceholders(Localize(Text));
    end
    return XGUIEng.GetStringTableText_Orig_Core(_Key);
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Text:DetectLanguage()
    local DefaultLanguage = Network.GetDesiredLanguage();
    if DefaultLanguage ~= "de" and DefaultLanguage ~= "fr" then
        DefaultLanguage = "en";
    end
    CONST_LANGUAGE = DefaultLanguage;
end

function Lib.Core.Text:ChangeSystemLanguage(_PlayerID, _IsGuiPlayer, _Language)
    local OldLanguage = CONST_LANGUAGE;
    local NewLanguage = _Language;

    if _IsGuiPlayer == nil or _IsGuiPlayer == true then
        CONST_LANGUAGE = _Language;
        ExecuteLocal([[CONST_LANGUAGE = "%s"]], _Language);
        SendReport(Report.LanguageChanged, OldLanguage, NewLanguage);
        SendReportToLocal(Report.LanguageChanged, OldLanguage, NewLanguage);
    end
end

function Lib.Core.Text:Localize(_Text)
    local LocalizedText = "ERROR_NO_TEXT";
    if type(_Text) == "table" then
        if _Text[CONST_LANGUAGE] then
            LocalizedText = _Text[CONST_LANGUAGE];
        else
            for k, v in pairs(self.Languages) do
                if v[1] == CONST_LANGUAGE and v[3] and _Text[v[3]] then
                    LocalizedText = _Text[v[3]];
                    break;
                end
            end
        end
    else
        LocalizedText = tostring(_Text);
    end
    return LocalizedText;
end

function Lib.Core.Text:ConvertPlaceholders(_Text)
    if type(_Text) == "string" then
        while true do
            local Before, Placeholder, After, Replacement, s1, e1, s2, e2;
            if _Text:find("{n:") then
                Before, Placeholder, After, s1, e1, s2, e2 = self:SplicePlaceholderText(_Text, "{n:");
                Replacement = self.Placeholders.Names[Placeholder];
                _Text = Before .. self:Localize(Replacement or ("n:" ..tostring(Placeholder).. ": not found")) .. After;
            elseif _Text:find("{t:") then
                Before, Placeholder, After, s1, e1, s2, e2 = self:SplicePlaceholderText(_Text, "{t:");
                Replacement = self.Placeholders.EntityTypes[Placeholder];
                _Text = Before .. self:Localize(Replacement or ("n:" ..tostring(Placeholder).. ": not found")) .. After;
            elseif _Text:find("{v:") then
                Before, Placeholder, After, s1, e1, s2, e2 = self:SplicePlaceholderText(_Text, "{v:");
                Replacement = self:ReplaceValuePlaceholder(Placeholder);
                _Text = Before .. self:Localize(Replacement or ("v:" ..tostring(Placeholder).. ": not found")) .. After;
            end
            if s1 == nil or e1 == nil or s2 == nil or e2 == nil then
                break;
            end
        end
        _Text = self:ReplaceColorPlaceholders(_Text);
    end
    return _Text;
end

function Lib.Core.Text:SplicePlaceholderText(_Text, _Start)
    local s1, e1      = _Text:find(_Start);
    local s2, e2      = _Text:find("}", e1);
    local Before      = _Text:sub(1, s1-1);
    local Placeholder = _Text:sub(e1+1, s2-1);
    local After       = _Text:sub(e2+1);
    return Before, Placeholder, After, s1, e1, s2, e2;
end

function Lib.Core.Text:ReplaceColorPlaceholders(_Text)
    for k, v in pairs(self.Colors) do
        _Text = _Text:gsub("{" ..k.. "}", v);
    end
    return _Text;
end

function Lib.Core.Text:ReplaceValuePlaceholder(_Text)
    local Ref = _G;
    local Slice = string.slice(_Text, "%.");
    for i= 1, #Slice do
        local KeyOrIndex = Slice[i];
        local Index = tonumber(KeyOrIndex);
        if Index ~= nil then
            KeyOrIndex = Index;
        end
        if not Ref[KeyOrIndex] then
            return nil;
        end
        Ref = Ref[KeyOrIndex];
    end
    return Ref;
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Text:GetAmountOfLines(_Text, _LineLength)
    local Lines = 0;
    if type(_Text) == "string" then
        local Text,cr = string.gsub(_Text, "{cr}", " ###CR### ");

        local Words = {};
        for Word in string.gmatch(Text, "%S+") do
            table.insert(Words, Word)
        end

        local Counter = 0;
        for _,Word in pairs(Words) do
            if Word == "###CR###" then
                Counter = 0;
                Lines = Lines + 1;
            else
                for Char in string.gmatch(Word, ".") do
                    local Size = self:GetLetterSize(Char);
                    if Counter + Size <= _LineLength then
                        Counter = Counter + Size;
                    else
                        Counter = 0;
                        Lines = Lines + 1;
                    end
                end
            end
        end
    end
    return Lines;
end

function Lib.Core.Text:GetLetterSize(_Byte)
    for Size, Letters in pairs(self.Letters) do
        if string.find(Letters, _Byte) then
            return Size;
        end
    end
    return 2;
end

-- -------------------------------------------------------------------------- --

function Localize(_Text)
    return Lib.Core.Text:Localize(_Text);
end
API.Localize = Localize;

function ConvertPlaceholders(_Text)
    return Lib.Core.Text:ConvertPlaceholders(_Text);
end
API.ConvertPlaceholders = ConvertPlaceholders;

function AddNote(_Text)
    _Text = ConvertPlaceholders(Localize(_Text));
    if not IsLocalScript() then
        Logic.DEBUG_AddNote(_Text);
        return;
    end
    if _Text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _Text = GetStringText(_Text);
    end
    GUI.AddNote(_Text);
end
API.Note = AddNote;

function AddStaticNote(_Text)
    _Text = ConvertPlaceholders(Localize(_Text));
    if not IsLocalScript() then
        ExecuteLocal([[GUI.AddStaticNote("%s")]], _Text);
        return;
    end
    if _Text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _Text = GetStringText(_Text);
    end
    GUI.AddStaticNote(_Text);
end
API.StaticNote = AddStaticNote;

function AddMessage(_Text, _Sound)
    _Text = ConvertPlaceholders(Localize(_Text));
    if not IsLocalScript() then
        ExecuteLocal([[AddMessage("%s", "%s")]], _Text, _Sound or "");
        return;
    end
    if _Text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _Text = GetStringText(_Text);
    end
    Message(_Text, (_Sound and _Sound ~= "" and _Sound:gsub("/", "\\")) or nil);
end

function ClearNotes()
    if not IsLocalScript() then
        ExecuteLocal([[ClearNotes()]]);
        return;
    end
    GUI.ClearNotes();
end
API.ClearNotes = ClearNotes;

function AddStringText(_Key, _Text)
    assert(IsLocalScript(), "Text can only be set in local script!");
    Lib.Core.Text:AddStringTableOverwrite(_Key, _Text)
end
API.AddStringText = AddStringText;

function DeleteStringText(_Key)
    assert(IsLocalScript(), "Text can only be removed in local script!");
    Lib.Core.Text:DeleteStringTableOverwrite(_Key);
end
API.DeleteStringText = DeleteStringText;

function GetStringText(_Key)
    assert(IsLocalScript(), "Text can only be retrieved in local script!");
    return Lib.Core.Text:GetStringTableOverwrite(_Key)
end
API.GetStringText = GetStringText;

function DefineLanguage(_Shortcut, _Name, _Fallback, _Index)
    assert(type(_Shortcut) == "string");
    assert(type(_Name) == "string");
    assert(type(_Fallback) == "string");
    for k, v in pairs(Lib.Core.Text.Languages) do
        if v[1] == _Shortcut then
            return;
        end
    end
    _Index = _Index or #Lib.Core.Text.Languages +1
    table.insert(Lib.Core.Text.Languages, _Index, {_Shortcut, _Name, _Fallback});
    ExecuteLocal([[
        table.insert(Lib.Core.Text.Languages, %d, {"%s", "%s", "%s"})
    ]], _Index, _Shortcut, _Name, _Fallback);
end

function CountTextLines(_Text, _LineLength)
    assert(type(_Text) == "string");
    assert(type(_LineLength) == "number");
    assert(_LineLength > 0);
    return Lib.Core.Text:GetAmountOfLines(_Text, _LineLength);
end

Lib.Core = Lib.Core or {};
Lib.Core.ScriptingValue = {
    SV = {
        Game = "Vanilla",
        Vanilla = {
            Destination = {X = 19, Y= 20},
            Health      = -41,
            Player      = -71,
            Size        = -45,
            Visible     = -50,
            Selectable  = -50,
            NPC         = 6,
        },
        HistoryEdition = {
            Destination = {X = 17, Y= 18},
            Health      = -38,
            Player      = -68,
            Size        = -42,
            Visible     = -47,
            Selectable  = -47,
            NPC         = 6,
        }
    }
}

CONST_SCRIPTING_VALUES = Lib.Core.ScriptingValue.SV.Vanilla;

Lib.Require("comfort/IsHistoryEdition");
Lib.Require("core/feature/Core_Report");
Lib.Require("core/feature/Core_LuaExtension");
Lib.Register("core/feature/Core_ScriptingValue");

-- -------------------------------------------------------------------------- --

function Lib.Core.ScriptingValue:Initialize()
    if IsHistoryEdition() then
        self.SV.Game = "HistoryEdition";
    end
    CONST_SCRIPTING_VALUES = self.SV[self.SV.Game];
end

function Lib.Core.ScriptingValue:OnSaveGameLoaded()
    if IsHistoryEdition() then
        self.SV.Game = "HistoryEdition";
    end
    CONST_SCRIPTING_VALUES = self.SV[self.SV.Game];
end

function Lib.Core.ScriptingValue:OnReportReceived(_ID, ...)
end

-- -------------------------------------------------------------------------- --

function Lib.Core.ScriptingValue:BitsInteger(num)
    local t = {};
    while num > 0 do
        local rest = math.qmod(num, 2);
        table.insert(t,1,rest);
        num=(num-rest)/2;
    end
    table.remove(t, 1);
    return t;
end

function Lib.Core.ScriptingValue:BitsFraction(num, t)
    for i = 1, 48 do
        num = num * 2;
        if(num >= 1) then
            table.insert(t, 1);
            num = num - 1;
        else
            table.insert(t, 0);
        end
        if(num == 0) then
            return t;
        end
    end
    return t;
end

function Lib.Core.ScriptingValue:IntegerToFloat(num)
    if(num == 0) then
        return 0;
    end
    local sign = 1;
    if (num < 0) then
        num = 2147483648 + num;
        sign = -1;
    end
    local frac = math.qmod(num, 8388608);
    local headPart = (num-frac)/8388608;
    local expNoSign = math.qmod(headPart, 256);
    local exp = expNoSign-127;
    local fraction = 1;
    local fp = 0.5;
    local check = 4194304;
    for i = 23, 0, -1 do
        if (frac - check) > 0 then
            fraction = fraction + fp;
            frac = frac - check;
        end
        check = check / 2;
        fp = fp / 2;
    end
    return fraction * math.pow(2, exp) * sign;
end

function Lib.Core.ScriptingValue:FloatToInteger(fval)
    if(fval == 0) then
        return 0;
    end
    local signed = false;
    if (fval < 0) then
        signed = true;
        fval = fval * -1;
    end
    local outval = 0;
    local bits;
    local exp = 0;
    if fval >= 1 then
        local intPart = math.floor(fval);
        local fracPart = fval - intPart;
        bits = self:BitsInteger(intPart);
        exp = #bits;
        self:BitsFraction(fracPart, bits);
    else
        bits = {};
        self:BitsFraction(fval, bits);
        while(bits[1] == 0) do
            exp = exp - 1;
            table.remove(bits, 1);
        end
        exp = exp - 1;
        table.remove(bits, 1);
    end
    local bitVal = 4194304;
    local start = 1;
    for bpos = start, 23 do
        local bit = bits[bpos];
        if(not bit) then
            break;
        end
        if(bit == 1) then
            outval = outval + bitVal;
        end
        bitVal = bitVal / 2;
    end
    outval = outval + (exp+127)*8388608;
    if(signed) then
        outval = outval - 2147483648;
    end
    return outval;
end

-- -------------------------------------------------------------------------- --

function GetEntityDestination(_Entity)
    assert(IsExisting(_Entity), "Entity does not exist.");
    local X = GetFloat(_Entity, CONST_SCRIPTING_VALUES.Destination.X);
    local Y = GetFloat(_Entity, CONST_SCRIPTING_VALUES.Destination.Y);
    return {X = X, Y = Y, Z = 0};
end

function GetEntityHealth(_Entity)
    assert(IsExisting(_Entity), "Entity does not exist.");
    return GetInteger(_Entity, CONST_SCRIPTING_VALUES.Health);
end

function SetEntityHealth(_Entity, _Health)
    assert(IsExisting(_Entity), "Entity does not exist.");
    SetInteger(_Entity, CONST_SCRIPTING_VALUES.Health, _Health);
end

function GetEntityNpc(_Entity)
    assert(IsExisting(_Entity), "Entity does not exist.");
    return GetInteger(_Entity, CONST_SCRIPTING_VALUES.NPC) > 0;
end

function GetEntityPlayer(_Entity)
    assert(IsExisting(_Entity), "Entity does not exist.");
    return GetInteger(_Entity, CONST_SCRIPTING_VALUES.Player);
end

function SetEntityPlayer(_Entity, _Player)
    assert(IsExisting(_Entity), "Entity does not exist.");
    SetInteger(_Entity, CONST_SCRIPTING_VALUES.Player, _Player);
end

function GetEntityScaling(_Entity)
    assert(IsExisting(_Entity), "Entity does not exist.");
    return GetFloat(_Entity, CONST_SCRIPTING_VALUES.Size);
end

function GetEntityScaling(_Entity, _Scaling)
    assert(IsExisting(_Entity), "Entity does not exist.");
    SetFloat(_Entity, CONST_SCRIPTING_VALUES.Size, _Scaling);
end

function IsEntityInvisible(_Entity)
    assert(IsExisting(_Entity), "Entity does not exist.");
    -- 801280 would be visible
    return GetInteger(_Entity, CONST_SCRIPTING_VALUES.Visible) == 793088;
end

function IsEntityInaccessible(_Entity)
    assert(IsExisting(_Entity), "Entity does not exist.");
    -- 801280 would be selectable
    return IsEntityInvisible(_Entity) or GetInteger(_Entity, CONST_SCRIPTING_VALUES.Visible) == 799232;
end

function GetInteger(_Entity, _SV)
    assert(IsExisting(_Entity), "Entity does not exist.");
    local ID = GetID(_Entity);
    return Logic.GetEntityScriptingValue(ID, _SV);
end
API.GetInteger = GetInteger;

function GetFloat(_Entity, _SV)
    assert(IsExisting(_Entity), "Entity does not exist.");
    local ID = GetID(_Entity);
    local Value = Logic.GetEntityScriptingValue(ID, _SV);
    return ConvertIntegerToFloat(Value);
end
API.GetFloat = GetFloat;

function SetInteger(_Entity, _SV, _Value)
    assert(IsExisting(_Entity), "Entity does not exist.");
    local ID = GetID(_Entity);
    Logic.SetEntityScriptingValue(ID, _SV, _Value);
end
API.SetInteger = SetInteger;

function SetFloat(_Entity, _SV, _Value)
    assert(IsExisting(_Entity), "Entity does not exist.");
    local ID = GetID(_Entity);
    Logic.SetEntityScriptingValue(ID, _SV, ConvertFloatToInteger(_Value));
end
API.SetFloat = SetFloat;

function ConvertIntegerToFloat(_Value)
    return Lib.Core.ScriptingValue:IntegerToFloat(_Value);
end
API.ConvertIntegerToFloat = ConvertIntegerToFloat;

function ConvertFloatToInteger(_Value)
    return Lib.Core.ScriptingValue:FloatToInteger(_Value);
end
API.ConvertFloatToInteger = ConvertFloatToInteger;

---@diagnostic disable: duplicate-set-field

Lib.Core = Lib.Core or {};
Lib.Core.Bugfix = {};

Lib.Require("comfort/IsLocalScript");
Lib.Require("comfort/GetDistance");
Lib.Require("core/feature/Core_Text");
Lib.Register("core/feature/Core_Bugfix");

function Lib.Core.Bugfix:Initialize()
    if not IsLocalScript() then
        self:FixResourceSlotsInStorehouses();
        self:FixMiddleEuropeNpcBarracks();
        self:FixMerchantArrivedCheckpoints();
        self:FixDestroyAllPlayerUnits();
        self:FixBanditCampFireplace();
    end
    if IsLocalScript() then
        self:FixInteractiveObjectClicked();
        self:FixBigCathedralName();
        self:FixClimateZoneForHouseMenu();
        self:FixAbilityInfoWhenHomeless();
    end
end

function Lib.Core.Bugfix:OnSaveGameLoaded()
end

function Lib.Core.Bugfix:OnReportReceived(_ID, ...)
end

-- -------------------------------------------------------------------------- --
-- Luxury for NPCs

function Lib.Core.Bugfix:FixResourceSlotsInStorehouses()
    for i= 1, 8 do
        local StorehouseID = Logic.GetStoreHouse(i);
        if StorehouseID ~= 0 then
            Logic.AddGoodToStock(StorehouseID, Goods.G_Salt, 0, true, true);
            Logic.AddGoodToStock(StorehouseID, Goods.G_Dye, 0, true, true);
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Respawning for ME barracks

function Lib.Core.Bugfix:FixMiddleEuropeNpcBarracks()
    GameCallback_OnBuildingConstructionComplete_Orig_Core_Bugfix = GameCallback_OnBuildingConstructionComplete;
    GameCallback_OnBuildingConstructionComplete = function(_PlayerID, _EntityID)
        GameCallback_OnBuildingConstructionComplete_Orig_Core_Bugfix(_PlayerID, _EntityID);
        local EntityType = Logic.GetEntityType(_EntityID);
        if EntityType == Entities.B_NPC_Barracks_ME then
            Logic.RespawnResourceSetMaxSpawn(_EntityID, 0.01);
            Logic.RespawnResourceSetMinSpawn(_EntityID, 0.01);
        end
    end

    for k, v in pairs(Logic.GetEntitiesOfType(Entities.B_NPC_Barracks_ME)) do
        Logic.RespawnResourceSetMaxSpawn(v, 0.01);
        Logic.RespawnResourceSetMinSpawn(v, 0.01);
    end
end

-- -------------------------------------------------------------------------- --
-- Delivery checkpoint

function Lib.Core.Bugfix:FixMerchantArrivedCheckpoints()
    QuestTemplate.IsMerchantArrived = function(this, objective)
        if objective.Data[3] ~= nil then
            if objective.Data[3] == 1 then
                local newID = objective.Data[5].ID;
                if newID ~= nil then
                    objective.Data[3] = newID;
                    DeleteQuestMerchantWithID(newID);
                    if MapCallback_DeliverCartSpawned then
                        MapCallback_DeliverCartSpawned(this, newID, objective.Data[1]);
                    end
                end
            elseif Logic.IsEntityDestroyed(objective.Data[3]) then
                DeleteQuestMerchantWithID(objective.Data[3]);
                objective.Data[3] = nil;
                objective.Data[5].ID = nil;
            else
                local isNearEntrance = function(_ID)
                    if _ID == 0 then
                        return false;
                    end
                    local x, y = Logic.GetBuildingApproachPosition(_ID)
                    return GetDistance(objective.Data[3], {X = x, Y = y}) <= 1000;
                end

                local playerID = objective.Data[6] or this.SendingPlayer;
                return isNearEntrance(Logic.GetHeadquarters(playerID)) or
                       isNearEntrance(Logic.GetMarketplace(playerID)) or
                       isNearEntrance(Logic.GetStoreHouse(playerID));
            end
        end
        return false;
    end
end

-- -------------------------------------------------------------------------- --
-- IO costs

function Lib.Core.Bugfix:FixInteractiveObjectClicked()
    GUI_Interaction.InteractiveObjectClicked = function()
        local widgetID = XGUIEng.GetCurrentWidgetID();
        local widgetName = XGUIEng.GetWidgetNameByID(widgetID);
        local buttonID = tonumber(widgetName);
        local objectID = g_Interaction.ActiveObjectsOnScreen[buttonID];

        if objectID == nil then
            return;
        end
        if not Logic.InteractiveObjectGetAvailability(objectID) then
            return;
        end

        local playerID = GUI.GetPlayerID();
        local costs = {Logic.InteractiveObjectGetEffectiveCosts(objectID, playerID)};
        local canNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");

        local isAffordable = function(costType, amount)
            if  Logic.GetGoodCategoryForGoodType(costType) ~= GoodCategories.GC_Resource
            and Logic.GetGoodCategoryForGoodType(costType) ~= GoodCategories.GC_Gold then
                error("Only resources can be used as costs for objects!");
                return false;
            end
            if costType == Goods.G_Gold then
                canNotBuyString = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_G_Gold");
            end
            return GetPlayerGoodsInSettlement(costType, playerID, false) >= amount;
        end

        local affordable = true;
        if costs[1] and costs[2] then
            affordable = isAffordable(costs[1], costs[2]);
        end
        if affordable and costs[3] and costs[4] then
            affordable = isAffordable(costs[3], costs[4]);
        end
        if not affordable then
            Message(canNotBuyString);
            return;
        end

        if not GUI_Interaction.InteractionClickOverride 
        or not GUI_Interaction.InteractionClickOverride(objectID) then
            Sound.FXPlay2DSound("ui\\menu_click");
        end

        if not GUI_Interaction.InteractionSpeechFeedbackOverride 
        or not GUI_Interaction.InteractionSpeechFeedbackOverride(objectID) then
            GUI_FeedbackSpeech.Add(
                "SpeechOnly_CartsSent", 
                g_FeedbackSpeech.Categories.CartsUnderway,
                nil,
                nil
            );
        end

        if not Mission_Callback_OverrideObjectInteraction
        or not Mission_Callback_OverrideObjectInteraction(objectID, playerID, costs) then
            GUI.ExecuteObjectInteraction(objectID, playerID);
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Destroy all units

function Lib.Core.Bugfix:FixDestroyAllPlayerUnits()
    QuestTemplate.IsObjectiveCompleted_Orig_Core_Bugfix = QuestTemplate.IsObjectiveCompleted;
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        if objective.Completed ~= nil then
            return objective.Completed;
        end

        local objectiveType = objective.Type;
        local data = objective.Data;

        -- Solves the problem that special entities and construction sites
        -- let the script believe that the player is still alive.
        if objectiveType == Objective.DestroyAllPlayerUnits then
            local playerEntities = GetPlayerEntities(data, 0);
            local illegalEntities = {};
            local indestructableEntities = {
                Entities.XD_ScriptEntity,
                Entities.S_AIHomePosition,
                Entities.S_AIAreaDefinition
            };

            for i = #playerEntities, 1, -1 do
                local entityID = playerEntities[i];
                local entityType = Logic.GetEntityType(entityID);

                local notReady = Logic.IsConstructionComplete(entityID) == 0;
                local notIsBuilding = Logic.IsEntityInCategory(entityID, EntityCategories.AttackableBuilding) == 0;
                local notIsWall = Logic.IsEntityInCategory(entityID, EntityCategories.Wall) == 0;
                if  (notIsBuilding or notIsWall) and notReady then
                    table.insert(illegalEntities, entityID);
                end

                if table.contains(indestructableEntities, entityType) then
                    table.insert(illegalEntities, entityID);
                end
            end

            if #playerEntities == 0 or #playerEntities == #illegalEntities then
                objective.Completed = true;
            end
        elseif objectiveType == Objective.Distance then
            objective.Completed = Lib.Core.Quest:IsQuestPositionReached(self, objective);
        else
            return self:IsObjectiveCompleted_Orig_Core_Bugfix(objective);
        end
        return objective.Completed;
    end
end

-- -------------------------------------------------------------------------- --
-- Cathedral name

function Lib.Core.Bugfix:FixBigCathedralName()
    AddStringText(
        "Names/B_Cathedral_Big",
        {de = "Dom", en = "Cathedral", fr = "Cathédrale"}
    );
end

-- -------------------------------------------------------------------------- --
-- House menu

function Lib.Core.Bugfix:FixClimateZoneForHouseMenu()
    HouseMenuGetNextBuildingID = function(WidgetName)
        local playerID = GUI.GetPlayerID();
        local buildingsList = {Logic.GetBuildingsByPlayer(playerID)};

        WidgetName = GetClimateEntityName(WidgetName);
        local TrimedWidgetName = string.gsub(WidgetName, "_%w%w?%w?$", "");
        if HouseMenu.Widget.CurrentBuilding ~= WidgetName then
            HouseMenu.Widget.CurrentBuilding = WidgetName;
            HouseMenu.Widget.CurrentBuildingNumber = 0;
        end

        local foundNumber = 0;
        local higherBuildingFound = false;
        for i = 1, #buildingsList do
            local entityType = Logic.GetEntityType(buildingsList[i]);
            local entityName = Logic.GetEntityTypeName(entityType);
            local trimedEntityName = string.gsub(entityName, "_%w%w?%w?$", "");
            if trimedEntityName == TrimedWidgetName then
                foundNumber = i;
                if foundNumber > HouseMenu.Widget.CurrentBuildingNumber then
                    HouseMenu.Widget.CurrentBuildingNumber = foundNumber;
                    higherBuildingFound = true;
                    break;
                end
            end
        end

        if foundNumber == 0 then
            return nil;
        end
        if not higherBuildingFound then
            for i = 1, #buildingsList do
                local entityType = Logic.GetEntityType(buildingsList[i]);
                local entityName = Logic.GetEntityTypeName(entityType);
                if entityName == WidgetName then
                    HouseMenu.Widget.CurrentBuildingNumber = i;
                    break;
                end
            end
        end
        return buildingsList[HouseMenu.Widget.CurrentBuildingNumber];
    end

    HouseMenuSetIconsPart = function(_Part, _HighlightBool)
        local playerID = GUI.GetPlayerID();
        local houseMenuButtons = {XGUIEng.ListSubWidgets(_Part)};
        local buildings = {Logic.GetBuildingsByPlayer(playerID)};

        for i = 1, #houseMenuButtons do
            local widgetName = XGUIEng.GetWidgetNameByID(houseMenuButtons[i]);
            local trimedWidgetName = string.gsub(widgetName, "_%w%w?%w?$", "");
            local button = _Part .. "/" .. widgetName .. "/Button";
            SetIcon(button, g_TexturePositions.Entities[Entities[widgetName]]);

            local count = 0;
            for j = 1, #buildings do
                local entityType = Logic.GetEntityType(buildings[j]);
                local entityName = Logic.GetEntityTypeName(entityType);
                local trimedEntityName = string.gsub(entityName, "_%w%w?%w?$", "");
                if trimedWidgetName == trimedEntityName then
                    count = count + 1;
                end
            end

            XGUIEng.DisableButton(button, (count == 0 and 1) or 0);
            XGUIEng.SetText(_Part .. "/" .. widgetName .. "/Amount", "{center}" .. count);
            UpdateStopOverlay(_Part .. "/" .. widgetName .. "/Stop", widgetName, count);

            if widgetName == HouseMenu.Widget.CurrentBuilding then
                UpdateStopOverlay(
                    HouseMenu.Widget.CurrentStop,
                    HouseMenu.Widget.CurrentBuilding,
                    count
                );
            end
        end

        HouseMenu.Counter = HouseMenu.Counter + 1;
        if _HighlightBool or HouseMenu.Counter % 20 == 0 then
            for j = 1, #houseMenuButtons do
                local building = HouseMenu.Widget.CurrentBuilding;
                local highligtedName = XGUIEng.GetWidgetNameByID(houseMenuButtons[j]);
                local button = _Part .. "/" .. highligtedName .. "/Button";
                highligtedName = GetClimateEntityName(highligtedName);
                local highlightFlag = (highligtedName == building and 1) or 0;
                XGUIEng.HighLightButton(button, highlightFlag);
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Ability info

function Lib.Core.Bugfix:FixAbilityInfoWhenHomeless()
    StartKnightVoiceForActionSpecialAbility = function(_KnightType, _NoPriority)
        local playerID = GUI.GetPlayerID();
        local storehouseID = Logic.GetStoreHouse(playerID);
        local knightType = Logic.GetEntityType(Logic.GetKnightID(playerID));
        if  _KnightType == knightType
        and storehouseID ~= 0
        and ActionAbilityIsExplained == nil then
            LocalScriptCallback_StartVoiceMessage(
                playerID,
                "Hint_SpecialAbilityAction",
                false,
                playerID,
                _NoPriority
            );
            ActionAbilityIsExplained = true;
        end
    end

    StartKnightVoiceForPermanentSpecialAbility = function(_KnightType)
        local playerID = GUI.GetPlayerID();
        local storehouseID = Logic.GetStoreHouse(playerID);
        local knightType = Logic.GetEntityType(Logic.GetKnightID(playerID));
        if  _KnightType == knightType
        and storehouseID ~= 0
        and PermanentAbilityIsExplained == nil then
            LocalScriptCallback_StartVoiceMessage(
                playerID,
                "Hint_SpecialAbilityPermanetly",
                false,
                playerID
            );
            PermanentAbilityIsExplained = true;
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Bandit fireplace

function Lib.Core.Bugfix:FixBanditCampFireplace()
    g_Outlaws.ReplaceCampType = {};
    g_Outlaws.ReplaceCampType[Entities.D_X_Fireplace01] = Entities.D_X_Fireplace01_Expired;
    g_Outlaws.ReplaceCampType[Entities.D_X_Fireplace02] = Entities.D_X_Fireplace02_Expired;

    ActivateFireplaceforBanditPack = function(_CaMarketplaceID)
        local playerID = Logic.EntityGetPlayer(_CaMarketplaceID);
        if g_Outlaws.Players[playerID][_CaMarketplaceID].CampFire == nil then
            local ApX, ApY = Logic.GetBuildingApproachPosition(_CaMarketplaceID);
            local PosX, PosY = Logic.GetEntityPosition(_CaMarketplaceID);
            local x = (ApX - PosX) * 1.3 + ApX;
            local y = (ApY - PosY) * 1.3 + ApY;

            local FireplaceType = Entities.D_X_Fireplace01;
            if Logic.IsEntityInCategory(_CaMarketplaceID, EntityCategories.Storehouse) == 1 then
                FireplaceType = Entities.D_X_Fireplace02;
            end

            g_Outlaws.Players[playerID][_CaMarketplaceID].CampFireType = FireplaceType;
            local OldID = g_Outlaws.Players[playerID][_CaMarketplaceID].ExtinguishedFire;
            Logic.DestroyEntity(OldID);
            local NewID = Logic.CreateEntityOnUnblockedLand(FireplaceType, x, y, 0, 0);
            g_Outlaws.Players[playerID][_CaMarketplaceID].CampFire = NewID
            g_Outlaws.Players[playerID][_CaMarketplaceID].CampFirePos = {X= x, Y= y};
            return true;
        end
        return false;
    end

    DisableFireplaceforBanditPack = function(_CaMarketplaceID)
        local playerID = Logic.EntityGetPlayer(_CaMarketplaceID);
        if g_Outlaws.Players[playerID][_CaMarketplaceID].CampFire ~= nil then
            local x = g_Outlaws.Players[playerID][_CaMarketplaceID].CampFirePos.X;
            local y = g_Outlaws.Players[playerID][_CaMarketplaceID].CampFirePos.Y;

            local OldID = g_Outlaws.Players[playerID][_CaMarketplaceID].CampFire;
            Logic.DestroyEntity(OldID);

            local CampfireType = g_Outlaws.Players[playerID][_CaMarketplaceID].CampFireType;
            local FireplaceType = g_Outlaws.ReplaceCampType[CampfireType];
            local NewID = Logic.CreateEntityOnUnblockedLand(FireplaceType, x, y, 0, 0);
            g_Outlaws.Players[playerID][_CaMarketplaceID].ExtinguishedFire = NewID;
            g_Outlaws.Players[playerID][_CaMarketplaceID].CampFire = nil;
        end
    end
end

Lib.Core = Lib.Core or {};
Lib.Core.Chat = {
    DebugInput = {};
};

Lib.Require("comfort/IsLocalScript");
Lib.Require("core/feature/Core_Report");
Lib.Require("core/feature/Core_Job");
Lib.Register("core/feature/Core_Chat");

-- -------------------------------------------------------------------------- --

function Lib.Core.Chat:Initialize()
    Report.ChatOpened = CreateReport("Event_ChatOpened");
    Report.ChatClosed = CreateReport("Event_ChatClosed");
    for i= 1, 8 do
        self.DebugInput[i] = {};
    end
end

function Lib.Core.Chat:OnSaveGameLoaded()
end

function Lib.Core.Chat:OnReportReceived(_ID, ...)
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Chat:ShowTextInput(_PlayerID, _AllowDebug)
    if Lib.IsHistoryEdition and Framework.IsNetworkGame() then
        return;
    end
    if not GUI then
        ExecuteLocal([[Lib.Core.Chat:ShowTextInput(%d, %s)]], _PlayerID,tostring(_AllowDebug == true));
        return;
    end
    _PlayerID = _PlayerID or GUI.GetPlayerID();
    self:PrepareInputVariable(_PlayerID);
    self:ShowInputBox(_PlayerID, _AllowDebug == true);
end

function Lib.Core.Chat:ShowInputBox(_PlayerID, _Debug)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.DebugInput[_PlayerID] = _Debug == true;

    RequestJobByEventType(
        Events.LOGIC_EVENT_EVERY_TURN,
        function ()
            -- Open chat
            Input.ChatMode();
            XGUIEng.SetText("/InGame/Root/Normal/ChatInput/ChatInput", "");
            XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput", 1);
            XGUIEng.SetFocus("/InGame/Root/Normal/ChatInput/ChatInput");
            -- Send events
            SendReportToGlobal(Report.ChatOpened, _PlayerID);
            SendReport(Report.ChatOpened,_PlayerID);

            -- Slow down game time. We can not set the game time to 0 because
            -- then Logic.ExecuteInLuaLocalState and GUI.SendScriptCommand do
            -- not work anymore.
            if not Framework.IsNetworkGame() then
                Game.GameTimeSetFactor(GUI.GetPlayerID(), 0.0000001);
            end
            return true;
        end
    )
end

function Lib.Core.Chat:PrepareInputVariable(_PlayerID)
    if not IsLocalScript() then
        return;
    end

    GUI_Chat.Abort_Orig_Core = GUI_Chat.Abort_Orig_Core or GUI_Chat.Abort;
    GUI_Chat.Confirm_Orig_Core = GUI_Chat.Confirm_Orig_Core or GUI_Chat.Confirm;

    GUI_Chat.Confirm = function()
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatInput", 0);
        local ChatMessage = XGUIEng.GetText("/InGame/Root/Normal/ChatInput/ChatInput");
        local IsDebug = Lib.Core.Chat.DebugInput[_PlayerID];
        Lib.Core.Chat.ChatBoxInput = ChatMessage;
        Lib.Core.Chat:SendInputAsEvent(ChatMessage, IsDebug);
        g_Chat.JustClosed = 1;
        if not Framework.IsNetworkGame() then
            Game.GameTimeSetFactor(_PlayerID, 1);
        end
        Input.GameMode();
        if  ChatMessage:len() > 0
        and Framework.IsNetworkGame()
        and not IsDebug then
            GUI.SendChatMessage(
                ChatMessage,
                _PlayerID,
                g_Chat.CurrentMessageType,
                g_Chat.CurrentWhisperTarget
            );
        end
    end

    if not Framework.IsNetworkGame() then
        GUI_Chat.Abort = function()
        end
    end
end

function Lib.Core.Chat:SendInputAsEvent(_Text, _Debug)
    _Text = (_Text == nil and "") or _Text;
    local PlayerID = GUI.GetPlayerID();
    -- Send chat input to global script
    SendReportToGlobal(
        Report.ChatClosed,
        (_Text or "<<<ES>>>"),
        GUI.GetPlayerID(),
        _Debug == true
    );
    -- Send chat input to local script
    SendReport(
        Report.ChatClosed,
        (_Text or "<<<ES>>>"),
        GUI.GetPlayerID(),
        _Debug == true
    );
    -- Reset debug flag
    self.DebugInput[PlayerID] = false;
end

-- -------------------------------------------------------------------------- --

function ShowTextInput(_PlayerID, _AllowDebug)
    Lib.Core.Chat:ShowTextInput(_PlayerID, _AllowDebug);
end
API.ShowTextInput = ShowTextInput;

Lib.Core = Lib.Core or {};
Lib.Core.Debug = {
    DisplayScriptErrors = false;
    CheckAtRun = false;
    TraceQuests = false;
    DevelopingCheats = false;
    DevelopingShell = false;
    LoadscreenClosed = false;
}

Lib.Require("comfort/IsLocalScript");
Lib.Require("core/feature/Core_Report");
Lib.Require("core/feature/Core_Chat");
Lib.Register("core/feature/Core_Debug");

function Lib.Core.Debug:Initialize()
    Report.DebugChatConfirmed = CreateReport("Event_DebugChatConfirmed");
    Report.DebugConfigChanged = CreateReport("Event_DebugConfigChanged");
    Report.DebugCallGlobal = CreateReport("Event_DebugCallGlobal");

    if IsLocalScript() then
        self:InitializeQsbDebugHotkeys();
    end
end

function Lib.Core.Debug:OnSaveGameLoaded()
    if IsLocalScript() then
        self:InitializeDebugWidgets();
        self:InitializeQsbDebugHotkeys();
    end
end

function Lib.Core.Debug:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.ChatClosed then
        if IsLocalScript() then
            Lib.Core.Debug:ProcessDebugInput(...);
        end
    elseif _ID == Report.DebugCallGlobal then
        if not IsLocalScript() then
            self:CallFunctionFromString(...);
        end
    -- elseif _ID == Report.EscapePressed then
    --     if IsLocalScript() and Framework.IsDevM() then
    --         ToggleScriptConsole();
    --     end
    end
end

function Lib.Core.Debug:Test(_Text)
    AddNote(_Text)
end

function Lib.Core.Debug:ActivateDebugMode(_DisplayScriptErrors, _CheckAtRun, _DevelopingCheats, _DevelopingShell, _TraceQuests)
    if IsLocalScript() then
        return;
    end

    self.DisplayScriptErrors = _DisplayScriptErrors == true;
    self.CheckAtRun          = _CheckAtRun == true;
    self.DevelopingCheats    = _DevelopingCheats == true;
    self.DevelopingShell     = _DevelopingShell == true;
    self.TraceQuests         = _TraceQuests == true;

    SendReport(
        Report.DebugConfigChanged,
        self.DisplayScriptErrors,
        self.CheckAtRun,
        self.DevelopingCheats,
        self.DevelopingShell,
        self.TraceQuests
    );

    ExecuteLocal(
        [[
            Lib.Core.Debug.DisplayScriptErrors = %s;
            Lib.Core.Debug.CheckAtRun          = %s;
            Lib.Core.Debug.DevelopingCheats    = %s;
            Lib.Core.Debug.DevelopingShell     = %s;
            Lib.Core.Debug.TraceQuests         = %s;

            SendReport(
                Report.DebugConfigChanged,
                Lib.Core.Debug.DisplayScriptErrors,
                Lib.Core.Debug.CheckAtRun,
                Lib.Core.Debug.DevelopingCheats,
                Lib.Core.Debug.DevelopingShell,
                Lib.Core.Debug.TraceQuests
            );
            Lib.Core.Debug:InitializeDebugWidgets();
        ]],
        tostring(self.DisplayScriptErrors),
        tostring(self.CheckAtRun),
        tostring(self.DevelopingCheats),
        tostring(self.DevelopingShell),
        tostring(self.TraceQuests)
    );
end

function Lib.Core.Debug:InitializeDebugWidgets()
    if Network.IsNATReady ~= nil and Framework.IsNetworkGame() then
        return;
    end
    if self.DevelopingCheats then
        KeyBindings_EnableDebugMode(1);
        KeyBindings_EnableDebugMode(2);
        KeyBindings_EnableDebugMode(3);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock", 1);
        self.GameClock = true;
    else
        KeyBindings_EnableDebugMode(0);
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock", 0);
        self.GameClock = false;
    end
end

function Lib.Core.Debug:InitializeQsbDebugHotkeys()
    if Framework.IsNetworkGame() then
        return;
    end
    -- Restart map
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.ModifierShift + Keys.ModifierAlt + Keys.R,
        "Lib.Core.Debug:ProcessDebugShortcut('RestartMap')",
        30,
        false
    );
    -- Open chat
    Input.KeyBindDown(
        Keys.ModifierShift + Keys.OemPipe,
        "Lib.Core.Debug:ProcessDebugShortcut('Terminal')",
        30,
        false
    );
end

function Lib.Core.Debug:CallFunctionFromString(...)
    local FunctionRef = nil;
    local FunctionNameParts = string.slice(table.remove(arg, 1), "%.");
    for i= 1, #FunctionNameParts do
        local FunctionName = string.slice(FunctionNameParts[i], ":");
        if #FunctionName > 1 then
            if FunctionRef == nil then
                FunctionRef = _G[FunctionName[1]][FunctionName[2]];
                if FunctionRef then
                    FunctionRef(_G[FunctionName[1]], unpack(arg));
                end
            else
                FunctionRef = FunctionRef[FunctionName[1]][FunctionName[2]];
                if FunctionRef then
                    FunctionRef(_G[FunctionName[1]], unpack(arg));
                end
            end
            return;
        else
            if FunctionRef == nil then
                FunctionRef = _G[FunctionName[1]];
            else
                FunctionRef = FunctionRef[FunctionName[1]];
            end
        end
    end
    if FunctionRef then
        FunctionRef(unpack(arg));
    end
end

function Lib.Core.Debug:ProcessDebugShortcut(_Type, _Params)
    if self.DevelopingCheats then
        if _Type == "RestartMap" then
            self:HideDebugInput();
            Framework.RestartMap();
        elseif _Type == "Terminal" then
            ShowTextInput(GUI.GetPlayerID(), true);
        end
    end
end

function Lib.Core.Debug:ProcessDebugInput(_Input, _PlayerID, _DebugAllowed)
    if _DebugAllowed then
        if _Input:lower():find("^restartmap") then
            self:ProcessDebugShortcut("RestartMap");
        elseif _Input:lower():find("^clear") then
            GUI.ClearNotes();
        elseif _Input:lower():find("^version") then
            GUI.AddStaticNote("Version: " ..Lib.Loader.Version);
        elseif _Input:find("^> ") then
            GUI.SendScriptCommand(_Input:sub(3), true);
        elseif _Input:find("^>> ") then
            GUI.SendScriptCommand(string.format(
                "Logic.ExecuteInLuaLocalState(\"%s\")",
                _Input:sub(4)
            ), true);
        elseif _Input:find("^< ") then
            GUI.SendScriptCommand(string.format(
                [[Script.Load("%s")]],
                _Input:sub(3)
            ));
        elseif _Input:find("^<< ") then
            Script.Load(_Input:sub(4));
        end
    end
end

function Lib.Core.Debug:CommandTokenizer(_Input)
    local Commands = {};
    if _Input == nil then
        return Commands;
    end
    local DAmberCommands = {_Input};
    local AmberCommands = {};

    -- parse & delimiter
    local s, e = string.find(_Input, "%s+&&%s+");
    if s then
        DAmberCommands = {};
        while (s) do
            local tmp = string.sub(_Input, 1, s-1);
            table.insert(DAmberCommands, tmp);
            _Input = string.sub(_Input, e+1);
            s, e = string.find(_Input, "%s+&&%s+");
        end
        if string.len(_Input) > 0 then 
            table.insert(DAmberCommands, _Input);
        end
    end

    -- parse & delimiter
    for i= 1, #DAmberCommands, 1 do
        s, e = string.find(DAmberCommands[i], "%s+&%s+");
        if s then
            local LastCommand = "";
            while (s) do
                local tmp = string.sub(DAmberCommands[i], 1, s-1);
                table.insert(AmberCommands, LastCommand .. tmp);
                if string.find(tmp, " ") then
                    LastCommand = string.sub(tmp, 1, string.find(tmp, " ")-1) .. " ";
                end
                DAmberCommands[i] = string.sub(DAmberCommands[i], e+1);
                s, e = string.find(DAmberCommands[i], "%s+&%s+");
            end
            if string.len(DAmberCommands[i]) > 0 then 
                table.insert(AmberCommands, LastCommand .. DAmberCommands[i]);
            end
        else
            table.insert(AmberCommands, DAmberCommands[i]);
        end
    end

    -- parse spaces
    for i= 1, #AmberCommands, 1 do
        local CommandLine = {};
        s, e = string.find(AmberCommands[i], "%s+");
        if s then
            while (s) do
                local tmp = string.sub(AmberCommands[i], 1, s-1);
                table.insert(CommandLine, tmp);
                AmberCommands[i] = string.sub(AmberCommands[i], e+1);
                s, e = string.find(AmberCommands[i], "%s+");
            end
            table.insert(CommandLine, AmberCommands[i]);
        else
            table.insert(CommandLine, AmberCommands[i]);
        end
        table.insert(Commands, CommandLine);
    end

    return Commands;
end

-- -------------------------------------------------------------------------- --

function Debug_ShowVersion()
    GUI.AddStaticNote("Version: " ..Lib.Loader.Version);
end

function Lib.Core.Debug:ToggleDebugInput()
    if self.ConsoleIsVisible then
        self:HideDebugInput();
    else
        self:ShowDebugInput();
    end
end

function Lib.Core.Debug:ShowDebugInput()
    local MotherPath = "/InGame/TempStuff/BGTopBar/temp";
    local TopWidget = XGUIEng.GetWidgetPathByID(XGUIEng.GetTopPage());
    if not self.LoadscreenClosed
    or not self.DevelopingShell
    or self.ConsoleIsVisible then
        return;
    end
    Display.ToggleScriptConsole();
    if TopWidget ~= MotherPath then
        XGUIEng.PushPage(MotherPath, false);
    end
    XGUIEng.ShowWidget(MotherPath, 0);
    RequestHiResDelay(0, function()
        XGUIEng.ShowWidget(MotherPath, 1);
        XGUIEng.ShowAllSubWidgets(MotherPath, 1);
        XGUIEng.ShowWidget(MotherPath.. "/ShadowBottom", 0);
        XGUIEng.ShowWidget(MotherPath.. "/ShadowTop", 0);
        XGUIEng.ShowWidget(MotherPath.. "/BGTopBarRightBound", 0);
        XGUIEng.SetWidgetLocalPosition(MotherPath, 0, 0);
        XGUIEng.SetWidgetLocalPosition(MotherPath.. "/BGTopBarLeftBound/1", 0, -22)
        XGUIEng.SetWidgetLocalPosition(MotherPath.. "/BGTopBarLeftBound/2", 295, -22)
        XGUIEng.SetWidgetLocalPosition(MotherPath.. "/BGTopBarLeftBound/3", 592, -22)
        XGUIEng.SetWidgetLocalPosition(MotherPath.. "/BGTopBarLeftBound/4", 889, -22)
        XGUIEng.SetWidgetLocalPosition(MotherPath.. "/BGTopBarLeftBound/5", 1184, -22)
        XGUIEng.SetWidgetLocalPosition(MotherPath.. "/BGTopBarLeftBound/6", 1483, -22);
        XGUIEng.SetWidgetSize(MotherPath.. "/BGTopBarLeftBound/6", 275, 300);
        XGUIEng.SetWidgetSize(MotherPath.. "/BGTopBarLeftBound/6/Frame", 275, 300);
        XGUIEng.SetWidgetSize(MotherPath.. "/BGTopBarLeftBound/6/Frame/Bottom", 275, 300);
        XGUIEng.SetWidgetSize(MotherPath.. "/BGTopBarLeftBound/6/Frame/Bottom/1", 275, 100);
        XGUIEng.SetWidgetSize(MotherPath.. "/BGTopBarLeftBound/6/Frame/Top", 275, 300);
        XGUIEng.SetWidgetSize(MotherPath.. "/BGTopBarLeftBound/6/Frame/Top/1", 275, 60);
        XGUIEng.SetWidgetSize(MotherPath.. "/BGTopBarLeftBound/6", 275, 60);
        XGUIEng.SetWidgetSize(MotherPath.. "/BGTopBarLeftBound/6/DialogBG", 275, 60);
        XGUIEng.SetWidgetSize(MotherPath.. "/BGTopBarLeftBound/6/DialogBG/1", 275, 60);
        XGUIEng.SetWidgetSize(MotherPath.. "/BGTopBarLeftBound/6/DialogBG/1/1", 275, 60);
        XGUIEng.SetWidgetLocalPosition(MotherPath, 0, -140);
    end);

    self.ConsoleIsVisible = true;
end

function Lib.Core.Debug:HideDebugInput()
    local ChatPath = "/InGame/Root/Normal/ChatInput";
    if XGUIEng.IsWidgetShown(ChatPath) == 1 then
        return;
    end
    local MotherPath = "/InGame/TempStuff/BGTopBar/temp";
    if not self.ConsoleIsVisible then
        return;
    end
    Display.ToggleScriptConsole();
    XGUIEng.ShowWidget(MotherPath, 0);

    self.ConsoleIsVisible = false;
end

-- -------------------------------------------------------------------------- --

function ActivateDebugMode(_DisplayScriptErrors, _CheckAtRun, _DevelopingCheats, _DevelopingShell, _TraceQuests)
    Lib.Core.Debug:ActivateDebugMode(_DisplayScriptErrors, _CheckAtRun, _DevelopingCheats, _DevelopingShell, _TraceQuests);
end
API.ActivateDebugMode = ActivateDebugMode;

function ShowScriptConsole()
    Lib.Core.Debug:ShowDebugInput();
end

function HideScriptConsole()
    Lib.Core.Debug:HideDebugInput();
end

function ToggleScriptConsole()
    Lib.Core.Debug:ToggleDebugInput();
end

function IsScriptConsoleShown()
    return Lib.Core.Debug.ConsoleIsVisible == true;
end

-- -------------------------------------------------------------------------- --

function Debug_ShowVersion()
    GUI.AddStaticNote("Version: " ..Lib.Loader.Version);
end

function Debug_Execute(_Function, ...)
    error(type(_Function) == "string", "function must be a string!");
    SendReportToGlobal(Report.DebugCallGlobal, _Function, unpack(arg));
end


Lib.Core = Lib.Core or {};

Lib.Core.ModuleList = {};
Lib.Core.Global = {
    IsInstalled = false,
};
Lib.Core.Local = {
    IsInstalled = false;
};

CONST_CURRENT_MODULE_CONTEXT = {};

Lib.Require("comfort/IsHistoryEdition");
Lib.Require("comfort/IsMultiplayer");
Lib.Require("comfort/IsLocalScript");

Lib.Require("core/QSB");

Lib.Require("core/feature/Core_Chat");
Lib.Require("core/feature/Core_Debug");
Lib.Require("core/feature/Core_LuaExtension");
Lib.Require("core/feature/Core_Bugfix");
Lib.Require("core/feature/Core_Report");
Lib.Require("core/feature/Core_ScriptingValue");
Lib.Require("core/feature/Core_Text");
Lib.Require("core/feature/Core_Job");
Lib.Require("core/feature/Core_Save");
Lib.Require("core/feature/Core_Quest");
Lib.Require("core/feature/Core_Player");

Lib.Require("core/Core_Behavior");
Lib.Register("core/Core");

---@diagnostic disable: deprecated

-- -------------------------------------------------------------------------- --

function log(_Text, ...)
    local Text = _Text;
    if #arg > 0 then
        Text = string.format(Text, unpack(arg));
    end
    Text = string.gsub(Text, "{cr}", "\n");
    Framework.WriteToLog(Text);
    return Text;
end

function warn(_Condition, _Text, ...)
    if not _Condition then
        local Color = "{@color:255,0,0,255}";
        local Text = Color .. log(_Text, unpack(arg));
        if GUI then
            GUI.AddNote(Text);
        else
            Logic.DEBUG_Addnote(Text);
        end
        return Text;
    end
end

function error(_Condition, _Text, ...)
    if not _Condition then
        local Text = log(_Text, unpack(arg));
        return assert(_Condition, Text);
    end
end

function debug(_Condition, _Text, ...)
    if not _Condition then
        local Text = log(_Text, unpack(arg));
        if GUI then
            GUI.AddNote(Text);
        else
            Logic.DEBUG_Addnote(Text);
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Global

function Lib.Core.Global:Initialize()
    if not self.IsInstalled then
        g_GameExtraNo = Framework.GetGameExtraNo();

        -- Init base features
        Lib.Core.LuaExtension:Initialize();
        Lib.Core.Report:Initialize();
        Lib.Core.Text:Initialize();
        Lib.Core.Job:Initialize();
        Lib.Core.ScriptingValue:Initialize();
        Lib.Core.Save:Initialize();
        Lib.Core.Quest:Initialize();
        Lib.Core.Chat:Initialize();
        Lib.Core.Debug:Initialize();
        Lib.Core.Bugfix:Initialize();
        Lib.Core.Player:Initialize();

        -- Load user files
        if Mission_LoadFiles then
            GameCallback_Lib_GetExternFilesToLoad = Mission_LoadFiles;
        end
        if GameCallback_Lib_GetExternFilesToLoad then
            local Files = GameCallback_Lib_GetExternFilesToLoad();
            for i= 1, #Files do
                Script.Load(Files[i]);
            end
        end

        -- Initialize modules
        for i= 1, #Lib.Core.ModuleList do
            local Name = Lib.Core.ModuleList[i];
            Lib[Name].Global.Name = Name;

            Lib[Name].AquireContext = function()
                return Lib.Core.Global:AquireContext(Lib[Name].Global);
            end
            Lib[Name].ReleaseContext = function()
                return Lib.Core.Global:ReleaseContext(Lib[Name].Global);
            end

            if Lib[Name].Global and Lib[Name].Global.Initialize then
                Lib[Name].Global:Initialize();
            end
        end

        self:OverrideOnSaveGameLoaded();
        self:InitReportListener();
        self:InitEscapeHandler();
        self:InitLoadscreenHandler();
        LoadBehaviors();

        -- Cleanup (garbage collection)
        Lib.Core.Local = nil;
    end
    self.IsInstalled = true;
end

function Lib.Core.Global:OnSaveGameLoaded()
    Lib.Core.LuaExtension:OnSaveGameLoaded();
    Lib.Core.Report:OnSaveGameLoaded();
    Lib.Core.Text:OnSaveGameLoaded();
    Lib.Core.Job:OnSaveGameLoaded();
    Lib.Core.ScriptingValue:OnSaveGameLoaded();
    Lib.Core.Save:OnSaveGameLoaded();
    Lib.Core.Quest:OnSaveGameLoaded();
    Lib.Core.Chat:OnSaveGameLoaded();
    Lib.Core.Debug:OnSaveGameLoaded();
    Lib.Core.Bugfix:OnSaveGameLoaded();
    Lib.Core.Player:OnSaveGameLoaded();

    -- Restore modules
    for i= 1, #Lib.Core.ModuleList do
        local Name = Lib.Core.ModuleList[i];

        Lib[Name].AquireContext = function()
            return Lib.Core.Global:AquireContext(Lib[Name].Global);
        end
        Lib[Name].ReleaseContext = function()
            return Lib.Core.Global:ReleaseContext(Lib[Name].Global);
        end

        if Lib[Name].Global and Lib[Name].Global.OnSaveGameLoaded then
            Lib[Name].Global:OnSaveGameLoaded();
        end
    end
end

function Lib.Core.Global:OverrideOnSaveGameLoaded()
    Mission_OnSaveGameLoaded_Orig_Libertica = Mission_OnSaveGameLoaded;
    Mission_OnSaveGameLoaded = function()
        Lib.Core.Global:ExecuteLocal("Lib.Core.Local:OnSaveGameLoaded()");
        Lib.Core.Global:OnSaveGameLoaded();
    end
end

function Lib.Core.Global:InitReportListener()
    GameCallback_Lib_OnEventReceived = function(_ID, ...)
        Lib.Core.LuaExtension:OnReportReceived(_ID, ...);
        Lib.Core.Report:OnReportReceived(_ID, ...);
        Lib.Core.Text:OnReportReceived(_ID, ...);
        Lib.Core.Job:OnReportReceived(_ID, ...);
        Lib.Core.ScriptingValue:OnReportReceived(_ID, ...);
        Lib.Core.Save:OnReportReceived(_ID, ...);
        Lib.Core.Quest:OnReportReceived(_ID, ...);
        Lib.Core.Chat:OnReportReceived(_ID, ...);
        Lib.Core.Debug:OnReportReceived(_ID, ...);
        Lib.Core.Bugfix:OnReportReceived(_ID, ...);
        Lib.Core.Player:OnReportReceived(_ID, ...);

        -- Loadscreen
        if _ID == Report.LoadingFinished then
            SendReportToLocal(Report.LoadingFinished, ...);
        end
        -- Escape
        if _ID == Report.EscapePressed then
            SendReportToLocal(Report.EscapePressed, ...);
        end

        for i= 1, #Lib.Core.ModuleList do
            local Name = Lib.Core.ModuleList[i];
            if Lib[Name].Global and Lib[Name].Global.OnReportReceived then
                Lib[Name].Global:OnReportReceived(_ID, ...);
            end
        end

        -- Loading finished callback
        if _ID == Report.LoadingFinished then
            if GameCallback_Lib_LoadingFinished then
                GameCallback_Lib_LoadingFinished();
            end
        end
    end
end

function Lib.Core.Global:ExecuteLocal(_Command, ...)
    local CommandString = _Command;
    if arg and #arg > 0 then
        CommandString = CommandString:format(unpack(arg));
    end
    Logic.ExecuteInLuaLocalState(CommandString);
end

function Lib.Core.Global:AquireContext(_Module)
    local Name = (type(_Module) == "table" and _Module.Name) or _Module;
    assert(Lib[Name] ~= nil);
    table.insert(CONST_CURRENT_MODULE_CONTEXT, Lib[Name].Global);
    local Frame = #CONST_CURRENT_MODULE_CONTEXT;
    this = CONST_CURRENT_MODULE_CONTEXT[Frame];
end

function Lib.Core.Global:ReleaseContext(_Module)
    local Name = (type(_Module) == "table" and _Module.Name) or _Module;
    assert(Lib[Name] ~= nil);
    local Frame = #CONST_CURRENT_MODULE_CONTEXT;
    Lib[Name].Global = CONST_CURRENT_MODULE_CONTEXT[Frame];
    table.remove(CONST_CURRENT_MODULE_CONTEXT);
    Frame = #CONST_CURRENT_MODULE_CONTEXT;
    this = CONST_CURRENT_MODULE_CONTEXT[Frame];
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Global:InitEscapeHandler()
    Report.EscapePressed = CreateReport("Event_EscapePressed");
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Global:InitLoadscreenHandler()
    Report.LoadingFinished = CreateReport("Event_LoadingFinished");
end

-- -------------------------------------------------------------------------- --
-- Local

function Lib.Core.Local:Initialize()
    if not self.IsInstalled then
        g_GameExtraNo = Framework.GetGameExtraNo();

        -- Init base features
        Lib.Core.LuaExtension:Initialize();
        Lib.Core.Report:Initialize();
        Lib.Core.Text:Initialize();
        Lib.Core.Job:Initialize();
        Lib.Core.ScriptingValue:Initialize();
        Lib.Core.Save:Initialize();
        Lib.Core.Quest:Initialize();
        Lib.Core.Chat:Initialize();
        Lib.Core.Debug:Initialize();
        Lib.Core.Bugfix:Initialize();
        Lib.Core.Player:Initialize();

        -- Load user files
        if Mission_LoadFiles then
            GameCallback_Lib_GetExternFilesToLoad = Mission_LoadFiles;
        end
        if GameCallback_Lib_GetExternFilesToLoad then
            local Files = GameCallback_Lib_GetExternFilesToLoad();
            for i= 1, #Files do
                Script.Load(Files[i]);
            end
        end

        -- Initialize modules
        for i= 1, #Lib.Core.ModuleList do
            local Name = Lib.Core.ModuleList[i];
            Lib[Name].Local.Name = Name;

            Lib[Name].AquireContext = function()
                return Lib.Core.Local:AquireContext(Lib[Name].Local);
            end
            Lib[Name].ReleaseContext = function()
                return Lib.Core.Local:ReleaseContext(Lib[Name].Local);
            end

            if Lib[Name].Local and Lib[Name].Local.Initialize then
                Lib[Name].Local:Initialize();
            end
        end

        self:InitReportListener();
        self:InitEscapeHandler();
        self:InitLoadscreenHandler();

        -- Cleanup (garbage collection)
        Lib.Core.Global = nil;
    end
    self.IsInstalled = true;
end

function Lib.Core.Local:OnSaveGameLoaded()
    Lib.Core.LuaExtension:OnSaveGameLoaded();
    Lib.Core.Report:OnSaveGameLoaded();
    Lib.Core.Text:OnSaveGameLoaded();
    Lib.Core.Job:OnSaveGameLoaded();
    Lib.Core.ScriptingValue:OnSaveGameLoaded();
    Lib.Core.Save:OnSaveGameLoaded();
    Lib.Core.Quest:OnSaveGameLoaded();
    Lib.Core.Chat:OnSaveGameLoaded();
    Lib.Core.Debug:OnSaveGameLoaded();
    Lib.Core.Bugfix:OnSaveGameLoaded();
    Lib.Core.Player:OnSaveGameLoaded();

    -- Restore modules
    for i= 1, #Lib.Core.ModuleList do
        local Name = Lib.Core.ModuleList[i];

        Lib[Name].AquireContext = function()
            return Lib.Core.Local:AquireContext(Lib[Name].Local);
        end
        Lib[Name].ReleaseContext = function()
            return Lib.Core.Local:ReleaseContext(Lib[Name].Local);
        end

        if Lib[Name].Local and Lib[Name].Local.OnSaveGameLoaded then
            Lib[Name].Local:OnSaveGameLoaded();
        end
    end

    self:SetEscapeKeyTrigger();

    SendReport(Report.SaveGameLoaded);
end

function Lib.Core.Local:InitReportListener()
    GameCallback_Lib_OnEventReceived = function(_ID, ...)
        Lib.Core.LuaExtension:OnReportReceived(_ID, ...);
        Lib.Core.Report:OnReportReceived(_ID, ...);
        Lib.Core.Text:OnReportReceived(_ID, ...);
        Lib.Core.Job:OnReportReceived(_ID, ...);
        Lib.Core.ScriptingValue:OnReportReceived(_ID, ...);
        Lib.Core.Save:OnReportReceived(_ID, ...);
        Lib.Core.Quest:OnReportReceived(_ID, ...);
        Lib.Core.Chat:OnReportReceived(_ID, ...);
        Lib.Core.Debug:OnReportReceived(_ID, ...);
        Lib.Core.Bugfix:OnReportReceived(_ID, ...);
        Lib.Core.Player:OnReportReceived(_ID, ...);

        -- Loadscreen
        if _ID == Report.LoadingFinished then
            XGUIEng.PopPage();
        end

        for i= 1, #Lib.Core.ModuleList do
            local Name = Lib.Core.ModuleList[i];
            if Lib[Name].Local and Lib[Name].Local.OnReportReceived then
                Lib[Name].Local:OnReportReceived(_ID, ...);
            end
        end

        -- Loading finished callback
        if _ID == Report.LoadingFinished then
            if GameCallback_Lib_LoadingFinished then
                GameCallback_Lib_LoadingFinished();
            end
        end
    end
end

function Lib.Core.Local:ExecuteGlobal(_Command, ...)
    local CommandString = _Command;
    assert(
        not (IsHistoryEdition() and IsMultiplayer()),
        "Script command is not allowed in history edition multiplayer."
    );
    if arg and #arg > 0 then
        CommandString = CommandString:format(unpack(arg));
    end
    GUI.SendScriptCommand(CommandString);
end

function Lib.Core.Local:AquireContext(_Module)
    local Name = (type(_Module) == "table" and _Module.Name) or _Module;
    assert(Lib[Name] ~= nil);
    table.insert(CONST_CURRENT_MODULE_CONTEXT, Lib[Name].Local);
    local Frame = #CONST_CURRENT_MODULE_CONTEXT;
    this = CONST_CURRENT_MODULE_CONTEXT[Frame];
end

function Lib.Core.Local:ReleaseContext(_Module)
    local Name = (type(_Module) == "table" and _Module.Name) or _Module;
    assert(Lib[Name] ~= nil);
    local Frame = #CONST_CURRENT_MODULE_CONTEXT;
    Lib[Name].Local = CONST_CURRENT_MODULE_CONTEXT[Frame];
    table.remove(CONST_CURRENT_MODULE_CONTEXT);
    Frame = #CONST_CURRENT_MODULE_CONTEXT;
    this = CONST_CURRENT_MODULE_CONTEXT[Frame];
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Local:InitEscapeHandler()
    Report.EscapePressed = CreateReport("Event_EscapePressed");
    self:SetEscapeKeyTrigger();
end

function Lib.Core.Local:SetEscapeKeyTrigger()
    Input.KeyBindDown(
        Keys.Escape,
        "SendReportToGlobal(Report.EscapePressed, GUI.GetPlayerID())",
        30,
        false
    );
end

-- -------------------------------------------------------------------------- --

function Lib.Core.Local:InitLoadscreenHandler()
    Report.LoadingFinished = CreateReport("Event_LoadingFinished");

    self.LoadscreenWatchJobID = RequestHiResJob(function()
        if XGUIEng.IsWidgetShownEx("/LoadScreen/LoadScreen") == 0 then
            SendReportToGlobal(Report.LoadingFinished, GUI.GetPlayerID());
            return true;
        end
    end);

    HideLoadScreen_Orig_Core = HideLoadScreen;
    HideLoadScreen = function()
        HideLoadScreen_Orig_Core();
        XGUIEng.PushPage("/LoadScreen/LoadScreen", true);
        XGUIEng.ShowWidget("/LoadScreen/LoadScreen/ButtonStart", 0);
        EndJob(Lib.Core.Local.LoadscreenWatchJobID);
        SendReportToGlobal(Report.LoadingFinished, GUI.GetPlayerID());
    end
end

function Lib.Core.Local:Preload_ViewWholeMap()
    local WorldX, WorldY = Logic.WorldGetSize();
    Display.SetFarClipPlaneMinAndMax(0, 0);
    Camera.SwitchCameraBehaviour(0);
    Camera.RTS_ToggleMapMode(1);
    Camera.RTS_SetMapModeFOV(90);
    Camera.RTS_SetMapModeZoomDistance(100000);
    Camera.RTS_SetMapModeZoomAngle(90);
    Camera.RTS_SetLookAtPosition(WorldX * 0.5, WorldY * 0.5);
    Display.SetRenderFogOfWar(0);
end

function Lib.Core.Local:Preload_ResetView()
    Camera.RTS_ToggleMapMode(0);
    Display.SetRenderFogOfWar(1);
end

-- -------------------------------------------------------------------------- --

function PrepareLibrary()
    assert(not IsLocalScript(), "Must be called from global script!");
    Lib.Core.Global:Initialize();
    ExecuteLocal("Lib.Core.Local:Initialize()");
end

function RegisterModule(_Name)
    assert(Lib[_Name], "Module '" .._Name.. "' does not exist!");
    table.insert(Lib.Core.ModuleList, _Name);
end

function ExecuteLocal(_Command, ...)
    if not IsLocalScript() then
        Lib.Core.Global:ExecuteLocal(_Command, ...);
    end
end

function ExecuteGlobal(_Command, ...)
    if IsLocalScript() then
        Lib.Core.Local:ExecuteGlobal(_Command, ...);
    end
end

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/diplomacy/Diplomacy_API");

function SetDiplomacyStateForPlayer(_PlayerID, _State, ...)
    local PlayerList = #{...} == 0 and {1,2,3,4,5,6,7,8} or {...};
    error(not IsLocalScript(), "Can not be used in local script!");
    Lib.Diplomacy.Global:SetDiplomacyStateForPlayer(_PlayerID, _State, PlayerList);
end

function SetDiplomacyStateForPlayers(_State, ...)
    local PlayerList = {1,2,3,4,5,6,7,8};
    error(not IsLocalScript(), "Can not be used in local script!");
    for i= 1, #PlayerList do
        Lib.Diplomacy.Global:SetDiplomacyStateForPlayer(PlayerList[i], _State, PlayerList);
    end
end

function SaveDiplomacyStates()
    error(not IsLocalScript(), "Can not be used in local script!");
    Lib.Diplomacy.Global:SaveDiplomacy();
end

function ResetDiplomacyStates()
    error(not IsLocalScript(), "Can not be used in local script!");
    Lib.Diplomacy.Global:ResetDiplomacy();
end

Lib.Diplomacy = Lib.Diplomacy or {};
Lib.Diplomacy.Name = "Diplomacy";
Lib.Diplomacy.Global = {
    DiplomacyBackup = {},
};
Lib.Diplomacy.Local  = {};

Lib.Require("core/Core");
Lib.Require("module/diplomacy/Diplomacy_API");
Lib.Register("module/diplomacy/Diplomacy");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.Diplomacy.Global:Initialize()
    if not self.IsInstalled then
        Report.DiplomacyChanged = CreateReport("Event_DiplomacyChanged");

        self:OverwriteDiplomaticEntity();

        -- Garbage collection
        Lib.Diplomacy.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.Diplomacy.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Diplomacy.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

function Lib.Diplomacy.Global:SaveDiplomacy()
    if #self.DiplomacyBackup == 0 then
        for PlayerID1 = 1, 8 do
            self.DiplomacyBackup[PlayerID1] = {};
            for PlayerID2 = 1, 8 do
                if PlayerID1 ~= PlayerID2 then
                    self.DiplomacyBackup[PlayerID1][PlayerID2] = GetDiplomacyState(PlayerID1, PlayerID2);
                end
            end
        end
    end
end

function Lib.Diplomacy.Global:SetDiplomacyStateForPlayer(_PlayerID, _State, _PlayerList)
    local State = _State or DiplomacyStates.Undecided;
    self:SaveDiplomacy();
    for i = 1, #_PlayerList do
        if _PlayerID ~= _PlayerList[i] then
            SetDiplomacyState(_PlayerID, _PlayerList[i], State);
        end
    end
end

function Lib.Diplomacy.Global:ResetDiplomacy()
    if #self.DiplomacyBackup ~= 0 then
        for PlayerID1 = 1, 8 do
            for PlayerID2 = 1, 8 do
                SetDiplomacyState(PlayerID1, PlayerID2, self.DiplomacyBackup[PlayerID1][PlayerID2]);
            end
        end
        self.DiplomacyBackup = {};
    end
end

function Lib.Diplomacy.Global:OverwriteDiplomaticEntity()
    self.Orig_DiplomaticEntity.OnDiplomacyStatusChange = DiplomaticEntity.OnDiplomacyStatusChange;
    DiplomaticEntity.OnDiplomacyStatusChange = function(_this, _relation, _diplomaticEntity, _oldState)
        -- Send event
        SendReport(Report.DiplomacyChanged, _this.ID, _diplomaticEntity.ID, _oldState, _relation.Status.State);
        SendReportToLocal(Report.DiplomacyChanged, _this.ID, _diplomaticEntity.ID, _oldState, _relation.Status.State);
        -- Call original
        Lib.Diplomacy.Global.Orig_DiplomaticEntity.OnDiplomacyStatusChange(_this, _relation, _diplomaticEntity, _oldState);
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.Diplomacy.Local:Initialize()
    if not self.IsInstalled then
        Report.DiplomacyChanged = CreateReport("Event_DiplomacyChanged");

        -- Garbage collection
        Lib.Diplomacy.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.Diplomacy.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.Diplomacy.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.Diplomacy.Name);

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/ui/UITools_API");

function ChangeIcon(_WidgetID, _Coordinates, _Size, _Name)
    error(IsLocalScript(), "Can only be done in local script!");
    _Coordinates = _Coordinates or {10, 14};
    Lib.UITools.Widget:SetIcon(_WidgetID, _Coordinates, _Size, _Name);
end
API.SetIcon = ChangeIcon;

function SetTooltipNormal(_Title, _Text, _DisabledText)
    error(IsLocalScript(), "Can only be done in local script!");
    Lib.UITools.Widget:TooltipNormal(_Title, _Text, _DisabledText);
end
API.SetTooltipNormal = SetTooltipNormal;

function SetTooltipCosts(_Title, _Text, _DisabledText, _Costs, _InSettlement)
    error(IsLocalScript(), "Can only be done in local script!");
    Lib.UITools.Widget:TooltipCosts(_Title,_Text,_DisabledText,_Costs,_InSettlement);
end
API.SetTooltipCosts = SetTooltipCosts;

function HideMinimap(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("HideMinimap(%s)", tostring(_Flag));
        return;
    end
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapOverlay",_Flag);
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/Minimap/MinimapTerrain",_Flag);
end
API.HideMinimap = HideMinimap;

function HideToggleMinimap(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("HideToggleMinimap(%s)", tostring(_Flag));
        return;
    end
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/MinimapButton",_Flag);
end
API.HideToggleMinimap = HideToggleMinimap;

function HideDiplomacyMenu(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("HideDiplomacyMenu(%s)", tostring(_Flag));
        return;
    end
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/DiplomacyMenuButton",_Flag);
end
API.HideDiplomacyMenu = HideDiplomacyMenu;

function HideProductionMenu(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("HideProductionMenu(%s)", tostring(_Flag));
        return;
    end
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/ProductionMenuButton",_Flag);
end
API.HideProductionMenu = HideProductionMenu;

function HideWeatherMenu(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("HideWeatherMenu(%s)", tostring(_Flag));
        return;
    end
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/WeatherMenuButton",_Flag);
end
API.HideWeatherMenu = HideWeatherMenu;

function HideBuyTerritory(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("HideBuyTerritory(%s)", tostring(_Flag));
        return;
    end
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory",_Flag);
end
API.HideBuyTerritory = HideBuyTerritory;

function HideKnightAbility(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("HideKnightAbility(%s)", tostring(_Flag));
        return;
    end
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbilityProgress",_Flag);
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/StartAbility",_Flag);
end
API.HideKnightAbility = HideKnightAbility;

function HideKnightButton(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("HideKnightButton(%s)", tostring(_Flag));
        Logic.SetEntitySelectableFlag("..KnightID..", (_Flag and 0) or 1);
        return;
    end
    local KnightID = Logic.GetKnightID(GUI.GetPlayerID());
    if _Flag then
        GUI.DeselectEntity(KnightID);
    end
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButtonProgress",_Flag);
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/KnightButton",_Flag);
end
API.HideKnightButton = HideKnightButton;

function HideSelectionButton(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("HideSelectionButton(%s)", tostring(_Flag));
        return;
    end
    HideKnightButton(_Flag);
    GUI.ClearSelection();
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/MapFrame/BattalionButton",_Flag);
end
API.HideSelectionButton = HideSelectionButton;

function HideBuildMenu(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("HideBuildMenu(%s)", tostring(_Flag));
        return;
    end
    Lib.UITools.Widget:DisplayInterfaceButton("/InGame/Root/Normal/AlignBottomRight/BuildMenu", _Flag);
end
API.HideBuildMenu = HideBuildMenu;

function AddShortcutDescription(_Key, _Description)
    if not IsLocalScript() then
        return -1;
    end
    g_KeyBindingsOptions.Descriptions = nil;
    for i= 1, #Lib.UITools.Shortcut.HotkeyDescriptions do
        if Lib.UITools.Shortcut.HotkeyDescriptions[i][1] == _Key then
            return -1;
        end
    end
    local ID = #Lib.UITools.Shortcut.HotkeyDescriptions+1;
    table.insert(Lib.UITools.Shortcut.HotkeyDescriptions, {ID = ID, _Key, _Description});
    return #Lib.UITools.Shortcut.HotkeyDescriptions;
end
API.AddShortcutDescription = AddShortcutDescription;

function RemoveShortcutDescription(_ID)
    if not IsLocalScript() then
        return;
    end
    g_KeyBindingsOptions.Descriptions = nil;
    for k, v in pairs(Lib.UITools.Shortcut.HotkeyDescriptions) do
        if v.ID == _ID then
            Lib.UITools.Shortcut.HotkeyDescriptions[k] = nil;
        end
    end
end
API.RemoveShortcutDescription = RemoveShortcutDescription;

function SpeedLimitActivate(_Flag)
    if IsLocalScript() or Framework.IsNetworkGame() then
        return;
    end
    return ExecuteLocal(
        "Lib.UITools.Speed:ActivateSpeedLimit(%s)",
        tostring(_Flag)
    );
end
API.SpeedLimitActivate = SpeedLimitActivate;

Lib.Register("module/ui/UITools_Speed");

Lib.UITools = Lib.UITools or {};
Lib.UITools.Speed = {
    SpeedLimit = 1,
    Text = {
        Message = {
            NoSpeedUp = {
                de = "Die Spielgeschwindigkeit kann nicht erhöht werden!",
                en = "The game speed can not be increased!",
                fr = "La vitesse du jeu ne peut pas être augmentée!"
            }
        }
    };
};

function Lib.UITools.Speed:SetSpeedLimit(_Limit)
    if Framework.IsNetworkGame() then
        log("ModuleGuiControl: Detect network game. Aborting!");
        return;
    end
    _Limit = (_Limit < 1 and 1) or math.floor(_Limit);
    log("ModuleGuiControl: Setting speed limit to " .._Limit);
    self.SpeedLimit = _Limit;
end

function Lib.UITools.Speed:ActivateSpeedLimit(_Flag)
    if Framework.IsNetworkGame() then
        log("ModuleGuiControl: Detect network game. Aborting!");
        return;
    end
    self.UseSpeedLimit = _Flag == true;
    if _Flag and Game.GameTimeGetFactor(GUI.GetPlayerID()) > self.SpeedLimit then
        log("ModuleGuiControl: Speed is capped at " ..self.SpeedLimit);
        Game.GameTimeSetFactor(GUI.GetPlayerID(), self.SpeedLimit);
        g_GameSpeed = 1;
    end
end

function Lib.UITools.Speed:InitForbidSpeedUp()
    GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp = GameCallback_GameSpeedChanged;
    GameCallback_GameSpeedChanged = function( _Speed )
        GameCallback_GameSpeedChanged_Orig_Preferences_ForbidSpeedUp( _Speed );
        if Lib.UITools.Speed.UseSpeedLimit == true then
            log("ModuleGuiControl: Checking speed limit.");
            if _Speed > Lib.UITools.Speed.SpeedLimit then
                log("ModuleGuiControl: Speed is capped at " ..tostring(_Speed).. ".");
                Game.GameTimeSetFactor(GUI.GetPlayerID(), Lib.UITools.Speed.SpeedLimit);
                g_GameSpeed = 1;
                Message(Lib.UITools.Speed.Text.Message.NoSpeedUp);
            end
        end
    end
end

Lib.Register("module/ui/UITools_Widget");

Lib.UITools = Lib.UITools or {};
Lib.UITools.Widget = {
    HiddenWidgets = {},
};

function Lib.UITools.Widget:DisplayInterfaceButton(_Widget, _Hide)
    self.HiddenWidgets[_Widget] = nil;
    if _Hide == true then
        self.HiddenWidgets[_Widget] = true;
    end
    XGUIEng.ShowWidget(_Widget, (_Hide == true and 0) or 1);
end

function Lib.UITools.Widget:UpdateHiddenWidgets()
    for k, v in pairs(self.HiddenWidgets) do
        XGUIEng.ShowWidget(k, 0);
    end
end

function Lib.UITools.Widget:OverrideMissionGoodCounter()
    StartMissionGoodOrEntityCounter = function(_Icon, _AmountToReach)
        local IconWidget = "/InGame/Root/Normal/MissionGoodOrEntityCounter/Icon";
        local CounterWidget = "/InGame/Root/Normal/MissionGoodOrEntityCounter";
        if type(_Icon[3]) == "string" or (_Icon[3] or 0) > 2 then
            Lib.UITools.Widget:SetIcon(IconWidget, _Icon, 64, _Icon[3]);
        else
            SetIcon(IconWidget, _Icon);
        end
        g_MissionGoodOrEntityCounterAmountToReach = _AmountToReach;
        g_MissionGoodOrEntityCounterIcon = _Icon;
        XGUIEng.ShowWidget(CounterWidget, 1);
    end
end

function Lib.UITools.Widget:OverrideUpdateClaimTerritory()
    GUI_Knight.ClaimTerritoryUpdate_Orig_QSB_Interface = GUI_Knight.ClaimTerritoryUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Knight.ClaimTerritoryUpdate = function()
        GUI_Knight.ClaimTerritoryUpdate_Orig_QSB_Interface();
        local Key = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Knight/ClaimTerritory";
        if Lib.UITools.Widget.HiddenWidgets[Key] == true then
            XGUIEng.ShowWidget(Key, 0);
            return true;
        end
    end
end

function Lib.UITools.Widget:SetIcon(_WidgetID, _Coordinates, _Size, _Name)
    _Size = _Size or 64;
    _Coordinates[3] = _Coordinates[3] or 0;
    if _Name == nil then
        return SetIcon(_WidgetID, _Coordinates, _Size);
    end
    assert(_Size == 44 or _Size == 64 or _Size == 128);
    if _Size == 44 then
        _Name = _Name.. ".png";
    end
    if _Size == 64 then
        _Name = _Name.. "big.png";
    end
    if _Size == 128 then
        _Name = _Name.. "verybig.png";
    end

    local u0, u1, v0, v1;
    u0 = (_Coordinates[1] - 1) * _Size;
    v0 = (_Coordinates[2] - 1) * _Size;
    u1 = (_Coordinates[1]) * _Size;
    v1 = (_Coordinates[2]) * _Size;
    State = 1;
    if XGUIEng.IsButton(_WidgetID) == 1 then
        State = 7;
    end
    XGUIEng.SetMaterialAlpha(_WidgetID, State, 255);
    XGUIEng.SetMaterialTexture(_WidgetID, State, _Name);
    XGUIEng.SetMaterialUV(_WidgetID, State, u0, v0, u1, v1);
end

function Lib.UITools.Widget:TooltipNormal(_title, _text, _disabledText)
    if _title and _title:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _title = XGUIEng.GetStringTableText(_title);
    end
    if _text and _text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _text = XGUIEng.GetStringTableText(_text);
    end
    if _disabledText and _disabledText:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _disabledText = XGUIEng.GetStringTableText(_disabledText);
    end

    local TooltipContainerPath = "/InGame/Root/Normal/TooltipNormal";
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");
    local PositionWidget = XGUIEng.GetCurrentWidgetID();

    local title = (_title and _title) or "";
    local text = (_text and _text) or "";
    local disabled = "";
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText;
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. title);
    XGUIEng.SetText(TooltipDescriptionWidget, text .. disabled);
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);

    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);
    local TooltipContainerSizeWidgets = {TooltipBGWidget};
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget);
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);
end

function Lib.UITools.Widget:TooltipCosts(_title,_text,_disabledText,_costs,_inSettlement)
    _costs = _costs or {};
    local Costs = {};
    -- This transforms the content of a metatable to a new table so that the
    -- internal script does correctly render the costs.
    for i= 1, 4, 1 do
        Costs[i] = _costs[i];
    end
    if _title and _title:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _title = XGUIEng.GetStringTableText(_title);
    end
    if _text and _text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _text = XGUIEng.GetStringTableText(_text);
    end
    if _disabledText and _disabledText:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
        _disabledText = XGUIEng.GetStringTableText(_disabledText);
    end

    local TooltipContainerPath = "/InGame/Root/Normal/TooltipBuy";
    local TooltipContainer = XGUIEng.GetWidgetID(TooltipContainerPath);
    local TooltipNameWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Name");
    local TooltipDescriptionWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/Text");
    local TooltipBGWidget = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn/BG");
    local TooltipFadeInContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/FadeIn");
    local TooltipCostsContainer = XGUIEng.GetWidgetID(TooltipContainerPath .. "/Costs");
    local PositionWidget = XGUIEng.GetCurrentWidgetID();

    local title = (_title and _title) or "";
    local text = (_text and _text) or "";
    local disabled = "";
    if XGUIEng.IsButtonDisabled(PositionWidget) == 1 and _disabledText then
        disabled = disabled .. "{cr}{@color:255,32,32,255}" .. _disabledText;
    end

    XGUIEng.SetText(TooltipNameWidget, "{center}" .. title);
    XGUIEng.SetText(TooltipDescriptionWidget, text .. disabled);
    local Height = XGUIEng.GetTextHeight(TooltipDescriptionWidget, true);
    local W, H = XGUIEng.GetWidgetSize(TooltipDescriptionWidget);
    XGUIEng.SetWidgetSize(TooltipDescriptionWidget, W, Height);

    GUI_Tooltip.ResizeBG(TooltipBGWidget, TooltipDescriptionWidget);
    GUI_Tooltip.SetCosts(TooltipCostsContainer, Costs, _inSettlement);
    local TooltipContainerSizeWidgets = {TooltipContainer, TooltipCostsContainer, TooltipBGWidget};
    GUI_Tooltip.SetPosition(TooltipContainer, TooltipContainerSizeWidgets, PositionWidget, nil, true);
    GUI_Tooltip.OrderTooltip(TooltipContainerSizeWidgets, TooltipFadeInContainer, TooltipCostsContainer, PositionWidget, TooltipBGWidget);
    GUI_Tooltip.FadeInTooltip(TooltipFadeInContainer);
end

Lib.Register("module/ui/UITools_Shortcut");

Lib.UITools = Lib.UITools or {};
Lib.UITools.Shortcut = {
    HotkeyDescriptions = {},
};

function Lib.UITools.Shortcut:OverrideRegisterHotkey()
    function g_KeyBindingsOptions:OnShow()
        if Game ~= nil then
            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 1);
        else
            XGUIEng.ShowWidget("/InGame/KeyBindingsMain/Backdrop", 0);
        end

        if g_KeyBindingsOptions.Descriptions == nil then
            g_KeyBindingsOptions.Descriptions = {};
            DescRegister("MenuInGame");
            DescRegister("MenuDiplomacy");
            DescRegister("MenuProduction");
            DescRegister("MenuPromotion");
            DescRegister("MenuWeather");
            DescRegister("ToggleOutstockInformations");
            DescRegister("JumpMarketplace");
            DescRegister("JumpMinimapEvent");
            DescRegister("BuildingUpgrade");
            DescRegister("BuildLastPlaced");
            DescRegister("BuildStreet");
            DescRegister("BuildTrail");
            DescRegister("KnockDown");
            DescRegister("MilitaryAttack");
            DescRegister("MilitaryStandGround");
            DescRegister("MilitaryGroupAdd");
            DescRegister("MilitaryGroupSelect");
            DescRegister("MilitaryGroupStore");
            DescRegister("MilitaryToggleUnits");
            DescRegister("UnitSelect");
            DescRegister("UnitSelectToggle");
            DescRegister("UnitSelectSameType");
            DescRegister("StartChat");
            DescRegister("StopChat");
            DescRegister("QuickSave");
            DescRegister("QuickLoad");
            DescRegister("TogglePause");
            DescRegister("RotateBuilding");
            DescRegister("ExitGame");
            DescRegister("Screenshot");
            DescRegister("ResetCamera");
            DescRegister("CameraMove");
            DescRegister("CameraMoveMouse");
            DescRegister("CameraZoom");
            DescRegister("CameraZoomMouse");
            DescRegister("CameraRotate");

            for k,v in pairs(Lib.UITools.Shortcut.HotkeyDescriptions) do
                if v then
                    v[1] = (type(v[1]) == "table" and Localize(v[1])) or v[1];
                    v[2] = (type(v[2]) == "table" and Localize(v[2])) or v[2];
                    table.insert(g_KeyBindingsOptions.Descriptions, 1, v);
                end
            end
        end
        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ShortcutList);
        XGUIEng.ListBoxPopAll(g_KeyBindingsOptions.Widget.ActionList);
        for Index, Desc in ipairs(g_KeyBindingsOptions.Descriptions) do
            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ShortcutList, Desc[1]);
            XGUIEng.ListBoxPushItem(g_KeyBindingsOptions.Widget.ActionList, Desc[2]);
        end
    end
end

Lib.UITools = Lib.UITools or {};
Lib.UITools.Name = "UITools";
Lib.UITools.Global = {};
Lib.UITools.Local = {};

CONST_PLAYER_NAMES = {};

Lib.Require("core/Core");
Lib.Require("module/ui/UITools_Shortcut");
Lib.Require("module/ui/UITools_Widget");
Lib.Require("module/ui/UITools_Speed");
Lib.Require("module/ui/UITools_API");
Lib.Register("module/ui/UITools");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.UITools.Global:Initialize()
    if not self.IsInstalled then
        -- public reports
        Report.BuildingPlaced = CreateReport("Event_BuildingPlaced");

        -- internal reports
        Report.UpdateTexturePosition = CreateReport("Event_UpdateTexturePosition");

        -- Garbage collection
        Lib.UITools.Local = nil;
        Lib.UITools.Shortcut = nil;
        Lib.UITools.Speed = nil;
        Lib.UITools.Widget = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.UITools.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.UITools.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.UpdateTexturePosition then
        g_TexturePositions = g_TexturePositions or {};
        g_TexturePositions[arg[1]] = g_TexturePositions[arg[1]] or {};
        g_TexturePositions[arg[1]][arg[2]] = {arg[3], arg[4], arg[5]};
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.UITools.Local:Initialize()
    if not self.IsInstalled then
        -- public reports
        Report.BuildingPlaced = CreateReport("Event_BuildingPlaced");

        -- internal reports
        Report.UpdateTexturePosition = CreateReport("Event_UpdateTexturePosition");

        Lib.UITools.Shortcut:OverrideRegisterHotkey();
        Lib.UITools.Widget:OverrideMissionGoodCounter();
        Lib.UITools.Widget:OverrideUpdateClaimTerritory();
        Lib.UITools.Speed:InitForbidSpeedUp();

        self:PostTexturePositionsToGlobal();
        self:OverrideAfterBuildingPlacement();

        -- Garbage collection
        Lib.UITools.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.UITools.Local:OnSaveGameLoaded()
    Lib.UITools.Widget:UpdateHiddenWidgets();
end

-- Global report listener
function Lib.UITools.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

function Lib.UITools.Local:OverrideAfterBuildingPlacement()
    GameCallback_GUI_AfterBuildingPlacement_Orig_UITools = GameCallback_GUI_AfterBuildingPlacement;
    GameCallback_GUI_AfterBuildingPlacement = function ()
        GameCallback_GUI_AfterBuildingPlacement_Orig_UITools();

        local x,y = GUI.Debug_GetMapPositionUnderMouse();
        RequestHiResJob(function()
            local Results = {Logic.GetPlayerEntitiesInArea(GUI.GetPlayerID(), 0, x, y, 50, 16)};
            for i= 2, Results[1] +1 do
                if  Results[i]
                and Results[i] ~= 0
                and Logic.IsBuilding(Results[i]) == 1
                and Logic.IsConstructionComplete(Results[i]) == 0
                then
                    SendReportToGlobal(Report.BuildingPlaced, Results[i], Logic.EntityGetPlayer(Results[i]));
                    SendReport(Report.BuildingPlaced, Results[i], Logic.EntityGetPlayer(Results[i]));
                end
            end
        end, x, y);
    end
end

function Lib.UITools.Local:PostTexturePositionsToGlobal()
    RequestJob(function()
        if Logic.GetTime() > 1 then
            for k, v in pairs(g_TexturePositions) do
                for kk, vv in pairs(v) do
                    local x,y,z = vv[1] or 1, vv[2] or 1, vv[3] or 0;
                    SendReportToGlobal(Report.UpdateTexturePosition, k, kk, x, y, z);
                end
            end
            return true;
        end
    end);
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.UITools.Name);

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/ui/UIEffects_API");

function ActivateColoredScreen(_PlayerID, _Red, _Green, _Blue, _Alpha)
    ActivateImageScreen(_PlayerID, "", _Red or 0, _Green or 0, _Blue or 0, _Alpha or 255);
end
API.ActivateColoredScreen = ActivateColoredScreen;

function DeactivateColoredScreen(_PlayerID)
    DeactivateImageScreen(_PlayerID);
end
API.DeactivateColoredScreen = DeactivateColoredScreen;

function ActivateImageScreen(_PlayerID, _Image, _Red, _Green, _Blue, _Alpha)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    if not IsLocalScript() then
        ExecuteLocal(
            [[Lib.UIEffects.Local:InterfaceActivateImageBackground(%d, "%s", %d, %d, %d, %d)]],
            _PlayerID,
            _Image,
            (_Red ~= nil and _Red) or 255,
            (_Green ~= nil and _Green) or 255,
            (_Blue ~= nil and _Blue) or 255,
            (_Alpha ~= nil and _Alpha) or 255
        );
        return;
    end
    Lib.UIEffects.Local:InterfaceActivateImageBackground(_PlayerID, _Image, _Red, _Green, _Blue, _Alpha);
end
API.ActivateImageScreen = ActivateImageScreen;

function DeactivateImageScreen(_PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    if not IsLocalScript() then
        ExecuteLocal(
            "Lib.UIEffects.Local:InterfaceDeactivateImageBackground(%d)",
            _PlayerID
        );
        return;
    end
    Lib.UIEffects.Local:InterfaceDeactivateImageBackground(_PlayerID);
end
API.DeactivateImageScreen = DeactivateImageScreen;

function ActivateNormalInterface(_PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    if not IsLocalScript() then
        ExecuteLocal(
            "Lib.UIEffects.Local:InterfaceActivateNormalInterface(%d)",
            _PlayerID
        );
        return;
    end
    Lib.UIEffects.Local:InterfaceActivateNormalInterface(_PlayerID);
end
API.ActivateNormalInterface = ActivateNormalInterface;

function DeactivateNormalInterface(_PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    if not IsLocalScript() then
        ExecuteLocal(
            "Lib.UIEffects.Local:InterfaceDeactivateNormalInterface(%d)",
            _PlayerID
        );
        return;
    end
    Lib.UIEffects.Local:InterfaceDeactivateNormalInterface(_PlayerID);
end
API.DeactivateNormalInterface = DeactivateNormalInterface;

function StartCinematicEvent(_Name, _PlayerID)
    assert(IsLocalScript() == false);
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    Lib.UIEffects.CinematicEvents[_PlayerID] = Lib.UIEffects.CinematicEvents[_PlayerID] or {};
    local ID = Lib.UIEffects.Global:ActivateCinematicEvent(_PlayerID);
    Lib.UIEffects.CinematicEvents[_PlayerID][_Name] = ID;
end
API.StartCinematicEvent = StartCinematicEvent;

function FinishCinematicEvent(_Name, _PlayerID)
    assert(IsLocalScript() == false);
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    Lib.UIEffects.CinematicEvents[_PlayerID] = Lib.UIEffects.CinematicEvents[_PlayerID] or {};
    if Lib.UIEffects.CinematicEvents[_PlayerID][_Name] then
        Lib.UIEffects.Global:ConcludeCinematicEvent(
            Lib.UIEffects.CinematicEvents[_PlayerID][_Name],
            _PlayerID
        );
    end
end
API.FinishCinematicEvent = FinishCinematicEvent;

function GetCinematicEvent(_Identifier, _PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    Lib.UIEffects.CinematicEvents[_PlayerID] = Lib.UIEffects.CinematicEvents[_PlayerID] or {};
    if type(_Identifier) == "number" then
        if IsLocalScript() then
            return Lib.UIEffects.Local:GetCinematicEventStatus(_Identifier);
        end
        return Lib.UIEffects.Global:GetCinematicEventStatus(_Identifier);
    end
    if Lib.UIEffects.CinematicEvents[_PlayerID][_Identifier] then
        if IsLocalScript() then
            return Lib.UIEffects.Local:GetCinematicEventStatus(Lib.UIEffects.CinematicEvents[_PlayerID][_Identifier]);
        end
        return Lib.UIEffects.Global:GetCinematicEventStatus(Lib.UIEffects.CinematicEvents[_PlayerID][_Identifier]);
    end
    return CinematicEventState.NotTriggered;
end
API.GetCinematicEvent = GetCinematicEvent;

function IsCinematicEventActive(_PlayerID)
    assert(_PlayerID and _PlayerID >= 1 and _PlayerID <= 8);
    Lib.UIEffects.CinematicEvents[_PlayerID] = Lib.UIEffects.CinematicEvents[_PlayerID] or {};
    for k, v in pairs(Lib.UIEffects.CinematicEvents[_PlayerID]) do
        if GetCinematicEvent(k, _PlayerID) == CinematicEventState.Active then
            return true;
        end
    end
    return false;
end
API.IsCinematicEventActive = IsCinematicEventActive;

function StartTypewriter(_Data)
    if Framework.IsNetworkGame() ~= true then
        _Data.PlayerID = _Data.PlayerID or 1; -- Human Player
    end
    if _Data.PlayerID == nil or (_Data.PlayerID < 1 or _Data.PlayerID > 8) then
        return;
    end
    _Data.Text = Localize(_Data.Text or "");
    _Data.Callback = _Data.Callback or function() end;
    _Data.CharSpeed = _Data.CharSpeed or 1;
    _Data.Waittime = (_Data.Waittime or 8) * 10;
    _Data.TargetEntity = GetID(_Data.TargetEntity or 0);
    _Data.Image = _Data.Image or "";
    _Data.Color = _Data.Color or {
        R = (_Data.Image and _Data.Image ~= "" and 255) or 0,
        G = (_Data.Image and _Data.Image ~= "" and 255) or 0,
        B = (_Data.Image and _Data.Image ~= "" and 255) or 0,
        A = 255
    };
    if _Data.Opacity and _Data.Opacity >= 0 and _Data.Opacity then
        _Data.Color.A = math.floor((255 * _Data.Opacity) + 0.5);
    end
    _Data.Delay = 15;
    _Data.Index = 0;
    return Lib.UIEffects.Global:StartTypewriter(_Data);
end
API.StartTypewriter = StartTypewriter;

Lib.Register("module/settings/Camera_Text");

Lib.Camera = Lib.Camera or {};
Lib.Camera.Text = {
    Shortcut = {
        Hotkey = {
            de = "STRG + UMSCHALT + K",
            en = "CTRL + SHIFT + K",
            fr = "CTRL + SHIFT + K",
        },
        Description = {
            de = "Alternativen Zoom ein/aus",
            en = "Alternative zoom on/off",
            fr = "Zoom alternatif On/Off",
        }
    }
};

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/settings/Camera_API");

function SetRenderDistance(_View)
    if not IsLocalScript() then
        ExecuteLocal([[Lib.Camera.Local:SetRenderDistance(%f)]], _View);
        return;
    end
    Lib.Camera.Local:SetRenderDistance(_View);
end

function ResetRenderDistance()
    if not IsLocalScript() then
        ExecuteLocal([[Lib.Camera.Local:ResetRenderDistance()]]);
        return;
    end
    Lib.Camera.Local:ResetRenderDistance();
end

function ActivateBorderScroll(_PlayerID)
    _PlayerID = _PlayerID or -1;
    assert(_PlayerID == -1 or (_PlayerID >= 1 and _PlayerID <= 8));
    if not IsLocalScript() then
        ExecuteLocal(
            "Lib.Camera.Local:ActivateBorderScroll(%d)",
            _PlayerID
        );
        return;
    end
    Lib.Camera.Local:ActivateBorderScroll(_PlayerID);
end
API.ActivateBorderScroll = ActivateBorderScroll;

function DeactivateBorderScroll(_Position, _PlayerID)
    _PlayerID = _PlayerID or -1;
    assert(_PlayerID == -1 or (_PlayerID >= 1 and _PlayerID <= 8));
    local PositionID;
    if _Position then
        PositionID = GetID(_Position);
    end
    if not IsLocalScript() then
        ExecuteLocal(
            "Lib.Camera.Local:DeactivateBorderScroll(%d, %d)",
            _PlayerID,
            (PositionID or 0)
        );
        return;
    end
    Lib.Camera.Local:DeactivateBorderScroll(_PlayerID, PositionID);
end
API.DeactivateBorderScroll = DeactivateBorderScroll;

function AllowExtendedZoom(_Flag, _PlayerID)
    _PlayerID = _PlayerID or -1;
    if not GUI then
        ExecuteLocal([[API.AllowExtendedZoom(%s, %d)]], tostring(_Flag == true), _PlayerID);
        return;
    end
    if _PlayerID ~= -1 and GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    Lib.Camera.Local.ExtendedZoomAllowed = _Flag == true;
    if _Flag == true then
        Lib.Camera.Local:DescribeExtendedZoomShortcut();
    else
        Lib.Camera.Local:RemoveExtendedZoomShortcut();
        Lib.Camera.Local:DeactivateExtendedZoom(_PlayerID);
    end
end
API.AllowExtendedZoom = AllowExtendedZoom;

function ToggleExtendedZoom(_PlayerID)
    if not GUI then
        ExecuteLocal([[ToggleExtendedZoom(%d)]], _PlayerID);
        return;
    end
    Lib.Camera.Local:ToggleExtendedZoom(_PlayerID)
end
API.ToggleExtendedZoom = ToggleExtendedZoom;

function SetNormalZoomProps(_Limit)
    if not GUI then
        ExecuteLocal([[SetNormalZoomProps(%f)]], _Limit);
        return;
    end
    assert(type(_Limit) == "number", "Limit is wrong!");
    Lib.Camera.Local:SetNormalZoomProps(_Limit);
end
API.SetNormalZoomProps = SetNormalZoomProps;

function SetExtendedZoomProps(_Limit)
    if not GUI then
        ExecuteLocal([[SetExtendedZoomProps(%f)]], _Limit);
        return;
    end
    assert(type(_Limit) == "number", "Limit is wrong!");
    Lib.Camera.Local:SetExtendedZoomProps(_Limit);
end
API.SetExtendedZoomProps = SetExtendedZoomProps;

function FocusCameraOnKnight(_PlayerID, _Rotation, _ZoomFactor)
    FocusCameraOnEntity(Logic.GetKnightID(_PlayerID), _Rotation, _ZoomFactor)
end
API.FocusCameraOnKnight = FocusCameraOnKnight;

function FocusCameraOnEntity(_Entity, _Rotation, _ZoomFactor)
    if not GUI then
        local Subject = (type(_Entity) ~= "string" and _Entity) or ("'" .._Entity.. "'");
        ExecuteLocal([[API.FocusCameraOnEntity(%s, %f, %f)]], Subject, _Rotation, _ZoomFactor);
        return;
    end
    assert(type(_Rotation) == "number", "Rotation is wrong!");
    assert(type(_ZoomFactor) == "number", "Zoom factor is wrong!");
    assert(IsExisting(_Entity), "Entity does not exist!");
    Lib.Camera.Local:SetCameraToEntity(_Entity, _Rotation, _ZoomFactor);
end
API.FocusCameraOnEntity = FocusCameraOnEntity;

--- @diagnostic disable: duplicate-set-field

Lib.Camera = Lib.Camera or {};
Lib.Camera.Name = "Camera";
Lib.Camera.Global = {};
Lib.Camera.Local  = {
    BorderScrollDeactivated = false,
    ExtendedZoomHotKeyID = 0,
    ExtendedZoomAllowed = true,

    CameraExtendedZoom = {
        [1] = {0.870001, 0.870000, 0.099999},
        [2] = {0.870001, 0.870000, 0.099999},
    },
    CameraNormalZoom = {
        [1] = {0.50001, 0.50000, 0.099999},
        [2] = {0.50001, 0.50000, 0.099999},
    },
};

CONST_FARCLIPPLANE = 45000;
CONST_FARCLIPPLANE_DEFAULT = 0;

Lib.Require("core/Core");
Lib.Require("module/settings/Camera_API");
Lib.Require("module/settings/Camera_Text");
Lib.Register("module/settings/Camera");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.Camera.Global:Initialize()
    if not self.IsInstalled then
        --- Scrolling at the edge of the screen is deactivated for a player.
        ---
        --- #### Parameter
        --- - `PlayerID` - ID of Player
        --- - `Position` - ID of Entity camera is fixed on
        Report.BorderScrollLocked = CreateReport("Event_BorderScrollLocked");

        --- Scrolling at the edge of the screen is activated for a player.
        ---
        --- #### Parameter
        --- - `PlayerID` - ID of Player
        Report.BorderScrollReset = CreateReport("Event_BorderScrollReset");

        --- Extended zoom distance is deactivated for the player.
        --- 
        --- #### Parameter
        --- - `PlayerID` - ID of Player
        Report.ExtendedZoomDeactivated = CreateReport("Event_ExtendedZoomDeactivated");

        --- Extended zoom distance is activated for the player.
        --- 
        --- #### Parameter
        --- - `PlayerID` - ID of Player
        Report.ExtendedZoomActivated = CreateReport("Event_ExtendedZoomActivated");

        -- Garbage collection
        Lib.Camera.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.Camera.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Camera.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.Camera.Local:Initialize()
    if not self.IsInstalled then
        Report.BorderScrollLocked = CreateReport("Event_BorderScrollLocked");
        Report.BorderScrollReset  = CreateReport("Event_BorderScrollReset");
        Report.ExtendedZoomDeactivated = CreateReport("Event_ExtendedZoomDeactivated");
        Report.ExtendedZoomActivated = CreateReport("Event_ExtendedZoomActivated");

        self:ResetRenderDistance();
        self:DescribeExtendedZoomShortcut();
        self:InitExtendedZoomHotkey();

        -- Garbage collection
        Lib.Camera.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.Camera.Local:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Camera.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.SaveGameLoaded then
        if self.ExtendedZoomActive then
            self:ActivateExtendedZoom(GUI.GetPlayerID());
        end
        self:InitExtendedZoomHotkey();
        self:ResetRenderDistance();
    end
end

function Lib.Camera.Local:SetRenderDistance(_View)
    Camera.Cutscene_SetFarClipPlane(_View, _View);
    Display.SetFarClipPlaneMinAndMax(_View, _View);
end

function Lib.Camera.Local:ResetRenderDistance()
    Camera.Cutscene_SetFarClipPlane(CONST_FARCLIPPLANE);
    Display.SetFarClipPlaneMinAndMax(CONST_FARCLIPPLANE_DEFAULT, CONST_FARCLIPPLANE_DEFAULT);
end

function Lib.Camera.Local:DeactivateBorderScroll(_PlayerID, _PositionID)
    if (_PlayerID ~= -1 and _PlayerID ~= GUI.GetPlayerID())
    or self.BorderScrollDeactivated then
        return;
    end
    self.BorderScrollDeactivated = true;
    if _PositionID then
        Camera.RTS_FollowEntity(_PositionID);
    end
    Camera.RTS_SetBorderScrollSize(0);
    Camera.RTS_SetZoomWheelSpeed(0);

    SendReportToGlobal(Report.BorderScrollLocked, _PlayerID, (_PositionID or 0));
    SendReport(Report.BorderScrollLocked, _PlayerID, (_PositionID or 0));
end

function Lib.Camera.Local:ActivateBorderScroll(_PlayerID)
    if (_PlayerID ~= -1 and _PlayerID ~= GUI.GetPlayerID())
    or not self.BorderScrollDeactivated then
        return;
    end
    self.BorderScrollDeactivated = false;
    Camera.RTS_FollowEntity(0);
    Camera.RTS_SetBorderScrollSize(3.0);
    Camera.RTS_SetZoomWheelSpeed(4.2);

    SendReportToGlobal(Report.BorderScrollReset, _PlayerID);
    SendReport(Report.BorderScrollReset, _PlayerID);
end

function Lib.Camera.Local:SetCameraToEntity(_Entity, _Rotation, _ZoomFactor)
    local pos = GetPosition(_Entity);
    local rotation = (_Rotation or -45);
    local zoomFactor = (_ZoomFactor or 0.5);
    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);
    Camera.RTS_SetRotationAngle(rotation);
    Camera.RTS_SetZoomFactor(zoomFactor);
end

function Lib.Camera.Local:DescribeExtendedZoomShortcut()
    self:RemoveExtendedZoomShortcut();
    if self.ExtendedZoomHotKeyID == 0 then
        self.ExtendedZoomHotKeyID = AddShortcutDescription(
            Localize(Lib.Camera.Text.Shortcut.Hotkey),
            Localize(Lib.Camera.Text.Shortcut.Description)
        );
    end
end

function Lib.Camera.Local:RemoveExtendedZoomShortcut()
    if self.ExtendedZoomHotKeyID ~= 0 then
        RemoveShortcutDescription(self.ExtendedZoomHotKeyID);
        self.ExtendedZoomHotKeyID = 0;
    end
end

function Lib.Camera.Local:InitExtendedZoomHotkey()
    Input.KeyBindDown(
        Keys.ModifierControl + Keys.ModifierShift + Keys.K,
        "Lib.Camera.Local:ToggleExtendedZoom(GUI.GetPlayerID())",
        2
    );
end

function Lib.Camera.Local:ToggleExtendedZoom(_PlayerID)
    if self.ExtendedZoomAllowed then
        if self.ExtendedZoomActive then
            self:DeactivateExtendedZoom(_PlayerID);
        else
            self:ActivateExtendedZoom(_PlayerID);
        end
    end
end

function Lib.Camera.Local:ActivateExtendedZoom(_PlayerID)
    if _PlayerID~= -1 and _PlayerID ~= GUI.GetPlayerID() then
        return;
    end
    if not self.ExtendedZoomActive then
        SendReportToGlobal(Report.ExtendedZoomDeactivated, _PlayerID);
    end
    self.ExtendedZoomActive = true;
    Camera.RTS_SetZoomFactor(self.CameraExtendedZoom[1][2]);
    Camera.RTS_SetZoomFactorMax(self.CameraExtendedZoom[1][1]);
    Camera.RTS_SetZoomFactorMin(self.CameraExtendedZoom[1][3]);
    SendReportToGlobal(Report.ExtendedZoomDeactivated, _PlayerID);
end

function Lib.Camera.Local:DeactivateExtendedZoom(_PlayerID)
    if _PlayerID~= -1 and _PlayerID ~= GUI.GetPlayerID() then
        return;
    end
    if self.ExtendedZoomActive then
        SendReportToGlobal(Report.ExtendedZoomActivated, _PlayerID);
    end
    self.ExtendedZoomActive = false;
    Camera.RTS_SetZoomFactor(self.CameraNormalZoom[1][2]);
    Camera.RTS_SetZoomFactorMax(self.CameraNormalZoom[1][1]);
    Camera.RTS_SetZoomFactorMin(self.CameraNormalZoom[1][3]);
end

function Lib.Camera.Local:SetNormalZoomProps(_Limit)
    local min, cur, max = 0.099999, _Limit, _Limit + 0.000001;
    if max > self.CameraNormalZoom[2][1] then
        max = self.CameraNormalZoom[2][1];
    end
    self.CameraNormalZoom[1] = {max, cur, min}
end

function Lib.Camera.Local:SetExtendedZoomProps(_Limit)
    local min, cur, max = 0.099999, _Limit, _Limit + 0.000001;
    if max > self.CameraExtendedZoom[2][1] then
        max = self.CameraExtendedZoom[2][1];
    end
    self.CameraExtendedZoom[1] = {max, cur, min}
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.Camera.Name);

Lib.UIEffects = Lib.UIEffects or {};
Lib.UIEffects.Name = "UIEffects";
Lib.UIEffects.CinematicEvents = {};
Lib.UIEffects.Global = {
    CinematicEventID = 0,
    CinematicEventStatus = {},
    CinematicEventQueue = {},
    TypewriterEventData = {},
    TypewriterEventCounter = 0,
};
Lib.UIEffects.Local = {
    CinematicEventStatus = {},
    ChatOptionsWasShown = false,
    MessageLogWasShown = false,
    PauseScreenShown = false,
    NormalModeHidden = false,
};

CinematicEventTypes = {};
CinematicEventState = {
    NotTriggered = 0,
    Active = 1,
    Concluded = 2,
};

Lib.Require("core/Core");
Lib.Require("module/settings/Camera");
Lib.Require("module/ui/UIEffects_API");
Lib.Register("module/ui/UIEffects");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.UIEffects.Global:Initialize()
    if not self.IsInstalled then
        --- A cinematic event, received by a player, has started.
        ---
        --- #### Parameter
        --- * `EventID`  - ID of cinematic event
        --- * `PlayerID` - ID of receiving Player
        Report.CinematicActivated = CreateReport("Event_CinematicEventActivated");

        --- A cinematic event, received by a player, has concluded.
        --- 
        --- #### Parameter
        --- * `EventID`  - ID of cinematic event
        --- * `PlayerID` - ID of receiving Player
        Report.CinematicConcluded = CreateReport("Event_CinematicEventConcluded");

        --- The normal interface is shown for the player.
        ---
        --- #### Parameter
        --- * `PlayerID` - ID of receiving Player
        Report.GameInterfaceShown = CreateReport("Event_GameInterfaceShown");

        --- The normal interface is hidden from the player.
        --- 
        --- #### Parameter
        --- * `PlayerID` - ID of receiving Player
        Report.GameInterfaceHidden = CreateReport("Event_GameInterfaceHidden");

        --- The fullscreen image background is shown for the player.
        ---
        --- #### Parameter
        --- * `PlayerID` - ID of receiving Player
        Report.ImageScreenShown = CreateReport("Event_ImageScreenShown");

        --- The fullscreen image background is hidden from the player.
        --- 
        --- #### Parameter
        --- * `PlayerID` - ID of receiving Player
        Report.ImageScreenHidden = CreateReport("Event_ImageScreenHidden");

        Report.TypewriterStarted = CreateReport("Event_TypewriterStarted");
        Report.TypewriterEnded = CreateReport("Event_TypewriterEnded");

        for i= 1, 8 do
            self.CinematicEventStatus[i] = {};
            self.CinematicEventQueue[i] = {};
        end
        RequestHiResJob(function()
            Lib.UIEffects.Global:ControlTypewriter();
        end);

        -- Garbage collection
        Lib.UIEffects.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.UIEffects.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.UIEffects.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.CinematicActivated then
        self.CinematicEventStatus[arg[2]][arg[1]] = 1;
        --- @diagnostic disable-next-line: param-type-mismatch
        DeactivateImageScreen(arg[2]);
        --- @diagnostic disable-next-line: param-type-mismatch
        ActivateNormalInterface(arg[2]);
    elseif _ID == Report.CinematicConcluded then
        if self.CinematicEventStatus[arg[2]][arg[1]] then
            self.CinematicEventStatus[arg[2]][arg[1]] = 2;
        end
        if #self.CinematicEventQueue[arg[2]] > 0 then
            --- @diagnostic disable-next-line: param-type-mismatch
            ActivateImageScreen(arg[2], "", 0, 0, 0, 255);
            --- @diagnostic disable-next-line: param-type-mismatch
            DeactivateNormalInterface(arg[2]);
        end
    end
end

-- -------------------------------------------------------------------------- --

function Lib.UIEffects.Global:PushCinematicEventToQueue(_PlayerID, _Type, _Name, _Data)
    table.insert(self.CinematicEventQueue[_PlayerID], {_Type, _Name, _Data});
end

function Lib.UIEffects.Global:LookUpCinematicInQueue(_PlayerID)
    if #self.CinematicEventQueue[_PlayerID] > 0 then
        return self.CinematicEventQueue[_PlayerID][1];
    end
end

function Lib.UIEffects.Global:PopCinematicEventFromQueue(_PlayerID)
    if #self.CinematicEventQueue[_PlayerID] > 0 then
        return table.remove(self.CinematicEventQueue[_PlayerID], 1);
    end
end

function Lib.UIEffects.Global:GetNewCinematicEventID()
    self.CinematicEventID = self.CinematicEventID +1;
    return self.CinematicEventID;
end

function Lib.UIEffects.Global:GetCinematicEventStatus(_InfoID)
    for i= 1, 8 do
        if self.CinematicEventStatus[i][_InfoID] then
            return self.CinematicEventStatus[i][_InfoID];
        end
    end
    return 0;
end

function Lib.UIEffects.Global:ActivateCinematicEvent(_PlayerID)
    local ID = self:GetNewCinematicEventID();
    SendReport(Report.CinematicActivated, ID, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[SendReport(Report.CinematicActivated, %d, %d);
          if GUI.GetPlayerID() == %d then
            Lib.UIEffects.Local.SavingWasDisabled = Lib.Core.Save.SavingDisabled == true;
            DisableSaving(true);
          end]],
        ID,
        _PlayerID,
        _PlayerID
    ))
    return ID;
end

function Lib.UIEffects.Global:ConcludeCinematicEvent(_ID, _PlayerID)
    SendReport(Report.CinematicConcluded, _ID, _PlayerID);
    Logic.ExecuteInLuaLocalState(string.format(
        [[SendReport(Report.CinematicConcluded, %d, %d);
          if GUI.GetPlayerID() == %d then
            if not Lib.UIEffects.Local.SavingWasDisabled then
                DisableSaving(false);
            end
            Lib.UIEffects.Local.SavingWasDisabled = false;
          end]],
        _ID,
        _PlayerID,
        _PlayerID
    ))
end

-- -------------------------------------------------------------------------- --

function Lib.UIEffects.Global:StartTypewriter(_Data)
    self.TypewriterEventCounter = self.TypewriterEventCounter +1;
    local EventName = "CinematicEvent_Typewriter" ..self.TypewriterEventCounter;
    _Data.Name = EventName;
    if not self.LoadscreenClosed or IsCinematicEventActive(_Data.PlayerID) then
        Lib.UIEffects.Global:PushCinematicEventToQueue(
            _Data.PlayerID,
            CinematicEventTypes.Typewriter,
            EventName,
            _Data
        );
        return _Data.Name;
    end
    return self:PlayTypewriter(_Data);
end

function Lib.UIEffects.Global:PlayTypewriter(_Data)
    local ID = StartCinematicEvent(_Data.Name, _Data.PlayerID);
    _Data.ID = ID;
    _Data.TextTokens = self:TokenizeText(_Data);
    self.TypewriterEventData[_Data.PlayerID] = _Data;

    ExecuteLocal(
        [[
        if GUI.GetPlayerID() == %d then
            ActivateImageScreen(GUI.GetPlayerID(), "%s", %d, %d, %d, %d)
            DeactivateNormalInterface(GUI.GetPlayerID())
            DeactivateBorderScroll(GUI.GetPlayerID(), %d)
            Input.CutsceneMode()
            GUI.ClearNotes()
        end
        ]],
        _Data.PlayerID,
        _Data.Image,
        _Data.Color.R or 0,
        _Data.Color.G or 0,
        _Data.Color.B or 0,
        _Data.Color.A or 255,
        _Data.TargetEntity
    );

    SendReport(Report.TypewriterStarted, _Data.PlayerID, _Data.Name);
    SendReportToLocal(Report.TypewriterStarted, _Data.PlayerID, _Data.Name);
    return _Data.Name;
end

function Lib.UIEffects.Global:FinishTypewriter(_PlayerID)
    if self.TypewriterEventData[_PlayerID] then
        local EventData = table.copy(self.TypewriterEventData[_PlayerID]);
        local EventPlayer = self.TypewriterEventData[_PlayerID].PlayerID;

        ExecuteLocal([[
            if GUI.GetPlayerID() == %d then
                ResetRenderDistance()
                DeactivateImageScreen(GUI.GetPlayerID())
                ActivateNormalInterface(GUI.GetPlayerID())
                ActivateBorderScroll(GUI.GetPlayerID())
                if ModuleGuiControl then
                    Lib.UITools.Widget:UpdateHiddenWidgets()
                end
                Input.GameMode()
                GUI.ClearNotes()
            end
        ]], _PlayerID);

        SendReport(Report.TypewriterEnded, EventPlayer, EventData.Name);
        SendReportToLocal(Report.TypewriterEnded, EventPlayer, EventData.Name);
        self.TypewriterEventData[_PlayerID]:Callback();
        FinishCinematicEvent(EventData.Name, EventPlayer);
        self.TypewriterEventData[_PlayerID] = nil;
    end
end

function Lib.UIEffects.Global:TokenizeText(_Data)
    local TextTokens = {};
    local TempTokens = {};
    local Text = ConvertPlaceholders(Localize(_Data.Text));
    Text = Text:gsub("%s+", " ");
    while (true) do
        local s1, e1 = Text:find("{");
        local s2, e2 = Text:find("}");
        if not s1 or not s2 then
            table.insert(TempTokens, Text);
            break;
        end
        if s1 > 1 then
            table.insert(TempTokens, Text:sub(1, s1 -1));
        end
        table.insert(TempTokens, Text:sub(s1, e2));
        Text = Text:sub(e2 +1);
    end

    local LastWasPlaceholder = false;
    for i= 1, #TempTokens, 1 do
        if TempTokens[i]:find("{") then
            local Index = #TextTokens;
            if LastWasPlaceholder then
                TextTokens[Index] = TextTokens[Index] .. TempTokens[i];
            else
                table.insert(TextTokens, Index+1, TempTokens[i]);
            end
            LastWasPlaceholder = true;
        else
            local Index = 1;
            while (Index <= #TempTokens[i]) do
                if string.byte(TempTokens[i]:sub(Index, Index)) == 195 then
                    table.insert(TextTokens, TempTokens[i]:sub(Index, Index+1));
                    Index = Index +1;
                else
                    table.insert(TextTokens, TempTokens[i]:sub(Index, Index));
                end
                Index = Index +1;
            end
            LastWasPlaceholder = false;
        end
    end
    return TextTokens;
end

function Lib.UIEffects.Global:ControlTypewriter()
    -- Check queue for next event
    for i= 1, 8 do
        if self.LoadscreenClosed and not IsCinematicEventActive(i) then
            local Next = Lib.UIEffects.Global:LookUpCinematicInQueue(i);
            if Next and Next[1] == CinematicEventTypes.Typewriter then
                local Data = Lib.UIEffects.Global:PopCinematicEventFromQueue(i);
                self:PlayTypewriter(Data[3]);
            end
        end
    end

    -- Perform active events
    for k, v in pairs(self.TypewriterEventData) do
        if self.TypewriterEventData[k].Delay > 0 then
            self.TypewriterEventData[k].Delay = self.TypewriterEventData[k].Delay -1;

            ExecuteLocal(
                [[if GUI.GetPlayerID() == %d then GUI.ClearNotes() end]],
                self.TypewriterEventData[k].PlayerID
            );
        end
        if self.TypewriterEventData[k].Delay == 0 then
            self.TypewriterEventData[k].Index = v.Index + v.CharSpeed;
            if v.Index > #self.TypewriterEventData[k].TextTokens then
                self.TypewriterEventData[k].Index = #self.TypewriterEventData[k].TextTokens;
            end
            local Index = math.floor(v.Index + 0.5);
            local Text = "";
            for i= 1, Index, 1 do
                Text = Text .. self.TypewriterEventData[k].TextTokens[i];
            end

            ExecuteLocal(
                [[
                if GUI.GetPlayerID() == %d then
                    GUI.ClearNotes()
                    GUI.AddNote("%s")
                end
                ]],
                self.TypewriterEventData[k].PlayerID,
                Text
            );

            if Index == #self.TypewriterEventData[k].TextTokens then
                self.TypewriterEventData[k].Waittime = v.Waittime -1;
                if v.Waittime <= 0 then
                    self:FinishTypewriter(k);
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.UIEffects.Local:Initialize()
    if not self.IsInstalled then
        -- public reports
        Report.CinematicActivated = CreateReport("Event_CinematicEventActivated");
        Report.CinematicConcluded = CreateReport("Event_CinematicEventConcluded");
        Report.GameInterfaceShown = CreateReport("Event_GameInterfaceShown");
        Report.GameInterfaceHidden = CreateReport("Event_GameInterfaceHidden");
        Report.ImageScreenShown = CreateReport("Event_ImageScreenShown");

        -- internal reports
        Report.ImageScreenHidden = CreateReport("Event_ImageScreenHidden");
        Report.TypewriterStarted = CreateReport("Event_TypewriterStarted");
        Report.TypewriterEnded = CreateReport("Event_TypewriterEnded");

        for i= 1, 8 do
            self.CinematicEventStatus[i] = {};
        end
        self:OverrideInterfaceUpdateForCinematicMode();
        self:OverrideInterfaceThroneroomForCinematicMode();

        -- Garbage collection
        Lib.UIEffects.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.UIEffects.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.UIEffects.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.CinematicActivated then
        self.CinematicEventStatus[arg[2]][arg[1]] = 1;
    elseif _ID == Report.CinematicConcluded then
        for i= 1, 8 do
            if self.CinematicEventStatus[i][arg[1]] then
                self.CinematicEventStatus[i][arg[1]] = 2;
            end
        end
    end
end

function Lib.UIEffects.Local:GetCinematicEventStatus(_InfoID)
    for i= 1, 8 do
        if self.CinematicEventStatus[i][_InfoID] then
            return self.CinematicEventStatus[i][_InfoID];
        end
    end
    return 0;
end

function Lib.UIEffects.Local:OverrideInterfaceUpdateForCinematicMode()
    GameCallback_GameSpeedChanged_Orig_UIEffects = GameCallback_GameSpeedChanged;
    GameCallback_GameSpeedChanged = function(_Speed)
        if not Lib.UIEffects.Local.PauseScreenShown then
            GameCallback_GameSpeedChanged_Orig_UIEffects(_Speed);
        end
    end

    MissionTimerUpdate_Orig_UIEffects = MissionTimerUpdate;
    MissionTimerUpdate = function()
        MissionTimerUpdate_Orig_UIEffects();
        if Lib.UIEffects.Local.NormalModeHidden
        or Lib.UIEffects.Local.PauseScreenShown then
            XGUIEng.ShowWidget("/InGame/Root/Normal/MissionTimer", 0);
        end
    end

    MissionGoodOrEntityCounterUpdate_Orig_UIEffects = MissionGoodOrEntityCounterUpdate;
    MissionGoodOrEntityCounterUpdate = function()
        MissionGoodOrEntityCounterUpdate_Orig_UIEffects();
        if Lib.UIEffects.Local.NormalModeHidden
        or Lib.UIEffects.Local.PauseScreenShown then
            XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 0);
        end
    end

    MerchantButtonsUpdater_Orig_UIEffects = GUI_Merchant.ButtonsUpdater;
    GUI_Merchant.ButtonsUpdater = function()
        MerchantButtonsUpdater_Orig_UIEffects();
        if Lib.UIEffects.Local.NormalModeHidden
        or Lib.UIEffects.Local.PauseScreenShown then
            XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant", 0);
        end
    end

    if GUI_Tradepost then
        TradepostButtonsUpdater_Orig_UIEffects = GUI_Tradepost.ButtonsUpdater;
        GUI_Tradepost.ButtonsUpdater = function()
            TradepostButtonsUpdater_Orig_UIEffects();
            if Lib.UIEffects.Local.NormalModeHidden
            or Lib.UIEffects.Local.PauseScreenShown then
                XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost", 0);
            end
        end
    end
end

function Lib.UIEffects.Local:OverrideInterfaceThroneroomForCinematicMode()
    GameCallback_Camera_StartButtonPressed = function(_PlayerID)
    end
    OnStartButtonPressed = function()
        GameCallback_Camera_StartButtonPressed(GUI.GetPlayerID());
    end

    GameCallback_Camera_BackButtonPressed = function(_PlayerID)
    end
    OnBackButtonPressed = function()
        GameCallback_Camera_BackButtonPressed(GUI.GetPlayerID());
    end

    GameCallback_Camera_SkipButtonPressed = function(_PlayerID)
    end
    OnSkipButtonPressed = function()
        GameCallback_Camera_SkipButtonPressed(GUI.GetPlayerID());
    end

    GameCallback_Camera_ThroneRoomLeftClick = function(_PlayerID)
    end
    ThroneRoomLeftClick = function()
        GameCallback_Camera_ThroneRoomLeftClick(GUI.GetPlayerID());
    end

    GameCallback_Camera_ThroneroomCameraControl = function(_PlayerID)
    end
    ThroneRoomCameraControl = function()
        GameCallback_Camera_ThroneroomCameraControl(GUI.GetPlayerID());
    end
end

function Lib.UIEffects.Local:InterfaceActivateImageBackground(_PlayerID, _Graphic, _R, _G, _B, _A)
    if _PlayerID ~= GUI.GetPlayerID() or self.PauseScreenShown then
        return;
    end

    XGUIEng.PushPage("/InGame/Root/Normal/PauseScreen", false);
    XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen", 1);
    if _Graphic and _Graphic ~= "" then
        local Size = {GUI.GetScreenSize()};
        local u0, v0, u1, v1 = 0, 0, 1, 1;
        if Size[1]/Size[2] < 1.6 then
            u0 = u0 + (u0 / 0.125);
            u1 = u1 - (u1 * 0.125);
        end
        XGUIEng.SetMaterialTexture("/InGame/Root/Normal/PauseScreen", 0, _Graphic);
        XGUIEng.SetMaterialUV("/InGame/Root/Normal/PauseScreen", 0, u0, v0, u1, v1);
    end
    XGUIEng.SetMaterialColor("/InGame/Root/Normal/PauseScreen", 0, _R, _G, _B, _A);
    SendReportToGlobal(Report.ImageScreenShown, _PlayerID);
    SendReport(Report.ImageScreenShown, _PlayerID);
    self.PauseScreenShown = true;
end

function Lib.UIEffects.Local:InterfaceDeactivateImageBackground(_PlayerID)
    if _PlayerID ~= GUI.GetPlayerID() or not self.PauseScreenShown then
        return;
    end

    XGUIEng.ShowWidget("/InGame/Root/Normal/PauseScreen", 0);
    XGUIEng.SetMaterialTexture("/InGame/Root/Normal/PauseScreen", 0, "");
    XGUIEng.SetMaterialColor("/InGame/Root/Normal/PauseScreen", 0, 40, 40, 40, 180);
    XGUIEng.PopPage();
    SendReportToGlobal(Report.ImageScreenHidden, _PlayerID);
    SendReport(Report.ImageScreenHidden, _PlayerID);
    self.PauseScreenShown = false;
end

function Lib.UIEffects.Local:InterfaceDeactivateNormalInterface(_PlayerID)
    if GUI.GetPlayerID() ~= _PlayerID or self.NormalModeHidden then
        return;
    end

    XGUIEng.PushPage("/InGame/Root/Normal/NotesWindow", false);
    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/TextMessages", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechStartAgainOrStop", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopRight", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/UpdateFunction", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/Buttons", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestLogButton", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestTimers", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MissionTimer", 0);
    HideOtherMenus();
    if XGUIEng.IsWidgetShown("/InGame/Root/Normal/AlignTopLeft/GameClock") == 1 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock", 0);
        self.GameClockWasShown = true;
    end
    if XGUIEng.IsWidgetShownEx("/InGame/Root/Normal/ChatOptions/Background") == 1 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions", 0);
        self.ChatOptionsWasShown = true;
    end
    if XGUIEng.IsWidgetShownEx("/InGame/Root/Normal/MessageLog/Name") == 1 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog", 0);
        self.MessageLogWasShown = true;
    end
    if g_GameExtraNo > 0 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost", 0);
    end

    SendReportToGlobal(Report.GameInterfaceHidden, GUI.GetPlayerID());
    SendReport(Report.GameInterfaceHidden, GUI.GetPlayerID());
    self.NormalModeHidden = true;
end

function Lib.UIEffects.Local:InterfaceActivateNormalInterface(_PlayerID)
    if GUI.GetPlayerID() ~= _PlayerID or not self.NormalModeHidden then
        return;
    end

    XGUIEng.ShowWidget("/InGame/Root/Normal", 1);
    XGUIEng.ShowWidget("/InGame/Root/3dOnScreenDisplay", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechStartAgainOrStop", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopRight", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/TopBar/UpdateFunction", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/Buttons", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestLogButton", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/QuestTimers", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Merchant", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message", 1);
    XGUIEng.PopPage();

    -- Timer
    if g_MissionTimerEndTime then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MissionTimer", 1);
    end
    -- Counter
    if g_MissionGoodOrEntityCounterAmountToReach then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MissionGoodOrEntityCounter", 1);
    end
    -- Debug Clock
    if self.GameClockWasShown then
        XGUIEng.ShowWidget("/InGame/Root/Normal/AlignTopLeft/GameClock", 1);
        self.GameClockWasShown = false;
    end
    -- Chat Options
    if self.ChatOptionsWasShown then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions", 1);
        self.ChatOptionsWasShown = false;
    end
    -- Message Log
    if self.MessageLogWasShown then
        XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog", 1);
        self.MessageLogWasShown = false;
    end
    -- Handelsposten
    if g_GameExtraNo > 0 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/Selected_Tradepost", 1);
    end

    SendReportToGlobal(Report.GameInterfaceShown, GUI.GetPlayerID());
    SendReport(Report.GameInterfaceShown, GUI.GetPlayerID());
    self.NormalModeHidden = false;
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.UIEffects.Name);

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/ui/UIBuilding_API");

function AddBuildingButtonAtPosition(_X, _Y, _Action, _Tooltip, _Update)
    assert(IsLocalScript());
    Lib.UIBuilding.AquireContext();
    local Button = this:AddButtonBinding(0, _X, _Y, _Action, _Tooltip, _Update);
    Lib.UIBuilding.ReleaseContext();
    return Button;
end
API.AddBuildingButtonAtPosition = AddBuildingButtonAtPosition;

function AddBuildingButton(_Action, _Tooltip, _Update)
    ---@diagnostic disable-next-line: param-type-mismatch
    return AddBuildingButtonAtPosition(nil, nil, _Action, _Tooltip, _Update);
end
API.AddBuildingButton = AddBuildingButton;

function AddBuildingButtonByTypeAtPosition(_Type, _X, _Y, _Action, _Tooltip, _Update)
    assert(IsLocalScript());
    Lib.UIBuilding.AquireContext();
    local Button = this:AddButtonBinding(_Type, _X, _Y, _Action, _Tooltip, _Update);
    Lib.UIBuilding.ReleaseContext();
    return Button;
end
API.AddBuildingButtonByTypeAtPosition = AddBuildingButtonByTypeAtPosition;

function AddBuildingButtonByType(_Type, _Action, _Tooltip, _Update)
    ---@diagnostic disable-next-line: param-type-mismatch
    return AddBuildingButtonByTypeAtPosition(_Type, nil, nil, _Action, _Tooltip, _Update);
end
API.AddBuildingButtonByType = AddBuildingButtonByType;

function AddBuildingButtonByEntityAtPosition(_ScriptName, _X, _Y, _Action, _Tooltip, _Update)
    assert(IsLocalScript());
    Lib.UIBuilding.AquireContext();
    local Button = this:AddButtonBinding(_ScriptName, _X, _Y, _Action, _Tooltip, _Update);
    Lib.UIBuilding.ReleaseContext();
    return Button;
end
API.AddBuildingButtonByEntityAtPosition = AddBuildingButtonByEntityAtPosition;

function AddBuildingButtonByEntity(_ScriptName, _Action, _Tooltip, _Update)
    ---@diagnostic disable-next-line: param-type-mismatch
    return AddBuildingButtonByEntityAtPosition(_ScriptName, nil, nil, _Action, _Tooltip, _Update);
end
API.AddBuildingButtonByEntity = AddBuildingButtonByEntity;

function DropBuildingButton(_ID)
    assert(IsLocalScript());
    Lib.UIBuilding.AquireContext();
    this:RemoveButtonBinding(0, _ID);
    Lib.UIBuilding.ReleaseContext();
end
API.DropBuildingButton = DropBuildingButton;

function DropBuildingButtonFromType(_Type, _ID)
    assert(IsLocalScript());
    Lib.UIBuilding.AquireContext();
    this:RemoveButtonBinding(_Type, _ID);
    Lib.UIBuilding.ReleaseContext();
end
API.DropBuildingButtonFromType = DropBuildingButtonFromType;

function DropBuildingButtonFromEntity(_ScriptName, _ID)
    assert(IsLocalScript());
    Lib.UIBuilding.AquireContext();
    this:RemoveButtonBinding(_ScriptName, _ID);
    Lib.UIBuilding.ReleaseContext();
end
API.DropBuildingButtonFromEntity = DropBuildingButtonFromEntity;

Lib.UIBuilding = Lib.UIBuilding or {};
Lib.UIBuilding.Name = "UIBuilding";
Lib.UIBuilding.CinematicEvents = {};
Lib.UIBuilding.Global = {};
Lib.UIBuilding.Local = {
    BuildingButtons = {
        BindingCounter = 0,
        Bindings = {},
        Configuration = {
            ["BuyAmmunitionCart"] = {
                TypeExclusion = "^B_.*StoreHouse",
                OriginalPosition = nil,
                Bind = nil,
            },
            ["BuyBattallion"] = {
                TypeExclusion = "^B_[CB]a[sr][tr][la][ec]",
                OriginalPosition = nil,
                Bind = nil,
            },
            ["PlaceField"] = {
                TypeExclusion = "^B_.*[BFH][aei][erv][kme]",
                OriginalPosition = nil,
                Bind = nil,
            },
            ["StartFestival"] = {
                TypeExclusion = "^B_Marketplace",
                OriginalPosition = nil,
                Bind = nil,
            },
            ["StartTheatrePlay"] = {
                TypeExclusion = "^B_Theatre",
                OriginalPosition = nil,
                Bind = nil,
            },
            ["UpgradeTurret"] = {
                TypeExclusion = "^B_WallTurret",
                OriginalPosition = nil,
                Bind = nil,
            },
            ["BuyBatteringRamCart"] = {
                TypeExclusion = "^B_SiegeEngineWorkshop",
                OriginalPosition = nil,
                Bind = nil,
            },
            ["BuyCatapultCart"] = {
                TypeExclusion = "^B_SiegeEngineWorkshop",
                OriginalPosition = nil,
                Bind = nil,
            },
            ["BuySiegeTowerCart"] = {
                TypeExclusion = "^B_SiegeEngineWorkshop",
                OriginalPosition = nil,
                Bind = nil,
            },
        },
    },
};

Lib.Require("core/Core");
Lib.Require("module/ui/UIBuilding_API");
Lib.Register("module/ui/UIBuilding");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.UIBuilding.Global:Initialize()
    if not self.IsInstalled then
        --- The player clicked the cancel upgrade button.
        --- 
        --- #### Parameter
        --- * `EntityID` - ID of building
        --- * `PlayerID` - ID of owner
        Report.CancelUpgradeClicked = CreateReport("Event_CancelUpgradeClicked");

        --- The player clicked the start upgrade button.
        --- 
        --- #### Parameter
        --- * `EntityID` - ID of building
        --- * `PlayerID` - ID of owner
        Report.StartUpgradeClicked = CreateReport("Event_StartUpgradeClicked");

        --- The player clicked the start festival button.
        --- 
        --- #### Parameter
        --- * `PlayerID` - ID of player
        --- * `Type`     - Type of festival
        Report.FestivalClicked = CreateReport("Event_FestivalClicked");

        --- The player clicked the start sermon button.
        --- 
        --- #### Parameter
        --- * `PlayerID` - ID of player
        Report.SermonClicked = CreateReport("Event_SermonClicked");

        --- The player clicked the start theatre play button.
        --- 
        --- #### Parameter
        --- * `EntityID` - ID of building
        --- * `PlayerID` - ID of owner
        Report.TheatrePlayClicked = CreateReport("Event_TheatrePlayClicked");
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.UIBuilding.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.UIBuilding.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.StartUpgradeClicked then
        SendReportToLocal(_ID, unpack(arg));
    elseif _ID == Report.CancelUpgradeClicked then
        SendReportToLocal(_ID, unpack(arg));
    elseif _ID == Report.FestivalClicked then
        SendReportToLocal(_ID, unpack(arg));
    elseif _ID == Report.SermonClicked then
        SendReportToLocal(_ID, unpack(arg));
    elseif _ID == Report.TheatrePlayClicked then
        SendReportToLocal(_ID, unpack(arg));
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.UIBuilding.Local:Initialize()
    if not self.IsInstalled then
        Report.CancelUpgradeClicked = CreateReport("Event_CancelUpgradeClicked");
        Report.StartUpgradeClicked = CreateReport("Event_StartUpgradeClicked");
        Report.FestivalClicked = CreateReport("Event_FestivalClicked");
        Report.SermonClicked = CreateReport("Event_SermonClicked");
        Report.TheatrePlayClicked = CreateReport("Event_TheatrePlayClicked");

        self:InitBackupPositions();
        self:OverrideOnSelectionChanged();
        self:OverrideBuyAmmunitionCart();
        self:OverrideBuyBattalion();
        self:OverrideBuySiegeEngineCart();
        self:OverridePlaceField();
        self:OverrideStartFestival();
        self:OverrideStartTheatrePlay();
        self:OverrideUpgradeTurret();
        self:OverrideUpgradeBuilding();
        self:OverrideStartSermon();
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.UIBuilding.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.UIBuilding.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

function Lib.UIBuilding.Local:OverrideOnSelectionChanged()
    self.Orig_GameCallback_GUI_SelectionChanged = GameCallback_GUI_SelectionChanged;
    GameCallback_GUI_SelectionChanged = function(_Source)
        Lib.UIBuilding.Local.Orig_GameCallback_GUI_SelectionChanged(_Source);
        Lib.UIBuilding.Local:UnbindButtons();
        Lib.UIBuilding.Local:BindButtons(GUI.GetSelectedEntity());
    end
end

function Lib.UIBuilding.Local:OverrideBuyAmmunitionCart()
    self.Orig_BuyAmmunitionCartClicked = GUI_BuildingButtons.BuyAmmunitionCartClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.BuyAmmunitionCartClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return Lib.UIBuilding.Local.Orig_BuyAmmunitionCartClicked();
        end
        Button.Action(WidgetID, EntityID);
    end

    Lib.UIBuilding.Local.Orig_BuyAmmunitionCartUpdate = GUI_BuildingButtons.BuyAmmunitionCartUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.BuyAmmunitionCartUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            SetIcon(WidgetID, {10, 4});
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return Lib.UIBuilding.Local.Orig_BuyAmmunitionCartUpdate();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function Lib.UIBuilding.Local:OverrideBuyBattalion()
    self.Orig_BuyBattalionClicked = GUI_BuildingButtons.BuyBattalionClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.BuyBattalionClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return Lib.UIBuilding.Local.Orig_BuyBattalionClicked();
        end
        Button.Action(WidgetID, EntityID);
    end

    self.Orig_BuyBattalionMouseOver = GUI_BuildingButtons.BuyBattalionMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.BuyBattalionMouseOver = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button;
        if Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName] then
            Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        end
        if not Button then
            return Lib.UIBuilding.Local.Orig_BuyBattalionMouseOver();
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    self.Orig_BuyBattalionUpdate = GUI_BuildingButtons.BuyBattalionUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.BuyBattalionUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return Lib.UIBuilding.Local.Orig_BuyBattalionUpdate();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function Lib.UIBuilding.Local:OverridePlaceField()
    self.Orig_PlaceFieldClicked = GUI_BuildingButtons.PlaceFieldClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.PlaceFieldClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return Lib.UIBuilding.Local.Orig_PlaceFieldClicked();
        end
        Button.Action(WidgetID, EntityID);
    end

    self.Orig_PlaceFieldMouseOver = GUI_BuildingButtons.PlaceFieldMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.PlaceFieldMouseOver = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return Lib.UIBuilding.Local.Orig_PlaceFieldMouseOver();
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    self.Orig_PlaceFieldUpdate = GUI_BuildingButtons.PlaceFieldUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.PlaceFieldUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return Lib.UIBuilding.Local.Orig_PlaceFieldUpdate();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function Lib.UIBuilding.Local:OverrideStartFestival()
    self.Orig_StartKnightsPromotionCelebration = StartKnightsPromotionCelebration;
    StartKnightsPromotionCelebration = function(_PlayerID, _OldTitle, _FirstTime)
        Lib.UIBuilding.Local.Orig_StartKnightsPromotionCelebration(_PlayerID, _OldTitle, _FirstTime);
        SendReportToGlobal(Report.FestivalClicked, _PlayerID, 1);
    end

    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.StartFestivalClicked = function(_FestivalIndex)
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            local PlayerID = GUI.GetPlayerID();
            local Costs = {Logic.GetFestivalCost(PlayerID, _FestivalIndex)};
            local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs);
            if EntityID ~= Logic.GetMarketplace(PlayerID) then
                return;
            end
            if CanBuyBoolean == true then
                Sound.FXPlay2DSound("ui\\menu_click");
                GUI.StartFestival(PlayerID, _FestivalIndex);
                StartEventMusic(MusicSystem.EventFestivalMusic, PlayerID);
                StartKnightVoiceForPermanentSpecialAbility(Entities.U_KnightSong);
                GUI.AddBuff(Buffs.Buff_Festival);
                SendReportToGlobal(Report.FestivalClicked, PlayerID, 0);
            else
                Message(CanNotBuyString);
            end
            return;
        end
        Button.Action(WidgetID, EntityID);
    end

    self.Orig_StartFestivalMouseOver = GUI_BuildingButtons.StartFestivalMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.StartFestivalMouseOver = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return Lib.UIBuilding.Local.Orig_StartFestivalMouseOver();
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    self.Orig_StartFestivalUpdate = GUI_BuildingButtons.StartFestivalUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.StartFestivalUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            SetIcon(WidgetID, {4, 15});
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return Lib.UIBuilding.Local.Orig_StartFestivalUpdate();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function Lib.UIBuilding.Local:OverrideStartTheatrePlay()
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.StartTheatrePlayClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            local PlayerID = GUI.GetPlayerID();
            local GoodType = Logic.GetGoodTypeOnOutStockByIndex(EntityID, 0);
            local Amount = Logic.GetMaxAmountOnStock(EntityID);
            local Costs = {GoodType, Amount};
            local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs);
            if Logic.CanStartTheatrePlay(EntityID) == true then
                Sound.FXPlay2DSound("ui\\menu_click");
                GUI.StartTheatrePlay(EntityID);
                SendReportToGlobal(Report.TheatrePlayClicked, PlayerID);
            elseif CanBuyBoolean == false then
                Message(CanNotBuyString);
            end
            return;
        end
        Button.Action(WidgetID, EntityID);
    end

    self.Orig_StartTheatrePlayMouseOver = GUI_BuildingButtons.StartTheatrePlayMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.StartTheatrePlayMouseOver = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return Lib.UIBuilding.Local.Orig_StartTheatrePlayMouseOver();
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    self.Orig_StartTheatrePlayUpdate = GUI_BuildingButtons.StartTheatrePlayUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.StartTheatrePlayUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            SetIcon(WidgetID, {16, 2});
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return Lib.UIBuilding.Local.Orig_StartTheatrePlayUpdate();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function Lib.UIBuilding.Local:OverrideUpgradeTurret()
    self.Orig_UpgradeTurretClicked = GUI_BuildingButtons.UpgradeTurretClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.UpgradeTurretClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return Lib.UIBuilding.Local.Orig_UpgradeTurretClicked();
        end
        Button.Action(WidgetID, EntityID);
    end

    self.Orig_UpgradeTurretMouseOver = GUI_BuildingButtons.UpgradeTurretMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.UpgradeTurretMouseOver = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            return Lib.UIBuilding.Local.Orig_UpgradeTurretMouseOver();
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    self.Orig_UpgradeTurretUpdate = GUI_BuildingButtons.UpgradeTurretUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.UpgradeTurretUpdate = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        if not Button then
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return Lib.UIBuilding.Local.Orig_UpgradeTurretUpdate();
        end
        Button.Update(WidgetID, EntityID);
    end
end

function Lib.UIBuilding.Local:OverrideBuySiegeEngineCart()
    self.Orig_BuySiegeEngineCartClicked = GUI_BuildingButtons.BuySiegeEngineCartClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.BuySiegeEngineCartClicked = function(_EntityType)
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button;
        if WidgetName == "BuyCatapultCart"
        or WidgetName == "BuySiegeTowerCart"
        or WidgetName == "BuyBatteringRamCart" then
            Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        end
        if not Button then
            return Lib.UIBuilding.Local.Orig_BuySiegeEngineCartClicked(_EntityType);
        end
        Button.Action(WidgetID, EntityID);
    end

    self.Orig_BuySiegeEngineCartMouseOver = GUI_BuildingButtons.BuySiegeEngineCartMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.BuySiegeEngineCartMouseOver = function(_EntityType, _Right)
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button;
        if WidgetName == "BuyCatapultCart"
        or WidgetName == "BuySiegeTowerCart"
        or WidgetName == "BuyBatteringRamCart" then
            Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        end
        if not Button then
            return Lib.UIBuilding.Local.Orig_BuySiegeEngineCartMouseOver(_EntityType, _Right);
        end
        Button.Tooltip(WidgetID, EntityID);
    end

    self.Orig_BuySiegeEngineCartUpdate = GUI_BuildingButtons.BuySiegeEngineCartUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.BuySiegeEngineCartUpdate = function(_EntityType)
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local WidgetName = XGUIEng.GetWidgetNameByID(WidgetID);
        local EntityID = GUI.GetSelectedEntity();
        local Button;
        if WidgetName == "BuyCatapultCart"
        or WidgetName == "BuySiegeTowerCart"
        or WidgetName == "BuyBatteringRamCart" then
            Button = Lib.UIBuilding.Local.BuildingButtons.Configuration[WidgetName].Bind;
        end
        if not Button then
            if WidgetName == "BuyBatteringRamCart" then
                SetIcon(WidgetID, {9, 2});
            elseif WidgetName == "BuySiegeTowerCart" then
                SetIcon(WidgetID, {9, 3});
            elseif WidgetName == "BuyCatapultCart" then
                SetIcon(WidgetID, {9, 1});
            end
            XGUIEng.ShowWidget(WidgetID, 1);
            XGUIEng.DisableButton(WidgetID, 0);
            return Lib.UIBuilding.Local.Orig_BuySiegeEngineCartUpdate(_EntityType);
        end
        Button.Update(WidgetID, EntityID);
    end
end

function Lib.UIBuilding.Local:OverrideUpgradeBuilding()
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.UpgradeClicked = function()
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local EntityID = GUI.GetSelectedEntity();
        if Logic.CanCancelUpgradeBuilding(EntityID) then
            Sound.FXPlay2DSound("ui\\menu_click");
            GUI.CancelBuildingUpgrade(EntityID);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/BuildingButtons", 1);
            SendReportToGlobal(Report.CancelUpgradeClicked, EntityID, GUI.GetPlayerID());
            return;
        end
        local Costs = GUI_BuildingButtons.GetUpgradeCosts();
        local CanBuyBoolean, CanNotBuyString = AreCostsAffordable(Costs);
        if CanBuyBoolean == true then
            Sound.FXPlay2DSound("ui\\menu_click");
            GUI.UpgradeBuilding(EntityID, nil);
            StartKnightVoiceForPermanentSpecialAbility(Entities.U_KnightWisdom);
            if WidgetID ~= 0 then
                SaveButtonPressed(WidgetID);
            end
            SendReportToGlobal(Report.StartUpgradeClicked, EntityID, GUI.GetPlayerID());
        else
            Message(CanNotBuyString);
        end
    end
end

function Lib.UIBuilding.Local:OverrideStartSermon()
    --- @diagnostic disable-next-line: duplicate-set-field
    function GUI_BuildingButtons.StartSermonClicked()
        local PlayerID = GUI.GetPlayerID();
        if Logic.CanSermonBeActivated(PlayerID) then
            GUI.ActivateSermon(PlayerID);
            StartKnightVoiceForPermanentSpecialAbility(Entities.U_KnightHealing);
            GUI.AddBuff(Buffs.Buff_Sermon);
            local CathedralID = Logic.GetCathedral(PlayerID);
            local x, y = Logic.GetEntityPosition(CathedralID);
            local z = 0;
            Sound.FXPlay3DSound("buildings\\building_start_sermon", x, y, z);
            SendReportToGlobal(Report.SermonClicked, GUI.GetPlayerID());
        end
    end
end

-- -------------------------------------------------------------------------- --

function Lib.UIBuilding.Local:InitBackupPositions()
    for k, v in pairs(self.BuildingButtons.Configuration) do
        local x, y = XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/" ..k);
        self.BuildingButtons.Configuration[k].OriginalPosition = {x, y};
    end
end

function Lib.UIBuilding.Local:GetButtonsForOverwrite(_ID, _Amount)
    local Buttons = {};
    local Type = Logic.GetEntityType(_ID);
    local TypeName = Logic.GetEntityTypeName(Type);
    for k, v in pairs(self.BuildingButtons.Configuration) do
        if #Buttons == _Amount then
            break;
        end
        if not TypeName:find(v.TypeExclusion) then
            table.insert(Buttons, k);
        end
    end
    assert(#Buttons == _Amount);
    table.sort(Buttons);
    return Buttons;
end

function Lib.UIBuilding.Local:AddButtonBinding(_Type, _X, _Y, _ActionFunction, _TooltipController, _UpdateController)
    if not self.BuildingButtons.Bindings[_Type] then
        self.BuildingButtons.Bindings[_Type] = {};
    end
    if #self.BuildingButtons.Bindings[_Type] < 6 then
        self.BuildingButtons.BindingCounter = self.BuildingButtons.BindingCounter +1;
        table.insert(self.BuildingButtons.Bindings[_Type], {
            ID       = self.BuildingButtons.BindingCounter,
            Position = {_X, _Y},
            Action   = _ActionFunction,
            Tooltip  = _TooltipController,
            Update   = _UpdateController,
        });
        return self.BuildingButtons.BindingCounter;
    end
    return 0;
end

function Lib.UIBuilding.Local:RemoveButtonBinding(_Type, _ID)
    if not self.BuildingButtons.Bindings[_Type] then
        self.BuildingButtons.Bindings[_Type] = {};
    end
    for i= #self.BuildingButtons.Bindings[_Type], 1, -1 do
        if self.BuildingButtons.Bindings[_Type][i].ID == _ID then
            table.remove(self.BuildingButtons.Bindings[_Type], i);
        end
    end
end

function Lib.UIBuilding.Local:BindButtons(_ID)
    if _ID == nil or _ID == 0 or (Logic.IsBuilding(_ID) == 0 and not Logic.IsWall(_ID)) then
        return self:UnbindButtons();
    end
    local Name = Logic.GetEntityName(_ID);
    local Type = Logic.GetEntityType(_ID);

    local WidgetsForOverride = self:GetButtonsForOverwrite(_ID, 6);
    local ButtonOverride = {};
    -- Add buttons for named entity
    if self.BuildingButtons.Bindings[Name] and #self.BuildingButtons.Bindings[Name] > 0 then
        for i= 1, #self.BuildingButtons.Bindings[Name] do
            table.insert(ButtonOverride, self.BuildingButtons.Bindings[Name][i]);
        end
    end
    -- Add buttons for type
    if self.BuildingButtons.Bindings[Type] and #self.BuildingButtons.Bindings[Type] > 0 then
        for i= 1, #self.BuildingButtons.Bindings[Type] do
            table.insert(ButtonOverride, self.BuildingButtons.Bindings[Type][i]);
        end
    end
    -- Add buttons for all
    if self.BuildingButtons.Bindings[0] and #self.BuildingButtons.Bindings[0] > 0 then
        for i= 1, #self.BuildingButtons.Bindings[0] do
            table.insert(ButtonOverride, self.BuildingButtons.Bindings[0][i]);
        end
    end

    -- Place first six buttons (if present)
    for i= 1, #ButtonOverride do
        if i > 6 then
            break;
        end
        local ButtonName = WidgetsForOverride[i];
        self.BuildingButtons.Configuration[ButtonName].Bind = ButtonOverride[i];
        XGUIEng.ShowWidget("/InGame/Root/Normal/BuildingButtons/" ..ButtonName, 1);
        XGUIEng.DisableButton("/InGame/Root/Normal/BuildingButtons/" ..ButtonName, 0);
        local X = ButtonOverride[i].Position[1];
        local Y = ButtonOverride[i].Position[2];
        if not X or not Y then
            local AnchorPosition = {15, 296};
            X = AnchorPosition[1] + (64 * (i-1));
            Y = AnchorPosition[2];
        end
        XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/" ..ButtonName, X, Y);
    end
end

function Lib.UIBuilding.Local:UnbindButtons()
    for k, v in pairs(self.BuildingButtons.Configuration) do
        local Position = self.BuildingButtons.Configuration[k].OriginalPosition;
        if Position then
            XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/" ..k, Position[1], Position[2]);
        end
        self.BuildingButtons.Configuration[k].Bind = nil;
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.UIBuilding.Name);

Lib.Register("module/city/Construction_Text");

Lib.Construction = Lib.Construction or {};
Lib.Construction.Text = {
    NoKnockdown = {
        de = "Das kann nicht abgerissen werden!",
        en = "This cannot be demolished!",
        fr = "Cela ne peut pas être démoli!",
    },
    NoRoad = {
        de = "Straßen sind hier nicht möglich!",
        en = "Roads are not possible here!",
        fr = "Les routes ne sont pas possibles ici!",
    },
    NoWall = {
        de = "Befästigungen sind hier nicht möglich!",
        en = "Ramparts are not possible here!",
        fr = "Les confirmations ne sont pas possibles ici!",
    },
    NoWallGate = {
        de = "Ein anderes Torhaus ist zu nah!",
        en = "Another gatehouse is too close!",
        fr = "Une autre guérite est trop proche!",
    },
    NoBallista = {
        de = "Zu nahe an anderem Mauerkatapult!",
        en = "To close to another ballista!",
        fr = "A rapprocher d'une autre baliste!",
    },
};

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/city/Construction_API");

function UseForceBallistaDistance(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("UseForceBallistaDistance(%s)", tostring(_Flag == true));
    end
    Lib.Construction.AquireContext();
    this.Construction.ForceBallistaDistance = _Flag == true;
    Lib.Construction.ReleaseContext();
end
API.UseForceBallistaDistance = UseForceBallistaDistance;

function CustomRuleConstructBuilding(_PlayerID, _FunctionName, ...)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:CustomRuleConstructBuilding(_PlayerID, _FunctionName, unpack(arg));
end
API.CustomRuleConstructBuilding = CustomRuleConstructBuilding;

function CustomRuleConstructRoad(_PlayerID, _FunctionName, ...)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:CustomRuleConstructRoad(_PlayerID, _FunctionName, unpack(arg));
end
API.CustomRuleConstructRoad = CustomRuleConstructRoad;

function CustomRuleConstructWall(_PlayerID, _FunctionName, ...)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:CustomRuleConstructWall(_PlayerID, _FunctionName, unpack(arg));
end
API.CustomRuleConstructWall = CustomRuleConstructWall;

function CustomRuleKnockdownBuilding(_PlayerID, _FunctionName, ...)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:CustomRuleKnockdownBuilding(_PlayerID, _FunctionName, unpack(arg));
end
API.CustomRuleKnockdownBuilding = CustomRuleKnockdownBuilding;

function WhitelistConstructTypeInArea(_PlayerID, _Type, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistConstructTypeInArea(_PlayerID, _Type, _X, _Y, _Area);
end
API.WhitelistConstructTypeInArea = WhitelistConstructTypeInArea;

function WhitelistConstructCategoryInArea(_PlayerID, _Category, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistConstructCategoryInArea(_PlayerID, _Category, _X, _Y, _Area);
end
API.WhitelistConstructCategoryInArea = WhitelistConstructCategoryInArea;

function WhitelistConstructTypeInTerritory(_PlayerID, _Type, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistConstructTypeInTerritory(_PlayerID, _Type, _Territory);
end
API.WhitelistConstructTypeInTerritory = WhitelistConstructTypeInTerritory;

function WhitelistConstructCategoryInTerritory(_PlayerID, _Category, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistConstructCategoryInTerritory(_PlayerID, _Category, _Territory);
end
API.WhitelistConstructCategoryInTerritory = WhitelistConstructCategoryInTerritory;

function BlacklistConstructTypeInArea(_PlayerID, _Type, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistConstructTypeInArea(_PlayerID, _Type, _X, _Y, _Area);
end
API.BlacklistConstructTypeInArea = BlacklistConstructTypeInArea;

function BlacklistConstructCategoryInArea(_PlayerID, _Category, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistConstructCategoryInArea(_PlayerID, _Category, _X, _Y, _Area);
end
API.BlacklistConstructCategoryInArea = BlacklistConstructCategoryInArea;

function BlacklistConstructTypeInTerritory(_PlayerID, _Type, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistConstructTypeInTerritory(_PlayerID, _Type, _Territory);
end
API.BlacklistConstructTypeInTerritory = BlacklistConstructTypeInTerritory;

function BlacklistConstructCategoryInTerritory(_PlayerID, _Category, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistConstructCategoryInTerritory(_PlayerID, _Category, _Territory);
end
API.BlacklistConstructCategoryInTerritory = BlacklistConstructCategoryInTerritory;

function WhitelistConstructRoadInArea(_PlayerID, _IsRoad, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistConstructRoadInArea(_PlayerID, _IsRoad, _X, _Y, _Area);
end
API.WhitelistConstructRoadInArea = WhitelistConstructRoadInArea;

function WhitelistConstructWallInArea(_PlayerID, _IsWall, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistConstructWallInArea(_PlayerID, _IsWall, _X, _Y, _Area);
end
API.WhitelistConstructWallInArea = WhitelistConstructWallInArea;

function WhitelistConstructRoadInTerritory(_PlayerID, _IsRoad, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistConstructRoadInTerritory(_PlayerID, _IsRoad, _Territory);
end
API.WhitelistConstructRoadInTerritory = WhitelistConstructRoadInTerritory;

function WhitelistConstructWallInTerritory(_PlayerID, _IsWall, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistConstructWallInTerritory(_PlayerID, _IsWall, _Territory);
end
API.WhitelistConstructWallInTerritory = WhitelistConstructWallInTerritory;

function BlacklistConstructRoadInArea(_PlayerID, _IsRoad, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistConstructRoadInArea(_PlayerID, _IsRoad, _X, _Y, _Area);
end
API.BlacklistConstructRoadInArea = BlacklistConstructRoadInArea;

function BlacklistConstructWallInArea(_PlayerID, _IsWall, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistConstructWallInArea(_PlayerID, _IsWall, _X, _Y, _Area);
end
API.BlacklistConstructWallInArea = BlacklistConstructWallInArea;

function BlacklistConstructRoadInTerritory(_PlayerID, _IsRoad, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistConstructRoadInTerritory(_PlayerID, _IsRoad, _Territory);
end
API.BlacklistConstructRoadInTerritory = BlacklistConstructRoadInTerritory;

function BlacklistConstructWallInTerritory(_PlayerID, _IsWall, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistConstructWallInTerritory(_PlayerID, _IsWall, _Territory);
end
API.BlacklistConstructWallInTerritory = BlacklistConstructWallInTerritory;

function WhitelistKnockdownTypeInArea(_PlayerID, _Type, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistKnockdownTypeInArea(_PlayerID, _Type, _X, _Y, _Area);
end
API.WhitelistKnockdownTypeInArea = WhitelistKnockdownTypeInArea;

function WhitelistKnockdownCategoryInArea(_PlayerID, _Category, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistKnockdownCategoryInArea(_PlayerID, _Category, _X, _Y, _Area);
end
API.WhitelistKnockdownCategoryInArea = WhitelistKnockdownCategoryInArea;

function WhitelistKnockdownTypeInTerritory(_PlayerID, _Type, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistKnockdownTypeInTerritory(_PlayerID, _Type, _Territory);
end
API.WhitelistKnockdownTypeInTerritory = WhitelistKnockdownTypeInTerritory;

function WhitelistKnockdownCategoryInTerritory(_PlayerID, _Category, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:WhitelistKnockdownCategoryInTerritory(_PlayerID, _Category, _Territory);
end
API.WhitelistKnockdownCategoryInTerritory = WhitelistKnockdownCategoryInTerritory;

function BlacklistKnockdownTypeInArea(_PlayerID, _Type, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistKnockdownTypeInArea(_PlayerID, _Type, _X, _Y, _Area);
end
API.BlacklistKnockdownTypeInArea = BlacklistKnockdownTypeInArea;

function BlacklistKnockdownCategoryInArea(_PlayerID, _Category, _X, _Y, _Area)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistKnockdownCategoryInArea(_PlayerID, _Category, _X, _Y, _Area);
end
API.BlacklistKnockdownCategoryInArea = BlacklistKnockdownCategoryInArea;

function BlacklistKnockdownTypeInTerritory(_PlayerID, _Type, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistKnockdownTypeInTerritory(_PlayerID, _Type, _Territory);
end
API.BlacklistKnockdownTypeInTerritory = BlacklistKnockdownTypeInTerritory;

function BlacklistKnockdownCategoryInTerritory(_PlayerID, _Category, _Territory)
    assert(not IsLocalScript(), "Can not be used in local script!");
    return Lib.Construction.Global:BlacklistKnockdownCategoryInTerritory(_PlayerID, _Category, _Territory);
end
API.BlacklistKnockdownCategoryInTerritory = BlacklistKnockdownCategoryInTerritory;

Lib.Construction = Lib.Construction or {};
Lib.Construction.Name = "Construction";
Lib.Construction.Global = {
    Construction = {
        ForceBallistaDistance = false,
        Restriction = {
            Index = 0,
            BuildingCustomRule = {},
            BuildingTerritoryBlacklist = {},
            BuildingAreaBlacklist = {},
            BuildingTerritoryWhitelist = {},
            BuildingAreaWhitelist = {},
            RoadCustomRule = {},
            RoadTerritoryBlacklist = {},
            RoadAreaBlacklist = {},
            RoadTerritoryWhitelist = {},
            RoadAreaWhitelist = {},
            WallCustomRule = {},
            WallTerritoryBlacklist = {},
            WallAreaBlacklist = {},
            WallTerritoryWhitelist = {},
            WallAreaWhitelist = {},
        },
    },
    Knockdown = {
        Restriction = {
            Index = 0,
            BuildingCustomRule = {},
            BuildingTerritoryBlacklist = {},
            BuildingAreaBlacklist = {},
            BuildingTerritoryWhitelist = {},
            BuildingAreaWhitelist = {},
        },
    },
};
Lib.Construction.Local  = {
    Construction = {
        ForceBallistaDistance = false,
        Restriction = {
            BuildingCustomRule = {},
            BuildingTerritoryBlacklist = {},
            BuildingAreaBlacklist = {},
            BuildingTerritoryWhitelist = {},
            BuildingAreaWhitelist = {},
            RoadCustomRule = {},
            RoadTerritoryBlacklist = {},
            RoadAreaBlacklist = {},
            RoadTerritoryWhitelist = {},
            RoadAreaWhitelist = {},
            WallCustomRule = {},
            WallTerritoryBlacklist = {},
            WallAreaBlacklist = {},
            WallTerritoryWhitelist = {},
            WallAreaWhitelist = {},
        },
    },
    Knockdown = {
        Restriction = {
            LastSelectedBuildingType = 0,
            LastSelectedRoadType = 0,
            BuildingCustomRule = {},
            BuildingTerritoryBlacklist = {},
            BuildingAreaBlacklist = {},
            BuildingTerritoryWhitelist = {},
            BuildingAreaWhitelist = {},
        }
    }
};

Lib.Require("comfort/GetCategoriesOfType");
Lib.Require("comfort/GetDistance");
Lib.Require("comfort/IsLocalScript");
Lib.Require("core/Core");
Lib.Require("module/city/Construction_API");
Lib.Require("module/city/Construction_Text");
Lib.Register("module/city/Construction");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.Construction.Global:Initialize()
    if not self.IsInstalled then
        for i= 1, 8 do
            self.Construction.Restriction.BuildingCustomRule[i] = {};
            self.Construction.Restriction.BuildingTerritoryBlacklist[i] = {};
            self.Construction.Restriction.BuildingAreaBlacklist[i] = {};
            self.Construction.Restriction.BuildingTerritoryWhitelist[i] = {};
            self.Construction.Restriction.BuildingAreaWhitelist[i] = {};
            self.Construction.Restriction.RoadCustomRule[i] = {};
            self.Construction.Restriction.RoadTerritoryBlacklist[i] = {};
            self.Construction.Restriction.RoadAreaBlacklist[i] = {};
            self.Construction.Restriction.RoadTerritoryWhitelist[i] = {};
            self.Construction.Restriction.RoadAreaWhitelist[i] = {};
            self.Construction.Restriction.WallCustomRule[i] = {};
            self.Construction.Restriction.WallTerritoryBlacklist[i] = {};
            self.Construction.Restriction.WallAreaBlacklist[i] = {};
            self.Construction.Restriction.WallTerritoryWhitelist[i] = {};
            self.Construction.Restriction.WallAreaWhitelist[i] = {};
            self.Knockdown.Restriction.BuildingCustomRule[i] = {};
            self.Knockdown.Restriction.BuildingTerritoryBlacklist[i] = {};
            self.Knockdown.Restriction.BuildingAreaBlacklist[i] = {};
            self.Knockdown.Restriction.BuildingTerritoryWhitelist[i] = {};
            self.Knockdown.Restriction.BuildingAreaWhitelist[i] = {};
        end

        -- Garbage collection
        Lib.Construction.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.Construction.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Construction.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self:OverwriteGameCallbacks();

        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

function Lib.Construction.Global:WhitelistConstructTypeInArea(_PlayerID, _Type, _X, _Y, _Area)
    return self:ListConstructArea("BuildingAreaWhitelist", _PlayerID, _Type, nil, _X, _Y, _Area);
end

function Lib.Construction.Global:WhitelistConstructCategoryInArea(_PlayerID, _Category, _X, _Y, _Area)
    return self:ListConstructArea("BuildingCateWhitelist", _PlayerID, nil, _Category, _X, _Y, _Area);
end

function Lib.Construction.Global:WhitelistConstructTypeInTerritory(_PlayerID, _Type, _Territory)
    return self:ListConstructTerritory("BuildingTerritoryWhitelist", _PlayerID, _Type, nil, _Territory);
end

function Lib.Construction.Global:WhitelistConstructCategoryInTerritory(_PlayerID, _Category, _Territory)
    return self:ListConstructTerritory("BuildingTerritoryWhitelist", _PlayerID, nil, _Category, _Territory);
end

function Lib.Construction.Global:BlacklistConstructTypeInArea(_PlayerID, _Type, _X, _Y, _Area)
    return self:ListConstructArea("BuildingAreaBlacklist", _PlayerID, _Type, nil, _X, _Y, _Area);
end

function Lib.Construction.Global:BlacklistConstructCategoryInArea(_PlayerID, _Category, _X, _Y, _Area)
    return self:ListConstructArea("BuildingAreaBlacklist", _PlayerID, nil, _Category, _X, _Y, _Area);
end

function Lib.Construction.Global:BlacklistConstructTypeInTerritory(_PlayerID, _Type, _Territory)
    return self:ListConstructTerritory("BuildingTerritoryBlacklist", _PlayerID, _Type, nil, _Territory);
end

function Lib.Construction.Global:BlacklistConstructCategoryInTerritory(_PlayerID, _Category, _Territory)
    return self:ListConstructTerritory("BuildingTerritoryBlacklist", _PlayerID, nil, _Category, _Territory);
end

function Lib.Construction.Global:WhitelistConstructRoadInArea(_PlayerID, _IsRoad, _X, _Y, _Area)
    return self:ListConstructArea("RoadAreaWhitelist", _PlayerID, _IsRoad, nil, _X, _Y, _Area);
end

function Lib.Construction.Global:WhitelistConstructWallInArea(_PlayerID, _IsWall, _X, _Y, _Area)
    return self:ListConstructArea("WallAreaWhitelist", _PlayerID, _IsWall, nil, _X, _Y, _Area);
end

function Lib.Construction.Global:WhitelistConstructRoadInTerritory(_PlayerID, _IsRoad, _Territory)
    return self:ListConstructTerritory("RoadTerritoryWhitelist", _PlayerID, _IsRoad, nil, _Territory);
end

function Lib.Construction.Global:WhitelistConstructWallInTerritory(_PlayerID, _IsWall, _Territory)
    return self:ListConstructTerritory("WallTerritoryWhitelist", _PlayerID, _IsWall, nil, _Territory);
end

function Lib.Construction.Global:BlacklistConstructRoadInArea(_PlayerID, _IsRoad, _X, _Y, _Area)
    return self:ListConstructArea("RoadAreaBlacklist", _PlayerID, _IsRoad, nil, _X, _Y, _Area);
end

function Lib.Construction.Global:BlacklistConstructWallInArea(_PlayerID, _IsWall, _X, _Y, _Area)
    return self:ListConstructArea("WallAreaBlacklist", _PlayerID, _IsWall, nil, _X, _Y, _Area);
end

function Lib.Construction.Global:BlacklistConstructRoadInTerritory(_PlayerID, _IsRoad, _Territory)
    return self:ListConstructTerritory("RoadTerritoryBlacklist", _PlayerID, _IsRoad, nil, _Territory);
end

function Lib.Construction.Global:BlacklistConstructWallInTerritory(_PlayerID, _IsWall, _Territory)
    return self:ListConstructTerritory("WallTerritoryBlacklist", _PlayerID, _IsWall, nil, _Territory);
end

function Lib.Construction.Global:CustomRuleConstructBuilding(_PlayerID, _FunctionName, ...)
    return self:ListConstructCustom("BuildingCustomRule", _PlayerID, _FunctionName, unpack(arg));
end

function Lib.Construction.Global:CustomRuleConstructRoad(_PlayerID, _FunctionName, ...)
    return self:ListConstructCustom("RoadCustomRule", _PlayerID, _FunctionName, unpack(arg));
end

function Lib.Construction.Global:CustomRuleConstructWall(_PlayerID, _FunctionName, ...)
    return self:ListConstructCustom("WallCustomRule", _PlayerID, _FunctionName, unpack(arg));
end

function Lib.Construction.Global:ListConstructArea(_List, _PlayerID, _Type, _Category, _X, _Y, _Area)
    local ID = self:GetNewRestrictionID();
    table.insert(self.Construction.Restriction[_List][_PlayerID], {
        ID = ID,
        Category = _Category,
        Type = _Type,
        Center = {X= _X, Y= _Y},
        Area = _Area,
    });
    self:MirrorConstructionRestrictionsToLocalScript();
    return ID;
end

function Lib.Construction.Global:ListConstructTerritory(_List, _PlayerID, _Type, _Category, _Territory)
    local ID = self:GetNewRestrictionID();
    table.insert(self.Construction.Restriction[_List][_PlayerID], {
        ID = ID,
        Category = _Category,
        Type = _Type,
        Territory = _Territory,
    });
    self:MirrorConstructionRestrictionsToLocalScript();
    return ID;
end

function Lib.Construction.Global:ListConstructCustom(_List, _PlayerID, _Rule, ...)
    local ID = self:GetNewRestrictionID();
    table.insert(self.Construction.Restriction[_List][_PlayerID], {
        ID = ID,
        Function = _Rule,
        Arguments = arg
    });
    self:MirrorConstructionRestrictionsToLocalScript();
    return ID;
end

function Lib.Construction.Global:GetNewRestrictionID()
    self.Construction.Restriction.Index = self.Construction.Restriction.Index + 1;
    local Index = self.Construction.Restriction.Index
    ExecuteLocal([[Lib.Construction.Local.Construction.Restriction.Index = %d]], Index);
    return Index;
end

function Lib.Construction.Global:MirrorConstructionRestrictionsToLocalScript()
    local Table = table.tostring(self.Construction.Restriction);
    ExecuteLocal([[Lib.Construction.Local.Construction.Restriction = %s]], Table);
end

-- -------------------------------------------------------------------------- --

function Lib.Construction.Global:WhitelistKnockdownTypeInArea(_PlayerID, _Type, _X, _Y, _Area)
    return self:ListKnockdownArea("BuildingAreaWhitelist", _PlayerID, _Type, nil, _X, _Y, _Area);
end

function Lib.Construction.Global:WhitelistKnockdownCategoryInArea(_PlayerID, _Category, _X, _Y, _Area)
    return self:ListKnockdownArea("BuildingAreaWhitelist", _PlayerID, nil, _Category, _X, _Y, _Area);
end

function Lib.Construction.Global:WhitelistKnockdownTypeInTerritory(_PlayerID, _Type, _Territory)
    return self:ListKnockdownTerritory("BuildingTerritoryWhitelist", _PlayerID, _Type, nil, _Territory);
end

function Lib.Construction.Global:WhitelistKnockdownCategoryInTerritory(_PlayerID, _Category, _Territory)
    return self:ListKnockdownTerritory("BuildingTerritoryWhitelist", _PlayerID, nil, _Category, _Territory);
end

function Lib.Construction.Global:BlacklistKnockdownTypeInArea(_PlayerID, _Type, _X, _Y, _Area)
    return self:ListKnockdownArea("BuildingAreaBlacklist", _PlayerID, _Type, nil, _X, _Y, _Area);
end

function Lib.Construction.Global:BlacklistKnockdownCategoryInArea(_PlayerID, _Category, _X, _Y, _Area)
    return self:ListKnockdownArea("BuildingAreaBlacklist", _PlayerID, nil, _Category, _X, _Y, _Area);
end

function Lib.Construction.Global:BlacklistKnockdownTypeInTerritory(_PlayerID, _Type, _Territory)
    return self:ListKnockdownTerritory("BuildingTerritoryBlacklist", _PlayerID, _Type, nil, _Territory);
end

function Lib.Construction.Global:BlacklistKnockdownCategoryInTerritory(_PlayerID, _Category, _Territory)
    return self:ListKnockdownTerritory("BuildingTerritoryBlacklist", _PlayerID, nil, _Category, _Territory);
end

function Lib.Construction.Global:CustomRuleKnockdownBuilding(_PlayerID, _FunctionName, ...)
    return self:ListKnockdownCustom("BuildingCustomRule", _PlayerID, _FunctionName, unpack(arg));
end

function Lib.Construction.Global:ListKnockdownArea(_List, _PlayerID, _Type, _Category, _X, _Y, _Area)
    local ID = self:GetNewProtectionID();
    table.insert(self.Knockdown.Restriction[_List][_PlayerID], {
        ID = ID,
        Category = _Category,
        Type = _Type,
        Center = {X= _X, Y= _Y},
        Area = _Area,
    });
    self:MirrorKnockdownRestrictionsToLocalScript();
    return ID;
end

function Lib.Construction.Global:ListKnockdownTerritory(_List, _PlayerID, _Type, _Category, _Territory)
    local ID = self:GetNewProtectionID();
    table.insert(self.Knockdown.Restriction[_List][_PlayerID], {
        ID = ID,
        Category = _Category,
        Type = _Type,
        Territory = _Territory,
    });
    self:MirrorKnockdownRestrictionsToLocalScript();
    return ID;
end

function Lib.Construction.Global:ListKnockdownCustom(_List, _PlayerID, _Rule, ...)
    local ID = self:GetNewRestrictionID();
    table.insert(self.Knockdown.Restriction[_List][_PlayerID], {
        ID = ID,
        Function = _Rule,
        Arguments = arg
    });
    self:MirrorKnockdownRestrictionsToLocalScript();
    return ID;
end

function Lib.Construction.Global:GetNewProtectionID()
    self.Knockdown.Restriction.Index = self.Knockdown.Restriction.Index + 1;
    local Index = self.Knockdown.Restriction.Index
    ExecuteLocal([[Lib.Construction.Local.Knockdown.Restriction.Index = %d]], Index);
    return Index;
end

function Lib.Construction.Global:MirrorKnockdownRestrictionsToLocalScript()
    local Table = table.tostring(self.Knockdown.Restriction);
    ExecuteLocal([[Lib.Construction.Local.Knockdown.Restriction = %s]], Table);
end

-- -------------------------------------------------------------------------- --

function Lib.Construction.Global:IsConstructionAllowed(_PlayerID, _Type, _X, _Y)
    local Territory = Logic.GetTerritoryAtPosition(_X, _Y);
    local Categories = GetCategoriesOfType(_Type);

    -- Do explicitly allow types or categories in territory
    local TerritoryWhitelist = self.Construction.Restriction.BuildingTerritoryWhitelist[_PlayerID];
    if #TerritoryWhitelist > 0 then
        for k,v in pairs(TerritoryWhitelist) do
            if  (v.Type == _Type or table.contains(Categories, v.Category))
            and v.Territory == Territory then
                return true;
            end
        end
        return false;
    end
    -- Do explicitly allow types or categories in area
    local AreaWhitelist = self.Construction.Restriction.BuildingAreaWhitelist[_PlayerID];
    if #AreaWhitelist > 0 then
        for k,v in pairs(AreaWhitelist) do
            if  (v.Type == _Type or table.contains(Categories, v.Category))
            and v.Center and GetDistance({X=_X, Y= _Y}, v.Center) <= v.Area then
                return true;
            end
        end
        return false;
    end

    -- Do not allow types of categories in territory
    local TerritoryBlacklist = self.Construction.Restriction.BuildingTerritoryBlacklist[_PlayerID];
    for k,v in pairs(TerritoryBlacklist) do
        if  (v.Type == _Type or table.contains(Categories, v.Category))
        and v.Territory == Territory then
            return false;
        end
    end
    -- Do not allow types or categories in area
    local AreaBlacklist = self.Construction.Restriction.BuildingAreaBlacklist[_PlayerID];
    for k,v in pairs(AreaBlacklist) do
        if  (v.Type == _Type or table.contains(Categories, v.Category))
        and v.Center and GetDistance({X=_X, Y= _Y}, v.Center) <= v.Area then
            return false;
        end
    end

    -- Do not allow by custom function
    local CustomRule = self.Construction.Restriction.BuildingCustomRule[_PlayerID];
    for k,v in pairs(CustomRule) do
        if _G[v.Function] and not _G[v.Function](_PlayerID, _Type, _X, _Y, unpack(v.Arguments)) then
            return false;
        end
    end
    return true;
end

function Lib.Construction.Global:OverwriteGameCallbacks()
    self.Orig_GameCallback_CanPlayerPlaceBuilding = GameCallback_CanPlayerPlaceBuilding;
    GameCallback_CanPlayerPlaceBuilding = function( _PlayerID, _Type, _X, _Y )
        if Lib.Construction.Global:IsConstructionAllowed(_PlayerID, _Type, _X, _Y) then
            return Lib.Construction.Global.Orig_GameCallback_CanPlayerPlaceBuilding( _PlayerID, _Type, _X, _Y );
        end
        return false;
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.Construction.Local:Initialize()
    if not self.IsInstalled then
        for i= 1, 8 do
            self.Construction.Restriction.BuildingCustomRule[i] = {};
            self.Construction.Restriction.BuildingTerritoryBlacklist[i] = {};
            self.Construction.Restriction.BuildingAreaBlacklist[i] = {};
            self.Construction.Restriction.BuildingTerritoryWhitelist[i] = {};
            self.Construction.Restriction.BuildingAreaWhitelist[i] = {};
            self.Construction.Restriction.RoadCustomRule[i] = {};
            self.Construction.Restriction.RoadTerritoryBlacklist[i] = {};
            self.Construction.Restriction.RoadAreaBlacklist[i] = {};
            self.Construction.Restriction.RoadTerritoryWhitelist[i] = {};
            self.Construction.Restriction.RoadAreaWhitelist[i] = {};
            self.Construction.Restriction.WallCustomRule[i] = {};
            self.Construction.Restriction.WallTerritoryBlacklist[i] = {};
            self.Construction.Restriction.WallAreaBlacklist[i] = {};
            self.Construction.Restriction.WallTerritoryWhitelist[i] = {};
            self.Construction.Restriction.WallAreaWhitelist[i] = {};
            self.Knockdown.Restriction.BuildingCustomRule[i] = {};
            self.Knockdown.Restriction.BuildingTerritoryBlacklist[i] = {};
            self.Knockdown.Restriction.BuildingAreaBlacklist[i] = {};
            self.Knockdown.Restriction.BuildingTerritoryWhitelist[i] = {};
            self.Knockdown.Restriction.BuildingAreaWhitelist[i] = {};
        end
        self:OverrideBuildButtonClicked();
        self:OverridePlacementUpdate();

        -- Garbage collection
        Lib.Construction.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.Construction.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.Construction.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self:OverwriteGameCallbacks();

        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

function Lib.Construction.Local:IsKnockdownAllowed(_PlayerID, _EntityID, _State)
    local Type = Logic.GetEntityType(_EntityID);
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local Territory = GetTerritoryUnderEntity(_EntityID);
    local Categories = GetCategoriesOfType(Type);

    -- Do explicitly allow types or categories in territory
    local TerritoryWhitelist = self.Knockdown.Restriction.BuildingTerritoryWhitelist[_PlayerID];
    if #TerritoryWhitelist > 0 then
        for k,v in pairs(TerritoryWhitelist) do
            if  (v.Type == Type or table.contains(Categories, v.Category))
            and v.Territory == Territory then
                return true;
            end
        end
        return false;
    end
    -- Do explicitly allow types or categories in area
    local AreaWhitelist = self.Knockdown.Restriction.BuildingAreaWhitelist[_PlayerID];
    if #AreaWhitelist > 0 then
        for k,v in pairs(AreaWhitelist) do
            if  (v.Type == Type or table.contains(Categories, v.Category))
            and v.Center and GetDistance({X= x, Y= y}, v.Center) <= v.Area then
                return true;
            end
        end
        return false;
    end

    -- Do not allow types of categories in territory
    local TerritoryBlacklist = self.Knockdown.Restriction.BuildingTerritoryBlacklist[_PlayerID];
    for k,v in pairs(TerritoryBlacklist) do
        if  (v.Type == Type or table.contains(Categories, v.Category))
        and v.Territory == Territory then
            return false;
        end
    end
    -- Do not allow types or categories in area
    local AreaBlacklist = self.Knockdown.Restriction.BuildingAreaBlacklist[_PlayerID];
    for k,v in pairs(AreaBlacklist) do
        if  (v.Type == Type or table.contains(Categories, v.Category))
        and v.Center and GetDistance({X= x, Y= y}, v.Center) <= v.Area then
            return false;
        end
    end

    -- Do not allow by custom function
    local CustomRule = self.Knockdown.Restriction.BuildingCustomRule[_PlayerID];
    for k,v in pairs(CustomRule) do
        if _G[v.Function] and not _G[v.Function](_PlayerID, _EntityID, x, y, unpack(v.Arguments)) then
            return false;
        end
    end
    return true;
end

function Lib.Construction.Local:OverwriteGameCallbacks()
    self.Orig_GameCallback_GUI_DeleteEntityStateBuilding = GameCallback_GUI_DeleteEntityStateBuilding;
    GameCallback_GUI_DeleteEntityStateBuilding = function(_BuildingID, _State)
        local PlayerID = Logic.EntityGetPlayer(_BuildingID);
        if not Lib.Construction.Local:IsKnockdownAllowed(PlayerID, _BuildingID, _State) then
            Message(Localize(Lib.Construction.Text.NoKnockdown));
            GUI.CancelBuildingKnockDown(_BuildingID);
            return;
        end
        Lib.Construction.Local.Orig_GameCallback_GUI_DeleteEntityStateBuilding(_BuildingID, _State);
    end
end

-- -------------------------------------------------------------------------- --

function Lib.Construction.Local:OverrideBuildButtonClicked()
    self.Orig_BuildClicked = GUI_Construction.BuildClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Construction.BuildClicked = function(_BuildingType)
        Lib.Construction.Local.LastSelectedBuildingType = _BuildingType;
        Lib.Construction.Local.Orig_BuildClicked(_BuildingType);
    end

    self.Orig_BuildStreetClicked = GUI_Construction.BuildStreetClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Construction.BuildStreetClicked = function(_IsTrail)
        _IsTrail = (_IsTrail ~= nil and _IsTrail) or false;
        Lib.Construction.Local.LastSelectedRoadType = _IsTrail;
        Lib.Construction.Local.Orig_BuildStreetClicked(_IsTrail);
    end

    self.Orig_BuildWallClicked = GUI_Construction.BuildWallClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Construction.BuildWallClicked = function(_BuildingType)
        if _BuildingType == nil then
            _BuildingType = GetUpgradeCategoryForClimatezone("WallSegment");
        end
        Lib.Construction.Local.LastSelectedBuildingType = _BuildingType;
        Lib.Construction.Local.Orig_BuildWallClicked(_BuildingType);
    end

    self.Orig_BuildWallGateClicked = GUI_Construction.BuildWallGateClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Construction.BuildWallGateClicked = function(_BuildingType)
        if _BuildingType == nil then
            _BuildingType = GetUpgradeCategoryForClimatezone("WallGate");
        end
        Lib.Construction.Local.LastSelectedBuildingType = _BuildingType;
        Lib.Construction.Local.Orig_BuildWallGateClicked(_BuildingType);
    end

    self.Orig_PlaceFieldClicked = GUI_BuildingButtons.PlaceFieldClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.PlaceFieldClicked = function()
        -- TODO: Implement anti crops spam
        local EntityType = Logic.GetEntityType(GUI.GetSelectedEntity());
        Lib.Construction.Local.LastSelectedBuildingType = EntityType;
        Lib.Construction.Local.Orig_PlaceFieldClicked();
    end
end

function Lib.Construction.Local:OverridePlacementUpdate()
    self.Orig_GameCallBack_GUI_ConstructWallSegmentCountChanged = GameCallBack_GUI_ConstructWallSegmentCountChanged;
    GameCallBack_GUI_ConstructWallSegmentCountChanged = function(_SegmentType, _TurretType)
        self.Orig_GameCallBack_GUI_ConstructWallSegmentCountChanged(_SegmentType, _TurretType);
        Lib.Construction.Local:CancleConstructWallSegmentState(GUI.GetPlayerID(), _SegmentType, _TurretType);
    end

    self.Orig_GameCallBack_GUI_BuildRoadCostChanged = GameCallBack_GUI_BuildRoadCostChanged;
    GameCallBack_GUI_BuildRoadCostChanged = function(_Length)
        self.Orig_GameCallBack_GUI_BuildRoadCostChanged(_Length);
        Lib.Construction.Local:CancleConstructRoad(GUI.GetPlayerID(), _Length);
    end

    self.Orig_PlacementUpdate = GUI_Construction.PlacementUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Construction.PlacementUpdate = function()
        Lib.Construction.Local.Orig_PlacementUpdate();
        Lib.Construction.Local:CancleConstructWallGateState(GUI.GetPlayerID());
    end

    self.Orig_UpgradeTurretClicked = GUI_BuildingButtons.UpgradeTurretClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.UpgradeTurretClicked = function()
        local EntityID = GUI.GetSelectedEntity();
        local PlayerID = Logic.EntityGetPlayer(EntityID);
        local x,y,z = Logic.EntityGetPos(EntityID)
        if Lib.Construction.Local:AreOtherBallistasToCloseToPosition(PlayerID, x, y, 2500) then
            Message(Localize(Lib.Construction.Text.NoBallista));
            return;
        end
        Lib.Construction.Local.Orig_UpgradeTurretClicked();
    end
end

function Lib.Construction.Local:AreOtherBallistasToCloseToPosition(_PlayerID, _x, _y, _AreaSize)
    if self.Construction.ForceBallistaDistance then
        local nSite, SiteID = Logic.GetPlayerEntitiesInArea(_PlayerID, Entities.U_MilitaryBallista_BuildingSite, _x, _y, _AreaSize, 1);
        local nBallista, BallistaID = Logic.GetPlayerEntitiesInArea(_PlayerID, Entities.U_MilitaryBallista, _x, _y, _AreaSize, 1);
        return (nSite + nBallista) > 0;
    end
    return false;
end

function Lib.Construction.Local:CancleConstructWallSegmentState(_PlayerID, _SegmentType, _TurretType)
    local GuiState = GUI.GetCurrentStateID();
    if g_Construction.CurrentPlacementType == 3 then
        local Costs = {Logic.GetCostForWall(_SegmentType, _TurretType, StartTurretX, StartTurretY, EndTurretX, EndTurretY)}
        if GuiState == 2 and Costs[1] and Costs[2] > 0 then
            local x, y = GUI.Debug_GetMapPositionUnderMouse();
            Lib.Construction.Local:CancleConstructWallState(_PlayerID, self.LastSelectedBuildingType, x, y);
        end
    end
end

function Lib.Construction.Local:CancleConstructWallGateState(_PlayerID)
    local GuiState = GUI.GetCurrentStateID();
    if g_Construction.CurrentPlacementType == 4 then
        if GuiState == 3 then
            local x, y = GUI.Debug_GetMapPositionUnderMouse();
            Lib.Construction.Local:CancleConstructWallState(_PlayerID, self.LastSelectedBuildingType, x, y);
        end
    end
end

function Lib.Construction.Local:CancleConstructWallState(_PlayerID, _Type, _X, _Y)
    local Territory = Logic.GetTerritoryAtPosition(_X or 1, _Y or 1);

    -- Cancel build walls if not whitelisted for territory
    local TerritoryWhitelist = self.Construction.Restriction.WallTerritoryWhitelist[_PlayerID];
    if #TerritoryWhitelist > 0 then
        for k,v in pairs(TerritoryWhitelist) do
            if v.Type == true then
                if  string.find(Logic.GetEntityTypeName(_Type), "B_Wall")
                and v.Territory == Territory then
                    return;
                end
            else
                if  (_Type == Entities.B_PalisadeSegment or _Type == Entities.B_PalisadeGate)
                and v.Territory == Territory then
                    return;
                end
            end
        end
        self:CancelState(g_Construction.CurrentPlacementType);
    end
    -- Cancel build walls if not whitelisted for area
    local AreaWhitelist = self.Construction.Restriction.WallAreaWhitelist[_PlayerID];
    if #AreaWhitelist > 0 then
        for k,v in pairs(TerritoryWhitelist) do
            if v.Type == true then
                if  string.find(Logic.GetEntityTypeName(_Type), "B_Wall")
                and v.Center and GetDistance({X= _X, Y= _Y}, v.Center) <= v.Area then
                    return;
                end
            else
                if  (_Type == Entities.B_PalisadeSegment or _Type == Entities.B_PalisadeGate)
                and v.Center and GetDistance({X= _X, Y= _Y}, v.Center) <= v.Area then
                    return;
                end
            end
        end
        self:CancelState(g_Construction.CurrentPlacementType);
    end

    -- Cancel build walls if blacklisted for territory
    local TerritoryBlacklist = self.Construction.Restriction.WallTerritoryBlacklist[_PlayerID];
    if true then
        for k,v in pairs(TerritoryBlacklist) do
            if v.Type == true then
                if  string.find(Logic.GetEntityTypeName(_Type), "B_Wall")
                and v.Territory == Territory then
                    self:CancelState(g_Construction.CurrentPlacementType);
                    return;
                end
            else
                if  (_Type == Entities.B_PalisadeSegment or _Type == Entities.B_PalisadeGate)
                and v.Territory == Territory then
                    self:CancelState(g_Construction.CurrentPlacementType);
                    return;
                end
            end
        end
    end
    -- Cancel build walls if blacklisted for area
    local AreaBlacklist = self.Construction.Restriction.WallAreaBlacklist[_PlayerID];
    if true then
        for k,v in pairs(AreaBlacklist) do
            if v.Type == true then
                if  string.find(Logic.GetEntityTypeName(_Type), "B_Wall")
                and v.Center and GetDistance({X= _X, Y= _Y}, v.Center) <= v.Area then
                    self:CancelState(g_Construction.CurrentPlacementType);
                    return;
                end
            else
                if  (_Type == Entities.B_PalisadeSegment or _Type == Entities.B_PalisadeGate)
                and v.Center and GetDistance({X= _X, Y= _Y}, v.Center) <= v.Area then
                    self:CancelState(g_Construction.CurrentPlacementType);
                    return;
                end
            end
        end
    end

    -- Cancel build walls by custom function
    local CustomRule = self.Construction.Restriction.WallCustomRule[_PlayerID];
    for k,v in pairs(CustomRule) do
        local IsWall = string.find(Logic.GetEntityTypeName(_Type), "B_Wall") ~= nil;
        if _G[v.Function] and not _G[v.Function](_PlayerID, IsWall, _X, _Y, unpack(v.Arguments)) then
            self:CancelState(g_Construction.CurrentPlacementType);
            return;
        end
    end
end

function Lib.Construction.Local:CancleConstructRoad(_PlayerID, _Length)
    local GuiState = GUI.GetCurrentStateID();
    local x,y = GUI.Debug_GetMapPositionUnderMouse();
    local Territory = Logic.GetTerritoryAtPosition(x or 1, y or 1);


    -- Check placing roads
    if g_Construction.CurrentPlacementType == 1 then
        if GuiState == 5 and _Length > 0 then
            local IsRoad = not self.LastSelectedRoadType;

            -- Allow roads only in territoty
            local TerritoryWhitelist = self.Construction.Restriction.RoadTerritoryWhitelist[_PlayerID];
            if #TerritoryWhitelist > 0 then
                for k,v in pairs(TerritoryWhitelist) do
                    if v.Type == IsRoad and v.Territory == Territory then
                        return;
                    end
                end
                self:CancelState(g_Construction.CurrentPlacementType);
            end
            -- Allow roads only in area
            local AreaWhitelist = self.Construction.Restriction.RoadAreaWhitelist[_PlayerID];
            if #AreaWhitelist > 0 then
                for k,v in pairs(AreaWhitelist) do
                    if v.Type == IsRoad and v.Center and GetDistance({X= x, Y= y}, v.Center) <= v.Area then
                        return;
                    end
                end
                self:CancelState(g_Construction.CurrentPlacementType);
            end

            -- Forbid roads in territory
            local TerritoryBlacklist = self.Construction.Restriction.RoadTerritoryBlacklist[_PlayerID];
            for k,v in pairs(TerritoryBlacklist) do
                if v.Type == IsRoad and v.Territory == Territory then
                    self:CancelState(g_Construction.CurrentPlacementType);
                    return;
                end
            end
            -- Forbid roads in area
            local AreaBlacklist = self.Construction.Restriction.RoadAreaBlacklist[_PlayerID];
            for k,v in pairs(AreaBlacklist) do
                if v.Type == IsRoad and v.Center and GetDistance({X= x, Y= y}, v.Center) <= v.Area then
                    self:CancelState(g_Construction.CurrentPlacementType);
                    return;
                end
            end

            -- Cancel build walls by custom function
            local CustomRule = self.Construction.Restriction.RoadCustomRule[_PlayerID];
            for k,v in pairs(CustomRule) do
                if _G[v.Function] and not _G[v.Function](_PlayerID, IsRoad, x, y, unpack(v.Arguments)) then
                    self:CancelState(g_Construction.CurrentPlacementType);
                    return;
                end
            end
        end
    end
end

function Lib.Construction.Local:CancelState(_PlacementType)
    local Text = Lib.Construction.Text.NoWall;
    if _PlacementType == 1 then
        Text = Lib.Construction.Text.NoRoad;
    elseif _PlacementType == -1 then
        Text = Lib.Construction.Text.NoWallGate;
    end
    Message(Localize(Text));
    GUI.CancelState();
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.Construction.Name);

Lib.Register("module/entity/NPC_Behavior");

function Goal_NPC(_NpcName, _HeroName)
    return B_Goal_NPC:new(_NpcName, _HeroName);
end

B_Goal_NPC = {
    Name             = "Goal_NPC",
    Description     = {
        en = "Goal: The hero has to talk to a non-player character.",
        de = "Ziel: Der Held muss einen Nichtspielercharakter ansprechen.",
        fr = "Objectif: le héros doit interpeller un personnage non joueur.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "NPC",  de = "NPC",  fr = "NPC" },
        { ParameterType.ScriptName, en = "Hero", de = "Held", fr = "Héro" },
    },
}

function B_Goal_NPC:GetGoalTable()
    return {Objective.Distance, -65565, self.Hero, self.NPC, self}
end

function B_Goal_NPC:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.NPC = _Parameter
    elseif (_Index == 1) then
        self.Hero = _Parameter
        if self.Hero == "-" then
            self.Hero = nil
        end
   end
end

function B_Goal_NPC:GetIcon()
    return {14,10}
end

RegisterBehavior(B_Goal_NPC);

-- -------------------------------------------------------------------------- --

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/entity/NPC_API");

function NpcCompose(_Data)
    error(not IsLocalScript(), "NPC manipulated in local script.");
    error(type(_Data) == "table", "NPC must be a table.");
    error(_Data.Name ~= nil, "NPC needs a script name.");
    error(IsExisting(_Data.Name), "Entity does not exist.");

    local Npc = Lib.NPC.Global:GetNpc(_Data.Name);
    error(Npc == nil or not Npc.Active, "NPC already active.");
    error(not _Data.Type or (_Data.Type >= 1 or _Data.Type <= 4), "NPC type is invalid.");
    return Lib.NPC.Global:CreateNpc(_Data);
end
API.NpcCompose = NpcCompose;

function NpcDispose(_Data)
    error(not IsLocalScript(), "NPC manipulated in local script.");
    error(IsExisting(_Data.Name), "Entity does not exist.");
    error(Lib.NPC.Global:GetNpc(_Data.Name) ~= nil, "NPC must first be composed.");
    Lib.NPC.Global:DestroyNpc(_Data);
end
API.NpcDispose = NpcDispose;

function NpcUpdate(_Data)
    error(not IsLocalScript(), "NPC manipulated in local script.");
    error(IsExisting(_Data.Name), "Entity does not exist.");
    error(Lib.NPC.Global:GetNpc(_Data.Name) ~= nil, "NPC must first be composed.");
    Lib.NPC.Global:UpdateNpc(_Data);
end
API.NpcUpdate = NpcUpdate;

function NpcIsActive(_Data)
    error(not IsLocalScript(), "NPC manipulated in local script.");
    error(IsExisting(_Data.Name), "Entity does not exist.");
    local NPC = Lib.NPC.Global:GetNpc(_Data.Name);
    error(NPC ~= nil, "NPC was not found.");
    if NPC.Active == true then
        return GetInteger(_Data.Name, CONST_SCRIPTING_VALUES.NPC) == 6;
    end
    return false;
end
API.NpcIsActive = NpcIsActive;

function NpcTalkedTo(_Data, _Hero, _PlayerID)
    error(not IsLocalScript(), "NPC manipulated in local script.");
    error(IsExisting(_Data.Name), "Entity does not exist.");

    local NPC = Lib.NPC.Global:GetNpc(_Data.Name);
    error(NPC ~= nil, "NPC was not found.");
    local TalkedTo = NPC.TalkedTo ~= nil and NPC.TalkedTo ~= 0;
    if _Hero and TalkedTo then
        TalkedTo = NPC.TalkedTo == GetID(_Hero);
    end
    if _PlayerID and TalkedTo then
        TalkedTo = Logic.EntityGetPlayer(NPC.TalkedTo) == _PlayerID;
    end
    return TalkedTo;
end
API.NpcTalkedTo = NpcTalkedTo;

function NpcHasArrived(_Data)
    error(not IsLocalScript(), "NPC manipulated in local script.");
    error(IsExisting(_Data.Name), "Entity does not exist.");

    local NPC = Lib.NPC.Global:GetNpc(_Data.Name);
    error(NPC ~= nil, "NPC was not found.");
    if NPC.FollowDestination then
        return NPC.Arrived == true;
    end
    return false;
end
API.NpcHasArrived = NpcHasArrived;

Lib.NPC = Lib.NPC or {};
Lib.NPC.Name = "NPC";
Lib.NPC.Global = {
    Interactions = {},
    NPC = {},
    UseMarker = true,
};
Lib.NPC.Local  = {};
Lib.NPC.Text = {
    StartConversation = {
        de = "Gespräch beginnen",
        en = "Start conversation",
        fr = "Conversation",
    }
};

CONST_LAST_NPC_INTERACTED = 0;
CONST_LAST_HERO_INTERACTED = 0;

Lib.Require("comfort/GetDistance");
Lib.Require("comfort/GetClosestToTarget");
Lib.Require("comfort/LookAt");
Lib.Require("comfort/Move");
Lib.Require("core/Core");
Lib.Require("module/entity/NPC_API");
Lib.Require("module/entity/NPC_Behavior");
Lib.Register("module/entity/NPC");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.NPC.Global:Initialize()
    if not self.IsInstalled then
        Report.NpcInteraction = CreateReport("Event_NpcInteraction");

        self:OverrideQuestFunctions();

        RequestHiResJob(function()
            if Logic.GetTime() > 1 then
                Lib.NPC.Global:InteractionTriggerController();
            end
        end);
        RequestJob(function()
            Lib.NPC.Global:InteractableMarkerController();
            Lib.NPC.Global:NpcFollowHeroController();
        end);

        -- Garbage collection
        Lib.NPC.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.NPC.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.NPC.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.NpcInteraction then
        CONST_LAST_NPC_INTERACTED = arg[1];
        CONST_LAST_HERO_INTERACTED = arg[2];
        self.Interactions[arg[1]] = self.Interactions[arg[1]] or {};
        if self.Interactions[arg[1]][arg[2]] then
            if Logic.GetCurrentTurn() <= self.Interactions[arg[1]][arg[2]] + 5 then
                return;
            end
        end
        self.Interactions[arg[1]][arg[2]] = Logic.GetCurrentTurn();
        self:PerformNpcInteraction(arg[3]);
    end
end

function Lib.NPC.Global:CreateNpc(_Data)
    self.NPC[_Data.Name] = {
        Name              = _Data.Name,
        Active            = true,
        Arrived           = false,
        Type              = _Data.Type or 1,
        Player            = _Data.Player or {1, 2, 3, 4, 5, 6, 7, 8},
        WrongPlayerAction = _Data.WrongPlayerAction,
        Hero              = _Data.Hero,
        WrongHeroAction   = _Data.WrongHeroAction,
        Distance          = _Data.Distance or 350,
        Condition         = _Data.Condition,
        Callback          = _Data.Callback,
        Follow            = _Data.Follow == true,
        FollowHero        = _Data.FollowHero,
        FollowCallback    = _Data.FollowCallback,
        FollowDestination = _Data.FollowDestination,
        FollowDistance    = _Data.FollowDistance or 2000,
        FollowArriveArea  = _Data.FollowArriveArea or 500,
        FollowSpeed       = _Data.FollowSpeed or 1.0,
        UseMarker         = self.UseMarker == true,
        MarkerID          = 0
    }
    self:UpdateNpc(_Data);
    return self.NPC[_Data.Name];
end

function Lib.NPC.Global:DestroyNpc(_Data)
    _Data.Active = false;
    self:UpdateNpc(_Data);
    self:DestroyMarker(_Data.Name);
    self.NPC[_Data.Name] = nil;
end

function Lib.NPC.Global:GetNpc(_ScriptName)
    return self.NPC[_ScriptName];
end

function Lib.NPC.Global:UpdateNpc(_Data)
    if not IsExisting(_Data.Name) then
        return;
    end
    if not self.NPC[_Data.Name] then
        local EntityID = GetID(_Data.Name);
        Logic.SetOnScreenInformation(EntityID, 0);
        return;
    end
    for k, v in pairs(_Data) do
        self.NPC[_Data.Name][k] = v;
    end
    self:CreateMarker(_Data.Name);
    if self.NPC[_Data.Name].Active then
        local EntityID = GetID(_Data.Name);
        Logic.SetOnScreenInformation(EntityID, self.NPC[_Data.Name].Type);
    else
        local EntityID = GetID(_Data.Name);
        Logic.SetOnScreenInformation(EntityID, 0);
    end
end

function Lib.NPC.Global:PerformNpcInteraction(_PlayerID)
    local ScriptName = Logic.GetEntityName(CONST_LAST_NPC_INTERACTED);
    if self.NPC[ScriptName] then
        local Data = self.NPC[ScriptName];
        self:RotateActorsToEachother(_PlayerID);
        self:AdjustHeroTalkingDistance(Data.Distance);

        if not self:InteractionIsAppropriatePlayer(ScriptName, _PlayerID, CONST_LAST_HERO_INTERACTED) then
            return;
        end
        Data.TalkedTo = CONST_LAST_HERO_INTERACTED;

        if not self:InteractionIsAppropriateHero(ScriptName) then
            return;
        end

        if Data.Condition == nil or Data:Condition(_PlayerID, CONST_LAST_HERO_INTERACTED) then
            if not Data.Follow then
                Data.Active = false;
                if Data.Callback then
                    Data:Callback(_PlayerID, CONST_LAST_HERO_INTERACTED);
                end
            else
                if Data.FollowCallback then
                    Data:FollowCallback(_PlayerID, CONST_LAST_HERO_INTERACTED, false);
                end
            end

        else
            Data.TalkedTo = 0;
        end

        self:UpdateNpc(Data);
    end
end

function Lib.NPC.Global:InteractionIsAppropriatePlayer(_ScriptName, _PlayerID, _HeroID)
    local Appropriate = true;
    if self.NPC[_ScriptName] then
        local Data = self.NPC[_ScriptName];
        if Data.Player ~= nil then
            if type(Data.Player) == "table" then
                Appropriate = table.contains(Data.Player, _PlayerID);
            else
                Appropriate = Data.Player == _PlayerID;
            end

            if not Appropriate then
                local LastTime = (Data.WrongHeroTick or 0) +1;
                local CurrentTime = Logic.GetTime();
                if Data.WrongPlayerAction and LastTime < CurrentTime then
                    self.NPC[_ScriptName].LastWongPlayerTick = CurrentTime;
                    Data:WrongPlayerAction(_PlayerID);
                end
            end
        end
    end
    return Appropriate;
end

function Lib.NPC.Global:InteractionIsAppropriateHero(_ScriptName)
    local Appropriate = true;
    if self.NPC[_ScriptName] then
        local Data = self.NPC[_ScriptName];
        if Data.Hero ~= nil then
            if type(Data.Hero) == "table" then
                Appropriate = table.contains(Data.Hero, Logic.GetEntityName(CONST_LAST_HERO_INTERACTED));
            end
            Appropriate = Data.Hero == Logic.GetEntityName(CONST_LAST_HERO_INTERACTED);

            if not Appropriate then
                local LastTime = (Data.WrongHeroTick or 0) +1;
                local CurrentTime = Logic.GetTime();
                if Data.WrongHeroAction and LastTime < CurrentTime then
                    self.NPC[_ScriptName].WrongHeroTick = CurrentTime;
                    Data:WrongHeroAction(CONST_LAST_HERO_INTERACTED);
                end
            end
        end
    end
    return Appropriate;
end

function Lib.NPC.Global:GetEntityMovementTarget(_EntityID)
    local X = GetFloat(_EntityID, CONST_SCRIPTING_VALUES.Destination.X);
    local Y = GetFloat(_EntityID, CONST_SCRIPTING_VALUES.Destination.Y);
    return {X= X, Y= Y};
end

function Lib.NPC.Global:RotateActorsToEachother(_PlayerID)
    local PlayerKnights = {};
    Logic.GetKnights(_PlayerID, PlayerKnights);
    for k, v in pairs(PlayerKnights) do
        local Target = self:GetEntityMovementTarget(v);
        local x, y, z = Logic.EntityGetPos(CONST_LAST_NPC_INTERACTED);
        if math.floor(Target.X) == math.floor(x) and math.floor(Target.Y) == math.floor(y) then
            x, y, z = Logic.EntityGetPos(v);
            Logic.MoveEntity(v, x, y);
            LookAt(v, CONST_LAST_NPC_INTERACTED);
        end
    end
    LookAt(CONST_LAST_HERO_INTERACTED, CONST_LAST_NPC_INTERACTED);
    LookAt(CONST_LAST_NPC_INTERACTED, CONST_LAST_HERO_INTERACTED);
end

function Lib.NPC.Global:AdjustHeroTalkingDistance(_Distance)
    local Distance = _Distance * GetFloat(CONST_LAST_NPC_INTERACTED, CONST_SCRIPTING_VALUES.Size);
    if GetDistance(CONST_LAST_HERO_INTERACTED, CONST_LAST_NPC_INTERACTED) <= Distance * 0.7 then
        local Orientation = Logic.GetEntityOrientation(CONST_LAST_NPC_INTERACTED);
        local x1, y1, z1 = Logic.EntityGetPos(CONST_LAST_HERO_INTERACTED);
        local x2 = x1 + ((Distance * 0.5) * math.cos(math.rad(Orientation)));
        local y2 = y1 + ((Distance * 0.5) * math.sin(math.rad(Orientation)));
        local ID = Logic.CreateEntityOnUnblockedLand(Entities.XD_ScriptEntity, x2, y2, 0, 0);
        local x3, y3, z3 = Logic.EntityGetPos(ID);
        Logic.MoveSettler(CONST_LAST_HERO_INTERACTED, x3, y3);
        RequestHiResJob( function(_HeroID, _NPCID, _Time)
            if Logic.GetTime() > _Time +0.5 and Logic.IsEntityMoving(_HeroID) == false then
                LookAt(_HeroID, _NPCID);
                LookAt(_NPCID, _HeroID);
                return true;
            end
        end, CONST_LAST_HERO_INTERACTED, CONST_LAST_NPC_INTERACTED, Logic.GetTime());
    end
end

function Lib.NPC.Global:OverrideQuestFunctions()
    GameCallback_OnNPCInteraction_Orig_NPC = GameCallback_OnNPCInteraction;
    GameCallback_OnNPCInteraction = function(_EntityID, _PlayerID, _KnightID)
        GameCallback_OnNPCInteraction_Orig_NPC(_EntityID, _PlayerID, _KnightID);
        local ClosestKnightID = _KnightID or Lib.NPC.Global:GetClosestKnight(_EntityID, _PlayerID);
        SendReport(Report.NpcInteraction, _EntityID, ClosestKnightID, _PlayerID);
        SendReportToLocal(Report.NpcInteraction, _EntityID, ClosestKnightID, _PlayerID);
    end

    QuestTemplate.RemoveQuestMarkers_Orig_NPC = QuestTemplate.RemoveQuestMarkers;
    --- @diagnostic disable-next-line: duplicate-set-field
    QuestTemplate.RemoveQuestMarkers = function(this)
        for i=1, this.Objectives[0] do
            if this.Objectives[i].Type == Objective.Distance then
                if this.Objectives[i].Data[1] ~= -65565 then
                    QuestTemplate.RemoveQuestMarkers_Orig_NPC(this);
                else
                    if this.Objectives[i].Data[4].NpcInstance then
                        NpcDispose(this.Objectives[i].Data[4].NpcInstance);
                        this.Objectives[i].Data[4].NpcInstance = nil;
                    end
                end
            else
                QuestTemplate.RemoveQuestMarkers_Orig_NPC(this);
            end
        end
    end

    QuestTemplate.ShowQuestMarkers_Orig_NPC = QuestTemplate.ShowQuestMarkers;
    --- @diagnostic disable-next-line: duplicate-set-field
    QuestTemplate.ShowQuestMarkers = function(this)
        for i=1, this.Objectives[0] do
            if this.Objectives[i].Type == Objective.Distance then
                if this.Objectives[i].Data[1] ~= -65565 then
                    QuestTemplate.ShowQuestMarkers_Orig_NPC(this);
                else
                    local Hero = this.Objectives[i].Data[2];
                    local Npc = this.Objectives[i].Data[3];
                    if  this.Objectives[i].Data[4].NpcInstance
                    and this.Objectives[i].Data[4].NpcInstance.Active == false then
                        this.Objectives[i].Data[4].NpcInstance = nil;
                    end
                    if not this.Objectives[i].Data[4].NpcInstance then
                        this.Objectives[i].Data[4].NpcInstance = NpcCompose {
                            Name   = Npc,
                            Hero   = Hero,
                            Player = this.ReceivingPlayer,
                        };
                    end
                end
            end
        end
    end

    QuestTemplate.IsObjectiveCompleted_Orig_NPC = QuestTemplate.IsObjectiveCompleted;
    --- @diagnostic disable-next-line: duplicate-set-field
    QuestTemplate.IsObjectiveCompleted = function(this, objective)
        local objectiveType = objective.Type;
        local data = objective.Data;
        if objective.Completed ~= nil then
            return objective.Completed;
        end

        if objectiveType ~= Objective.Distance then
            return this:IsObjectiveCompleted_Orig_NPC(objective);
        else
            if data[1] == -65565 then
                error(IsExisting(data[3]), data[3].. " is dead! :(");
                if data[4].NpcInstance and NpcTalkedTo(data[4].NpcInstance, data[2], this.ReceivingPlayer) then
                    objective.Completed = true;
                end
            else
                return this:IsObjectiveCompleted_Orig_NPC(objective);
            end
        end
    end
end

function Lib.NPC.Global:GetClosestKnight(_Entity, _PlayerID)
    local EntityID = GetID(_Entity);
    local KnightIDs = {};
    Logic.GetKnights(_PlayerID, KnightIDs);
    return GetClosestToTarget(EntityID, KnightIDs);
end

function Lib.NPC.Global:GetClosestKnightAllPlayer(_Entity)
    local ScriptName = Logic.GetEntityName(GetID(_Entity));
    if self.NPC[ScriptName] then
        local KnightIDs = {};
        for _, PlayerID in pairs(self.NPC[ScriptName].Player) do
            local PlayerKnightIDs = {};
            Logic.GetKnights(PlayerID, KnightIDs);
            KnightIDs = Array_Append(KnightIDs, PlayerKnightIDs);
        end
        return GetClosestToTarget(ScriptName, KnightIDs);
    end
end

function Lib.NPC.Global:ToggleMarkerUsage(_Flag)
    self.UseMarker = _Flag == true;
    for k, v in pairs(self.NPC) do
        self.NPC[k].UseMarker = _Flag == true;
        self:HideMarker(k);
    end
end

function Lib.NPC.Global:CreateMarker(_ScriptName)
    if self.NPC[_ScriptName] then
        local x,y,z = Logic.EntityGetPos(GetID(_ScriptName));
        local MarkerID = Logic.CreateEntity(Entities.XD_ScriptEntity, x, y, 0, 0);
        DestroyEntity(self.NPC[_ScriptName].MarkerID);
        self.NPC[_ScriptName].MarkerID = MarkerID;
        self:HideMarker(_ScriptName);
    end
end

function Lib.NPC.Global:DestroyMarker(_ScriptName)
    if self.NPC[_ScriptName] then
        DestroyEntity(self.NPC[_ScriptName].MarkerID);
        self.NPC[_ScriptName].MarkerID = 0;
    end
end

function Lib.NPC.Global:HideMarker(_ScriptName)
    if self.NPC[_ScriptName] then
        if IsExisting(self.NPC[_ScriptName].MarkerID) then
            Logic.SetModel(self.NPC[_ScriptName].MarkerID, Models.Effects_E_NullFX);
            Logic.SetVisible(self.NPC[_ScriptName].MarkerID, false);
        end
    end
end

function Lib.NPC.Global:ShowMarker(_ScriptName)
    if self.NPC[_ScriptName] then
        if self.NPC[_ScriptName].UseMarker == true and IsExisting(self.NPC[_ScriptName].MarkerID) then
            local Size = GetFloat(_ScriptName, CONST_SCRIPTING_VALUES.Size);
            SetFloat(self.NPC[_ScriptName].MarkerID, CONST_SCRIPTING_VALUES.Size, Size);
            Logic.SetModel(self.NPC[_ScriptName].MarkerID, Models.Effects_E_Wealth);
            Logic.SetVisible(self.NPC[_ScriptName].MarkerID, true);
        end
    end
end

function Lib.NPC.Global:GetEntityMovingTarget(_EntityID)
    local x = GetFloat(_EntityID, CONST_SCRIPTING_VALUES.Destination.X);
    local y = GetFloat(_EntityID, CONST_SCRIPTING_VALUES.Destination.Y);
    return {X= x, Y= y};
end

function Lib.NPC.Global:InteractionTriggerController()
    for PlayerID = 1, 8, 1 do
        local PlayersKnights = {};
        Logic.GetKnights(PlayerID, PlayersKnights);
        for i= 1, #PlayersKnights, 1 do
            if Logic.GetCurrentTaskList(PlayersKnights[i]) == "TL_NPC_INTERACTION" then
                for k, v in pairs(self.NPC) do
                    if v.Distance >= 350 then
                        local Target = self:GetEntityMovementTarget(PlayersKnights[i]);
                        local x2, y2 = Logic.EntityGetPos(GetID(k));
                        if math.floor(Target.X) == math.floor(x2) and math.floor(Target.Y) == math.floor(y2) then
                            if IsExisting(k) and IsNear(PlayersKnights[i], k, v.Distance) then
                                GameCallback_OnNPCInteraction(GetID(k), PlayerID, PlayersKnights[i]);
                                return;
                            end
                        end
                    end
                end
            end
        end
    end
end

function Lib.NPC.Global:InteractableMarkerController()
    for k, Data in pairs(self.NPC) do
        if Data.Active then
            if  Data.UseMarker and IsExisting(Data.MarkerID)
            and GetInteger(Data.MarkerID, CONST_SCRIPTING_VALUES.Visible) == 801280 then
                self:HideMarker(k);
            else
                self:ShowMarker(k);
            end
            local x1,y1,z1 = Logic.EntityGetPos(Data.MarkerID);
            local x2,y2,z2 = Logic.EntityGetPos(GetID(k));
            if math.abs(x1-x2) > 20 or math.abs(y1-y2) > 20 then
                Logic.DEBUG_SetPosition(Data.MarkerID, x2, y2);
            end
        end
    end
end

function Lib.NPC.Global:NpcFollowHeroController()
    for _, Data in pairs(self.NPC) do
        if Data.Active and Data.Follow and not Data.Arrived then
            local EntityID = GetID(Data.Name);
            local LeadingEntity = GetID(Data.FollowHero);
            local FollowDistance = Data.FollowDistance;
            local FollowDestination = Data.FollowDestination;
            local FollowArriveArea = Data.FollowArriveArea;
            local FollowSpeed = Data.FollowSpeed;

            -- Get leader
            if not LeadingEntity then
                LeadingEntity = self:GetClosestKnightAllPlayer(EntityID);
            end
            -- Move NPC
            if LeadingEntity and not Logic.IsEntityMoving(EntityID) then
                if  GetDistance(EntityID, LeadingEntity) <= FollowDistance
                and GetDistance(EntityID, LeadingEntity) > FollowArriveArea / 2 then
                    Logic.SetSpeedFactor(EntityID, FollowSpeed);
                    Move(EntityID, LeadingEntity);
                end
            end
            -- Check arrival
            if LeadingEntity and GetDistance(EntityID, FollowDestination) <= FollowArriveArea then
                if not Logic.IsEntityMoving(EntityID) then
                    Move(EntityID, FollowDestination);
                    if Data.FollowCallback then
                        local PlayerID = Logic.EntityGetPlayer(LeadingEntity);
                        Data:FollowCallback(PlayerID, LeadingEntity, true);
                    end
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.NPC.Local:Initialize()
    if not self.IsInstalled then
        Report.NpcInteraction = CreateReport("Event_NpcInteraction");

        self:OverrideQuestFunctions();

        -- Garbage collection
        Lib.NPC.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.NPC.Local:OnSaveGameLoaded()
end

-- Global report listener
function Lib.NPC.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.NpcInteraction then
        CONST_LAST_NPC_INTERACTED = arg[1];
        CONST_LAST_HERO_INTERACTED = arg[2];
    end
end

function Lib.NPC.Local:OverrideQuestFunctions()
    GUI_Interaction.DisplayQuestObjective_Orig_NPC = GUI_Interaction.DisplayQuestObjective;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local QuestIndexTemp = tonumber(_QuestIndex);
        if QuestIndexTemp then
            _QuestIndex = QuestIndexTemp;
        end

        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
        local QuestObjectiveContainer;
        local QuestTypeCaption;

        g_CurrentDisplayedQuestID = _QuestIndex;

        if QuestType == Objective.Distance then
            QuestObjectiveContainer = QuestObjectivesPath .. "/List";
            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction");
            local ObjectList = {};

            assert(Quest ~= nil);
            if Quest.Objectives[1].Data[1] == -65565 then
                QuestObjectiveContainer = QuestObjectivesPath .. "/Distance";
                QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestMoveHere");
                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{7,10});

                local MoverEntityID = GetID(Quest.Objectives[1].Data[2]);
                local MoverEntityType = Logic.GetEntityType(MoverEntityID);
                local MoverIcon = g_TexturePositions.Entities[MoverEntityType];
                if not MoverIcon then
                    MoverIcon = {7, 9};
                end
                SetIcon(QuestObjectiveContainer .. "/IconMover", MoverIcon);

                local TargetEntityID = GetID(Quest.Objectives[1].Data[3]);
                local TargetEntityType = Logic.GetEntityType(TargetEntityID);
                local TargetIcon = g_TexturePositions.Entities[TargetEntityType];
                if not TargetIcon then
                    TargetIcon = {14, 10};
                end

                local IconWidget = QuestObjectiveContainer .. "/IconTarget";
                local ColorWidget = QuestObjectiveContainer .. "/TargetPlayerColor";

                SetIcon(IconWidget, TargetIcon);
                XGUIEng.SetMaterialColor(ColorWidget, 0, 255, 255, 255, 0);

                SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{16,12});
                local caption = Lib.NPC.Text.StartConversation;
                QuestTypeCaption = Localize(caption);

                XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);
                XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
            else
                GUI_Interaction.DisplayQuestObjective_Orig_NPC(_QuestIndex, _MessageKey);
            end
        else
            GUI_Interaction.DisplayQuestObjective_Orig_NPC(_QuestIndex, _MessageKey);
        end
    end

    GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_NPC = GUI_Interaction.GetEntitiesOrTerritoryListForQuest
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Interaction.GetEntitiesOrTerritoryListForQuest = function( _Quest, _QuestType )
        local EntityOrTerritoryList = {}
        local IsEntity = true

        if _QuestType == Objective.Distance then
            if _Quest.Objectives[1].Data[1] == -65565 then
                local Entity = GetID(_Quest.Objectives[1].Data[3]);
                table.insert(EntityOrTerritoryList, Entity);
            else
                return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_NPC(_Quest, _QuestType);
            end

        else
            return GUI_Interaction.GetEntitiesOrTerritoryListForQuest_Orig_NPC(_Quest, _QuestType);
        end
        return EntityOrTerritoryList, IsEntity
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.NPC.Name);

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/settings/Sound_API");

function StartEventPlaylist(_Playlist, _PlayerID)
    _PlayerID = _PlayerID or 1;
    if GUI and _PlayerID == GUI.GetPlayerID() then
        Sound.MusicStartEventPlaylist(_Playlist);
    end
    ExecuteLocal("StartEventPlaylist('%s', %d)", _Playlist, _PlayerID);
end
API.StartEventPlaylist = StartEventPlaylist;

function StopEventPlaylist(_Playlist, _PlayerID)
    _PlayerID = _PlayerID or 1;
    if GUI and _PlayerID == GUI.GetPlayerID() then
        Sound.MusicStopEventPlaylist(_Playlist);
    end
    ExecuteLocal("StopEventPlaylist('%s', %d)", _Playlist, _PlayerID);
end
API.StopEventPlaylist = StopEventPlaylist;

function Play2DSound(_Sound, _PlayerID)
    _PlayerID = _PlayerID or 1;
    if GUI or _PlayerID == GUI.GetPlayerID() then
        Sound.FXPlay2DSound(_Sound:gsub("/", "\\"));
    end
    ExecuteLocal([[Play2DSound("%s", %d)]], _Sound, _PlayerID);
end
API.Play2DSound = Play2DSound;

function Play3DSound(_Sound, _X, _Y, _Z, _PlayerID)
    _PlayerID = _PlayerID or 1;
    _X = _X or 1;
    _Y = _Y or 1
    _Z = _Z or 0
    if GUI or _PlayerID == GUI.GetPlayerID() then
        Sound.FXPlay3DSound(_Sound:gsub("/", "\\"), _X, _Y, _Z);
    end
    ExecuteLocal([[Play3DSound("%s", %f, %f, %d)]], _Sound, _X, _Y, _PlayerID);
end
API.Play3DSound = Play3DSound;

function SoundSetVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if GUI then
        Lib.Sound.Local:AdjustSound(_Volume, nil, nil, nil, nil);
    end
    ExecuteLocal("SoundSetVolume(%d)", _Volume);
end
API.SoundSetVolume = SoundSetVolume;

function SoundSetMusicVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if GUI then
        Lib.Sound.Local:AdjustSound(nil, _Volume, nil, nil, nil);
    end
    ExecuteLocal("SoundSetMusicVolume(%d)", _Volume);
end
API.SoundSetMusicVolume = SoundSetMusicVolume;

function SoundSetVoiceVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if GUI then
        Lib.Sound.Local:AdjustSound(nil, nil, _Volume, nil, nil);
    end
    ExecuteLocal("SoundSetVoiceVolume(%d)", _Volume);
end
API.SoundSetVoiceVolume = SoundSetVoiceVolume;

function SoundSetAtmoVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if GUI then
        Lib.Sound.Local:AdjustSound(nil, nil, nil, _Volume, nil);
    end
    ExecuteLocal("SoundSetAtmoVolume(%d)", _Volume);
end
API.SoundSetAtmoVolume = SoundSetAtmoVolume;

function SoundSetUIVolume(_Volume)
    _Volume = (_Volume < 0 and 0) or math.floor(_Volume);
    if GUI then
        Lib.Sound.Local:AdjustSound(nil, nil, nil, nil, _Volume);
    end
    ExecuteLocal("SoundSetUIVolume(%d)", _Volume);
end
API.SoundSetUIVolume = SoundSetUIVolume;

function SoundSave()
    if GUI then
        Lib.Sound.Local:SaveSound();
    end
    Logic.ExecuteInLuaLocalState("SoundSave()");
end
API.SoundSave = SoundSave;

function SoundRestore()
    if GUI then
        Lib.Sound.Local:RestoreSound();
    end
    ExecuteLocal("SoundRestore()");
end
API.SoundRestore = SoundRestore;

function PlayVoice(_File, _Identifier)
    _Identifier = _Identifier or "ImportantStuff";
    if GUI then
        StopVoice();
        Sound.PlayVoice(_Identifier, _File);
    end
    ExecuteLocal([[PlayVoice("%s", "%s")]], _File, _Identifier);
end
API.PlayVoice = PlayVoice;

function StopVoice(_Identifier)
    _Identifier = _Identifier or "ImportantStuff";
    if GUI then
        Sound.StopVoice(_Identifier);
    end
    ExecuteLocal("StopVoice()");
end
API.StopVoice = StopVoice;

function RequestAlternateSound()
    if GUI then
        Lib.Sound.Local:RequestAlternateSound();
    end
    ExecuteLocal("RequestAlternateSound()");
end
API.RequestAlternateSound = RequestAlternateSound;

Lib.Register("module/settings/Sound_Text");

Lib.Sound = Lib.Sound or {};
Lib.Sound.Text = {
    Request = {
        Title = {
            de = "Lautstärke ändern",
            en = "Alternate Volume",
            fr = "Modifier le volume",
        },
        Text  = {
            de = "Während des Spiels kann die Lautstärke durch das Mapscript vorübergehend geändert werden. Willst du das zulassen?",
            en = "During gameplay the sound volume might be changed temporarily by the mapscript. Do you want to allow that?",
            fr = "Pendant le jeu, le volume sonore peut être modifié temporairement par le mapscript. Voulez-vous autoriser cela?",
        },
    },
};

Lib.Register("module/information/Requester_Behavior");

function Goal_Decide(...)
    return B_Goal_Decide:new(...);
end

g_GoalDecideDialogDisplayed = nil;
g_DecisionWindowResult = nil;

B_Goal_Decide = {
    Name = "Goal_Decide",
    Description = {
        en = "Goal: Opens a Yes/No Dialog. The decision dictates the quest result (yes=true, no=false).",
        de = "Ziel: Öffnet einen Ja/Nein-Dialog. Die Entscheidung bestimmt das Quest-Ergebnis (ja=true, nein=false).",
        fr = "Objectif: ouvre une fenêtre de dialogue oui/non. La décision détermine le résultat de la quête (oui=true, non=false).",
    },
    Parameter = {
        { ParameterType.Default, en = "Text",          de = "Text",                fr = "Text", },
        { ParameterType.Default, en = "Title",         de = "Titel",               fr = "Titre", },
        { ParameterType.Custom,  en = "Button labels", de = "Button Beschriftung", fr = "Inscription sur le bouton", },
    },
}

function B_Goal_Decide:GetGoalTable()
    return { Objective.Custom2, { self, self.CustomFunction } }
end

function B_Goal_Decide:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Text = _Parameter
    elseif (_Index == 1) then
        self.Title = _Parameter
    elseif (_Index == 2) then
        self.Buttons = (_Parameter == "Ok/Cancel" or _Parameter == true)
    end
end

function B_Goal_Decide:CustomFunction(_Quest)
    if Framework.IsNetworkGame() then
        return false;
    end
    if IsCinematicEventActive and IsCinematicEventActive(_Quest.ReceivingPlayer) then
        return;
    end
    if g_GoalDecideDialogDisplayed == nil then
        g_GoalDecideDialogDisplayed = true;
        ExecuteLocal(
            [[DialogRequestBox("%s", "%s", function(_Yes) end, %s)]],
            self.Title,
            self.Text,
            (self.Buttons and "true") or "nil"
        );
    end
    local result = g_DecisionWindowResult
    if result ~= nil then
        g_GoalDecideDialogDisplayed = nil;
        g_DecisionWindowResult = nil;
        return result;
    end
end

function B_Goal_Decide:GetCustomData(_Index)
    if _Index == 2 then
        return {"Yes/No", "Ok/Cancel"};
    end
end

function B_Goal_Decide:Debug(_Quest)
    if Framework.IsNetworkGame() then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Can not be used in multiplayer!");
        return true;
    end
    if _Quest.Visible == true then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Is supposed to be used in invisible quests!");
        return true;
    end
    return false;
end

function B_Goal_Decide:Reset()
    g_GoalDecideDialogDisplayed = nil;
end

RegisterBehavior(B_Goal_Decide);

-- -------------------------------------------------------------------------- --

Lib.Require("comfort/IsMultiplayer");
Lib.Require("comfort/IsLocalScript");
Lib.Register("module/information/Requester_API");

function TextWindow(_Caption, _Content, _PlayerID)
    _PlayerID = _PlayerID or 1;
    _Caption = Localize(_Caption);
    _Content = Localize(_Content);
    if not GUI then
        ExecuteLocal(
            [[TextWindow("%s", "%s", %d)]],
            _Caption,
            _Content,
            _PlayerID
        );
        return;
    end
    Lib.Requester.Local:ShowTextWindow {
        PlayerID = _PlayerID,
        Caption  = _Caption,
        Content  = _Content,
    };
end
API.TextWindow = TextWindow;

function DialogInfoBox(_PlayerID, _Title, _Text, _Action)
    assert(IsLocalScript(), "Can not be used in global script.");
    if type(_PlayerID) ~= "number" then
        _Action = _Text;
        _Text = _Title;
        _Title = _PlayerID;
        _PlayerID = GUI.GetPlayerID();
    end
    if type(_Title) == "table" then
        _Title = Localize(_Title);
    end
    if type(_Text) == "table" then
        _Text  = Localize(_Text);
    end
    Lib.Requester.Local:OpenDialog(_PlayerID, _Title, _Text, _Action);
end
API.DialogInfoBox = DialogInfoBox;

function DialogRequestBox(_PlayerID, _Title, _Text, _Action, _OkCancel)
    assert(IsLocalScript(), "Can not be used in global script.");
    if type(_PlayerID) ~= "number" then
        --- @diagnostic disable-next-line: cast-local-type
        _OkCancel = _Action;
        _Action = _Text;
        _Text = _Title;
        _Title = _PlayerID;
        _PlayerID = GUI.GetPlayerID();
    end
    if type(_Title) == "table" then
        _Title = Localize(_Title);
    end
    if type(_Text) == "table" then
        _Text  = Localize(_Text);
    end
    Lib.Requester.Local:OpenRequesterDialog(_PlayerID, _Title, _Text, _Action, _OkCancel);
end
API.DialogRequestBox = DialogRequestBox;

function DialogSelectBox(_PlayerID, _Title, _Text, _Action, _List)
    assert(IsLocalScript(), "Can not be used in global script.");
    if type(_PlayerID) ~= "number" then
        --- @diagnostic disable-next-line: cast-local-type
        _List = _Action;
        _Action = _Text;
        _Text = _Title;
        _Title = _PlayerID;
        _PlayerID = GUI.GetPlayerID();
    end
    if type(_Title) == "table" then
        _Title = Localize(_Title);
    end
    if type(_Text) == "table" then
        _Text  = Localize(_Text);
    end
    _Text = _Text .. "{cr}";
    Lib.Requester.Local:OpenSelectionDialog(_PlayerID, _Title, _Text, _Action, _List);
end
API.DialogSelectBox = DialogSelectBox;

function DialogLanguageSelection(_PlayerID)
    _PlayerID = _PlayerID or 0
    if not GUI then
        ExecuteLocal([[DialogLanguageSelection(%d)]], _PlayerID);
        return;
    end

    local ReceiverID = _PlayerID;
    local PlayerID = GUI.GetPlayerID();
    local IsGuiPlayer = ReceiverID == 0 or ReceiverID == PlayerID;
    if ReceiverID ~= 0 and GUI.GetPlayerID() ~= ReceiverID then
        return;
    end

    local DisplayedList = {};
    for i= 1, #Lib.Core.Text.Languages do
        table.insert(DisplayedList, Lib.Core.Text.Languages[i][2]);
    end
    local Action = function(_Selected)
        SendReportToGlobal(Report.LanguageSelectionClosed, PlayerID, IsGuiPlayer, Lib.Core.Text.Languages[_Selected][1]);
        SendReport(Report.LanguageSelectionClosed, PlayerID, IsGuiPlayer, Lib.Core.Text.Languages[_Selected][1]);
    end
    DialogSelectBox(
        PlayerID,
        Localize(Lib.Requester.Shared.Text.ChooseLanguage.Title),
        Localize(Lib.Requester.Shared.Text.ChooseLanguage.Text),
        Action,
        DisplayedList
    );
end
API.DialogLanguageSelection = DialogLanguageSelection;

Lib.Requester = Lib.Requester or {};
Lib.Requester.Name = "Requester";
Lib.Requester.Global = {};
Lib.Requester.Local = {
    Chat = {
        Data = {},
        History = {},
        Visible = {},
        Widgets = {}
    },
    Requester = {
        ActionFunction = nil,
        ActionRequester = nil,
        Next = nil,
        Queue = {},
    },
};
Lib.Requester.Shared = {
    Text = {
        ChooseLanguage = {
            Title = {
                de = "Wählt die Sprache",
                en = "Chose your Tongue",
                fr = "Sélectionnez la langue",
            },
            Text = {
                de = "Wählt aus der Liste die Sprache aus, in die Handlungstexte übersetzt werden sollen.",
                en = "Choose from the list below which language story texts shall be presented to you.",
                fr = "Sélectionne dans la liste la langue dans laquelle les textes narratifs doivent être traduits.",
            }
        }
    },
};

Lib.Require("core/core");
Lib.Require("module/information/Requester_API");
Lib.Require("module/information/Requester_Behavior");
Lib.Register("module/information/Requester");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.Requester.Global:Initialize()
    if not self.IsInstalled then
        Report.RequesterClosed = CreateReport("Event_RequesterClosed");
        Report.LanguageSelectionClosed = CreateReport("Event_LanguageSelectionClosed");

        -- Garbage collection
        Lib.Requester.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.Requester.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Requester.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.RequesterClosed then
        -- HACK: Make Goal_Decide more safe
        g_GoalDecideDialogDisplayed = false;
        g_DecisionWindowResult = arg[3] == true;
    elseif _ID == Report.LanguageSelectionClosed then
        Lib.Core.Text:ChangeSystemLanguage(arg[1], arg[2], arg[3]);
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.Requester.Local:Initialize()
    if not self.IsInstalled then
        Report.RequesterClosed = CreateReport("Event_RequesterClosed");
        Report.LanguageSelectionClosed = CreateReport("Event_LanguageSelectionClosed");

        for i= 1, 8 do
            self.Chat.Data[i] = {};
            self.Chat.History[i] = {};
            self.Chat.Visible[i] = false;
            self.Chat.Widgets[i] = {};
        end

        self:OverrideChatLog();
        self:DialogOverwriteOriginal();
        self:DialogAltF4Hotkey();

        -- Garbage collection
        Lib.Requester.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.Requester.Local:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Requester.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.SaveGameLoaded then
        self:DialogAltF4Hotkey();
    end
end

-- ---------
-- Requester

function Lib.Requester.Local:DialogAltF4Hotkey()
    StartSimpleJobEx(function ()
        if Lib.Requester.Local.LoadscreenClosed then
            Input.KeyBindDown(Keys.ModifierAlt + Keys.F4, "Lib.Requester.Local:DialogAltF4Action()", 2, false);
            return true;
        end
    end);
end

function Lib.Requester.Local:DialogAltF4Action()
    Input.KeyBindDown(Keys.ModifierAlt + Keys.F4, "", 30, false);
    self:OpenRequesterDialog(
        GUI.GetPlayerID(),
        XGUIEng.GetStringTableText("UI_Texts/MainMenuExitGame_center"),
        XGUIEng.GetStringTableText("UI_Texts/ConfirmQuitCurrentGame"),
        function (_Yes)
            if _Yes then
                Framework.ExitGame();
            end
            if not Framework.IsNetworkGame() then
                Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);
            end
            Lib.Requester.Local:DialogAltF4Hotkey();
        end
    );
end

function Lib.Requester.Local:Callback(_PlayerID)
    if self.Requester.ActionFunction then
        self.Requester.ActionFunction(CustomGame.Knight + 1, _PlayerID);
    end
    self:OnDialogClosed(CustomGame.Knight + 1);
end

function Lib.Requester.Local:CallbackRequester(_yes, _PlayerID)
    if self.Requester.ActionRequester then
        self.Requester.ActionRequester(_yes, _PlayerID);
    end
    self:OnDialogClosed(_yes);
end

function Lib.Requester.Local:OnDialogClosed(_Selected)
    if not self.SavingWasDisabled then
        DisableSaving(false);
    end
    if not IsMultiplayer() then
        Game.GameTimeSetFactor(GUI.GetPlayerID(), 1);
    end
    SendReportToGlobal(Report.RequesterClosed, GUI.GetPlayerID(), self.DialogWindowShown, _Selected);
    SendReport(Report.RequesterClosed, GUI.GetPlayerID(), self.DialogWindowShown, _Selected);
    self.SavingWasDisabled = false;
    self.DialogWindowShown = nil;
    self:DialogQueueStartNext();
end

function Lib.Requester.Local:DialogQueueStartNext()
    self.Requester.Next = table.remove(self.Requester.Queue, 1);

    RequestHiResJob(function()
        local Entry = Lib.Requester.Local.Requester.Next;
        if Entry and Entry[1] and Entry[2] then
            local Methode = Entry[1];
            Lib.Requester.Local[Methode](Lib.Requester.Local, unpack(Entry[2]));
            Lib.Requester.Local.Requester.Next = nil;
        end
        return true;
    end);
end

function Lib.Requester.Local:DialogQueuePush(_Methode, _Args)
    local Entry = {_Methode, _Args};
    table.insert(self.Requester.Queue, Entry);
end

function Lib.Requester.Local:OpenDialog(_PlayerID, _Title, _Text, _Action)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        assert(type(_Title) == "string");
        assert(type(_Text) == "string");

        if not IsMultiplayer() then
            Game.GameTimeSetFactor(GUI.GetPlayerID(), 0.0000001);
        end

        _Title = "{center}" .. Lib.Core.Text:ConvertPlaceholders(_Title);
        _Text  = Lib.Core.Text:ConvertPlaceholders(_Text);
        if string.len(_Text) < 35 then
            _Text = _Text .. "{cr}";
        end

        g_MapAndHeroPreview.SelectKnight = function(_Knight) end

        XGUIEng.ShowAllSubWidgets("/InGame/Dialog/BG",1);
        XGUIEng.ShowWidget("/InGame/Dialog/Backdrop",0);
        XGUIEng.ShowWidget(RequesterDialog,1);
        XGUIEng.ShowWidget(RequesterDialog_Yes,0);
        XGUIEng.ShowWidget(RequesterDialog_No,0);
        XGUIEng.ShowWidget(RequesterDialog_Ok,1);

        if type(_Action) == "function" then
            self.Requester.ActionFunction = _Action;
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; if not Framework.IsNetworkGame() then Game.GameTimeSetFactor(GUI.GetPlayerID(), 1) end";
            Action = Action .. "; XGUIEng.PopPage()";
            Action = Action .. "; Lib.Requester.Local.Callback(Lib.Requester.Local, GUI.GetPlayerID())";
            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);
        else
            self.Requester.ActionFunction = nil;
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; if not Framework.IsNetworkGame() then Game.GameTimeSetFactor(GUI.GetPlayerID(), 1) end";
            Action = Action .. "; XGUIEng.PopPage()";
            Action = Action .. "; Lib.Requester.Local.Callback(Lib.Requester.Local, GUI.GetPlayerID())";
            XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);
        end

        XGUIEng.SetText(RequesterDialog_Message, "{center}" .. _Text);
        XGUIEng.SetText(RequesterDialog_Title, _Title);
        XGUIEng.SetText(RequesterDialog_Title.."White", _Title);
        XGUIEng.PushPage(RequesterDialog,false);

        if Lib.Core.Save.SavingDisabled then
            self.SavingWasDisabled = true;
        end
        DisableSaving(true);
        self.DialogWindowShown = 1;
        -- HACK: Ensure Goal_Decide work safety
        ExecuteGlobal("g_GoalDecideDialogDisplayed = true");
    else
        self:DialogQueuePush("OpenDialog", {_PlayerID, _Title, _Text, _Action});
    end
end

function Lib.Requester.Local:OpenRequesterDialog(_PlayerID, _Title, _Text, _Action, _OkCancel)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        assert(type(_Title) == "string");
        assert(type(_Text) == "string");
        _Title = "{center}" .. _Title;

        self:OpenDialog(_PlayerID, _Title, _Text, _Action);
        XGUIEng.ShowWidget(RequesterDialog_Yes,1);
        XGUIEng.ShowWidget(RequesterDialog_No,1);
        XGUIEng.ShowWidget(RequesterDialog_Ok,0);

        if _OkCancel then
            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Ok_center"));
            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/Cancel_center"));
        else
            XGUIEng.SetText(RequesterDialog_Yes, XGUIEng.GetStringTableText("UI_Texts/Yes_center"));
            XGUIEng.SetText(RequesterDialog_No, XGUIEng.GetStringTableText("UI_Texts/No_center"));
        end

        self.Requester.ActionRequester = nil;
        if _Action then
            assert(type(_Action) == "function");
            self.Requester.ActionRequester = _Action;
        end
        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
        Action = Action .. "; if not Framework.IsNetworkGame() then Game.GameTimeSetFactor(GUI.GetPlayerID(), 1) end";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; Lib.Requester.Local.CallbackRequester(Lib.Requester.Local, true, GUI.GetPlayerID())"
        XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);
        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)"
        Action = Action .. "; if not Framework.IsNetworkGame() then Game.GameTimeSetFactor(GUI.GetPlayerID(), 1) end";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; Lib.Requester.Local.CallbackRequester(Lib.Requester.Local, false, GUI.GetPlayerID())"
        XGUIEng.SetActionFunction(RequesterDialog_No, Action);
        self.DialogWindowShown = 2;
        -- HACK: Ensure Goal_Decide work safety
        ExecuteGlobal("g_GoalDecideDialogDisplayed = true");
    else
        self:DialogQueuePush("OpenRequesterDialog", {_PlayerID, _Title, _Text, _Action, _OkCancel});
    end
end

function Lib.Requester.Local:OpenSelectionDialog(_PlayerID, _Title, _Text, _Action, _List)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
        self:OpenDialog(_PlayerID, _Title, _Text, _Action);

        local HeroComboBoxID = XGUIEng.GetWidgetID(CustomGame.Widget.KnightsList);
        XGUIEng.ListBoxPopAll(HeroComboBoxID);
        for i=1,#_List do
            XGUIEng.ListBoxPushItem(HeroComboBoxID, _List[i] );
        end
        XGUIEng.ListBoxSetSelectedIndex(HeroComboBoxID, 0);
        CustomGame.Knight = 0;

        local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)"
        Action = Action .. "; if not Framework.IsNetworkGame() then Game.GameTimeSetFactor(GUI.GetPlayerID(), 1) end";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; XGUIEng.PopPage()";
        Action = Action .. "; Lib.Requester.Local.Callback(Lib.Requester.Local, GUI.GetPlayerID())";
        XGUIEng.SetActionFunction(RequesterDialog_Ok, Action);

        local Container = "/InGame/Singleplayer/CustomGame/ContainerSelection/";
        XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", "");
        if _List[1] then
            XGUIEng.SetText(Container .. "HeroComboBoxMain/HeroComboBox", _List[1]);
        end
        XGUIEng.PushPage(Container .. "HeroComboBoxContainer", false);
        XGUIEng.PushPage(Container .. "HeroComboBoxMain",false);
        XGUIEng.ShowWidget(Container .. "HeroComboBoxContainer", 0);
        local screen = {GUI.GetScreenSize()};
        local x1, y1 = XGUIEng.GetWidgetScreenPosition(RequesterDialog_Ok);
        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxMain", x1-25, y1-(90*(screen[2]/1080)));
        XGUIEng.SetWidgetScreenPosition(Container .. "HeroComboBoxContainer", x1-25, y1-(20*(screen[2]/1080)));
        self.DialogWindowShown = 3;
        -- HACK: Ensure Goal_Decide work safety
        ExecuteGlobal("g_GoalDecideDialogDisplayed = true");
    else
        self:DialogQueuePush("OpenSelectionDialog", {_PlayerID, _Title, _Text, _Action, _List});
    end
end

function Lib.Requester.Local:DialogOverwriteOriginal()
    OpenDialog_Orig_Windows = OpenDialog;
    OpenDialog = function(_Message, _Title, _IsMPError)
        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            OpenDialog_Orig_Windows(_Title, _Message);
        end
    end

    OpenRequesterDialog_Orig_Windows = OpenRequesterDialog;
    OpenRequesterDialog = function(_Message, _Title, action, _OkCancel, no_action)
        if XGUIEng.IsWidgetShown(RequesterDialog) == 0 then
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            XGUIEng.SetActionFunction(RequesterDialog_Yes, Action);
            local Action = "XGUIEng.ShowWidget(RequesterDialog, 0)";
            Action = Action .. "; XGUIEng.PopPage()";
            XGUIEng.SetActionFunction(RequesterDialog_No, Action);
            OpenRequesterDialog_Orig_Windows(_Message, _Title, action, _OkCancel, no_action);
        end
    end
end

-- --------
-- Chat Log

function Lib.Requester.Local:ShowTextWindow(_Data)
    _Data.PlayerID = _Data.PlayerID or 1;
    _Data.Button = _Data.Button or {};
    local PlayerID = GUI.GetPlayerID();
    if _Data.PlayerID ~= PlayerID then
        return;
    end
    if XGUIEng.IsWidgetShown("/InGame/Root/Normal/ChatOptions") == 1 then
        self:UpdateChatLogText(_Data);
        return;
    end
    self.Chat.Data[PlayerID] = _Data;
    self:CloseTextWindow(PlayerID);
    self:AlterChatLog();

    XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ChatLog", _Data.Content);
    XGUIEng.SetText("/InGame/Root/Normal/MessageLog/Name","{center}" .._Data.Caption);
    if _Data.DisableClose then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/Exit",0);
    end
    self:ShouldShowSlider(_Data.Content);
    XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",1);
end

function Lib.Requester.Local:CloseTextWindow(_PlayerID)
    assert(_PlayerID ~= nil);
    local PlayerID = GUI.GetPlayerID();
    if _PlayerID ~= PlayerID then
        return;
    end
    GUI_Chat.CloseChatMenu();
end

function Lib.Requester.Local:UpdateChatLogText(_Data)
    XGUIEng.SetText("/InGame/Root/Normal/ChatOptions/ChatLog", _Data.Content);
end

function Lib.Requester.Local:AlterChatLog()
    local PlayerID = GUI.GetPlayerID();
    if self.Chat.Visible[PlayerID] then
        return;
    end
    self.Chat.Visible[PlayerID] = true;
    self.Chat.History[PlayerID] = table.copy(g_Chat.ChatHistory);
    g_Chat.ChatHistory = {};
    self:AlterChatLogDisplay();
end

function Lib.Requester.Local:RestoreChatLog()
    local PlayerID = GUI.GetPlayerID();
    if not self.Chat.Visible[PlayerID] then
        return;
    end
    self.Chat.Visible[PlayerID] = false;
    g_Chat.ChatHistory = {};
    for i= 1, #self.Chat.History[PlayerID] do
        GUI_Chat.ChatlogAddMessage(self.Chat.History[PlayerID][i]);
    end
    self:RestoreChatLogDisplay();
    self.Chat.History[PlayerID] = {};
    self.Chat.Widgets[PlayerID] = {};
    self.Chat.Data[PlayerID] = {};
end

function Lib.Requester.Local:UpdateToggleWhisperTarget()
    local PlayerID = GUI.GetPlayerID();
    local MotherWidget = "/InGame/Root/Normal/ChatOptions/";
    if not self.Chat.Data[PlayerID] or not self.Chat.Data[PlayerID].Button
    or not self.Chat.Data[PlayerID].Button.Action then
        XGUIEng.ShowWidget(MotherWidget.. "ToggleWhisperTarget",0);
        return;
    end
    local ButtonText = self.Chat.Data[PlayerID].Button.Text;
    XGUIEng.SetText(MotherWidget.. "ToggleWhisperTarget","{center}" ..ButtonText);
end

function Lib.Requester.Local:ShouldShowSlider(_Text)
    local Lines = CountTextLines(_Text, 170);
    if Lines > 20 then
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions/ChatLogSlider",1);
    end
end

function Lib.Requester.Local:OverrideChatLog()
    GUI_Chat.ChatlogAddMessage_Orig_Requester = GUI_Chat.ChatlogAddMessage;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Chat.ChatlogAddMessage = function(_Message)
        local PlayerID = GUI.GetPlayerID();
        if not Lib.Requester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.ChatlogAddMessage_Orig_Requester(_Message);
            return;
        end
        table.insert(Lib.Requester.Local.Chat.History[PlayerID], _Message);
    end

    GUI_Chat.DisplayChatLog_Orig_Requester = GUI_Chat.DisplayChatLog;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Chat.DisplayChatLog = function()
        local PlayerID = GUI.GetPlayerID();
        if not Lib.Requester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.DisplayChatLog_Orig_Requester();
        end
    end

    GUI_Chat.CloseChatMenu_Orig_Requester = GUI_Chat.CloseChatMenu;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Chat.CloseChatMenu = function()
        local PlayerID = GUI.GetPlayerID();
        if not Lib.Requester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.CloseChatMenu_Orig_Requester();
            return;
        end
        Lib.Requester.Local:RestoreChatLog();
        XGUIEng.ShowWidget("/InGame/Root/Normal/ChatOptions",0);
    end

    GUI_Chat.ToggleWhisperTargetUpdate_Orig_Requester = GUI_Chat.ToggleWhisperTargetUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Chat.ToggleWhisperTargetUpdate = function()
        local PlayerID = GUI.GetPlayerID();
        if not Lib.Requester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.ToggleWhisperTargetUpdate_Orig_Requester();
            return;
        end
        Lib.Requester.Local:UpdateToggleWhisperTarget();
    end

    GUI_Chat.CheckboxMessageTypeWhisperUpdate_Orig_Requester = GUI_Chat.CheckboxMessageTypeWhisperUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Chat.CheckboxMessageTypeWhisperUpdate = function()
        local PlayerID = GUI.GetPlayerID();
        if not Lib.Requester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.CheckboxMessageTypeWhisperUpdate_Orig_Requester();
            return;
        end
    end

    GUI_Chat.ToggleWhisperTarget_Orig_Requester = GUI_Chat.ToggleWhisperTarget;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Chat.ToggleWhisperTarget = function()
        local PlayerID = GUI.GetPlayerID();
        if not Lib.Requester.Local.Chat.Visible[PlayerID] then
            GUI_Chat.ToggleWhisperTarget_Orig_Requester();
            return;
        end
        if Lib.Requester.Local.Chat.Data[PlayerID].Button.Action then
            local Data = Lib.Requester.Local.Chat.Data[PlayerID];
            Lib.Requester.Local.Chat.Data[PlayerID].Button.Action(Data);
        end
    end
end

function Lib.Requester.Local:AlterChatLogDisplay()
    local PlayerID = GUI.GetPlayerID();

    local w,h,x,y;
    local Widget;
    local MotherWidget = "/InGame/Root/Normal/ChatOptions/";
    x,y = XGUIEng.GetWidgetLocalPosition(MotherWidget.. "ToggleWhisperTarget");
    w,h = XGUIEng.GetWidgetSize(MotherWidget.. "ToggleWhisperTarget");
    self.Chat.Widgets[PlayerID]["ToggleWhisperTarget"] = {X= x, Y= y, W= w, H= h};
    Widget = self.Chat.Widgets[PlayerID]["ToggleWhisperTarget"];

    x,y = XGUIEng.GetWidgetLocalPosition(MotherWidget.. "ChatLog");
    w,h = XGUIEng.GetWidgetSize(MotherWidget.. "ChatLog");
    self.Chat.Widgets[PlayerID]["ChatLog"] = {X= x, Y= y, W= w, H= h};
    Widget = self.Chat.Widgets[PlayerID]["ChatLog"];

    x,y = XGUIEng.GetWidgetLocalPosition(MotherWidget.. "ChatLogSlider");
    w,h = XGUIEng.GetWidgetSize(MotherWidget.. "ChatLogSlider");
    self.Chat.Widgets[PlayerID]["ChatLogSlider"] = {X= x, Y= y, W= w, H= h};
    Widget = self.Chat.Widgets[PlayerID]["ChatLogSlider"];

    XGUIEng.ShowWidget(MotherWidget.. "ChatModeAllPlayers",0);
    XGUIEng.ShowWidget(MotherWidget.. "ChatModeTeam",0);
    XGUIEng.ShowWidget(MotherWidget.. "ChatModeWhisper",0);
    XGUIEng.ShowWidget(MotherWidget.. "ChatChooseModeCaption",0);
    XGUIEng.ShowWidget(MotherWidget.. "Background/TitleBig",1);
    XGUIEng.ShowWidget(MotherWidget.. "Background/TitleBig/Info",0);
    XGUIEng.ShowWidget(MotherWidget.. "ChatLogCaption",0);
    XGUIEng.ShowWidget(MotherWidget.. "BGChoose",0);
    XGUIEng.ShowWidget(MotherWidget.. "BGChatLog",0);
    XGUIEng.ShowWidget(MotherWidget.. "ChatLogSlider",0);

    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/BG",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Close",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Slider",0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog/Text",0);
    XGUIEng.SetText("/InGame/Root/Normal/MessageLog/Name","{center}Test");
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog",15,90);
    XGUIEng.SetWidgetLocalPosition("/InGame/Root/Normal/MessageLog/Name",0,0);
    XGUIEng.SetTextColor("/InGame/Root/Normal/MessageLog/Name",51,51,121,255);

    XGUIEng.SetWidgetSize(MotherWidget.. "ChatLogSlider",46,600);
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ChatLogSlider",780,130);
    XGUIEng.SetWidgetSize(MotherWidget.. "Background/DialogBG/1 (2)/2",150,400);
    XGUIEng.SetWidgetPositionAndSize(MotherWidget.. "Background/DialogBG/1 (2)/3",400,500,350,400);
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ToggleWhisperTarget",280,760);
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ChatLog",140,150);
    XGUIEng.SetWidgetSize(MotherWidget.. "ChatLog",640,560);
end

function Lib.Requester.Local:RestoreChatLogDisplay()
    local PlayerID = GUI.GetPlayerID();

    local Widget;
    local MotherWidget = "/InGame/Root/Normal/ChatOptions/";
    Widget = self.Chat.Widgets[PlayerID]["ToggleWhisperTarget"];
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ToggleWhisperTarget", Widget.X, Widget.Y);
    XGUIEng.SetWidgetSize(MotherWidget.. "ToggleWhisperTarget", Widget.W, Widget.H);
    Widget = self.Chat.Widgets[PlayerID]["ChatLog"];
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ChatLog", Widget.X, Widget.Y);
    XGUIEng.SetWidgetSize(MotherWidget.. "ChatLog", Widget.W, Widget.H);
    Widget = self.Chat.Widgets[PlayerID]["ChatLogSlider"];
    XGUIEng.SetWidgetLocalPosition(MotherWidget.. "ChatLogSlider", Widget.X, Widget.Y);
    XGUIEng.SetWidgetSize(MotherWidget.. "ChatLogSlider", Widget.W, Widget.H);

    XGUIEng.ShowWidget(MotherWidget.. "ChatModeAllPlayers",1);
    XGUIEng.ShowWidget(MotherWidget.. "ChatModeTeam",1);
    XGUIEng.ShowWidget(MotherWidget.. "ChatModeWhisper",1);
    XGUIEng.ShowWidget(MotherWidget.. "ChatChooseModeCaption",1);
    XGUIEng.ShowWidget(MotherWidget.. "Background/TitleBig",1);
    XGUIEng.ShowWidget(MotherWidget.. "Background/TitleBig/Info",1);
    XGUIEng.ShowWidget(MotherWidget.. "ChatLogCaption",1);
    XGUIEng.ShowWidget(MotherWidget.. "BGChoose",1);
    XGUIEng.ShowWidget(MotherWidget.. "BGChatLog",1);
    XGUIEng.ShowWidget(MotherWidget.. "ChatLogSlider",1);
    XGUIEng.ShowWidget(MotherWidget.. "ToggleWhisperTarget",1);

    XGUIEng.ShowWidget("/InGame/Root/Normal/MessageLog",0);
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.Requester.Name);

--- @diagnostic disable: duplicate-set-field

Lib.Sound = Lib.Sound or {};
Lib.Sound.Name = "Sound";
Lib.Sound.Global = {};
Lib.Sound.Local = {
    Config = {
        DoAlternateSound = true,
    },
    SoundBackup = {},
};

CONST_FARCLIPPLANE = 45000;
CONST_FARCLIPPLANE_DEFAULT = 0;

Lib.Require("comfort/IsMultiplayer");
Lib.Require("core/Core");
Lib.Require("module/information/Requester");
Lib.Require("module/settings/Sound_Text");
Lib.Require("module/settings/Sound_API");
Lib.Register("module/settings/Sound");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.Sound.Global:Initialize()
    if not self.IsInstalled then
        -- Garbage collection
        Lib.Sound.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.Sound.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Sound.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.Sound.Local:Initialize()
    if not self.IsInstalled then
        -- Garbage collection
        Lib.Sound.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.Sound.Local:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Sound.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

function Lib.Sound.Local:RequestAlternateSound()
    -- Request window won't show in Multiplayer
    if IsMultiplayer() then
        return;
    end
    -- Ask the player if they want to allow changing sound settings.
    DialogRequestBox(
        GUI.GetPlayerID(),
        Lib.Sound.Text.Request.Title,
        Lib.Sound.Text.Request.Text,
        function(_Yes)
            Lib.Sound.Local.Config.DoAlternateSound = _Yes == true;
        end,
        false
    );
end

function Lib.Sound.Local:AdjustSound(_Global, _Music, _Voice, _Atmo, _UI)
    -- Prevent changing sound altogether if player chosed to
    if not self.Config.DoAlternateSound then
        return;
    end
    -- Save sound backup
    self:SaveSound();
    -- Make changes to the sound
    if _Global then
        Sound.SetGlobalVolume(_Global);
    end
    if _Music then
        Sound.SetMusicVolume(_Music);
    end
    if _Voice then
        Sound.SetSpeechVolume(_Voice);
    end
    if _Atmo then
        Sound.SetFXSoundpointVolume(_Atmo);
        Sound.SetFXAtmoVolume(_Atmo);
    end
    if _UI then
        Sound.Set2DFXVolume(_UI);
        Sound.SetFXVolume(_UI);
    end
end

function Lib.Sound.Local:SaveSound()
    if not self.SoundBackup.Saved then
        self.SoundBackup.Saved = true;
        self.SoundBackup.FXSP = Sound.GetFXSoundpointVolume();
        self.SoundBackup.FXAtmo = Sound.GetFXAtmoVolume();
        self.SoundBackup.FXVol = Sound.GetFXVolume();
        self.SoundBackup.Sound = Sound.GetGlobalVolume();
        self.SoundBackup.Music = Sound.GetMusicVolume();
        self.SoundBackup.Voice = Sound.GetSpeechVolume();
        self.SoundBackup.UI = Sound.Get2DFXVolume();
    end
end

function Lib.Sound.Local:RestoreSound()
    if self.SoundBackup.Saved then
        Sound.SetFXSoundpointVolume(self.SoundBackup.FXSP);
        Sound.SetFXAtmoVolume(self.SoundBackup.FXAtmo);
        Sound.SetFXVolume(self.SoundBackup.FXVol);
        Sound.SetGlobalVolume(self.SoundBackup.Sound);
        Sound.SetMusicVolume(self.SoundBackup.Music);
        Sound.SetSpeechVolume(self.SoundBackup.Voice);
        Sound.Set2DFXVolume(self.SoundBackup.UI);
        self.SoundBackup = {};
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.Sound.Name);

Lib.Register("module/city/Promotion_Requirements");

-- This is the real deal. Defines the requirements, needs and rights.
InitKnightTitleTablesOverwrite = function()
    KnightTitles = {}
    KnightTitles.Knight     = 0
    KnightTitles.Mayor      = 1
    KnightTitles.Baron      = 2
    KnightTitles.Earl       = 3
    KnightTitles.Marquees   = 4
    KnightTitles.Duke       = 5
    KnightTitles.Archduke   = 6

    -- ---------------------------------------------------------------------- --
    -- Rights and Duties                                                      --
    -- ---------------------------------------------------------------------- --

    NeedsAndRightsByKnightTitle = {}

    -- The following applies to rights and needs: Both are displayed in the
    -- order they are listed in the table. There are only 8 icons available
    -- for the rights and only 3 for the needs. So if something needs to be
    -- visible for the player it must be put first in the table.

    -- Knight ------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Knight] = {
        ActivateNeedForPlayer,
        {
            Needs.Nutrition,                                    -- Need: Food
            Needs.Medicine,                                     -- Need: Medicine
        },
        ActivateRightForPlayer,
        {
            Technologies.R_Gathering,                           -- Right: Gathering
            Technologies.R_Woodcutter,                          -- Right: Woodcutter
            Technologies.R_StoneQuarry,                         -- Right: Stone Quarry
            Technologies.R_HuntersHut,                          -- Right: Hunter
            Technologies.R_FishingHut,                          -- Right: Fishing Hut
            Technologies.R_CattleFarm,                          -- Right: Cow Farm
            Technologies.R_GrainFarm,                           -- Right: Grain Farm
            Technologies.R_SheepFarm,                           -- Right: Sheep Farm
            Technologies.R_IronMine,                            -- Right: Iron Mine
            Technologies.R_Beekeeper,                           -- Right: Beekeeper
            Technologies.R_HerbGatherer,                        -- Right: Herb Gatherer
            Technologies.R_Nutrition,                           -- Right: Food
            Technologies.R_Bakery,                              -- Right: Bakery
            Technologies.R_Dairy,                               -- Right: Dairy
            Technologies.R_Butcher,                             -- Right: Butcher
            Technologies.R_SmokeHouse,                          -- Right: Smoke House
            Technologies.R_Clothes,                             -- Right: Clothes
            Technologies.R_Tanner,                              -- Right: Tanner
            Technologies.R_Weaver,                              -- Right: Weaver
            Technologies.R_Construction,                        -- Right: Construction
            Technologies.R_Trail,                               -- Right: Path
            Technologies.R_KnockDown,                           -- Right: Demolition
            Technologies.R_Sermon,                              -- Right: Sermon
        }
    }

    -- Mayor -------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Mayor] = {
        ActivateNeedForPlayer,
        {
            Needs.Clothes,                                      -- Need: Clothes
        },
        ActivateRightForPlayer,
        {
            Technologies.R_Military,                            -- Right: Military
            Technologies.R_MilitarySword,                       -- Right: Swordmen
            Technologies.R_Thieves,                             -- Right: Thief
            Technologies.R_Hygiene,                             -- Right: Hygiene
            Technologies.R_Soapmaker,                           -- Right: Soap Maker
            Technologies.R_BroomMaker,                          -- Right: Broom Maker
            Technologies.R_SpecialEdition,                      -- Right: Special Edition
            Technologies.R_SpecialEdition_Pavilion,             -- Right: Pavilion (AeK SE)
            Technologies.R_SpecialEdition_StatueFamily,         -- Right: Statue of Family (AeK SE)
            -- Technologies.R_SwordSmith,                          
            -- Technologies.R_Barracks,                            
        },
        StartKnightsPromotionCelebration                        -- Start promotion celebration
    }

    -- Baron -------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Baron] = {
        ActivateNeedForPlayer,
        {
            Needs.Hygiene,                                      -- Need: Hygiene
        },
        ActivateRightForPlayer,
        {
            Technologies.R_SiegeEngineWorkshop,                 -- Right: Siege Engine Workshop
            Technologies.R_BatteringRam,                        -- Right: Battering Ram
            Technologies.R_Pallisade,                           -- Right: Palisade
            Technologies.R_Medicine,                            -- Right: Medicine
            Technologies.R_Entertainment,                       -- Right: Entertainment
            Technologies.R_Tavern,                              -- Right: Tavern
            Technologies.R_Street,                              -- Right: Street
            Technologies.R_Festival,                            -- Right: Festival
            Technologies.R_SpecialEdition_Column,               -- Right: Pilar (AeK SE)
        },
        StartKnightsPromotionCelebration                        -- Start promotion celebration
    }

    -- Earl --------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Earl] = {
        ActivateNeedForPlayer,
        {
            Needs.Entertainment,                                -- Need: Entertainment
            Needs.Prosperity,                                   -- Need: Prosperity
        },
        ActivateRightForPlayer,
        {
            Technologies.R_MilitaryBow,                         -- Right: Swordmen
            Technologies.R_Baths,                               -- Right: Baths
            Technologies.R_Prosperity,                          -- Right: Prosperity
            Technologies.R_Taxes,                               -- Right: Adjust taxes
            Technologies.R_SpecialEdition_StatueSettler,        -- Right: Statue of Settlers (AeK SE)
            -- Technologies.R_BowMaker,                            
            -- Technologies.R_BarracksArchers,                     
        },
        StartKnightsPromotionCelebration                        -- Start promotion celebration
    }

    -- Marquees ----------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Marquees] = {
        ActivateNeedForPlayer,
        {
            Needs.Wealth,                                       -- Need: Decoration
        },
        ActivateRightForPlayer,
        {
            Technologies.R_Theater,                             -- Right: Theathre
            Technologies.R_Wealth,                              -- Right: Decorations
            Technologies.R_BannerMaker,                         -- Right: Banner Maker
            Technologies.R_SiegeTower,                          -- Right: Siege Tower
            Technologies.R_Wall,                                -- Right: Wall
            Technologies.R_Ballista,                            -- Right: Wall Catapult
            Technologies.R_AmmunitionCart,                      -- Right: Ammunition Cart
            Technologies.R_SpecialEdition_StatueProduction,     -- Right: Statue of Production (AeK SE)
        },
        StartKnightsPromotionCelebration                        -- Start promotion celebration
    }

    -- Duke --------------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Duke] = {
        ActivateNeedForPlayer,
        nil,
        ActivateRightForPlayer,
        {
            Technologies.R_Catapult,                            -- Right: Catapult
            Technologies.R_Carpenter,                           -- Right: Carpenter
            Technologies.R_CandleMaker,                         -- Right: Cancle Maker
            Technologies.R_Blacksmith,                          -- Right: Blacksmith
            Technologies.R_SpecialEdition_StatueDario,          -- Right: Statue of Dario (AeK SE)
        },
        StartKnightsPromotionCelebration                        -- Start promotion celebration
    }

    -- Archduke ----------------------------------------------------------------

    NeedsAndRightsByKnightTitle[KnightTitles.Archduke] = {
        ActivateNeedForPlayer,
        nil,
        ActivateRightForPlayer,
        {
            Technologies.R_Victory                              -- Victory
        },
        -- VictroryBecauseOfTitle,                              -- Victory because of title
        StartKnightsPromotionCelebration                        -- Start promotion celebration
    }

    -- Addon -------------------------------------------------------------------

    if Framework.GetGameExtraNo() >= 1 then
        local TechnologiesTableIndex = 4;
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Cistern);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Mayor][TechnologiesTableIndex],Technologies.R_Beautification_Brazier);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Baron][TechnologiesTableIndex],Technologies.R_Beautification_Shrine);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Baron][TechnologiesTableIndex],Technologies.R_Beautification_Pillar);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_StoneBench);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Earl][TechnologiesTableIndex],Technologies.R_Beautification_Sundial);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Marquees][TechnologiesTableIndex],Technologies.R_Beautification_Vase);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Duke][TechnologiesTableIndex],Technologies.R_Beautification_VictoryColumn);
        table.insert(NeedsAndRightsByKnightTitle[KnightTitles.Archduke][TechnologiesTableIndex],Technologies.R_Beautification_TriumphalArch);
    end

    -- ---------------------------------------------------------------------- --
    -- Conditions                                                             --
    -- ---------------------------------------------------------------------- --

    KnightTitleRequirements = {}

    -- Knight ------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Mayor] = {}
    KnightTitleRequirements[KnightTitles.Mayor].Headquarters = 1
    KnightTitleRequirements[KnightTitles.Mayor].Settlers = 10
    KnightTitleRequirements[KnightTitles.Mayor].Products = {
        {GoodCategories.GC_Clothes, 6},
    }

    -- Baron -------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Baron] = {}
    KnightTitleRequirements[KnightTitles.Baron].Settlers = 30
    KnightTitleRequirements[KnightTitles.Baron].Headquarters = 1
    KnightTitleRequirements[KnightTitles.Baron].Storehouse = 1
    KnightTitleRequirements[KnightTitles.Baron].Cathedrals = 1
    KnightTitleRequirements[KnightTitles.Baron].Products = {
        {GoodCategories.GC_Hygiene, 12},
    }

    -- Earl --------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Earl] = {}
    KnightTitleRequirements[KnightTitles.Earl].Settlers = 50
    KnightTitleRequirements[KnightTitles.Earl].Headquarters = 2
    KnightTitleRequirements[KnightTitles.Earl].Goods = {
        {Goods.G_Beer, 18},
    }

    -- Marquess ----------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Marquees] = {}
    KnightTitleRequirements[KnightTitles.Marquees].Settlers = 70
    KnightTitleRequirements[KnightTitles.Marquees].Headquarters = 2
    KnightTitleRequirements[KnightTitles.Marquees].Storehouse = 2
    KnightTitleRequirements[KnightTitles.Marquees].Cathedrals = 2
    KnightTitleRequirements[KnightTitles.Marquees].RichBuildings = 20

    -- Duke --------------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Duke] = {}
    KnightTitleRequirements[KnightTitles.Duke].Settlers = 90
    KnightTitleRequirements[KnightTitles.Duke].Storehouse = 2
    KnightTitleRequirements[KnightTitles.Duke].Cathedrals = 2
    KnightTitleRequirements[KnightTitles.Duke].Headquarters = 3
    KnightTitleRequirements[KnightTitles.Duke].DecoratedBuildings = {
        {Goods.G_Banner, 9 },
    }

    -- Archduke ----------------------------------------------------------------

    KnightTitleRequirements[KnightTitles.Archduke] = {}
    KnightTitleRequirements[KnightTitles.Archduke].Settlers = 150
    KnightTitleRequirements[KnightTitles.Archduke].Storehouse = 3
    KnightTitleRequirements[KnightTitles.Archduke].Cathedrals = 3
    KnightTitleRequirements[KnightTitles.Archduke].Headquarters = 3
    KnightTitleRequirements[KnightTitles.Archduke].RichBuildings = 30
    KnightTitleRequirements[KnightTitles.Archduke].FullDecoratedBuildings = 30

    -- Activate settings
    CreateTechnologyKnightTitleTable()
end

Lib.Register("module/city/Promotion_Helper");

Lib.Promotion = Lib.Promotion or {};
Lib.Promotion.Helper = {};

-- This is needed to overwrite the helper functions after the loadscreen has
-- been clicked away.
Lib.Promotion.Helper.OverwritePromotionHelper = function()
    DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist = Lib.Promotion.Helper.DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist;
    DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist = Lib.Promotion.Helper.DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist;
    DoesNeededNumberOfGoodTypesForKnightTitleExist = Lib.Promotion.Helper.DoesNeededNumberOfGoodTypesForKnightTitleExist;
    DoNeededNumberOfConsumedGoodsForKnightTitleExist = Lib.Promotion.Helper.DoNeededNumberOfConsumedGoodsForKnightTitleExist;
    DoNumberOfProductsInCategoryExist = Lib.Promotion.Helper.DoNumberOfProductsInCategoryExist;
    DoNeededDiversityBuffForKnightTitleExist = Lib.Promotion.Helper.DoNeededDiversityBuffForKnightTitleExist;
    DoCustomFunctionForKnightTitleSucceed = Lib.Promotion.Helper.DoCustomFunctionForKnightTitleSucceed;
    DoNeededNumberOfDecoratedBuildingsForKnightTitleExist = Lib.Promotion.Helper.DoNeededNumberOfDecoratedBuildingsForKnightTitleExist;
    DoNeededSpecialBuildingUpgradeForKnightTitleExist = Lib.Promotion.Helper.DoNeededSpecialBuildingUpgradeForKnightTitleExist;
    DoesNeededCityReputationForKnightTitleExist = Lib.Promotion.Helper.DoesNeededCityReputationForKnightTitleExist;
    DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist = Lib.Promotion.Helper.DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist;
    DoNeededNumberOfRichBuildingsForKnightTitleExist = Lib.Promotion.Helper.DoNeededNumberOfRichBuildingsForKnightTitleExist;
    DoNeededNumberOfGoodsForKnightTitleExist = Lib.Promotion.Helper.DoNeededNumberOfGoodsForKnightTitleExist;
    DoesNeededNumberOfSettlersForKnightTitleExist = Lib.Promotion.Helper.DoesNeededNumberOfSettlersForKnightTitleExist;
    CanKnightBePromoted = Lib.Promotion.Helper.CanKnightBePromoted;
    VictroryBecauseOfTitle = Lib.Promotion.Helper.VictroryBecauseOfTitle;
end

Lib.Promotion.Helper.DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Category == nil then
        return;
    end
    if _i then
        local EntityCategory = KnightTitleRequirements[_KnightTitle].Category[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Category[_i][2];

        local ReachedAmount = 0;
        if EntityCategory == EntityCategories.Spouse then
            ReachedAmount = Logic.GetNumberOfSpouses(_PlayerID);
        else
            local Buildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategory)};
            for i=1, #Buildings do
                if Logic.IsBuilding(Buildings[i]) == 1 then
                    if Logic.IsConstructionComplete(Buildings[i]) == 1 then
                        ReachedAmount = ReachedAmount +1;
                    end
                else
                    ReachedAmount = ReachedAmount +1;
                end
            end
        end

        if ReachedAmount >= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Category do
            bool, reach, need = Lib.Promotion.Helper.DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

Lib.Promotion.Helper.DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Entities == nil then
        return;
    end
    if _i then
        local EntityType = KnightTitleRequirements[_KnightTitle].Entities[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Entities[_i][2];
        local Buildings = GetPlayerEntities(_PlayerID, EntityType);

        local ReachedAmount = 0;
        for i=1, #Buildings do
            if Logic.IsBuilding(Buildings[i]) == 1 then
                if Logic.IsConstructionComplete(Buildings[i]) == 1 then
                    ReachedAmount = ReachedAmount +1;
                end
            else
                ReachedAmount = ReachedAmount +1;
            end
        end

        if ReachedAmount >= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Entities do
            bool, reach, need = Lib.Promotion.Helper.DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

Lib.Promotion.Helper.DoesNeededNumberOfGoodTypesForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Goods == nil then
        return;
    end
    if _i then
        local GoodType = KnightTitleRequirements[_KnightTitle].Goods[_i][1];
        local NeededAmount = KnightTitleRequirements[_KnightTitle].Goods[_i][2];
        local ReachedAmount = GetPlayerGoodsInSettlement(GoodType, _PlayerID, true);

        if ReachedAmount >= NeededAmount then
            return true, ReachedAmount, NeededAmount;
        end
        return false, ReachedAmount, NeededAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Goods do
            bool, reach, need = Lib.Promotion.Helper.DoesNeededNumberOfGoodTypesForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

Lib.Promotion.Helper.DoNeededNumberOfConsumedGoodsForKnightTitleExist = function( _PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Consume == nil then
        return;
    end
    if _i then
        CONST_CONSUMED_GOODS_COUNTER[_PlayerID] = CONST_CONSUMED_GOODS_COUNTER[_PlayerID] or {};

        local GoodType = KnightTitleRequirements[_KnightTitle].Consume[_i][1];
        local GoodAmount = CONST_CONSUMED_GOODS_COUNTER[_PlayerID][GoodType] or 0;
        local NeededGoodAmount = KnightTitleRequirements[_KnightTitle].Consume[_i][2];
        if GoodAmount >= NeededGoodAmount then
            return true, GoodAmount, NeededGoodAmount;
        else
            return false, GoodAmount, NeededGoodAmount;
        end
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Consume do
            bool, reach, need = Lib.Promotion.Helper.DoNeededNumberOfConsumedGoodsForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return false, reach, need
            end
        end
        return true, reach, need;
    end
end

Lib.Promotion.Helper.DoNumberOfProductsInCategoryExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Products == nil then
        return;
    end
    if _i then
        local GoodAmount = 0;
        local NeedAmount = KnightTitleRequirements[_KnightTitle].Products[_i][2];
        local GoodCategory = KnightTitleRequirements[_KnightTitle].Products[_i][1];
        local GoodsInCategory = {Logic.GetGoodTypesInGoodCategory(GoodCategory)};

        for i=1, #GoodsInCategory do
            GoodAmount = GoodAmount + GetPlayerGoodsInSettlement(GoodsInCategory[i], _PlayerID, true);
        end
        return (GoodAmount >= NeedAmount), GoodAmount, NeedAmount;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Products do
            bool, reach, need = Lib.Promotion.Helper.DoNumberOfProductsInCategoryExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

Lib.Promotion.Helper.DoNeededDiversityBuffForKnightTitleExist = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Buff == nil then
        return;
    end
    if _i then
        local buff = KnightTitleRequirements[_KnightTitle].Buff[_i];
        if Logic.GetBuff(_PlayerID,buff) and Logic.GetBuff(_PlayerID,buff) ~= 0 then
            return true;
        end
        return false;
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Buff do
            bool, reach, need = Lib.Promotion.Helper.DoNeededDiversityBuffForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

Lib.Promotion.Helper.DoCustomFunctionForKnightTitleSucceed = function(_PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].Custom == nil then
        return;
    end
    if _i then
        return KnightTitleRequirements[_KnightTitle].Custom[_i][1](_PlayerID, _KnightTitle, _i);
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].Custom do
            bool, reach, need = Lib.Promotion.Helper.DoCustomFunctionForKnightTitleSucceed(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

Lib.Promotion.Helper.DoNeededNumberOfDecoratedBuildingsForKnightTitleExist = function( _PlayerID, _KnightTitle, _i)
    if KnightTitleRequirements[_KnightTitle].DecoratedBuildings == nil then
        return
    end

    if _i then
        local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}
        local DecorationGoodType = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][1]
        local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].DecoratedBuildings[_i][2]
        local BuildingsWithDecoration = 0

        for i=1, #CityBuildings do
            local BuildingID = CityBuildings[i]
            local GoodState = Logic.GetBuildingWealthGoodState(BuildingID, DecorationGoodType)
            if GoodState > 0 then
                BuildingsWithDecoration = BuildingsWithDecoration + 1
            end
        end

        if BuildingsWithDecoration >= NeededBuildingsWithDecoration then
            return true, BuildingsWithDecoration, NeededBuildingsWithDecoration
        else
            return false, BuildingsWithDecoration, NeededBuildingsWithDecoration
        end
    else
        local bool, reach, need;
        for i=1,#KnightTitleRequirements[_KnightTitle].DecoratedBuildings do
            bool, reach, need = Lib.Promotion.Helper.DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(_PlayerID, _KnightTitle, i);
            if bool == false then
                return bool, reach, need
            end
        end
        return bool;
    end
end

Lib.Promotion.Helper.DoNeededSpecialBuildingUpgradeForKnightTitleExist = function( _PlayerID, _KnightTitle, _EntityCategory)
    local SpecialBuilding
    local SpecialBuildingName
    if _EntityCategory == EntityCategories.Headquarters then
        SpecialBuilding = Logic.GetHeadquarters(_PlayerID)
        SpecialBuildingName = "Headquarters"
    elseif _EntityCategory == EntityCategories.Storehouse then
        SpecialBuilding = Logic.GetStoreHouse(_PlayerID)
        SpecialBuildingName = "Storehouse"
    elseif _EntityCategory == EntityCategories.Cathedrals then
        SpecialBuilding = Logic.GetCathedral(_PlayerID)
        SpecialBuildingName = "Cathedrals"
    else
        return
    end
    if KnightTitleRequirements[_KnightTitle][SpecialBuildingName] == nil then
        return
    end
    local NeededUpgradeLevel = KnightTitleRequirements[_KnightTitle][SpecialBuildingName]
    if SpecialBuilding ~= nil then
        local SpecialBuildingUpgradeLevel = Logic.GetUpgradeLevel(SpecialBuilding)
        if SpecialBuildingUpgradeLevel >= NeededUpgradeLevel then
            return true, SpecialBuildingUpgradeLevel, NeededUpgradeLevel
        else
            return false, SpecialBuildingUpgradeLevel, NeededUpgradeLevel
        end
    else
        return false, 0, NeededUpgradeLevel
    end
end

Lib.Promotion.Helper.DoesNeededCityReputationForKnightTitleExist = function(_PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].Reputation == nil then
        return;
    end
    local NeededAmount = KnightTitleRequirements[_KnightTitle].Reputation;
    if not NeededAmount then
        return;
    end
    local ReachedAmount = math.floor((Logic.GetCityReputation(_PlayerID) * 100) + 0.5);
    if ReachedAmount >= NeededAmount then
        return true, ReachedAmount, NeededAmount;
    end
    return false, ReachedAmount, NeededAmount;
end

Lib.Promotion.Helper.DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist = function( _PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings == nil then
        return
    end
    local CityBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)}
    local NeededBuildingsWithDecoration = KnightTitleRequirements[_KnightTitle].FullDecoratedBuildings
    local BuildingsWithDecoration = 0

    for i=1, #CityBuildings do
        local BuildingID = CityBuildings[i]
        local AmountOfWealthGoodsAtBuilding = 0

        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Banner ) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Sign  ) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Candle) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if Logic.GetBuildingWealthGoodState(BuildingID, Goods.G_Ornament  ) > 0 then
            AmountOfWealthGoodsAtBuilding = AmountOfWealthGoodsAtBuilding  + 1
        end
        if AmountOfWealthGoodsAtBuilding >= 4 then
            BuildingsWithDecoration = BuildingsWithDecoration + 1
        end
    end

    if BuildingsWithDecoration >= NeededBuildingsWithDecoration then
        return true, BuildingsWithDecoration, NeededBuildingsWithDecoration
    else
        return false, BuildingsWithDecoration, NeededBuildingsWithDecoration
    end
end

Lib.Promotion.Helper.DoNeededNumberOfRichBuildingsForKnightTitleExist = function( _PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].RichBuildings == nil then
        return
    end
    local NumberOfRichBuildings = Logic.GetNumberOfProsperBuildings(_PlayerID, 1)
    local NeededNumberOfRichBuildings = KnightTitleRequirements[_KnightTitle].RichBuildings

    if NeededNumberOfRichBuildings == -1 then
        NeededNumberOfRichBuildings = Logic.GetNumberOfPlayerEntitiesInCategory(_PlayerID, EntityCategories.CityBuilding)
        NeededNumberOfRichBuildings = NeededNumberOfRichBuildings
            - Logic.GetNumberOfEntitiesOfTypeOfPlayer(_PlayerID, Entities.B_Barracks)
            - Logic.GetNumberOfEntitiesOfTypeOfPlayer(_PlayerID, Entities.B_BarracksArchers)
            - Logic.GetNumberOfEntitiesOfTypeOfPlayer(_PlayerID, Entities.B_SiegeEngineWorkshop)
    end

    if NumberOfRichBuildings >= NeededNumberOfRichBuildings then
        return true, NumberOfRichBuildings, NeededNumberOfRichBuildings
    else
        return false, NumberOfRichBuildings, NeededNumberOfRichBuildings
    end
end

Lib.Promotion.Helper.DoNeededNumberOfGoodsForKnightTitleExist = function( _PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].Good == nil then
        return
    end
    local EntityCategory = KnightTitleRequirements[_KnightTitle].Good[1]
    local EntitiesInCategory = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategory)}
    local GoodAmount = 0

    for i = 1, #EntitiesInCategory do
        local EntityID = EntitiesInCategory[i]
        local EntityType = Logic.GetEntityType(EntityID)
        if  EntityType ~= Entities.B_TableBeer
        and EntityType ~= Entities.B_Marketslot
        and Logic.IsEntityTypeInCategory(EntityType, EntityCategories.Marketplace) == 0
        and Logic.IsKnight(EntityID) == false then
            local GoodAmountInEntity = Logic.GetAmountOnOutStockByIndex(EntityID,0)
            GoodAmount = GoodAmount + GoodAmountInEntity
        end
    end

    local NeededGoodAmount = KnightTitleRequirements[_KnightTitle].Good[2]
    if GoodAmount >= NeededGoodAmount then
        return true, GoodAmount, NeededGoodAmount
    else
        return false, GoodAmount, NeededGoodAmount
    end
end

Lib.Promotion.Helper.DoesNeededNumberOfSettlersForKnightTitleExist = function( _PlayerID, _KnightTitle)
    if KnightTitleRequirements[_KnightTitle].Settlers == nil then
        return
    end
    local NeededSettlers = KnightTitleRequirements[_KnightTitle].Settlers
    if NeededSettlers ~= nil then
        local Settlers = Logic.GetNumberOfEmployedWorkers(_PlayerID)
        if Settlers >= NeededSettlers then
            return true, Settlers, NeededSettlers
        else
            return false, Settlers, NeededSettlers
        end
    end
end

Lib.Promotion.Helper.CanKnightBePromoted = function(_PlayerID, _KnightTitle)
    if _KnightTitle == nil then
        _KnightTitle = Logic.GetKnightTitle(_PlayerID) + 1;
    end

    if Logic.CanStartFestival(_PlayerID, 1) == true then
        if  KnightTitleRequirements[_KnightTitle] ~= nil
        and DoesNeededNumberOfSettlersForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfGoodsForKnightTitleExist(_PlayerID, _KnightTitle)  ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist(_PlayerID, _KnightTitle, EntityCategories.Headquarters) ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist(_PlayerID, _KnightTitle, EntityCategories.Storehouse) ~= false
        and DoNeededSpecialBuildingUpgradeForKnightTitleExist(_PlayerID, _KnightTitle, EntityCategories.Cathedrals)  ~= false
        and DoNeededNumberOfRichBuildingsForKnightTitleExist(_PlayerID, _KnightTitle)  ~= false
        and DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoesNeededCityReputationForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoesNeededNumberOfGoodTypesForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoNeededDiversityBuffForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoCustomFunctionForKnightTitleSucceed(_PlayerID, _KnightTitle) ~= false
        and DoNeededNumberOfConsumedGoodsForKnightTitleExist(_PlayerID, _KnightTitle) ~= false
        and DoNumberOfProductsInCategoryExist(_PlayerID, _KnightTitle) ~= false then
            return true;
        end
    end
    return false;
end

Lib.Promotion.Helper.VictroryBecauseOfTitle = function()
    QuestTemplate:TerminateEventsAndStuff();
    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);
end

Lib.Register("module/city/Promotion_Config");

Lib.Promotion = Lib.Promotion or {};
Lib.Promotion.Config = {};

function Lib.Promotion.Config:InitAddonText()
    if Framework.GetGameExtraNo() ~= 0 then
        Lib.Promotion.Config.BuffTypeNames[Buffs.Buff_Gems] = {
            de = "Edelsteine beschaffen",
            en = "Obtain gems",
            fr = "Se procurer des Gemmes",
        }
        Lib.Promotion.Config.BuffTypeNames[Buffs.Buff_Olibanum] = {
            de = "Weihrauch beschaffen",
            en = "Obtain olibanum",
            fr = "Se procurer de l'encens",
        }
        Lib.Promotion.Config.BuffTypeNames[Buffs.Buff_MusicalInstrument] = {
            de = "Muskinstrumente beschaffen",
            en = "Obtain instruments",
            fr = "Se procurer des instruments de musique",
        }
    end
end

function Lib.Promotion.Config:InitTexturePositions()
    g_TexturePositions.EntityCategories[EntityCategories.GC_Food_Supplier]          = { 1, 1};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Clothes_Supplier]       = { 1, 2};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Hygiene_Supplier]       = {16, 1};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Entertainment_Supplier] = { 1, 4};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Luxury_Supplier]        = {16, 3};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Weapon_Supplier]        = { 1, 7};
    g_TexturePositions.EntityCategories[EntityCategories.GC_Medicine_Supplier]      = { 2,10};
    g_TexturePositions.EntityCategories[EntityCategories.Outpost]                   = {12, 3};
    g_TexturePositions.EntityCategories[EntityCategories.Spouse]                    = { 5,15};
    g_TexturePositions.EntityCategories[EntityCategories.CattlePasture]             = { 3,16};
    g_TexturePositions.EntityCategories[EntityCategories.SheepPasture]              = { 4, 1};
    g_TexturePositions.EntityCategories[EntityCategories.Soldier]                   = { 7,12};
    g_TexturePositions.EntityCategories[EntityCategories.GrainField]                = {14, 2};
    g_TexturePositions.EntityCategories[EntityCategories.BeeHive]                   = { 2, 1};
    g_TexturePositions.EntityCategories[EntityCategories.OuterRimBuilding]          = { 3, 4};
    g_TexturePositions.EntityCategories[EntityCategories.CityBuilding]              = { 8, 1};
    g_TexturePositions.EntityCategories[EntityCategories.Leader]                    = { 7, 11};
    g_TexturePositions.EntityCategories[EntityCategories.Range]                     = { 9, 8};
    g_TexturePositions.EntityCategories[EntityCategories.Melee]                     = { 9, 7};
    g_TexturePositions.EntityCategories[EntityCategories.SiegeEngine]               = { 2,15};

    g_TexturePositions.Entities[Entities.B_Beehive]                                 = { 2, 1};
    g_TexturePositions.Entities[Entities.B_Cathedral_Big]                           = { 3,12};
    g_TexturePositions.Entities[Entities.B_CattlePasture]                           = { 3,16};
    g_TexturePositions.Entities[Entities.B_GrainField_ME]                           = { 1,13};
    g_TexturePositions.Entities[Entities.B_GrainField_NA]                           = { 1,13};
    g_TexturePositions.Entities[Entities.B_GrainField_NE]                           = { 1,13};
    g_TexturePositions.Entities[Entities.B_GrainField_SE]                           = { 1,13};
    g_TexturePositions.Entities[Entities.U_MilitaryBallista]                        = {10, 5};
    g_TexturePositions.Entities[Entities.B_Outpost]                                 = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_ME]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_NA]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_NE]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_Outpost_SE]                              = {12, 3};
    g_TexturePositions.Entities[Entities.B_SheepPasture]                            = { 4, 1};
    g_TexturePositions.Entities[Entities.U_SiegeEngineCart]                         = { 9, 4};
    g_TexturePositions.Entities[Entities.U_Trebuchet]                               = { 9, 1};

    g_TexturePositions.Needs[Needs.Medicine]                                        = { 2,10};

    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_1]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_2]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Castle_Upgrade_3]                = { 4, 7};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_1]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_2]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Cathedral_Upgrade_3]             = { 4, 5};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_1]            = { 4, 6};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_2]            = { 4, 6};
    g_TexturePositions.Technologies[Technologies.R_Storehouse_Upgrade_3]            = { 4, 6};

    g_TexturePositions.Buffs = g_TexturePositions.Buffs or {};

    g_TexturePositions.Buffs[Buffs.Buff_ClothesDiversity]                           = { 1, 2};
    g_TexturePositions.Buffs[Buffs.Buff_EntertainmentDiversity]                     = { 1, 4};
    g_TexturePositions.Buffs[Buffs.Buff_FoodDiversity]                              = { 1, 1};
    g_TexturePositions.Buffs[Buffs.Buff_HygieneDiversity]                           = { 1, 3};
    g_TexturePositions.Buffs[Buffs.Buff_Colour]                                     = { 5,11};
    g_TexturePositions.Buffs[Buffs.Buff_Entertainers]                               = { 5,12};
    g_TexturePositions.Buffs[Buffs.Buff_ExtraPayment]                               = { 1, 8};
    g_TexturePositions.Buffs[Buffs.Buff_Sermon]                                     = { 4,14};
    g_TexturePositions.Buffs[Buffs.Buff_Spice]                                      = { 5,10};
    g_TexturePositions.Buffs[Buffs.Buff_NoTaxes]                                    = { 1, 6};

    g_TexturePositions.GoodCategories = g_TexturePositions.GoodCategories or {};

    g_TexturePositions.GoodCategories[GoodCategories.GC_Ammunition]                 = {10, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Animal]                     = { 4,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Clothes]                    = { 1, 2};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Document]                   = { 5, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Entertainment]              = { 1, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Food]                       = { 1, 1};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Gold]                       = { 1, 8};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Hygiene]                    = {16, 1};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Luxury]                     = {16, 3};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Medicine]                   = { 2,10};
    g_TexturePositions.GoodCategories[GoodCategories.GC_None]                       = {15,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_RawFood]                    = { 3, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_RawMedicine]                = { 2, 2};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Research]                   = { 5, 6};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Resource]                   = { 3, 4};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Tools]                      = { 4,12};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Water]                      = { 1,16};
    g_TexturePositions.GoodCategories[GoodCategories.GC_Weapon]                     = { 8, 5};
end

function Lib.Promotion.Config:InitTexturePositionsAddon()
    if Framework.GetGameExtraNo() ~= 0 then
        g_TexturePositions.Entities[Entities.B_GrainField_AS]  = { 1,13};
        g_TexturePositions.Entities[Entities.B_Outpost_AS]     = {12, 3};
        g_TexturePositions.Buffs[Buffs.Buff_Gems]              = { 1, 1, 1};
        g_TexturePositions.Buffs[Buffs.Buff_MusicalInstrument] = { 1, 3, 1};
        g_TexturePositions.Buffs[Buffs.Buff_Olibanum]          = { 1, 2, 1};
    end
end

Lib.Promotion.Config.RequirementWidgets = {
    [1] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Settlers",
    [2] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Goods",
    [3] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/RichBuildings",
    [4] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Castle",
    [5] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Storehouse",
    [6] = "/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/Requirements/Cathedral",
};

if GoodCategories then
    Lib.Promotion.Config.GoodCategoryNames = {
        [GoodCategories.GC_Ammunition]      = {de = "Munition",         en = "Ammunition",      fr = "Munition"},
        [GoodCategories.GC_Animal]          = {de = "Nutztiere",        en = "Livestock",       fr = "Animaux d'élevage"},
        [GoodCategories.GC_Clothes]         = {de = "Kleidung",         en = "Clothes",         fr = "Vêtements"},
        [GoodCategories.GC_Document]        = {de = "Dokumente",        en = "Documents",       fr = "Documents"},
        [GoodCategories.GC_Entertainment]   = {de = "Unterhaltung",     en = "Entertainment",   fr = "Divertissement"},
        [GoodCategories.GC_Food]            = {de = "Nahrungsmittel",   en = "Food",            fr = "Nourriture"},
        [GoodCategories.GC_Gold]            = {de = "Gold",             en = "Gold",            fr = "Or"},
        [GoodCategories.GC_Hygiene]         = {de = "Hygieneartikel",   en = "Hygiene",         fr = "Hygiène"},
        [GoodCategories.GC_Luxury]          = {de = "Dekoration",       en = "Decoration",      fr = "Décoration"},
        [GoodCategories.GC_Medicine]        = {de = "Medizin",          en = "Medicine",        fr = "Médecine"},
        [GoodCategories.GC_None]            = {de = "Nichts",           en = "None",            fr = "Rien"},
        [GoodCategories.GC_RawFood]         = {de = "Nahrungsmittel",   en = "Food",            fr = "Nourriture"},
        [GoodCategories.GC_RawMedicine]     = {de = "Medizin",          en = "Medicine",        fr = "Médecine"},
        [GoodCategories.GC_Research]        = {de = "Forschung",        en = "Research",        fr = "Recherche"},
        [GoodCategories.GC_Resource]        = {de = "Rohstoffe",        en = "Resource",        fr = "Ressources"},
        [GoodCategories.GC_Tools]           = {de = "Werkzeug",         en = "Tools",           fr = "Outils"},
        [GoodCategories.GC_Water]           = {de = "Wasser",           en = "Water",           fr = "Eau"},
        [GoodCategories.GC_Weapon]          = {de = "Waffen",           en = "Weapon",          fr = "Armes"},
    };
end

if Buffs then
    Lib.Promotion.Config.BuffTypeNames = {
        [Buffs.Buff_ClothesDiversity]        = {de = "Vielfältige Kleidung",        en = "Clothes variety",         fr = "Diversité vestimentaire"},
        [Buffs.Buff_Colour]                  = {de = "Farben beschaffen",           en = "Obtain color",            fr = "Se procurer des couleurs"},
        [Buffs.Buff_Entertainers]            = {de = "Gaukler anheuern",            en = "Hire entertainer",        fr = "Engager des saltimbanques"},
        [Buffs.Buff_EntertainmentDiversity]  = {de = "Vielfältige Unterhaltung",    en = "Entertainment variety",   fr = "Diversité des divertissements"},
        [Buffs.Buff_ExtraPayment]            = {de = "Sonderzahlung",               en = "Extra payment",           fr = "Paiement supplémentaire"},
        [Buffs.Buff_Festival]                = {de = "Fest veranstalten",           en = "Hold Festival",           fr = "Organiser une fête"},
        [Buffs.Buff_FoodDiversity]           = {de = "Vielfältige Nahrung",         en = "Food variety",            fr = "Diversité alimentaire"},
        [Buffs.Buff_HygieneDiversity]        = {de = "Vielfältige Hygiene",         en = "Hygiene variety",         fr = "Diversité hygiénique"},
        [Buffs.Buff_NoTaxes]                 = {de = "Steuerbefreiung",             en = "No taxes",                fr = "Exonération fiscale"},
        [Buffs.Buff_Sermon]                  = {de = "Pregigt abhalten",            en = "Hold sermon",             fr = "Tenir des prêches"},
        [Buffs.Buff_Spice]                   = {de = "Salz beschaffen",             en = "Obtain salt",             fr = "Se procurer du sel"},
    };
end

Lib.Promotion.Config.Description = {
    Settlers = {
        Title = {
            de = "Benötigte Siedler",
            en = "Needed settlers",
            fr = "Settlers nécessaires",
        },
        Text = {
            de = "- Benötigte Menge an Siedlern",
            en = "- Needed number of settlers",
            fr = "- Quantité de settlers nécessaire",
        },
    },

    RichBuildings = {
        Title = {
            de = "Reiche Häuser",
            en = "Rich city buildings",
            fr = "Bâtiments riches",
        },
        Text = {
            de = "- Menge an reichen Stadtgebäuden",
            en = "- Needed amount of rich city buildings",
            fr = "- Quantité de bâtiments de la ville riches",
        },
    },

    Goods = {
        Title = {
            de = "Waren lagern",
            en = "Store Goods",
            fr = "Entreposer des marchandises",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed amount",
            fr = "- Quantité nécessaire",
        },
    },

    FullDecoratedBuildings = {
        Title = {
            de = "Dekorierte Häuser",
            en = "Decorated City buildings",
            fr = "Bâtiments décorés",
        },
        Text = {
            de = "- Menge an voll dekorierten Gebäuden",
            en = "- Amount of full decoraded city buildings",
            fr = "- Quantité de bâtiments entièrement décorés",
        },
    },

    DecoratedBuildings = {
        Title = {
            de = "Dekoration",
            en = "Decoration",
            fr = "Décoration",
        },
        Text = {
            de = "- Menge an Dekorationsgütern in der Siedlung",
            en = "- Amount of decoration goods in settlement",
            fr = "- Quantité de biens de décoration dans la ville",
        },
    },

    Headquarters = {
        Title = {
            de = "Burgstufe",
            en = "Castle level",
            fr = "Niveau du château",
        },
        Text = {
            de = "- Benötigte Ausbauten der Burg",
            en = "- Needed castle upgrades",
            fr = "- Améliorations nécessaires du château",
        },
    },

    Storehouse = {
        Title = {
            de = "Lagerhausstufe",
            en = "Storehouse level",
            fr = "Niveau de l'entrepôt",
        },
        Text = {
            de = "- Benötigte Ausbauten des Lagerhauses",
            en = "- Needed storehouse upgrades",
            fr = "- Améliorations nécessaires de l'entrepôt",
        },
    },

    Cathedrals = {
        Title = {
            de = "Kirchenstufe",
            en = "Cathedral level",
            fr = "Niveau de la cathédrale",
        },
        Text = {
            de = "- Benötigte Ausbauten der Kirche",
            en = "- Needed cathedral upgrades",
            fr = "- Améliorations nécessaires de la cathédrale",
        },
    },

    Reputation = {
        Title = {
            de = "Ruf der Stadt",
            en = "City reputation",
            fr = "Réputation de la ville",
        },
        Text = {
            de = "- Benötigter Ruf der Stadt",
            en = "- Needed city reputation",
            fr = "- Réputation de la ville nécessaire",
        },
    },

    EntityCategoryDefault = {
        Title = {
            de = "",
            en = "",
            fr = "",
        },
        Text = {
            de = "- Benötigte Anzahl",
            en = "- Needed amount",
            fr = "- Nombre requis",
        },
    },

    Cattle = {
        Title = {
            de = "Kühe",
            en = "Cattle",
            fr = "Vaches",
        },
        Text = {
            de = "- Benötigte Menge an Kühen",
            en = "- Needed amount of cattle",
            fr = "- Quantité de vaches nécessaire",
        },
    },

    Sheep = {
        Title = {
            de = "Schafe",
            en = "Sheeps",
            fr = "Moutons",
        },
        Text = {
            de = "- Benötigte Menge an Schafen",
            en = "- Needed amount of sheeps",
            fr = "- Quantité de moutons nécessaire",
        },
    },

    Outposts = {
        Title = {
            de = "Territorien",
            en = "Territories",
            fr = "Territoires",
        },
        Text = {
            de = "- Zu erobernde Territorien",
            en = "- Territories to claim",
            fr = "- Territoires à conquérir",
        },
    },

    CityBuilding = {
        Title = {
            de = "Stadtgebäude",
            en = "City buildings",
            fr = "Bâtiment de la ville",
        },
        Text = {
            de = "- Menge benötigter Stadtgebäude",
            en = "- Needed amount of city buildings",
            fr = "- Quantité de bâtiments urbains nécessaires",
        },
    },

    OuterRimBuilding = {
        Title = {
            de = "Rohstoffgebäude",
            en = "Gatherer",
            fr = "Cueilleur",
        },
        Text = {
            de = "- Menge benötigter Rohstoffgebäude",
            en = "- Needed amount of gatherer",
            fr = "- Quantité de bâtiments de matières premières nécessaires",
        },
    },

    FarmerBuilding = {
        Title = {
            de = "Farmeinrichtungen",
            en = "Farming structure",
            fr = "Installations de la ferme",
        },
        Text = {
            de = "- Menge benötigter Nutzfläche",
            en = "- Needed amount of farming structure",
            fr = "- Quantité de surface utile nécessaire",
        },
    },

    Consume = {
        Title = {
            de = "",
            en = "",
            fr = "",
        },
        Text = {
            de = "- Durch Siedler zu konsumierende Menge",
            en = "- Amount to be consumed by the settlers",
            fr = "- Quantité à consommer par les settlers",
        },
    },

    Products = {
        Title = {
            de = "",
            en = "",
            fr = "",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed amount",
            fr = "- Quantité nécessaire",
        },
    },

    Buff = {
        Title = {
            de = "Bonus aktivieren",
            en = "Activate Buff",
            fr = "Activer bonus",
        },
        Text = {
            de = "- Aktiviere diesen Bonus auf den Ruf der Stadt",
            en = "- Raise the city reputatition with this buff",
            fr = "- Active ce bonus sur la réputation de la ville",
        },
    },

    Leader = {
        Title = {
            de = "Batalione",
            en = "Battalions",
            fr = "Battalions",
        },
        Text = {
            de = "- Menge an Batalionen unterhalten",
            en = "- Battalions you need under your command",
            fr = "- Maintenir une quantité de bataillons",
        },
    },

    Soldiers = {
        Title = {
            de = "Soldaten",
            en = "Soldiers",
            fr = "Soldats",
        },
        Text = {
            de = "- Menge an Streitkräften unterhalten",
            en = "- Soldiers you need under your command",
            fr = "- Maintenir une quantité de forces armées",
        },
    },

    Worker = {
        Title = {
            de = "Arbeiter",
            en = "Workers",
            fr = "Travailleurs",
        },
        Text = {
            de = "- Menge an arbeitender Bevölkerung",
            en = "- Workers you need under your reign",
            fr = "- Quantité de population au travail",
        },
    },

    Entities = {
        Title = {
            de = "",
            en = "",
            fr = "",
        },
        Text = {
            de = "- Benötigte Menge",
            en = "- Needed Amount",
            fr = "- Quantité nécessaire",
        },
    },

    Buildings = {
        Title = {
            de = "Gebäude",
            en = "Buildings",
            fr = "Bâtiments",
        },
        Text = {
            de = "- Gesamtmenge an Gebäuden",
            en = "- Amount of buildings",
            fr = "- Total des bâtiments",
        },
    },

    Weapons = {
        Title = {
            de = "Waffen",
            en = "Weapons",
            fr = "Armes",
        },
        Text = {
            de = "- Benötigte Menge an Waffen",
            en = "- Needed amount of weapons",
            fr = "- Quantité d'armes nécessaire",
        },
    },

    HeavyWeapons = {
        Title = {
            de = "Belagerungsgeräte",
            en = "Siege Engines",
            fr = "Matériel de siège",
        },
        Text = {
            de = "- Benötigte Menge an Belagerungsgeräten",
            en = "- Needed amount of siege engine",
            fr = "- Quantité de matériel de siège nécessaire",
        },
    },

    Spouse = {
        Title = {
            de = "Ehefrauen",
            en = "Spouses",
            fr = "Épouses",
        },
        Text = {
            de = "- Benötigte Anzahl Ehefrauen in der Stadt",
            en = "- Needed amount of spouses in your city",
            fr = "- Nombre d'épouses nécessaires dans la ville",
        },
    },
};

Lib.Register("module/city/Promotion_API");

-- Promotion_API: currently unused

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/faker/Technology_API");

function AddCustomTechnology(_Key, _Name, _Icon)
    Lib.Technology.Shared:AddCustomTechnology(_Key, _Name, _Icon);
end
API.AddCustomTechnology = AddCustomTechnology;

Lib.Technology = Lib.Technology or {};
Lib.Technology.Name = "Technology";
Lib.Technology.Global = {};
Lib.Technology.Local  = {};
Lib.Technology.Shared  = {
    CustomTechnologySequence = 0,
    CustomTechnologies = {},
};

CONST_TECHNOLOGY_TO_INDEX = {};

Lib.Require("comfort/IsLocalScript");
Lib.Require("core/Core");
Lib.Require("module/faker/Technology_API");
Lib.Register("module/faker/Technology");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.Technology.Global:Initialize()
    if not self.IsInstalled then
        Lib.Technology.Shared:OverwriteLogic();
        Lib.Technology.Shared:InitNewTechnologies();

        -- Garbage collection
        Lib.Technology.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.Technology.Global:OnSaveGameLoaded()
    Lib.Technology.Shared:OverwriteLogic();
    Lib.Technology.Shared:RestoreNewTechnologies();
end

-- Global report listener
function Lib.Technology.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.Technology.Local:Initialize()
    if not self.IsInstalled then
        Lib.Technology.Shared:OverwriteLogic();
        Lib.Technology.Shared:InitNewTechnologies();

        -- Garbage collection
        Lib.Technology.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.Technology.Local:OnSaveGameLoaded()
    Lib.Technology.Shared:OverwriteLogic();
    Lib.Technology.Shared:RestoreNewTechnologies();
end

-- Local report listener
function Lib.Technology.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --
-- Shared

function Lib.Technology.Shared:AddCustomTechnology(_Key, _Name, _Icon)
    if Technologies[_Key] then
        return;
    end
    self.CustomTechnologySequence = self.CustomTechnologySequence + 1;
    local Technology = {_Key, self.CustomTechnologySequence, _Icon, {}, _Name};
    table.insert(self.CustomTechnologies, Technology);
    Technologies[_Key] = self.CustomTechnologySequence;

    CONST_TECHNOLOGY_TO_INDEX[Technologies[_Key]] = #self.CustomTechnologies;
    CONST_TECHNOLOGY_TO_INDEX[_Key] = #self.CustomTechnologies;

    if IsLocalScript() then
        AddStringText("UI_ObjectNames/" .._Key, _Name);
        g_TexturePositions.Technologies[Technologies[_Key]] = _Icon;
    else
        for i= 1, 8 do
            Logic.TechnologySetState(i, Technologies[_Key], 0);
        end
    end
end

function Lib.Technology.Shared:IsCustomTechnology(_Technology)
    return _Technology >= 1000 and CONST_TECHNOLOGY_TO_INDEX[_Technology] ~= nil;
end

function Lib.Technology.Shared:OverwriteLogic()
    -- Get state of technology
    Lib.Technology.Shared.Orig_Logic_TechnologyGetState = Logic.TechnologyGetState;
    Logic.TechnologyGetState = function(_PlayerID, _Technology)
        return Lib.Technology.Shared:GetTechnologyState(_PlayerID, _Technology);
    end

    -- Change state of technology
    if not IsLocalScript() then
        Lib.Technology.Shared.Orig_Logic_TechnologySetState = Logic.TechnologySetState;
        Logic.TechnologySetState = function(_PlayerID, _Technology, _State)
            Lib.Technology.Shared:SetTechnologyState(_PlayerID, _Technology, _State);
        end
    end
end

function Lib.Technology.Shared:InitNewTechnologies()
    self.CustomTechnologySequence = 0;
    for k,v in pairs(Technologies) do
        if self.CustomTechnologySequence < v then
            self.CustomTechnologySequence = v;
        end
    end
    self.CustomTechnologySequence = self.CustomTechnologySequence + (1000 - self.CustomTechnologySequence);
    for i= 1, #self.CustomTechnologies do
        self.CustomTechnologySequence = self.CustomTechnologySequence + 1;
        self.CustomTechnologies[i][2] = self.CustomTechnologySequence;

        local Data = self.CustomTechnologies[i];
        Technologies[Data[1]] = self.CustomTechnologySequence;
        CONST_TECHNOLOGY_TO_INDEX[Technologies[Data[1]]] = i;
        CONST_TECHNOLOGY_TO_INDEX[Data[1]] = i;
        if IsLocalScript() then
            AddStringText("UI_ObjectNames/" ..Data[1], Data[4]);
            g_TexturePositions.Technologies[Technologies[Data[1]]] = Data[3];
        end
    end
end

function Lib.Technology.Shared:RestoreNewTechnologies()
    for i= 1, #self.CustomTechnologies do
        local Data = self.CustomTechnologies[i];
        Technologies[Data[1]] = Data[2];
        CONST_TECHNOLOGY_TO_INDEX[Technologies[Data[1]]] = i;
        CONST_TECHNOLOGY_TO_INDEX[Data[1]] = i;
    end
end

function Lib.Technology.Shared:GetTechnologyState(_PlayerID, _Technology)
    if _Technology and self:IsCustomTechnology(_Technology) then
        local Index = CONST_TECHNOLOGY_TO_INDEX[_Technology];
        if self.CustomTechnologies[Index] then
            return self.CustomTechnologies[Index][4][_PlayerID] or TechnologyStates.Locked;
        end
    end
    return self.Orig_Logic_TechnologyGetState(_PlayerID, _Technology);
end

function Lib.Technology.Shared:SetTechnologyState(_PlayerID, _Technology, _State)
    if _Technology and self:IsCustomTechnology(_Technology) then
        local Index = CONST_TECHNOLOGY_TO_INDEX[_Technology];
        if self.CustomTechnologies[Index] then
            self.CustomTechnologies[Index][4][_PlayerID] = _State;
            RequestHiResDelay(
                1, ExecuteLocal,
                [[Lib.Technology.Shared.CustomTechnologies[%d][4][%d] = %d]],
                Index, _PlayerID, _State
            );
            return;
        end
    end
    self.Orig_Logic_TechnologySetState(_PlayerID, _Technology, _State);
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.Technology.Name);

--- @diagnostic disable: cast-local-type
--- @diagnostic disable: missing-return-value

Lib.Promotion = Lib.Promotion or {};
Lib.Promotion.Name = "Promotion";
Lib.Promotion.Global = {};
Lib.Promotion.Local = {};
Lib.Promotion.Shared = {
    TechnologiesToResearch = {},
    TechnologyConfig = {
        -- Tech name, Description, Icon, Extra Number
        {"R_MilitarySword", "UI_ObjectNames/BuySwordfighters", {9, 7, 0}, 0},
        {"R_MilitaryBow",   "UI_ObjectNames/BuyBowmen",        {9, 8, 0}, 0},
    }
};

CONST_REQUIREMENT_TOOLTIP_TYPE = {};
CONST_CONSUMED_GOODS_COUNTER = {};

Lib.Require("core/Core");
Lib.Require("module/faker/Technology");
Lib.Require("module/ui/UITools");
Lib.Require("module/city/Promotion_API");
Lib.Require("module/city/Promotion_Config");
Lib.Require("module/city/Promotion_Helper");
Lib.Require("module/city/Promotion_Requirements");
Lib.Register("module/city/Promotion");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.Promotion.Global:Initialize()
    if not self.IsInstalled then
        Report.KnightTitleChanged = CreateReport("Event_KnightTitleChanged");
        Report.GoodsConsumed = CreateReport("Event_GoodsConsumed");

        Lib.Promotion.Shared:CreateTechnologies();
        Lib.Promotion.Shared:UpdateInvisibleTechnologies();
        Lib.Promotion.Shared:InitRelatedTechnologies();
        Lib.Promotion.Shared:OverwriteTitleTechnologyUpdate();

        self:OverrideKnightTitleChanged();
        self:OverwriteConsumedGoods();

        -- Garbage collection
        Lib.Promotion.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.Promotion.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Promotion.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        Lib.Promotion.Helper.OverwritePromotionHelper();
        InitKnightTitleTables = InitKnightTitleTablesOverwrite;
        InitKnightTitleTables();
        for i= 1, 8 do
            ActivateNeedsAndRightsForPlayerByKnightTitle(i, 0);
        end
        self.LoadscreenClosed = true;
    elseif _ID == Report.KnightTitleChanged then
        self:UnlockRelatedTechnologies(arg[1], arg[2]);
        local Consume = CONST_CONSUMED_GOODS_COUNTER[arg[1]];
        CONST_CONSUMED_GOODS_COUNTER[arg[1]] = Consume or {};
        for k,v in pairs(CONST_CONSUMED_GOODS_COUNTER[arg[1]]) do
            CONST_CONSUMED_GOODS_COUNTER[arg[1]][k] = 0;
        end
    elseif _ID == Report.GoodsConsumed then
        local PlayerID = Logic.EntityGetPlayer(arg[1]);
        self:RegisterConsumedGoods(PlayerID, arg[2]);
    end
end

function Lib.Promotion.Global:RegisterConsumedGoods(_PlayerID, _Good)
    CONST_CONSUMED_GOODS_COUNTER[_PlayerID]        = CONST_CONSUMED_GOODS_COUNTER[_PlayerID] or {};
    CONST_CONSUMED_GOODS_COUNTER[_PlayerID][_Good] = CONST_CONSUMED_GOODS_COUNTER[_PlayerID][_Good] or 0;
    CONST_CONSUMED_GOODS_COUNTER[_PlayerID][_Good] = CONST_CONSUMED_GOODS_COUNTER[_PlayerID][_Good] +1;
end

function Lib.Promotion.Global:OverrideKnightTitleChanged()
    GameCallback_KnightTitleChanged_Orig_Promo = GameCallback_KnightTitleChanged;
    GameCallback_KnightTitleChanged = function(_PlayerID, _TitleID)
        GameCallback_KnightTitleChanged_Orig_Promo(_PlayerID, _TitleID);
        SendReport(Report.KnightTitleChanged, _PlayerID, _TitleID);
        SendReportToLocal(Report.KnightTitleChanged, _PlayerID, _TitleID);
    end
end

function Lib.Promotion.Global:OverwriteConsumedGoods()
    GameCallback_ConsumeGood_Orig_Promo = GameCallback_ConsumeGood;
    GameCallback_ConsumeGood = function(_Consumer, _Good, _Building)
        GameCallback_ConsumeGood_Orig_Promo(_Consumer, _Good, _Building)
        SendReport(Report.GoodsConsumed, _Consumer, _Good, _Building);
        SendReportToLocal(Report.GoodsConsumed, _Consumer, _Good, _Building);
    end
end

-- Unlocks technologies mapped to a technology researched by the new knight
-- title if they are still prohibited.
function Lib.Promotion.Global:UnlockRelatedTechnologies(_PlayerID, _TitleID)
    if NeedsAndRightsByKnightTitle[_TitleID] then
        for k,v in pairs(NeedsAndRightsByKnightTitle[_TitleID][4]) do
            if Lib.Promotion.Shared.TechnologiesToResearch[v] then
                for _,Technology in pairs(Lib.Promotion.Shared.TechnologiesToResearch[v]) do
                    if Logic.TechnologyGetState(_PlayerID, Technology) == 0
                    or Logic.TechnologyGetState(_PlayerID, Technology) == 2 then
                        Logic.TechnologySetState(_PlayerID, Technology, 3);
                    end
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.Promotion.Local:Initialize()
    if not self.IsInstalled then
        Report.KnightTitleChanged = CreateReport("Event_KnightTitleChanged");
        Report.GoodsConsumed = CreateReport("Event_GoodsConsumed");

        Lib.Promotion.Shared:CreateTechnologies();
        Lib.Promotion.Shared:UpdateInvisibleTechnologies();
        Lib.Promotion.Shared:InitRelatedTechnologies();
        Lib.Promotion.Shared:OverwriteTitleTechnologyUpdate();

        self:InitTexturePositions();
        self:OverwriteUpdateRequirements();
        self:OverwriteTooltips();

        -- Garbage collection
        Lib.Promotion.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.Promotion.Local:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Promotion.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        Lib.Promotion.Helper.OverwritePromotionHelper();
        InitKnightTitleTables = InitKnightTitleTablesOverwrite;
        InitKnightTitleTables();
        self.LoadscreenClosed = true;
    elseif _ID == Report.KnightTitleChanged then
        local Consume = CONST_CONSUMED_GOODS_COUNTER[arg[1]];
        CONST_CONSUMED_GOODS_COUNTER[arg[1]] = Consume or {};
        for k,v in pairs(CONST_CONSUMED_GOODS_COUNTER[arg[1]]) do
            CONST_CONSUMED_GOODS_COUNTER[arg[1]][k] = 0;
        end
    elseif _ID == Report.GoodsConsumed then
        local PlayerID = Logic.EntityGetPlayer(arg[1]);
        self:RegisterConsumedGoods(PlayerID, arg[2]);
    end
end

function Lib.Promotion.Local:RegisterConsumedGoods(_PlayerID, _Good)
    CONST_CONSUMED_GOODS_COUNTER[_PlayerID]        = CONST_CONSUMED_GOODS_COUNTER[_PlayerID] or {};
    CONST_CONSUMED_GOODS_COUNTER[_PlayerID][_Good] = CONST_CONSUMED_GOODS_COUNTER[_PlayerID][_Good] or 0;
    CONST_CONSUMED_GOODS_COUNTER[_PlayerID][_Good] = CONST_CONSUMED_GOODS_COUNTER[_PlayerID][_Good] +1;
end

function Lib.Promotion.Local:InitTexturePositions()
    Lib.Promotion.Config:InitTexturePositions();
    Lib.Promotion.Config:InitTexturePositionsAddon();
end

function Lib.Promotion.Local:OverwriteUpdateRequirements()
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Knight.UpdateRequirements = function()
        local WidgetPos = Lib.Promotion.Config.RequirementWidgets;
        local RequirementsIndex = 1;

        local PlayerID = GUI.GetPlayerID();
        local CurrentTitle = Logic.GetKnightTitle(PlayerID);
        local NextTitle = CurrentTitle + 1;

        -- Headline
        local KnightID = Logic.GetKnightID(PlayerID);
        local KnightType = Logic.GetEntityType(KnightID);
        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitle", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));
        XGUIEng.SetText("/InGame/Root/Normal/AlignBottomRight/KnightTitleMenu/NextKnightTitleWhite", "{center}" .. GUI_Knight.GetTitleNameByTitleID(KnightType, NextTitle));

        -- show Settlers
        if KnightTitleRequirements[NextTitle].Settlers ~= nil then
            ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,16})
            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfSettlersForKnightTitleExist(PlayerID, NextTitle)
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount)
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1)
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0)
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1)

            CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Settlers";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- show rich buildings
        if KnightTitleRequirements[NextTitle].RichBuildings ~= nil then
            ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", {8,4});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfRichBuildingsForKnightTitleExist(PlayerID, NextTitle);
            if NeededAmount == -1 then
                NeededAmount = Logic.GetNumberOfPlayerEntitiesInCategory(PlayerID, EntityCategories.CityBuilding);
            end
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "RichBuildings";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Castle
        if KnightTitleRequirements[NextTitle].Headquarters ~= nil then
            ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,7});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Headquarters);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Headquarters";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Storehouse
        if KnightTitleRequirements[NextTitle].Storehouse ~= nil then
            ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,6});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Storehouse);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Storehouse";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Cathedral
        if KnightTitleRequirements[NextTitle].Cathedrals ~= nil then
            ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", {4,5});
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededSpecialBuildingUpgradeForKnightTitleExist(PlayerID, NextTitle, EntityCategories.Cathedrals);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount + 1 .. "/" .. NeededAmount + 1);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Cathedrals";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Volldekorierte Gebäude
        if KnightTitleRequirements[NextTitle].FullDecoratedBuildings ~= nil then
            local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfFullDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle);
            local EntityCategory = KnightTitleRequirements[NextTitle].FullDecoratedBuildings;
            ChangeIcon(WidgetPos[RequirementsIndex].."/Icon"  , g_TexturePositions.Needs[Needs.Wealth]);

            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] , 1);

            CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "FullDecoratedBuildings";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Stadtruf
        if KnightTitleRequirements[NextTitle].Reputation ~= nil then
            ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", {5,14});
            local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededCityReputationForKnightTitleExist(PlayerID, NextTitle);
            XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
            if IsFulfilled then
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
            else
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
            end
            XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

            CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Reputation";
            RequirementsIndex = RequirementsIndex +1;
        end

        -- Güter sammeln
        if KnightTitleRequirements[NextTitle].Goods ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Goods do
                local GoodType = KnightTitleRequirements[NextTitle].Goods[i][1];
                ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfGoodTypesForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Goods" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Kategorien
        if KnightTitleRequirements[NextTitle].Category ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Category do
                local Category = KnightTitleRequirements[NextTitle].Category[i][1];
                ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.EntityCategories[Category]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesInCategoryForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                local EntitiesInCategory = {Logic.GetEntityTypesInCategory(Category)};
                if Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.GC_Weapon_Supplier) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Weapons" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SiegeEngine) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "HeavyWeapons" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Spouse) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Spouse" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Worker) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Worker" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Soldier) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Soldiers" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Leader) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Leader" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.Outpost) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Outposts" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CattlePasture) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Cattle" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.SheepPasture) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Sheep" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.CityBuilding) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "CityBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.OuterRimBuilding) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "OuterRimBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.GrainField) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "FarmerBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.BeeHive) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "FarmerBuilding" .. i;
                elseif Logic.IsEntityTypeInCategory(EntitiesInCategory[1], EntityCategories.AttackableBuilding) == 1 then
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Buildings" .. i;
                else
                    CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "EntityCategoryDefault" .. i;
                end
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Entities
        if KnightTitleRequirements[NextTitle].Entities ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Entities do
                local EntityType = KnightTitleRequirements[NextTitle].Entities[i][1];
                local EntityTypeName = Logic.GetEntityTypeName(EntityType);
                ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Entities[EntityType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoesNeededNumberOfEntitiesOfTypeForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                local TopltipType = "Entities" .. i;
                if EntityTypeName == "B_Beehive" or EntityTypeName:find("GrainField") or EntityTypeName:find("Pasture") then
                    TopltipType = "FarmerBuilding" .. i;
                end
                CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = TopltipType;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Güter konsumieren
        if KnightTitleRequirements[NextTitle].Consume ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Consume do
                local GoodType = KnightTitleRequirements[NextTitle].Consume[i][1];
                ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfConsumedGoodsForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Consume" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Güter aus Gruppe produzieren
        if KnightTitleRequirements[NextTitle].Products ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Products do
                local Product = KnightTitleRequirements[NextTitle].Products[i][1];
                ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.GoodCategories[Product]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNumberOfProductsInCategoryExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Products" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Bonus aktivieren
        if KnightTitleRequirements[NextTitle].Buff ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Buff do
                local Buff = KnightTitleRequirements[NextTitle].Buff[i];
                ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", g_TexturePositions.Buffs[Buff]);
                local IsFulfilled = DoNeededDiversityBuffForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Buff" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Selbstdefinierte Bedingung
        if KnightTitleRequirements[NextTitle].Custom ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].Custom do
                local FileBaseName;
                local Icon = table.copy(KnightTitleRequirements[NextTitle].Custom[i][2]);
                if type(Icon[3]) == "string" then
                    FileBaseName = Icon[3];
                    Icon[3] = 0;
                end
                ChangeIcon(WidgetPos[RequirementsIndex] .. "/Icon", Icon, nil, FileBaseName);
                local IsFulfilled, CurrentAmount, NeededAmount = DoCustomFunctionForKnightTitleSucceed(PlayerID, NextTitle, i);
                if CurrentAmount and NeededAmount then
                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                else
                    XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "");
                end
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "Custom" .. i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Dekorationselemente
        if KnightTitleRequirements[NextTitle].DecoratedBuildings ~= nil then
            for i=1, #KnightTitleRequirements[NextTitle].DecoratedBuildings do
                local GoodType = KnightTitleRequirements[NextTitle].DecoratedBuildings[i][1];
                ChangeIcon(WidgetPos[RequirementsIndex].."/Icon", g_TexturePositions.Goods[GoodType]);
                local IsFulfilled, CurrentAmount, NeededAmount = DoNeededNumberOfDecoratedBuildingsForKnightTitleExist(PlayerID, NextTitle, i);
                XGUIEng.SetText(WidgetPos[RequirementsIndex] .. "/Amount", "{center}" .. CurrentAmount .. "/" .. NeededAmount);
                if IsFulfilled then
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 1);
                else
                    XGUIEng.ShowWidget(WidgetPos[RequirementsIndex] .. "/Done", 0);
                end
                XGUIEng.ShowWidget(WidgetPos[RequirementsIndex], 1);

                CONST_REQUIREMENT_TOOLTIP_TYPE[RequirementsIndex] = "DecoratedBuildings" ..i;
                RequirementsIndex = RequirementsIndex +1;
            end
        end

        -- Übrige ausblenden
        for i=RequirementsIndex, 6 do
            XGUIEng.ShowWidget(WidgetPos[i], 0);
        end
    end
end

function Lib.Promotion.Local:OverwriteTooltips()
    GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements = GUI_Tooltip.SetNameAndDescription;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Tooltip.SetNameAndDescription = function(...)
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();

        for k,v in pairs(Lib.Promotion.Config.RequirementWidgets) do
            if v .. "/Icon" == XGUIEng.GetWidgetPathByID(CurrentWidgetID) then
                local key = CONST_REQUIREMENT_TOOLTIP_TYPE[k];
                local num = tonumber(string.sub(key, string.len(key)));
                if num ~= nil then
                    key = string.sub(key, 1, string.len(key)-1);
                end
                Lib.Promotion.Local:RequirementTooltipWrapped(key, num);
                return;
            end
        end
        GUI_Tooltip.SetNameAndDescription_Orig_QSB_Requirements(...);
    end

    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Knight.RewardTooltip = function(_ButtonIndex)
        Lib.Promotion.Local:RewardTooltipWrapped(_ButtonIndex);
    end

    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Knight.RequiredGoodTooltip = function()
        local key = CONST_REQUIREMENT_TOOLTIP_TYPE[2];
        local num = tonumber(string.sub(key, string.len(key)));
        if num ~= nil then
            key = string.sub(key, 1, string.len(key)-1);
        end
        Lib.Promotion.Local:RequirementTooltipWrapped(key, num);
    end

    Lib.Promotion.Config:InitAddonText();
end

function Lib.Promotion.Local:RewardTooltipWrapped(_i)
    local TechnologyType = GUI_Knight.NextRightsForTitle[_i];
    local TechnologyTypeName =  GetNameOfKeyInTable(Technologies, TechnologyType);
    local Name = string.gsub(TechnologyTypeName, "R_", "");
    local TooltipName = "";

    local Key = "B_" .. Name;
    if GetStringText("UI_ObjectNames/" .. Key) == "" then
        Key = "U_" .. Name;
    end
    if GetStringText("UI_ObjectNames/" .. Key) == "" then
        Key = "Start" .. Name;
    end
    if GetStringText("UI_ObjectNames/" .. Key) == "" then
        Key = "R_" .. Name;
    end

    TooltipName = GetStringText("UI_ObjectNames/" .. Key);
    SetTooltipNormal(Localize(TooltipName), "");
end

function Lib.Promotion.Local:RequirementTooltipWrapped(_key, _i)
    local PlayerID = GUI.GetPlayerID();
    local KnightTitle = Logic.GetKnightTitle(PlayerID);
    local Title = ""
    local Text = "";

    if _key == "Consume" or _key == "Goods" or _key == "DecoratedBuildings" then
        local GoodType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local GoodTypeName = Logic.GetGoodTypeName(GoodType);
        local GoodName     = GetStringText("UI_ObjectNames/" .. GoodTypeName);

        if GoodName == nil then
            GoodName = "Goods." .. GoodTypeName;
        end
        Title = GoodName;
        Text  = Lib.Promotion.Config.Description[_key].Text;

    elseif _key == "Products" then
        local GoodCategoryNames = Lib.Promotion.Config.GoodCategoryNames;
        local Category = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local CategoryName = Localize(GoodCategoryNames[Category]);

        if CategoryName == nil then
            CategoryName = "ERROR: Name missng!";
        end
        Title = CategoryName;
        Text  = Lib.Promotion.Config.Description[_key].Text;

    elseif _key == "Entities" then
        local EntityType     = KnightTitleRequirements[KnightTitle+1][_key][_i][1];
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);
        local EntityName = GetStringText("Names/" .. EntityTypeName);

        if EntityName == nil then
            EntityName = "Entities." .. EntityTypeName;
        end

        Title = EntityName;
        Text  = Lib.Promotion.Config.Description[_key].Text;

    elseif _key == "Custom" then
        local Custom = KnightTitleRequirements[KnightTitle+1].Custom[_i];
        Title = Custom[3];
        Text  = Custom[4];

    elseif _key == "Buff" then
        local BuffTypeNames = Lib.Promotion.Config.BuffTypeNames;
        local BuffType = KnightTitleRequirements[KnightTitle+1][_key][_i];
        local BuffTitle = Localize(BuffTypeNames[BuffType]);

        if BuffTitle == nil then
            BuffTitle = "ERROR: Name missng!";
        end
        Title = BuffTitle;
        Text  = Lib.Promotion.Config.Description[_key].Text;

    else
        Title = Lib.Promotion.Config.Description[_key].Title;
        Text  = Lib.Promotion.Config.Description[_key].Text;
    end
    SetTooltipNormal(Localize(Title), Localize(Text), nil);
end

-- -------------------------------------------------------------------------- --
-- Shared

-- A workaround that clears all technologies.
InitKnightTitleTables = function()
    NeedsAndRightsByKnightTitle = {};
    KnightTitleRequirements = {};
end

function Lib.Promotion.Shared:UpdateInvisibleTechnologies()
    if not IsLocalScript() then
        return;
    end
    if TechnologiesNotShownForKnightTitle == nil then
        TechnologiesNotShownForKnightTitle = {};
        TechnologiesNotShownForKnightTitle[Technologies.R_Nutrition] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_Clothes] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_Hygiene] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_Entertainment] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_Wealth] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_Prosperity] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_Military] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_SpecialEdition] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_SpecialEdition_Column] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_SpecialEdition_Pavilion] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_SpecialEdition_StatueDario] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_SpecialEdition_StatueFamily] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_SpecialEdition_StatueProduction] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_SpecialEdition_StatueSettler] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_Victory] = true;

        -- Disabled to make space in the window
        TechnologiesNotShownForKnightTitle[Technologies.R_Barracks] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_BarracksArchers] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_BowMaker] = true;
        TechnologiesNotShownForKnightTitle[Technologies.R_SwordSmith] = true;
    end

    -- If io module is used this pseudo technology exists
    if g_GameExtraNo > 0 and Technologies.R_CallGeologist then
        TechnologiesNotShownForKnightTitle[Technologies.R_CallGeologist] = true;
    end
end

function Lib.Promotion.Shared:OverwriteTitleTechnologyUpdate()
    CreateTechnologyKnightTitleTable = function()
        KnightTitleNeededForTechnology = {};
        for KnightTitle = 0, #NeedsAndRightsByKnightTitle do
            local TechnologyTable = NeedsAndRightsByKnightTitle[KnightTitle][4];
            if TechnologyTable ~= nil then
                for i=1, #TechnologyTable do
                    local TechnologyType = TechnologyTable[i];
                    KnightTitleNeededForTechnology[TechnologyType] = KnightTitle;

                    -- Set required title for the relatives of the technology
                    local Relatives = Lib.Promotion.Shared.TechnologiesToResearch;
                    if Relatives[TechnologyType] then
                        for j= 1, #Relatives[TechnologyType] do
                            RelativeType = Relatives[TechnologyType][j];
                            KnightTitleNeededForTechnology[RelativeType] = KnightTitle;
                        end
                    end
                end
            end
        end
    end
end

function Lib.Promotion.Shared:InitRelatedTechnologies()
    self.TechnologiesToResearch[Technologies.R_MilitaryBow] = {
        Technologies.R_BarracksArchers,
        Technologies.R_BowMaker,
    };
    self.TechnologiesToResearch[Technologies.R_MilitarySword] = {
        Technologies.R_Barracks,
        Technologies.R_SwordSmith,
    };
end

function Lib.Promotion.Shared:CreateTechnologies()
    for i= 1, #self.TechnologyConfig do
        if g_GameExtraNo >= self.TechnologyConfig[i][4] then
            if not Technologies[self.TechnologyConfig[i][1]] then
                AddCustomTechnology(self.TechnologyConfig[i][1], self.TechnologyConfig[i][2], self.TechnologyConfig[i][3]);
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.Promotion.Name);

Lib.Register("module/io/IO_Behavior");

function Goal_ActivateSeveralObjects(...)
    return B_Goal_ActivateSeveralObjects:new(...);
end

B_Goal_ActivateSeveralObjects = {
    Name = "Goal_ActivateSeveralObjects",
    Description = {
        en = "Goal: Activate an interactive object",
        de = "Ziel: Aktiviere ein interaktives Objekt",
        fr = "Objectif: activer un objet interactif",
    },
    Parameter = {
        { ParameterType.Default, en = "Object name 1", de = "Skriptname 1", fr = "Nom de l'entité 1" },
        { ParameterType.Default, en = "Object name 2", de = "Skriptname 2", fr = "Nom de l'entité 2" },
        { ParameterType.Default, en = "Object name 3", de = "Skriptname 3", fr = "Nom de l'entité 3" },
        { ParameterType.Default, en = "Object name 4", de = "Skriptname 4", fr = "Nom de l'entité 4" },
    },
    ScriptNames = {};
}

function B_Goal_ActivateSeveralObjects:GetGoalTable()
    return {Objective.Object, { unpack(self.ScriptNames) } }
end

function B_Goal_ActivateSeveralObjects:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        assert(_Parameter ~= nil and _Parameter ~= "", "Goal_ActivateSeveralObjects: At least one IO needed!");
    end
    if _Parameter ~= nil and _Parameter ~= "" then
        table.insert(self.ScriptNames, _Parameter);
    end
end

function B_Goal_ActivateSeveralObjects:GetMsgKey()
    return "Quest_Object_Activate"
end

RegisterBehavior(B_Goal_ActivateSeveralObjects);

-- -------------------------------------------------------------------------- --

--- @diagnostic disable-next-line: duplicate-set-field
B_Reward_ObjectInit.CustomFunction = function(self, _Quest)
    local EntityID = GetID(self.ScriptName);
    if EntityID == 0 then
        return;
    end
    CONST_INITIALIZED_OBJECTS[EntityID] = _Quest.Identifier;

    local GoodReward;
    if self.RewardType and self.RewardType ~= "-" then
        GoodReward = {Goods[self.RewardType], self.RewardAmount};
    end

    local GoodCosts;
    if self.FirstCostType and self.FirstCostType ~= "-" then
        GoodCosts = GoodReward or {};
        table.insert(GoodCosts, Goods[self.FirstCostType]);
        table.insert(GoodCosts, Goods[self.FirstCostAmount]);
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        GoodCosts = GoodReward or {};
        table.insert(GoodCosts, Goods[self.SecondCostType]);
        table.insert(GoodCosts, Goods[self.SecondCostAmount]);
    end

    SetupObject {
        Name                   = self.ScriptName,
        Distance               = self.Distance,
        Waittime               = self.Waittime,
        Reward                 = GoodReward,
        Costs                  = GoodCosts,
    };
    InteractiveObjectActivate(self.ScriptName, self.UsingState);
end

-- -------------------------------------------------------------------------- --

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/io/IO_API");

function SetupObject(_Description)
    if GUI then
        return;
    end
    return Lib.IO.Global:CreateObject(_Description);
end
API.CreateObject = SetupObject;

function DisposeObject(_ScriptName)
    if GUI or not CONST_IO[_ScriptName] then
        return;
    end
    Lib.IO.Global:DestroyObject(_ScriptName);
end
API.DisposeObject = DisposeObject;

function ResetObject(_ScriptName)
    if GUI or not CONST_IO[_ScriptName] then
        return;
    end
    Lib.IO.Global:ResetObject(_ScriptName);
    InteractiveObjectDeactivate(_ScriptName);
end
API.ResetObject = ResetObject;

function InteractiveObjectAddCustomName(_Key, _Text)
    local Prefix = (Entities[_Key] and "UI_Names/") or "Names/";
    if not IsLocalScript() then
        ExecuteLocal(
            [[InteractiveObjectSetQuestName("%s", %s)]],
            _Key,
            (type(_Text) == "table" and table.tostring(_Text))
            or ("\"" .. _Text .. "\"")
        );
        return;
    end
    AddStringText(Prefix .. _Key, _Text);
end
API.InteractiveObjectSetQuestName = InteractiveObjectAddCustomName;

function InteractiveObjectDeleteCustomName(_Key)
    local Prefix = (Entities[_Key] and "UI_Names/") or "Names/";
    if not IsLocalScript() then
        ExecuteLocal([[InteractiveObjectDeleteCustomName("%s")]], _Key);
        return;
    end
    DeleteStringText(Prefix .. _Key);
end
API.InteractiveObjectUnsetQuestName = InteractiveObjectDeleteCustomName;

function AllowActivateIronMines(_PlayerID, _Allowed)
    assert(not IsLocalScript(), "Can not be used in local script!");
    Logic.TechnologySetState(_PlayerID, Technologies.R_RefillIronMine, (_Allowed and 3 or 1));
end
API.AllowActivateIronMines = AllowActivateIronMines;

function RequireTitleToRefilIronMines(_Title)
    assert(not IsLocalScript(), "Can not be used in local script!");
    ExecuteLocal([[
        table.insert(NeedsAndRightsByKnightTitle[%d][4], 1, Technologies.R_RefillIronMine)
        CreateTechnologyKnightTitleTable()
    ]], _Title);
    table.insert(NeedsAndRightsByKnightTitle[_Title][4], 1, Technologies.R_RefillIronMine);
    CreateTechnologyKnightTitleTable()
    for i= 1, 8 do
        Logic.TechnologySetState(i, Technologies.R_RefillIronMine, 0);
    end
end
API.RequireTitleToRefilIronMines = RequireTitleToRefilIronMines;

function AllowActivateStoneMines(_PlayerID, _Allowed)
    assert(not IsLocalScript(), "Can not be used in local script!");
    Logic.TechnologySetState(_PlayerID, Technologies.R_RefillStoneMine, (_Allowed and 3 or 1));
end
API.AllowActivateStoneMines = AllowActivateStoneMines;

function RequireTitleToRefilStoneMines(_Title)
    assert(not IsLocalScript(), "Can not be used in local script!");
    ExecuteLocal([[
        table.insert(NeedsAndRightsByKnightTitle[%d][4], 1, Technologies.R_RefillStoneMine)
        CreateTechnologyKnightTitleTable()
    ]], _Title);
    table.insert(NeedsAndRightsByKnightTitle[_Title][4], 1, Technologies.R_RefillStoneMine);
    CreateTechnologyKnightTitleTable()
    for i= 1, 8 do
        Logic.TechnologySetState(i, Technologies.R_RefillStoneMine, 0);
    end
end
API.RequireTitleToRefilStoneMines = RequireTitleToRefilStoneMines;

function AllowActivateCisterns(_PlayerID, _Allowed)
    assert(not IsLocalScript(), "Can not be used in local script!");
    Logic.TechnologySetState(_PlayerID, Technologies.R_RefillCistern, (_Allowed and 3 or 1));
end
API.AllowActivateCisterns = AllowActivateCisterns;

function RequireTitleToRefilCisterns(_Title)
    assert(not IsLocalScript(), "Can not be used in local script!");
    ExecuteLocal([[
        table.insert(NeedsAndRightsByKnightTitle[%d][4], 1, Technologies.R_RefillCistern)
        CreateTechnologyKnightTitleTable()
    ]], _Title);
    table.insert(NeedsAndRightsByKnightTitle[_Title][4], 1, Technologies.R_RefillCistern);
    CreateTechnologyKnightTitleTable()
    for i= 1, 8 do
        Logic.TechnologySetState(i, Technologies.R_RefillCisternMine, 0);
    end
end
API.RequireTitleToRefilCisterns = RequireTitleToRefilCisterns;

function AllowActivateTradepost(_PlayerID, _Allowed)
    assert(not IsLocalScript(), "Can not be used in local script!");
    Logic.TechnologySetState(_PlayerID, Technologies.R_Tradepost, (_Allowed and 3 or 1));
end
API.AllowActivateTradepost = AllowActivateTradepost;

function RequireTitleToBuildTradeposts(_Title)
    assert(not IsLocalScript(), "Can not be used in local script!");
    ExecuteLocal([[
        table.insert(NeedsAndRightsByKnightTitle[%d][4], 1, Technologies.R_Tradepost)
        CreateTechnologyKnightTitleTable()
    ]], _Title);
    table.insert(NeedsAndRightsByKnightTitle[_Title][4], 1, Technologies.R_Tradepost);
    CreateTechnologyKnightTitleTable();
    for i= 1, 8 do
        Logic.TechnologySetState(i, Technologies.R_Tradepost, 0);
    end
end
API.RequireTitleToBuildTradeposts = RequireTitleToBuildTradeposts;

InteractiveObjectActivate = function(_ScriptName, _State, ...)
    arg = arg or {1};
    if not IsLocalScript() then
        if CONST_IO[_ScriptName] then
            local SlaveName = (CONST_IO[_ScriptName].Slave or _ScriptName);
            if CONST_IO[_ScriptName].Slave then
                CONST_IO_SLAVE_STATE[SlaveName] = 1;
                Logic.ExecuteInLuaLocalState(string.format(
                    [[CONST_IO_SLAVE_STATE["%s"] = 1]],
                    SlaveName
                ));
            end
            Lib.IO.Global:SetObjectState(SlaveName, _State, unpack(arg));
            CONST_IO[_ScriptName].IsActive = true;
            ExecuteLocal([[CONST_IO["%s"].IsActive = true]], _ScriptName);
        else
            Lib.IO.Global:SetObjectState(_ScriptName, _State, unpack(arg));
        end
    end
end
API.InteractiveObjectActivate = InteractiveObjectActivate;

InteractiveObjectDeactivate = function(_ScriptName, ...)
    arg = arg or {1};
    if not IsLocalScript() then
        if CONST_IO[_ScriptName] then
            local SlaveName = (CONST_IO[_ScriptName].Slave or _ScriptName);
            if CONST_IO[_ScriptName].Slave then
                CONST_IO_SLAVE_STATE[SlaveName] = 0;
                Logic.ExecuteInLuaLocalState(string.format(
                    [[CONST_IO_SLAVE_STATE["%s"] = 0]],
                    SlaveName
                ));
            end
            Lib.IO.Global:SetObjectState(SlaveName, 2, unpack(arg));
            CONST_IO[_ScriptName].IsActive = false;
            ExecuteLocal([[CONST_IO["%s"].IsActive = false]], _ScriptName);
        else
            Lib.IO.Global:SetObjectState(_ScriptName, 2, unpack(arg));
        end
    end
end
API.InteractiveObjectDeactivate = InteractiveObjectDeactivate;



function Debug_EnableIO(_Entity, _State, _PlayerID)
    assert(IsLocalScript(), "Debug function must be used in local script!");
    SendReportToGlobal(Report.Internal_DebugEnableObject, _Entity, _State, _PlayerID);
end

function Debug_DisableIO(_Entity, _State, _PlayerID)
    assert(IsLocalScript(), "Debug function must be used in local script!");
    SendReportToGlobal(Report.Internal_DebugDisableObject, _Entity, _State, _PlayerID);
end

function Debug_InitIO(_Entity, _RewardType, _RewardAmount, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount)
    assert(IsLocalScript(), "Debug function must be used in local script!");
    SendReportToGlobal(Report.Internal_DebugInitObject, _Entity, _RewardType, _RewardAmount, _Cost1Type, _Cost1Amount, _Cost2Type, _Cost2Amount);
end

Lib.IO = Lib.IO or {};
Lib.IO.Name = "IO";
Lib.IO.Global = {
    SlaveSequence = 0,
};
Lib.IO.Local  = {
    Data = {},
};
Lib.IO.Shared = {
    TechnologyConfig = {
        -- Tech name, Description, Icon, Extra Number
        {"R_CallGeologist", {de = "Geologen rufen", en = "Order geologist", fr = "Ordre géologue"}, {8, 1, 1}, 1},
        {"R_RefillIronMine", {de = "Eisenmine auffüllen", en = "Refill mine", fr = "Recharger le mien"}, {8, 2, 1}, 1},
        {"R_RefillStoneMine", {de = "Steinbruch auffüllen", en = "Refill quarry", fr = "Carrière de recharge"}, {8, 3, 1}, 1},
        {"R_RefillCistern", {de = "Brunnen auffüllen", en = "Refill well", fr = "Bien remplir"}, {8, 4, 1}, 1},
        {"R_Tradepost", {de = "Handelsposten bauen", en = "Build Tradepost", fr = "Route commerciale"}, {3, 1, 1}, 1},
    }
};

CONST_IO = {};
CONST_IO_SLAVE_TO_MASTER = {};
CONST_IO_SLAVE_STATE = {};

CONST_IO_LAST_OBJECT = 0;
CONST_IO_LAST_HERO = 0;

Lib.Require("comfort/GetClosestToTarget");
Lib.Require("comfort/IsLocalScript");
Lib.Require("comfort/IsHistoryEdition");
Lib.Require("comfort/ReplaceEntity");
Lib.Require("core/Core");
Lib.Require("module/ui/UITools");
Lib.Require("module/faker/Technology");
Lib.Require("module/io/IO_API");
Lib.Require("module/io/IO_Behavior");
Lib.Register("module/io/IO");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.IO.Global:Initialize()
    if not self.IsInstalled then
        --- The player clicked the interaction button.
        --- 
        --- #### Parameters
        --- * `ScriptName` - Scriptname of entity
        --- * `KnightID`   - ID of activating hero
        --- * `PlayerID`   - ID of activating player
        Report.ObjectClicked = CreateReport("Event_ObjectClicked");

        --- The interaction of the object was successfull.
        --- If the object has costs the activation concludes when the costs arrive.
        --- 
        --- #### Parameters
        --- * `ScriptName` - Scriptname of entity
        --- * `KnightID`   - ID of activating hero
        --- * `PlayerID`   - ID of activating player
        Report.ObjectInteraction = CreateReport("Event_ObjectInteraction");

        --- The interaction is deleted from the object.
        ---
        --- #### Parameters
        --- * `ScriptName` - Scriptname of entity
        Report.ObjectReset = CreateReport("Event_ObjectReset");

        --- The state of an object has been reset.
        ---
        --- #### Parameters
        --- * `ScriptName` - Scriptname of entity
        Report.ObjectDelete = CreateReport("Event_ObjectDelete");

        Report.Internal_DebugEnableObject = CreateReport("Event_Internal_DebugEnableObject");
        Report.Internal_DebugDisableObject = CreateReport("Event_Internal_DebugDisableObject");
        Report.Internal_DebugInitObject = CreateReport("Event_Internal_DebugInitObject");

        Lib.IO.Shared:CreateTechnologies();

        self:OverrideObjectInteraction();
        self:StartObjectDestructionController();
        self:StartObjectConditionController();

        -- Garbage collection
        Lib.IO.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.IO.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.IO.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.ObjectInteraction then
        self:OnObjectInteraction(arg[1], arg[2], arg[3]);
    elseif _ID == Report.ChatClosed then
        if arg[3] then
            self:ProcessChatInput(arg[1]);
        end
    elseif _ID == Report.Internal_DebugEnableObject then
        error(IsExisting(arg[1]), "object " ..arg[1].. " does not exist!");
        InteractiveObjectActivate(arg[1], arg[2], arg[3]);
    elseif _ID == Report.Internal_DebugDeableObject then
        error(IsExisting(arg[1]), "object " ..arg[1].. " does not exist!");
        InteractiveObjectDeactivate(arg[1], arg[2], arg[3]);
    elseif _ID == Report.Internal_DebugInitObject then
        error(IsExisting(arg[1]), "object " ..arg[1].. " does not exist!");
        local Reward = (arg[2] ~= nil and {arg[2], arg[3]});
        local Costs = (arg[4] ~= nil and {arg[4], arg[5], arg[6], arg[7]});
        API.SetupObject({
            Name = arg[1],
            Costs = Costs,
            Reward = Reward,
            Waittime = 0,
            State = 0
        });
    end
end

function Lib.IO.Global:OnObjectInteraction(_ScriptName, _KnightID, _PlayerID)
    CONST_IO_LAST_OBJECT = GetID(_ScriptName);
    CONST_IO_LAST_HERO = _KnightID;

    if CONST_IO_SLAVE_TO_MASTER[_ScriptName] then
        _ScriptName = CONST_IO_SLAVE_TO_MASTER[_ScriptName];
    end
    if CONST_IO[_ScriptName] then
        CONST_IO[_ScriptName].IsUsed = true;
        ExecuteLocal([[
            local ScriptName = "%s"
            if CONST_IO[ScriptName] then
                CONST_IO[ScriptName].IsUsed = true
            end
        ]], _ScriptName);
        if CONST_IO[_ScriptName].Replacement then
            ReplaceEntity(_ScriptName, CONST_IO[_ScriptName].Replacement);
        end
        if CONST_IO[_ScriptName].Action then
            CONST_IO[_ScriptName]:Action(_PlayerID, _KnightID);
        end
    end
end

function Lib.IO.Global:CreateObject(_Description)
    local ID = GetID(_Description.Name);
    if ID == 0 then
        return;
    end
    self:DestroyObject(_Description.Name);

    local TypeName = Logic.GetEntityTypeName(Logic.GetEntityType(ID));
    if TypeName and not TypeName:find("^I_X_") then
        self:CreateSlaveObject(_Description);
    end

    _Description.IsActive = true;
    _Description.IsUsed = false;
    _Description.Player = _Description.Player or {1, 2, 3, 4, 5, 6, 7, 8};
    _Description.State = _Description.State or 0;
    _Description.Waittime = _Description.Waittime or 5;
    _Description.Distance = _Description.Distance or 1000;
    CONST_IO[_Description.Name] = _Description;
    ExecuteLocal(
        [[CONST_IO["%s"] = %s]],
        _Description.Name,
        table.tostring(CONST_IO[_Description.Name])
    );
    self:SetupObject(_Description);
    return _Description;
end

function Lib.IO.Global:DestroyObject(_ScriptName)
    if not CONST_IO[_ScriptName] then
        return;
    end
    if CONST_IO[_ScriptName].Slave then
        CONST_IO_SLAVE_TO_MASTER[CONST_IO[_ScriptName].Slave] = nil;
        ExecuteLocal(
            [[CONST_IO_SLAVE_TO_MASTER["%s"] = nil]],
            CONST_IO[_ScriptName].Slave
        );
        CONST_IO_SLAVE_STATE[CONST_IO[_ScriptName].Slave] = nil;
        DestroyEntity(CONST_IO[_ScriptName].Slave);
    end
    self:SetObjectState(_ScriptName, 2);
    SendReport(Report.ObjectDelete, _ScriptName);
    SendReportToLocal(Report.ObjectDelete, _ScriptName);
    ExecuteLocal([[CONST_IO["%s"] = nil]], _ScriptName);
    CONST_IO[_ScriptName] = nil;
end

function Lib.IO.Global:CreateSlaveObject(_Object)
    local Name;
    for k, v in pairs(CONST_IO_SLAVE_TO_MASTER) do
        if v == _Object.Name and IsExisting(k) then
            Name = k;
        end
    end
    if Name == nil then
        self.SlaveSequence = self.SlaveSequence +1;
        Name = "LIB_IO_SlaveObject_" ..self.SlaveSequence;
    end

    local SlaveID = GetID(Name);
    if not IsExisting(Name) then
        local x,y,z = Logic.EntityGetPos(GetID(_Object.Name));
        SlaveID = Logic.CreateEntity(Entities.I_X_DragonBoatWreckage, x, y, 0, 0);
        Logic.SetModel(SlaveID, Models.Effects_E_Mosquitos);
        Logic.SetEntityName(SlaveID, Name);
        CONST_IO_SLAVE_TO_MASTER[Name] = _Object.Name;
        ExecuteLocal([[CONST_IO_SLAVE_TO_MASTER["%s"] = "%s"]], Name, _Object.Name);
        _Object.Slave = Name;
    end
    CONST_IO_SLAVE_STATE[Name] = 1;
    return SlaveID;
end

function Lib.IO.Global:SetupObject(_Object)
    local ID = GetID((_Object.Slave and _Object.Slave) or _Object.Name);
    Logic.InteractiveObjectClearCosts(ID);
    Logic.InteractiveObjectClearRewards(ID);
    Logic.InteractiveObjectSetInteractionDistance(ID, _Object.Distance);
    Logic.InteractiveObjectSetTimeToOpen(ID, _Object.Waittime);

    local RewardResourceCart = _Object.RewardResourceCartType or Entities.U_ResourceMerchant;
    Logic.InteractiveObjectSetRewardResourceCartType(ID, RewardResourceCart);
    local RewardGoldCart = _Object.RewardGoldCartType or Entities.U_GoldCart;
    Logic.InteractiveObjectSetRewardGoldCartType(ID, RewardGoldCart);
    local CostResourceCart = _Object.CostResourceCartType or Entities.U_ResourceMerchant;
    Logic.InteractiveObjectSetCostResourceCartType(ID, CostResourceCart);
    local CostGoldCart = _Object.CostGoldCartType or Entities.U_GoldCart;
    Logic.InteractiveObjectSetCostGoldCartType(ID, CostGoldCart);

    if _Object.Reward then
        Logic.InteractiveObjectAddRewards(ID, _Object.Reward[1], _Object.Reward[2]);
    end
    if _Object.Costs and _Object.Costs[1] then
        Logic.InteractiveObjectAddCosts(ID, _Object.Costs[1], _Object.Costs[2]);
    end
    if _Object.Costs and _Object.Costs[3] then
        Logic.InteractiveObjectAddCosts(ID, _Object.Costs[3], _Object.Costs[4]);
    end
    table.insert(HiddenTreasures, ID);
    InteractiveObjectActivate(Logic.GetEntityName(ID), _Object.State or 0);
end

function Lib.IO.Global:ResetObject(_ScriptName)
    local ID = GetID((CONST_IO[_ScriptName].Slave and CONST_IO[_ScriptName].Slave) or _ScriptName);
    RemoveInteractiveObjectFromOpenedList(ID);
    table.insert(HiddenTreasures, ID);
    Logic.InteractiveObjectSetAvailability(ID, true);
    self:SetObjectState(ID, CONST_IO[_ScriptName].State or 0);
    CONST_IO[_ScriptName].IsUsed = false;
    CONST_IO[_ScriptName].IsActive = true;

    SendReport(Report.ObjectReset, _ScriptName);
    SendReportToLocal(Report.ObjectReset, _ScriptName);
end

function Lib.IO.Global:SetObjectState(_ScriptName, _State, ...)
    arg = ((not arg or #arg == 0) and {1, 2, 3, 4, 5, 6, 7, 8}) or arg;
    for i= 1, 8 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), i, 2);
    end
    for i= 1, #arg, 1 do
        Logic.InteractiveObjectSetPlayerState(GetID(_ScriptName), arg[i], _State);
    end
    Logic.InteractiveObjectSetAvailability(GetID(_ScriptName), _State ~= 2);
end

function Lib.IO.Global:OverrideObjectInteraction()
    GameCallback_OnObjectInteraction = function(_EntityID, _PlayerID)
        OnInteractiveObjectOpened(_EntityID, _PlayerID);
        OnTreasureFound(_EntityID, _PlayerID);

        local ScriptName = Logic.GetEntityName(_EntityID);
        if CONST_IO_SLAVE_TO_MASTER[ScriptName] then
            ScriptName = CONST_IO_SLAVE_TO_MASTER[ScriptName];
        end
        local KnightIDs = {};
        Logic.GetKnights(_PlayerID, KnightIDs);
        local KnightID = GetClosestToTarget(_EntityID, KnightIDs);
        SendReport(Report.ObjectInteraction, ScriptName, KnightID, _PlayerID);
        SendReportToLocal(Report.ObjectInteraction, ScriptName, KnightID, _PlayerID);
    end

    --- @diagnostic disable-next-line: duplicate-set-field
    QuestTemplate.AreObjectsActivated = function(self, _ObjectList)
        for i=1, _ObjectList[0] do
            if not _ObjectList[-i] then
                _ObjectList[-i] = GetID(_ObjectList[i]);
            end
            local EntityName = Logic.GetEntityName(_ObjectList[-i]);
            if CONST_IO_SLAVE_TO_MASTER[EntityName] then
                EntityName = CONST_IO_SLAVE_TO_MASTER[EntityName];
            end

            if CONST_IO[EntityName] then
                if CONST_IO[EntityName].IsUsed ~= true then
                    return false;
                end
            elseif Logic.IsInteractiveObject(_ObjectList[-i]) then
                if not IsInteractiveObjectOpen(_ObjectList[-i]) then
                    return false;
                end
            end
        end
        return true;
    end
end

function Lib.IO.Global:ProcessChatInput(_Text)
    if IsHistoryEdition() then
        local Commands = Lib.Core.Debug:CommandTokenizer(_Text);
        for i= 1, #Commands, 1 do
            if Commands[i][1] == "enableobject" then
                local State = (Commands[i][3] and tonumber(Commands[i][3])) or nil;
                local PlayerID = (Commands[i][4] and tonumber(Commands[i][4])) or nil;
                error(IsExisting(Commands[i][2]), "object " ..Commands[i][2].. " does not exist!");
                ---@diagnostic disable-next-line: param-type-mismatch
                InteractiveObjectActivate(Commands[i][2], State, PlayerID);
                log("activated object " ..Commands[i][2].. ".");
            elseif Commands[i][1] == "disableobject" then
                local PlayerID = (Commands[i][3] and tonumber(Commands[i][3])) or nil;
                error(IsExisting(Commands[i][2]), "object " ..Commands[i][2].. " does not exist!");
                InteractiveObjectDeactivate(Commands[i][2], PlayerID);
                log("deactivated object " ..Commands[i][2].. ".");
            elseif Commands[i][1] == "initobject" then
                error(IsExisting(Commands[i][2]), "object " ..Commands[i][2].. " does not exist!");
                API.SetupObject({
                    Name     = Commands[i][2],
                    Waittime = 0,
                    State    = 0
                });
                log("quick initalization of object " ..Commands[i][2].. ".");
            end
        end
    end
end

function Lib.IO.Global:StartObjectDestructionController()
    RequestJobByEventType(Events.LOGIC_EVENT_ENTITY_DESTROYED, function()
        local DestryoedEntityID = Event.GetEntityID();
        local SlaveName  = Logic.GetEntityName(DestryoedEntityID);
        local MasterName = CONST_IO_SLAVE_TO_MASTER[SlaveName];
        if SlaveName and MasterName then
            local Object = CONST_IO[MasterName];
            if not Object then
                return;
            end
            log("slave " ..SlaveName.. " of master " ..MasterName.. " has been deleted!");
            log("try to create new slave...");
            CONST_IO_SLAVE_TO_MASTER[SlaveName] = nil;
            ExecuteLocal([[CONST_IO_SLAVE_TO_MASTER["%s"] = nil]], SlaveName);
            local SlaveID = Lib.IO.Global:CreateSlaveObject(Object);
            error(IsExisting(SlaveID), "failed to create slave!");
            Lib.IO.Global:SetupObject(Object);
            if Object.IsUsed == true or (CONST_IO_SLAVE_STATE[SlaveName] and CONST_IO_SLAVE_STATE[SlaveName] == 0) then
                InteractiveObjectDeactivate(Object.Slave);
            end
            log("new slave created for master " ..MasterName.. ".");
        end
    end);
end

function Lib.IO.Global:StartObjectConditionController()
    RequestHiResJob(function()
        for k, v in pairs(CONST_IO) do
            if v and not v.IsUsed and v.IsActive then
                CONST_IO[k].IsFullfilled = true;
                if CONST_IO[k].Condition then
                    local IsFulfulled = v:Condition();
                    CONST_IO[k].IsFullfilled = IsFulfulled;
                end
                ExecuteLocal([[
                    local ScriptName = "%s"
                    if CONST_IO[ScriptName] then
                        CONST_IO[ScriptName].IsFullfilled = %s
                    end
                ]], k, tostring(CONST_IO[k].IsFullfilled));
            end
        end
    end);
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.IO.Local:Initialize()
    if not self.IsInstalled then
        Report.ObjectClicked = CreateReport("Event_ObjectClicked");
        Report.ObjectInteraction = CreateReport("Event_ObjectInteraction");
        Report.ObjectReset = CreateReport("Event_ObjectReset");
        Report.ObjectDelete = CreateReport("Event_ObjectDelete");

        Report.Internal_DebugEnableObject = CreateReport("Event_Internal_DebugEnableObject");
        Report.Internal_DebugDisableObject = CreateReport("Event_Internal_DebugDisableObject");
        Report.Internal_DebugInitObject = CreateReport("Event_Internal_DebugInitObject");

        Lib.IO.Shared:CreateTechnologies();

        self:OverrideGameFunctions();

        -- Garbage collection
        Lib.IO.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.IO.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.IO.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.ObjectReset then
        if CONST_IO[arg[1]] then
            CONST_IO[arg[1]].IsUsed = false;
        end
    elseif _ID == Report.ObjectInteraction then
        CONST_IO_LAST_OBJECT = GetID(arg[1]);
        CONST_IO_LAST_HERO = arg[2];
    end
end

function Lib.IO.Local:OverrideGameFunctions()
    g_CurrentDisplayedQuestID = 0;

    GUI_Interaction.InteractiveObjectClicked_Orig_Lib_IO = GUI_Interaction.InteractiveObjectClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Interaction.InteractiveObjectClicked = function()
        local i = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));
        local EntityID = g_Interaction.ActiveObjectsOnScreen[i];
        local PlayerID = GUI.GetPlayerID();
        if not EntityID then
            return;
        end
        local ScriptName = Logic.GetEntityName(EntityID);
        if CONST_IO_SLAVE_TO_MASTER[ScriptName] then
            ScriptName = CONST_IO_SLAVE_TO_MASTER[ScriptName];
        end
        if CONST_IO[ScriptName] then
            if not CONST_IO[ScriptName].IsFullfilled then
                local Text = XGUIEng.GetStringTableText("UI_ButtonDisabled/PromoteKnight");
                if CONST_IO[ScriptName].ConditionInfo then
                    Text = ConvertPlaceholders(Localize(CONST_IO[ScriptName].ConditionInfo));
                end
                Message(Text);
                return;
            end
            if type(CONST_IO[ScriptName].Costs) == "table" and #CONST_IO[ScriptName].Costs ~= 0 then
                local StoreHouseID = Logic.GetStoreHouse(PlayerID);
                local CastleID     = Logic.GetHeadquarters(PlayerID);
                if StoreHouseID == nil or StoreHouseID == 0 or CastleID == nil or CastleID == 0 then
                    GUI.AddNote("DEBUG: Player needs special buildings when using activation costs!");
                    return;
                end
            end
        end
        GUI_Interaction.InteractiveObjectClicked_Orig_Lib_IO();

        -- Send additional click event
        -- This is supposed to be used in singleplayer only!
        if not Framework.IsNetworkGame() then
            local KnightIDs = {};
            Logic.GetKnights(PlayerID, KnightIDs);
            local KnightID = GetClosestToTarget(EntityID, KnightIDs);
            SendReportToGlobal(Report.ObjectClicked, ScriptName, KnightID, PlayerID);
            SendReport(Report.ObjectClicked, ScriptName, KnightID, PlayerID);
        end
    end

    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Interaction.InteractiveObjectUpdate = function()
        if g_Interaction.ActiveObjects == nil then
            return;
        end

        local PlayerID = GUI.GetPlayerID();
        for i = 1, #g_Interaction.ActiveObjects do
            local ObjectID = g_Interaction.ActiveObjects[i];
            local MasterObjectID = ObjectID;
            local ScriptName = Logic.GetEntityName(ObjectID);
            if CONST_IO_SLAVE_TO_MASTER[ScriptName] then
                MasterObjectID = GetID(CONST_IO_SLAVE_TO_MASTER[ScriptName]);
            end
            local X, Y = GUI.GetEntityInfoScreenPosition(MasterObjectID);
            local ScreenSizeX, ScreenSizeY = GUI.GetScreenSize();
            if X ~= 0 and Y ~= 0 and X > -50 and Y > -50 and X < (ScreenSizeX + 50) and Y < (ScreenSizeY + 50) then
                if not table.contains(g_Interaction.ActiveObjectsOnScreen, ObjectID) then
                    table.insert(g_Interaction.ActiveObjectsOnScreen, ObjectID);
                end
            else
                for i = 1, #g_Interaction.ActiveObjectsOnScreen do
                    if g_Interaction.ActiveObjectsOnScreen[i] == ObjectID then
                        table.remove(g_Interaction.ActiveObjectsOnScreen, i);
                    end
                end
            end
        end

        for i = 1, #g_Interaction.ActiveObjectsOnScreen do
            local Widget = "/InGame/Root/Normal/InteractiveObjects/" ..i;
            if XGUIEng.IsWidgetExisting(Widget) == 1 then
                local ObjectID       = g_Interaction.ActiveObjectsOnScreen[i];
                local MasterObjectID = ObjectID;
                local ScriptName     = Logic.GetEntityName(ObjectID);
                if CONST_IO_SLAVE_TO_MASTER[ScriptName] then
                    MasterObjectID = GetID(CONST_IO_SLAVE_TO_MASTER[ScriptName]);
                    ScriptName = Logic.GetEntityName(MasterObjectID);
                end
                local EntityType = Logic.GetEntityType(ObjectID);
                local EntityTypeName = Logic.GetEntityTypeName(EntityType);
                local X, Y = GUI.GetEntityInfoScreenPosition(MasterObjectID);
                local WidgetSize = {XGUIEng.GetWidgetScreenSize(Widget)};
                XGUIEng.SetWidgetScreenPosition(Widget, X - (WidgetSize[1]/2), Y - (WidgetSize[2]/2));
                local BaseCosts = {Logic.InteractiveObjectGetCosts(ObjectID)};
                local EffectiveCosts = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};
                local IsAvailable = Logic.InteractiveObjectGetAvailability(ObjectID);
                local HasSpace = Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID);
                local Disable = false;

                if BaseCosts[1] ~= nil and EffectiveCosts[1] == nil and IsAvailable == true then
                    Disable = true;
                end
                if HasSpace == false then
                    Disable = true
                end

                if Logic.GetTime() > 1 and g_GameExtraNo > 0 then
                    if Disable == false and string.find(EntityTypeName, "R_StoneMine") then
                        if Logic.TechnologyGetState(PlayerID, Technologies.R_RefillStoneMine) ~= TechnologyStates.Researched
                        or Logic.TechnologyGetState(PlayerID, Technologies.R_CallGeologist) ~= TechnologyStates.Researched then
                            Disable = true;
                        end
                    end
                    if Disable == false and string.find(EntityTypeName, "R_IronMine") then
                        if Logic.TechnologyGetState(PlayerID, Technologies.R_RefillIronMine) ~= TechnologyStates.Researched
                        or Logic.TechnologyGetState(PlayerID, Technologies.R_CallGeologist) ~= TechnologyStates.Researched then
                            Disable = true;
                        end
                    end
                    if Disable == false and (string.find(EntityTypeName, "B_Cistern") or string.find(EntityTypeName, "B_Well")) then
                        if Logic.TechnologyGetState(PlayerID, Technologies.R_RefillCistern) ~= TechnologyStates.Researched
                        or Logic.TechnologyGetState(PlayerID, Technologies.R_CallGeologist) ~= TechnologyStates.Researched then
                            Disable = true;
                        end
                    end
                    if Disable == false and string.find(EntityTypeName, "I_X_TradePostConstructionSite") then
                        if Logic.TechnologyGetState(PlayerID, Technologies.R_Tradepost) ~= TechnologyStates.Researched then
                            Disable = true;
                        end
                    end
                end

                if Disable == false then
                    if CONST_IO[ScriptName] and type(CONST_IO[ScriptName].Player) == "table" then
                        Disable = not self:IsAvailableForGuiPlayer(ScriptName);
                    elseif CONST_IO[ScriptName] and type(CONST_IO[ScriptName].Player) == "number" then
                        Disable = CONST_IO[ScriptName].Player ~= PlayerID;
                    end
                end

                if Disable == true then
                    XGUIEng.DisableButton(Widget, 1);
                else
                    XGUIEng.DisableButton(Widget, 0);
                end
                if GUI_Interaction.InteractiveObjectUpdateEx1 ~= nil then
                    GUI_Interaction.InteractiveObjectUpdateEx1(Widget, EntityType);
                end
                XGUIEng.ShowWidget(Widget, 1);
            end
        end

        for i = #g_Interaction.ActiveObjectsOnScreen + 1, 2 do
            local Widget = "/InGame/Root/Normal/InteractiveObjects/" .. i;
            XGUIEng.ShowWidget(Widget, 0);
        end

        for i = 1, #g_Interaction.ActiveObjectsOnScreen do
            local Widget     = "/InGame/Root/Normal/InteractiveObjects/" ..i;
            local ObjectID   = g_Interaction.ActiveObjectsOnScreen[i];
            local ScriptName = Logic.GetEntityName(ObjectID);
            if CONST_IO_SLAVE_TO_MASTER[ScriptName] then
                ScriptName = CONST_IO_SLAVE_TO_MASTER[ScriptName];
            end
            if CONST_IO[ScriptName] and CONST_IO[ScriptName].Texture then
                local FileBaseName;
                local a = (CONST_IO[ScriptName].Texture[1]) or 14;
                local b = (CONST_IO[ScriptName].Texture[2]) or 10;
                local c = (CONST_IO[ScriptName].Texture[3]) or 0;
                if type(c) == "string" then
                    FileBaseName = c;
                    c = 0;
                end
                ChangeIcon(Widget, {a, b, c}, nil, FileBaseName);
            end
        end
    end

    GUI_Interaction.InteractiveObjectMouseOver_Orig_Lib_IO = GUI_Interaction.InteractiveObjectMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Interaction.InteractiveObjectMouseOver = function()
        local PlayerID = GUI.GetPlayerID();
        local WidgetID = XGUIEng.GetCurrentWidgetID();
        local ButtonNumber = tonumber(XGUIEng.GetWidgetNameByID(XGUIEng.GetCurrentWidgetID()));
        local ObjectID = g_Interaction.ActiveObjectsOnScreen[ButtonNumber];
        local EntityType = Logic.GetEntityType(ObjectID);
        local EntityTypeName = Logic.GetEntityTypeName(EntityType);

        -- Call original for gold ruins
        if  tonumber(Logic.GetEntityName(ObjectID)) ~= nil
        and string.find(EntityTypeName, "^I_X_") then
            GUI_Interaction.InteractiveObjectMouseOver_Orig_Lib_IO();
            return;
        end

        -- addon special objects
        local IsGeologistTarget = false;
        local IsTradepost = false;
        if g_GameExtraNo > 0 then
            IsGeologistTarget = string.find(EntityTypeName, "^R_Stone") ~= nil or
                                string.find(EntityTypeName, "^R_Iron") ~= nil or
                                string.find(EntityTypeName, "^B_Cistern") ~= nil or
                                string.find(EntityTypeName, "^B_Well") ~= nil;
            IsTradepost = string.find(EntityTypeName, "^I_X_Trade") ~= nil;
        end

        -- Get default text keys
        local DisabledKey;
        local Key = "InteractiveObjectAvailable";
        if Logic.InteractiveObjectGetAvailability(ObjectID) == false then
            Key = "InteractiveObjectNotAvailable";
        elseif Logic.InteractiveObjectHasPlayerEnoughSpaceForRewards(ObjectID, PlayerID) == false then
            DisabledKey = "InteractiveObjectAvailableReward";
        elseif XGUIEng.IsButtonDisabled(WidgetID) == 1 then
            DisabledKey = "UpgradeOutpost";
            if g_GameExtraNo > 0 then
                if string.find(EntityTypeName, "R_StoneMine") then
                    if Logic.TechnologyGetState(PlayerID, Technologies.R_RefillStoneMine) ~= TechnologyStates.Researched
                    or Logic.TechnologyGetState(PlayerID, Technologies.R_CallGeologist) ~= TechnologyStates.Researched then
                        DisabledKey = GUI_Tooltip.GetDisabledKeyForTechnologyType(Technologies.R_RefillStoneMine) or DisabledKey;
                    end
                end
                if string.find(EntityTypeName, "R_IronMine") then
                    if Logic.TechnologyGetState(PlayerID, Technologies.R_RefillIronMine) ~= TechnologyStates.Researched
                    or Logic.TechnologyGetState(PlayerID, Technologies.R_CallGeologist) ~= TechnologyStates.Researched then
                        DisabledKey = GUI_Tooltip.GetDisabledKeyForTechnologyType(Technologies.R_RefillIronMine) or DisabledKey;
                    end
                end
                if (string.find(EntityTypeName, "B_Cistern") or string.find(EntityTypeName, "B_Well")) then
                    if Logic.TechnologyGetState(PlayerID, Technologies.R_RefillCistern) ~= TechnologyStates.Researched
                    or Logic.TechnologyGetState(PlayerID, Technologies.R_CallGeologist) ~= TechnologyStates.Researched then
                        DisabledKey = GUI_Tooltip.GetDisabledKeyForTechnologyType(Technologies.R_RefillCistern) or DisabledKey;
                    end
                end
                if string.find(EntityTypeName, "I_X_TradePostConstructionSite") then
                    if Logic.TechnologyGetState(PlayerID, Technologies.R_Tradepost) ~= TechnologyStates.Researched then
                        DisabledKey = GUI_Tooltip.GetDisabledKeyForTechnologyType(Technologies.R_Tradepost) or DisabledKey;
                    end
                end
            end
        end
        local Title = "UI_ObjectNames/" ..Key;
        local Text = "UI_ObjectDescription/" ..Key;
        local Disabled = (DisabledKey ~= nil and "UI_ButtonDisabled/" ..DisabledKey) or nil;
        if IsGeologistTarget then
            Title = "UI_ObjectNames/InteractiveObjectGeologist";
        end
        if IsTradepost then
            Title = "UI_ObjectNames/InteractiveObjectTradepost";
        end

        -- Get default costs
        local CheckSettlement = false;
        local Costs = {Logic.InteractiveObjectGetEffectiveCosts(ObjectID, PlayerID)};
        if Costs and Costs[1] and Costs[1] ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then
            CheckSettlement = true;
        end

        -- Handle initalized lib objects
        local ScriptName = Logic.GetEntityName(ObjectID);
        if CONST_IO_SLAVE_TO_MASTER[ScriptName] then
            ScriptName = CONST_IO_SLAVE_TO_MASTER[ScriptName];
        end
        if CONST_IO[ScriptName] and CONST_IO[ScriptName].IsUsed ~= true then
            Key = "InteractiveObjectAvailable";
            if (CONST_IO[ScriptName] and type(CONST_IO[ScriptName].Player) == "table" and not self:IsAvailableForGuiPlayer(ScriptName))
            or (CONST_IO[ScriptName] and type(CONST_IO[ScriptName].Player) == "number" and CONST_IO[ScriptName].Player ~= PlayerID)
            or Logic.InteractiveObjectGetAvailability(ObjectID) == false then
                Key = "InteractiveObjectNotAvailable";
            end
            Title = ConvertPlaceholders(Localize(CONST_IO[ScriptName].Title or Title));
            if Title and Title:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                Title = XGUIEng.GetStringTableText(Title);
            end
            Text = ConvertPlaceholders(Localize(CONST_IO[ScriptName].Text or Text));
            if Text and Text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                Text = XGUIEng.GetStringTableText(Text);
            end
            Disabled = CONST_IO[ScriptName].DisabledText or Disabled;
            if Disabled then
                Disabled = ConvertPlaceholders(Localize(Disabled));
                if Disabled and Disabled:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                    Disabled = XGUIEng.GetStringTableText(Disabled);
                end
            end
            Costs = CONST_IO[ScriptName].Costs;
            if Costs and Costs[1] and Costs[1] ~= Goods.G_Gold and Logic.GetGoodCategoryForGoodType(Costs[1]) ~= GoodCategories.GC_Resource then
                CheckSettlement = true;
            end
        end
        SetTooltipCosts(Title, Text, Disabled, Costs, CheckSettlement);
    end

    GUI_Interaction.DisplayQuestObjective_Orig_Lib_IO = GUI_Interaction.DisplayQuestObjective
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Interaction.DisplayQuestObjective = function(_QuestIndex, _MessageKey)
        local QuestIndexTemp = tonumber(_QuestIndex);
        if QuestIndexTemp then
            _QuestIndex = QuestIndexTemp;
        end

        local Quest, QuestType = GUI_Interaction.GetPotentialSubQuestAndType(_QuestIndex);
        local QuestObjectivesPath = "/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives";
        XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
        local QuestObjectiveContainer;
        local QuestTypeCaption;

        g_CurrentDisplayedQuestID = _QuestIndex;

        if QuestType == Objective.Object then
            QuestObjectiveContainer = QuestObjectivesPath .. "/List";
            QuestTypeCaption = Wrapped_GetStringTableText(_QuestIndex, "UI_Texts/QuestInteraction");
            local ObjectList = {};

            assert(Quest ~= nil);
            for i = 1, Quest.Objectives[1].Data[0] do
                local ObjectType;
                if Logic.IsEntityDestroyed(Quest.Objectives[1].Data[i]) then
                    ObjectType = g_Interaction.SavedQuestEntityTypes[_QuestIndex][i];
                else
                    ObjectType = Logic.GetEntityType(GetID(Quest.Objectives[1].Data[i]));
                end
                local ObjectEntityName = Logic.GetEntityName(Quest.Objectives[1].Data[i]);
                local ObjectName = "";
                if ObjectType ~= nil and ObjectType ~= 0 then
                    local ObjectTypeName = Logic.GetEntityTypeName(ObjectType)
                    ObjectName = Wrapped_GetStringTableText(_QuestIndex, "Names/" .. ObjectTypeName)
                                 or GetStringText("Names/" .. ObjectTypeName);
                    if ObjectName == "" then
                        ObjectName = Wrapped_GetStringTableText(_QuestIndex, "UI_ObjectNames/" .. ObjectTypeName)
                                     or GetStringText("UI_ObjectNames/" .. ObjectTypeName);
                    end
                    if ObjectName == nil then
                        ObjectName = "Debug: ObjectName missing for " .. ObjectTypeName;
                    end
                end
                table.insert(ObjectList, Localize(ConvertPlaceholders(ObjectName)));
            end
            for i = 1, 4 do
                local String = ObjectList[i];
                if String == nil then
                    String = "";
                end
                XGUIEng.SetText(QuestObjectiveContainer .. "/Entry" .. i, "{center}" .. String);
            end

            SetIcon(QuestObjectiveContainer .. "/QuestTypeIcon",{14, 10});
            XGUIEng.SetText(QuestObjectiveContainer.."/Caption","{center}"..QuestTypeCaption);
            XGUIEng.ShowWidget(QuestObjectiveContainer, 1);
        else
            GUI_Interaction.DisplayQuestObjective_Orig_Lib_IO(_QuestIndex, _MessageKey);
        end
    end
end

function Lib.IO.Local:IsAvailableForGuiPlayer(_ScriptName)
    local PlayerID = GUI.GetPlayerID();
    if CONST_IO[_ScriptName] and type(CONST_IO[_ScriptName].Player) == "table" then
        for i= 1, 8 do
            if CONST_IO[_ScriptName].Player[i] and CONST_IO[_ScriptName].Player[i] == PlayerID then
                return true;
            end
        end
        return false;
    end
    return true;
end

-- -------------------------------------------------------------------------- --
-- Shared

function Lib.IO.Shared:CreateTechnologies()
    for i= 1, #self.TechnologyConfig do
        if g_GameExtraNo >= self.TechnologyConfig[i][4] then
            if not Technologies[self.TechnologyConfig[i][1]] then
                AddCustomTechnology(self.TechnologyConfig[i][1], self.TechnologyConfig[i][2], self.TechnologyConfig[i][3]);
                if not IsLocalScript() then
                    for j= 1, 8 do
                        Logic.TechnologySetState(j, Technologies[self.TechnologyConfig[i][1]], 3);
                    end
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.IO.Name);

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/io/IOChest_API");

function CreateRandomChest(_Name, _Good, _Min, _Max, _Condition, _Action)
    if IsLocalScript() then
        return;
    end
    if not _Action then
        _Action = _Condition;
        _Condition = nil;
    end
    assert(IsExisting(_Name), "Entity does not exist!");
    assert(GetNameOfKeyInTable(Goods, _Good) ~= nil, "Good type is invalid!");
    assert(type(_Min) == "number" and _Min >= 1, "Minimum is to low!");
    _Max = _Max or _Min;
    assert(type(_Max) == "number" or _Max >= 1, "Maximum is to low!");
    assert(_Max >= _Min, "Maximum can not be lower than minimum!");
    Lib.IOChest.Global:CreateRandomChest(_Name, _Good, _Min, _Max, false, false, _Condition, _Action);
end
API.CreateRandomChest = CreateRandomChest;

function CreateRandomChest(_Name, _Good, _Min, _Max, _Condition, _Action)
    if IsLocalScript() then
        return;
    end
    if not _Action then
        _Action = _Condition;
        _Condition = nil;
    end
    assert(IsExisting(_Name), "Entity does not exist!");
    assert(GetNameOfKeyInTable(Goods, _Good) ~= nil, "Good type is invalid!");
    assert(type(_Min) == "number" and _Min >= 1, "Minimum is to low!");
    _Max = _Max or _Min;
    assert(type(_Max) == "number" or _Max >= 1, "Maximum is to low!");
    assert(_Max >= _Min, "Maximum can not be lower than minimum!");
    Lib.IOChest.Global:CreateRandomChest(_Name, _Good, _Min, _Max, false, true, _Condition, _Action);
end
API.CreateRandomChest = CreateRandomChest;

function CreateRandomGoldChest(_Name)
    if IsLocalScript() then
        return;
    end
    assert(IsExisting(_Name), "Entity does not exist!");
    Lib.IOChest.Global:CreateRandomGoldChest(_Name);
end
API.CreateRandomGoldChest = CreateRandomGoldChest;

function CreateRandomResourceChest(_Name)
    if IsLocalScript() then
        return;
    end
    assert(IsExisting(_Name), "Entity does not exist!");
    Lib.IOChest.Global:CreateRandomResourceChest(_Name);
end
API.CreateRandomResourceChest = CreateRandomResourceChest;

function CreateRandomLuxuryChest(_Name)
    if IsLocalScript() then
        return;
    end
    assert(IsExisting(_Name), "Entity does not exist!");
    Lib.IOChest.Global:CreateRandomLuxuryChest(_Name);
end
API.CreateRandomLuxuryChest = CreateRandomLuxuryChest;



function Debug_GoldChest(_Entity)
    assert(IsLocalScript(), "Debug function must be used in local script!");
    SendReportToGlobal(Report.Internal_DebugGoldChest, _Entity);
end

function Debug_GoodChest(_Entity)
    assert(IsLocalScript(), "Debug function must be used in local script!");
    SendReportToGlobal(Report.Internal_DebugResourceChest, _Entity);
end

function Debug_LuxuryChest(_Entity)
    assert(IsLocalScript(), "Debug function must be used in local script!");
    SendReportToGlobal(Report.Internal_DebugLuxuryChest, _Entity);
end

Lib.IOChest = Lib.IOChest or {};
Lib.IOChest.Name = "IOChest";
Lib.IOChest.Global = {};
Lib.IOChest.Local = {};

Lib.Require("comfort/IsHistoryEdition");
Lib.Require("core/Core");
Lib.Require("module/io/IO");
Lib.Require("module/io/IOChest_API");
Lib.Register("module/io/IOChest");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.IOChest.Global:Initialize()
    if not self.IsInstalled then
        --- The player activated a treasure
        --- 
        --- #### Parameters
        --- * `ScriptName` - Scriptname of entity
        --- * `KnightID`   - ID of activating hero
        --- * `PlayerID`   - ID of activating player
        Report.InteractiveTreasureActivated = CreateReport("Event_InteractiveTreasureActivated");

        Report.Internal_DebugGoldChest = CreateReport("Event_Internal_DebugGoldChest");
        Report.Internal_DebugResourceChest = CreateReport("Event_Internal_DebugResourceChest");
        Report.Internal_DebugLuxuryChest = CreateReport("Event_Internal_DebugLuxuryChest");

        -- Garbage collection
        Lib.IOChest.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.IOChest.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.IOChest.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.ChatClosed then
        if arg[3] then
            self:ProcessChatInput(arg[1]);
        end
    elseif _ID == Report.ObjectReset then
        if CONST_IO[arg[1]] and CONST_IO[arg[1]].IsInteractiveChest then
            self:ResetIOChest(arg[1]);
        end
    elseif _ID == Report.ObjectDelete then
        if CONST_IO[arg[1]] and CONST_IO[arg[1]].IsInteractiveChest then
            -- Nothing to do?
        end
    elseif _ID == Report.Internal_DebugGoldChest then
        error(IsExisting(arg[1]), "entity " ..arg[1].. " does not exist!");
        CreateRandomGoldChest(arg[1]);
    elseif _ID == Report.Internal_DebugResourceChest then
        error(IsExisting(arg[1]), "entity " ..arg[1].. " does not exist!");
        CreateRandomResourceChest(arg[1]);
    elseif _ID == Report.Internal_DebugLuxuryChest then
        error(IsExisting(arg[1]), "entity " ..arg[1].. " does not exist!");
        CreateRandomLuxuryChest(arg[1]);
    end
end

function Lib.IOChest.Global:ProcessChatInput(_Text)
    if IsHistoryEdition() then
        local Commands = Lib.Core.Debug:CommandTokenizer(_Text);
        for i= 1, #Commands, 1 do
            if Commands[i][1] == "goldchest" then
                if not IsExisting(Commands[i][2]) then
                    CreateRandomGoldChest(Commands[i][2]);
                end
            elseif Commands[i][1] == "goodchest" then
                if not IsExisting(Commands[i][2]) then
                    CreateRandomResourceChest(Commands[i][2]);
                end
            elseif Commands[i][1] == "luxurychest" then
                if not IsExisting(Commands[i][2]) then
                    CreateRandomLuxuryChest(Commands[i][2]);
                end
            end
        end
    end
end

function Lib.IOChest.Global:CreateRandomChest(_Name, _Good, _Min, _Max, _DirectPay, _NoModelChange, _Condition, _Action)
    _Min = math.floor((_Min ~= nil and _Min > 0 and _Min) or 1);
    _Max = math.floor((_Max ~= nil and _Max > 1 and _Max) or 2);
    assert(_Good ~= nil, "CreateRandomChest: Good does not exist!");
    assert(_Min <= _Max, "CreateRandomChest: min amount must be smaller or equal than max amount!");

    -- Debug Informationen schreiben
    log(
        "Creating chest (%s, %s, %d, %d, %s, %s)",
        _Name,
        Logic.GetGoodTypeName(_Good),
        _Min,
        _Max,
        tostring(_DirectPay == true),
        tostring(_NoModelChange == true)
    );

    -- Model setzen
    if not _NoModelChange then
        local eID = ReplaceEntity(_Name, Entities.XD_ScriptEntity, 0);
        Logic.SetModel(eID, Models.Doodads_D_X_ChestClose);
        Logic.SetVisible(eID, true);
    end

    -- Menge an Gütern ermitteln
    local GoodAmount = _Min;
    if _Min < _Max then
        GoodAmount = math.random(_Min, _Max);
    end

    -- Rewards
    local DirectReward;
    local IOReward;
    if not _DirectPay then
        IOReward = {_Good, GoodAmount};
    else
        DirectReward = {_Good, GoodAmount};
    end

    SetupObject {
        Name                    = _Name,
        IsInteractiveChest      = true,
        Reward                  = IOReward,
        DirectReward            = DirectReward,
        Texture                 = {1, 6},
        Distance                = (_NoModelChange and 1200) or 650,
        Waittime                = 0,
        State                   = 0,
        DoNotChangeModel        = _NoModelChange == true,
        ActivationCondition     = _Condition,
        ActivationAction        = _Action,
        Condition               = function(_Data)
            if _Data.ActivationCondition then
                return _Data.ActivationCondition(_Data);
            end
            return true;
        end,
        Action                  = function(_Data, _KnightID, _PlayerID)
            if not _Data.DoNotChangeModel then
                Logic.SetModel(GetID(_Data.Name), Models.Doodads_D_X_ChestOpenEmpty);
            end
            if _Data.DirectReward then
                AddGood(_Data.DirectReward[1], _Data.DirectReward[2], _PlayerID);
            end
            if _Data.ActivationAction then
                _Data.ActivationAction(_Data, _KnightID, _PlayerID);
            end

            SendReport(Report.InteractiveTreasureActivated, _Data.Name, _KnightID, _PlayerID);
            SendReportToLocal(Report.InteractiveTreasureActivated, _Data.Name, _KnightID, _PlayerID);
        end,
    };
end

function Lib.IOChest.Global:ResetIOChest(_ScriptName)
    if not CONST_IO[_ScriptName].DoNotChangeModel then
        local EntityID = ReplaceEntity(_ScriptName, Entities.XD_ScriptEntity, 0);
        Logic.SetModel(EntityID, Models.Doodads_D_X_ChestClose);
        Logic.SetVisible(EntityID, true);
    end
end

function Lib.IOChest.Global:CreateRandomGoldChest(_Name)
    self:CreateRandomChest(_Name, Goods.G_Gold, 300, 600, false);
end

function Lib.IOChest.Global:CreateRandomResourceChest(_Name)
    local PossibleGoods = {
        Goods.G_Iron, Goods.G_Stone, Goods.G_Wood, Goods.G_Wool,
        Goods.G_Carcass, Goods.G_Herb, Goods.G_Honeycomb,
        Goods.G_Milk, Goods.G_RawFish, Goods.G_Grain
    };
    local Good = PossibleGoods[math.random(1, #PossibleGoods)];
    self:CreateRandomChest(_Name, Good, 30, 60, false);
end

function Lib.IOChest.Global:CreateRandomLuxuryChest(_Name)
    local Luxury = {Goods.G_Salt, Goods.G_Dye};
    if g_GameExtraNo >= 1 then
        table.insert(Luxury, Goods.G_Gems);
        table.insert(Luxury, Goods.G_MusicalInstrument);
        table.insert(Luxury, Goods.G_Olibanum);
    end
    local Good = Luxury[math.random(1, #Luxury)];
    self:CreateRandomChest(_Name, Good, 50, 100, false);
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.IOChest.Local:Initialize()
    if not self.IsInstalled then
        Report.InteractiveTreasureActivated = CreateReport("Event_InteractiveTreasureActivated");

        Report.Internal_DebugGoldChest = CreateReport("Event_Internal_DebugGoldChest");
        Report.Internal_DebugResourceChest = CreateReport("Event_Internal_DebugResourceChest");
        Report.Internal_DebugLuxuryChest = CreateReport("Event_Internal_DebugLuxuryChest");

        self:CreateDefaultObjectNames();

        -- Garbage collection
        Lib.IOChest.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.IOChest.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.IOChest.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

function Lib.IOChest.Local:CreateDefaultObjectNames()
    AddStringText("UI_ObjectNames/D_X_ChestClosed", {
        de = "Verschlossene Schatztruhe",
        en = "Closed Treasure Chest",
        fr = "Coffre au trésor fermé"
    });
    AddStringText("UI_ObjectNames/D_X_ChestOpenEmpty", {
        de = "Leere Truhe",
        en = "Empty Chest",
        fr = "Coffre vide"
    });
    AddStringText("UI_ObjectNames/D_X_ChestOpen01", {
        de = "Leere Truhe",
        en = "Empty Chest",
        fr = "Coffre vide"
    });
    AddStringText("UI_ObjectNames/D_X_ChestOpen02", {
        de = "Leere Truhe",
        en = "Empty Chest",
        fr = "Coffre vide"
    });
    AddStringText("UI_ObjectNames/D_X_ChestOpen03", {
        de = "Leere Truhe",
        en = "Empty Chest",
        fr = "Coffre vide"
    });
    AddStringText("UI_ObjectNames/D_X_ChestOpen04", {
        de = "Leere Truhe",
        en = "Empty Chest",
        fr = "Coffre vide"
    });
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.IOChest.Name);

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/io/IOMine_API");

function CreateIOIronMine(_Data)
    local Costs = {Goods.G_Gold, 500, Goods.G_Wood, 20};
    CheckIOMineParameter(_Data);
    Lib.IOMine.Global:CreateIOMine(
        _Data.Scriptname,
        Entities.R_IronMine,
        _Data.Title,
        _Data.Text,
        _Data.Costs or Costs,
        _Data.ResourceAmount,
        _Data.RefillAmount,
        _Data.ConstructionCondition,
        _Data.ConditionInfo,
        _Data.ConstructionAction
    );
end
API.CreateIOIronMine = CreateIOIronMine;

function CreateIOStoneMine(_Data)
    local Costs = {Goods.G_Gold, 500, Goods.G_Wood, 20};
    CheckIOMineParameter(_Data);
    Lib.IOMine.Global:CreateIOMine(
        _Data.Scriptname,
        Entities.R_StoneMine,
        _Data.Title,
        _Data.Text,
        _Data.Costs or Costs,
        _Data.ResourceAmount,
        _Data.RefillAmount,
        _Data.ConstructionCondition,
        _Data.ConditionInfo,
        _Data.ConstructionAction
    );
end
API.CreateIOStoneMine = CreateIOStoneMine;

function CheckIOMineParameter(_Data)
    error(not IsLocalScript(), "Must be used in global script!");
    error(IsExisting(_Data.Scriptname),
          "API.CreateIOIronMine: Scriptname '%s' does not exist!",
          tostring(_Data.Scriptname));
    local Costs = {Goods.G_Gold, 500, Goods.G_Wood, 20};
    if _Data.Costs then
        if _Data.Costs[1] then
            error(
                GetNameOfKeyInTable(Goods, _Data.Costs[1]),
                "API.CreateIOIronMine: First cost type '%s' is wrong!",
                tostring(_Data.Costs[1])
            );
            error(
                _Data.Costs[2] and (type(_Data.Costs[2]) == "number" or _Data.Costs[2] < 1),
                "API.CreateIOIronMine: First cost amount must be above 0!"
            );
        end
        if _Data.Costs[3] then
            error(
                GetNameOfKeyInTable(Goods, _Data.Costs[3]),
                "API.CreateIOIronMine: First cost type '%s' is wrong!",
                tostring(_Data.Costs[3])
            );
            error(
                _Data.Costs[4] and (type(_Data.Costs[4]) == "number" or _Data.Costs[4] < 1),
                "API.CreateIOIronMine: First cost amount must be above 0!"
            );
        end
    end
end

Lib.IOMine = Lib.IOMine or {};
Lib.IOMine.Name = "IOMine";
Lib.IOMine.Global = {
    Mines = {},
};
Lib.IOMine.Local  = {};

Lib.Require("core/Core");
Lib.Require("module/io/IO");
Lib.Require("module/io/IOMine_API");
Lib.Register("module/io/IOMine");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.IOMine.Global:Initialize()
    if not self.IsInstalled then
        --- A resource source was constructed.
        ---
        --- #### Parameter
        --- - `ScriptName` - Scriptname of mine
        --- * `KnightID`   - ID of activating hero
        --- * `PlayerID`   - ID of activating player
        Report.InteractiveMineErected = CreateReport("Event_InteractiveMineErected");

        -- Garbage collection
        Lib.IOMine.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.IOMine.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.IOMine.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.ObjectReset then
        if CONST_IO[arg[1]] and CONST_IO[arg[1]].IsInteractiveMine then
            self:ResetIOMine(arg[1], CONST_IO[arg[1]].Type);
        end
    elseif _ID == Report.ObjectDelete then
        if CONST_IO[arg[1]].IsInteractiveMine and CONST_IO[arg[1]].Type then
            ReplaceEntity(arg[1], CONST_IO[arg[1]].Type);
        end
    end
end

function Lib.IOMine.Global:CreateIOMine(
    _Position, _Type, _Title, _Text, _Costs, _ResourceAmount,
    _RefillAmount, _Condition, _ConditionInfo, _Action
)
    local BlockerID = self:ResetIOMine(_Position, _Type);
    local Icon = {14, 10};
    local TextKey;
    if _Type == Entities.R_IronMine then
        TextKey = "Names/R_IronMine";
        Icon = {14, 10};
    end
    if _Type == Entities.R_StoneMine then
        TextKey = "Names/R_StoneMine";
        Icon = {14, 10};
    end

    SetupObject {
        Name                 = _Position,
        IsInteractiveMine    = true,
        Title                = _Title or TextKey,
        Text                 = _Text,
        Texture              = Icon,
        Type                 = _Type,
        ResourceAmount       = _ResourceAmount or 250,
        RefillAmount         = _RefillAmount or 75,
        Costs                = _Costs,
        InvisibleBlocker     = BlockerID,
        Distance             = 1200,
        Waittime             = 0,
        ConditionInfo        = _ConditionInfo,
        AdditionalCondition  = _Condition,
        AdditionalAction     = _Action,
        Condition            = function(_Data)
            if _Data.AdditionalCondition then
                return _Data:AdditionalCondition(_Data);
            end
            return true;
        end,
        Action               = function(_Data, _KnightID, _PlayerID)
            local ID = ReplaceEntity(_Data.Name, _Data.Type);
            SetResourceAmount(ID, _Data.ResourceAmount, _Data.RefillAmount);
            DestroyEntity(_Data.InvisibleBlocker);
            SendReport(Report.InteractiveMineErected, _Data.Name, _KnightID, _PlayerID);
            SendReportToLocal(Report.InteractiveMineErected, _Data.Name, _KnightID, _PlayerID);
            if _Data.AdditionalAction then
                _Data.AdditionalAction(_Data, _KnightID, _PlayerID);
            end
        end
    };
end

function Lib.IOMine.Global:ResetIOMine(_ScriptName, _Type)
    if CONST_IO[_ScriptName] then
        DestroyEntity(CONST_IO[_ScriptName].InvisibleBlocker);
    end
    local EntityID = ReplaceEntity(_ScriptName, Entities.XD_ScriptEntity);
    local Model = Models.Doodads_D_SE_ResourceIron_Wrecked;
    if _Type == Entities.R_StoneMine then
        Model = Models.R_SE_ResorceStone_10;
    end
    Logic.SetVisible(EntityID, true);
    Logic.SetModel(EntityID, Model);
    local x, y, z = Logic.EntityGetPos(EntityID);
    local BlockerID = Logic.CreateEntity(Entities.D_ME_Rock_Set01_B_07, x, y, 0, 0);
    Logic.SetVisible(BlockerID, false);
    if CONST_IO[_ScriptName] then
        CONST_IO[_ScriptName].InvisibleBlocker = BlockerID;
    end
    return BlockerID;
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.IOMine.Local:Initialize()
    if not self.IsInstalled then
        Report.InteractiveMineErected = CreateReport("Event_InteractiveMineErected");

        -- Garbage collection
        Lib.IOMine.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.IOMine.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.IOMine.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.IOMine.Name);

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/entity/EntityEvent_API");

function ThiefDisableStorehouseEffect(_Flag)
    Lib.EntityEvent.Global.DisableThiefStorehouseHeist = _Flag == true;
end
API.ThiefDisableStorehouseEffect = ThiefDisableStorehouseEffect;

function ThiefDisableCathedralEffect(_Flag)
    Lib.EntityEvent.Global.DisableThiefCathedralSabotage = _Flag == true;
end
API.ThiefDisableCathedralEffect = ThiefDisableCathedralEffect;

function ThiefDisableCisternEffect(_Flag)
    Lib.EntityEvent.Global.DisableThiefCisternSabotage = _Flag == true;
end
API.ThiefDisableCisternEffect = ThiefDisableCisternEffect;

Lib.EntityEvent = Lib.EntityEvent or {};
Lib.EntityEvent.Name = "EntityEvent";
Lib.EntityEvent.Global = {
    JobID = {},
    RegisteredEntities = {},
    MineAmounts = {},
    AttackedEntities = {},
    DisableThiefStorehouseHeist = false,
    DisableThiefCathedralSabotage = false,
    DisableThiefCisternSabotage = false,

    -- TODO: Add predators?
    StaticSpawnerTypes = {
        "B_NPC_BanditsHQ_ME",
        "B_NPC_BanditsHQ_NA",
        "B_NPC_BanditsHQ_NE",
        "B_NPC_BanditsHQ_SE",
        "B_NPC_BanditsHutBig_ME",
        "B_NPC_BanditsHutBig_NA",
        "B_NPC_BanditsHutBig_NE",
        "B_NPC_BanditsHutBig_SE",
        "B_NPC_BanditsHutSmall_ME",
        "B_NPC_BanditsHutSmall_NA",
        "B_NPC_BanditsHutSmall_NE",
        "B_NPC_BanditsHutSmall_SE",
        "B_NPC_Barracks_ME",
        "B_NPC_Barracks_NA",
        "B_NPC_Barracks_NE",
        "B_NPC_Barracks_SE",
        "B_NPC_BanditsHQ_AS",
        "B_NPC_BanditsHutBig_AS",
        "B_NPC_BanditsHutSmall_AS",
        "B_NPC_Barracks_AS",
    },

    -- Those are "fluctuating" spawner entities that are keep appearing
    -- and disappearing depending of if they have resources spawned. They
    -- change their ID every time they do it. So scriptnames are a nono.
    DynamicSpawnerTypes = {
        "S_AxisDeer_AS",
        "S_Deer_ME",
        "S_FallowDeer_SE",
        "S_Gazelle_NA",
        "S_Herbs",
        "S_Moose_NE",
        "S_RawFish",
        "S_Reindeer_NE",
        "S_WildBoar",
        "S_Zebra_NA",
    },
};
Lib.EntityEvent.Local  = {};

Lib.Require("comfort/GetDistance");
Lib.Require("core/Core");
Lib.Require("module/entity/EntityEvent_API");
Lib.Register("module/entity/EntityEvent");

-- Global ------------------------------------------------------------------- --

function Lib.EntityEvent.Global:Initialize()
    Report.SettlerAttracted = CreateReport("Event_SettlerAttracted");
    Report.EntitySpawned = CreateReport("Event_EntitySpawned");
    Report.EntityDestroyed = CreateReport("Event_EntityDestroyed");
    Report.EntityHurt = CreateReport("Event_EntityHurt");
    Report.EntityKilled = CreateReport("Event_EntityKilled");
    Report.EntityOwnerChanged = CreateReport("Event_EntityOwnerChanged");
    Report.EntityResourceChanged = CreateReport("Event_EntityResourceChanged");

    Report.ThiefInfiltratedBuilding = CreateReport("Event_ThiefInfiltratedBuilding");
    Report.ThiefDeliverEarnings = CreateReport("Event_ThiefDeliverEarnings");
    Report.BuildingConstructed = CreateReport("Event_BuildingConstructed");
    Report.BuildingUpgradeCollapsed = CreateReport("Event_BuildingUpgradeCollapsed");
    Report.BuildingUpgraded = CreateReport("Event_BuildingUpgraded");

    self:StartTriggers();
    self:OverrideCallback();
    self:OverrideLogic();
end

function Lib.EntityEvent.Global:OnSaveGameLoaded()
    self:OverrideLogic();
end

function Lib.EntityEvent.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadscreenClosed then
        self.LoadscreenClosed = true;
    elseif _ID == Report.EntityHurt then
        self.AttackedEntities[arg[3]] = {arg[1], 300};
    end
end

function Lib.EntityEvent.Global:CleanTaggedAndDeadEntities()
    -- check if entity should no longer be considered attacked
    for k,v in pairs(self.AttackedEntities) do
        self.AttackedEntities[k][2] = v[2] - 1;
        if v[2] <= 0 then
            self.AttackedEntities[k] = nil;
        else
            -- Send killed event for knights
            if IsExisting(k) and IsExisting(v[1]) and Logic.IsKnight(k) then
                if Logic.KnightGetResurrectionProgress(k) ~= 1 then
                    local PlayerID1 = Logic.EntityGetPlayer(k);
                    local PlayerID2 = Logic.EntityGetPlayer(v[1]);
                    self:TriggerEntityKilledEvent(k, PlayerID1, v[1], PlayerID2);
                    self.AttackedEntities[k] = nil;
                end
            end
        end
    end
end

function Lib.EntityEvent.Global:OverrideCallback()
    GameCallback_SettlerSpawned_Orig_QSB_EntityCore = GameCallback_SettlerSpawned;
    GameCallback_SettlerSpawned = function(_PlayerID, _EntityID)
        GameCallback_SettlerSpawned_Orig_QSB_EntityCore(_PlayerID, _EntityID);
        Lib.EntityEvent.Global:TriggerSettlerArrivedEvent(_PlayerID, _EntityID);
    end

    GameCallback_OnBuildingConstructionComplete_Orig_QSB_EntityCore = GameCallback_OnBuildingConstructionComplete;
    GameCallback_OnBuildingConstructionComplete = function(_PlayerID, _EntityID)
        GameCallback_OnBuildingConstructionComplete_Orig_QSB_EntityCore(_PlayerID, _EntityID);
        Lib.EntityEvent.Global:TriggerConstructionCompleteEvent(_PlayerID, _EntityID);
    end

    GameCallback_FarmAnimalChangedPlayerID_Orig_QSB_EntityCore = GameCallback_FarmAnimalChangedPlayerID;
    GameCallback_FarmAnimalChangedPlayerID = function(_PlayerID, _NewEntityID, _OldEntityID)
        GameCallback_FarmAnimalChangedPlayerID_Orig_QSB_EntityCore(_PlayerID, _NewEntityID, _OldEntityID);
        local OldPlayerID = Logic.EntityGetPlayer(_OldEntityID);
        local NewPlayerID = Logic.EntityGetPlayer(_NewEntityID);
        Lib.EntityEvent.Global:TriggerEntityOnwershipChangedEvent(_OldEntityID, OldPlayerID, _NewEntityID, NewPlayerID);
    end

    GameCallback_EntityCaptured_Orig_QSB_EntityCore = GameCallback_EntityCaptured;
    GameCallback_EntityCaptured = function(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID)
        GameCallback_EntityCaptured_Orig_QSB_EntityCore(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID)
        Lib.EntityEvent.Global:TriggerEntityOnwershipChangedEvent(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID);
    end

    GameCallback_CartFreed_Orig_QSB_EntityCore = GameCallback_CartFreed;
    GameCallback_CartFreed = function(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID)
        GameCallback_CartFreed_Orig_QSB_EntityCore(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID);
        Lib.EntityEvent.Global:TriggerEntityOnwershipChangedEvent(_OldEntityID, _OldEntityPlayerID, _NewEntityID, _NewEntityPlayerID);
    end

    GameCallback_OnThiefDeliverEarnings_Orig_QSB_EntityCore = GameCallback_OnThiefDeliverEarnings;
    GameCallback_OnThiefDeliverEarnings = function(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount)
        GameCallback_OnThiefDeliverEarnings_Orig_QSB_EntityCore(_ThiefPlayerID, _ThiefID, _BuildingID, _GoodAmount);
        local BuildingPlayerID = Logic.EntityGetPlayer(_BuildingID);
        Lib.EntityEvent.Global:TriggerThiefDeliverEarningsEvent(_ThiefID, _ThiefPlayerID, _BuildingID, BuildingPlayerID, _GoodAmount);
    end

    GameCallback_OnThiefStealBuilding_Orig_QSB_EntityCore = GameCallback_OnThiefStealBuilding;
    GameCallback_OnThiefStealBuilding = function(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID)
        Lib.EntityEvent.Global:TriggerThiefStealFromBuildingEvent(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
    end

    GameCallback_OnBuildingUpgraded_Orig_QSB_EntityCore = GameCallback_OnBuildingUpgradeFinished;
	GameCallback_OnBuildingUpgradeFinished = function(_PlayerID, _EntityID, _NewUpgradeLevel)
		GameCallback_OnBuildingUpgraded_Orig_QSB_EntityCore(_PlayerID, _EntityID, _NewUpgradeLevel);
        Lib.EntityEvent.Global:TriggerUpgradeCompleteEvent(_PlayerID, _EntityID, _NewUpgradeLevel);
    end

    GameCallback_OnUpgradeLevelCollapsed_Orig_QSB_EntityCore = GameCallback_OnUpgradeLevelCollapsed;
    GameCallback_OnUpgradeLevelCollapsed = function(_PlayerID, _BuildingID, _NewUpgradeLevel)
        GameCallback_OnUpgradeLevelCollapsed_Orig_QSB_EntityCore(_PlayerID, _BuildingID, _NewUpgradeLevel);
        Lib.EntityEvent.Global:TriggerUpgradeCollapsedEvent(_PlayerID, _BuildingID, _NewUpgradeLevel);
    end
end

function Lib.EntityEvent.Global:OverrideLogic()
    self.Logic_ChangeEntityPlayerID = Logic.ChangeEntityPlayerID;
    Logic.ChangeEntityPlayerID = function(...)
        local OldID = {arg[1]};
        local OldPlayerID = Logic.EntityGetPlayer(arg[1]);
        local NewID = {self.Logic_ChangeEntityPlayerID(unpack(arg))};
        local NewPlayerID = Logic.EntityGetPlayer(NewID[1]);
        Lib.EntityEvent.Global:TriggerEntityOnwershipChangedEvent(
            OldID,
            OldPlayerID,
            NewID,
            NewPlayerID
        );
        return NewID;
    end

    self.Logic_ChangeSettlerPlayerID = Logic.ChangeSettlerPlayerID;
    Logic.ChangeSettlerPlayerID = function(...)
        local OldID = {arg[1]};
        local OldPlayerID = Logic.EntityGetPlayer(arg[1]);
        local OldSoldierTable = {Logic.GetSoldiersAttachedToLeader(arg[1])};
        if OldSoldierTable[1] and OldSoldierTable[1] > 0 then
            for i=2, OldSoldierTable[1]+1 do
                table.insert(OldID, OldSoldierTable[i]);
            end
        end
        local NewID = {self.Logic_ChangeSettlerPlayerID(unpack(arg))};
        local NewSoldierTable = {Logic.GetSoldiersAttachedToLeader(NewID[1])};
        if NewSoldierTable[1] and NewSoldierTable[1] > 0 then
            for i=2, NewSoldierTable[1]+1 do
                table.insert(NewID, NewSoldierTable[i]);
            end
        end
        local NewPlayerID = Logic.EntityGetPlayer(NewID[1]);
        Lib.EntityEvent.Global:TriggerEntityOnwershipChangedEvent(OldID, OldPlayerID, NewID, NewPlayerID);
        return NewID[1];
    end
end

function Lib.EntityEvent.Global:StartTriggers()
    self.JobID.EveryTurn = RequestJobByEventType(
        Events.LOGIC_EVENT_EVERY_TURN,
        function()
            if Logic.GetCurrentTurn() > 0 then
                Lib.EntityEvent.Global:CleanTaggedAndDeadEntities();
                Lib.EntityEvent.Global:CheckOnSpawnerEntities();
            end
        end
    );

    self.JobID.EverySecond = RequestJobByEventType(
        Events.LOGIC_EVENT_EVERY_SECOND,
        function()
            local MineEntityTypes = {
                Entities.R_IronMine,
                Entities.R_StoneMine
            };
            for i= 1, #MineEntityTypes do
                local Mines = Logic.GetEntitiesOfType(MineEntityTypes[i]);
                for j= 1, #Mines do
                    local Old = self.MineAmounts[Mines[j]];
                    local New = Logic.GetResourceDoodadGoodAmount(Mines[j]);
                    if Old and New and Old ~= New then
                        local Type = Logic.GetResourceDoodadGoodType(Mines[j]);
                        SendReport(Report.EntityResourceChanged, Mines[j], Type, Old, New);
                        SendReportToLocal(Report.EntityResourceChanged, Mines[j], Type, Old, New);
                    end
                    self.MineAmounts[Mines[j]] = New;
                end
            end
        end
    );

    self.JobID.EntityDestroyed = RequestJobByEventType(
        Events.LOGIC_EVENT_ENTITY_DESTROYED,
        function()
            local EntityID1 = Event.GetEntityID();
            local PlayerID1 = Logic.EntityGetPlayer(EntityID1);
            Lib.EntityEvent.Global:TriggerEntityDestroyedEvent(EntityID1, PlayerID1);
            if Lib.EntityEvent.Global.AttackedEntities[EntityID1] ~= nil then
                local EntityID2 = Lib.EntityEvent.Global.AttackedEntities[EntityID1][1];
                local PlayerID2 = Logic.EntityGetPlayer(EntityID2);
                Lib.EntityEvent.Global.AttackedEntities[EntityID1] = nil;
                Lib.EntityEvent.Global:TriggerEntityKilledEvent(EntityID1, PlayerID1, EntityID2, PlayerID2);
            end
        end
    );

    self.JobID.EveryHurn = RequestJobByEventType(
        Events.LOGIC_EVENT_ENTITY_HURT_ENTITY,
        function()
            local EntityID1 = Event.GetEntityID1();
            local PlayerID1 = Logic.EntityGetPlayer(EntityID1);
            local EntityID2 = Event.GetEntityID2();
            local PlayerID2 = Logic.EntityGetPlayer(EntityID2);
            SendReport(Report.EntityHurt, EntityID1, PlayerID1, EntityID2, PlayerID2);
            SendReportToLocal(Report.EntityHurt, EntityID1, PlayerID1, EntityID2, PlayerID2);
        end
    );
end

function Lib.EntityEvent.Global:CheckOnSpawnerEntities()
    -- Get spawners
    local SpawnerEntities = {};
    for i= 1, #self.DynamicSpawnerTypes do
        if Entities[self.DynamicSpawnerTypes[i]] then
            if Logic.GetCurrentTurn() % 10 == i then
                for k, v in pairs(Logic.GetEntitiesOfType(Entities[self.DynamicSpawnerTypes[i]])) do
                    table.insert(SpawnerEntities, v);
                end
            end
        end
    end
    for i= 1, #self.StaticSpawnerTypes do
        if Entities[self.StaticSpawnerTypes[i]] then
            if Logic.GetCurrentTurn() % 10 == i then
                for k, v in pairs(Logic.GetEntitiesOfType(Entities[self.StaticSpawnerTypes[i]])) do
                    table.insert(SpawnerEntities, v);
                end
            end
        end
    end
    -- Check spawned entities
    for i= 1, #SpawnerEntities do
        for k, v in pairs{Logic.GetSpawnedEntities(SpawnerEntities[i])} do
            -- On Spawner entity spawned
            if not self.RegisteredEntities[v] then
                self:TriggerEntitySpawnedEvent(v, SpawnerEntities[i]);
                self.RegisteredEntities[v] = SpawnerEntities[i];
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

function Lib.EntityEvent.Global:TriggerEntityOnwershipChangedEvent(_OldID, _OldOwnerID, _NewID, _NewOwnerID)
    _OldID = (type(_OldID) ~= "table" and {_OldID}) or _OldID;
    _NewID = (type(_NewID) ~= "table" and {_NewID}) or _NewID;
    assert(#_OldID == #_NewID, "Sums of entities with changed owner does not add up!");
    for i=1, #_OldID do
        SendReport(Report.EntityOwnerChanged, _OldID[i], _OldOwnerID, _NewID[i], _NewOwnerID);
        SendReportToLocal(Report.EntityOwnerChanged, _OldID[i], _OldOwnerID, _NewID[i], _NewOwnerID);
    end
end

function Lib.EntityEvent.Global:TriggerThiefDeliverEarningsEvent(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID, _GoodAmount)
    SendReport(Report.ThiefDeliverEarnings, _ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID, _GoodAmount);
    SendReportToLocal(Report.ThiefDeliverEarnings, _ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID, _GoodAmount);
end

function Lib.EntityEvent.Global:TriggerThiefStealFromBuildingEvent(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID)
    local HeadquartersID = Logic.GetHeadquarters(_BuildingPlayerID);
    local CathedralID = Logic.GetCathedral(_BuildingPlayerID);
    local StorehouseID = Logic.GetStoreHouse(_BuildingPlayerID);
    local IsVillageStorehouse = Logic.IsEntityInCategory(StorehouseID, EntityCategories.VillageStorehouse) == 1;
    local BuildingType = Logic.GetEntityType(_BuildingID);

    -- Aus Lagerhaus stehlen
    if StorehouseID == _BuildingID and (not IsVillageStorehouse or HeadquartersID == 0) then
        if not self.DisableThiefStorehouseHeist then
            GameCallback_OnThiefStealBuilding_Orig_QSB_EntityCore(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
        end
    end
    -- Kirche sabotieren
    if CathedralID == _BuildingID then
        if not self.DisableThiefCathedralSabotage then
            GameCallback_OnThiefStealBuilding_Orig_QSB_EntityCore(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
        end
    end
    -- Brunnen sabotieren
    if Framework.GetGameExtraNo() > 0 and BuildingType == Entities.B_Cistern then
        if not self.DisableThiefCisternSabotage then
            GameCallback_OnThiefStealBuilding_Orig_QSB_EntityCore(_ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
        end
    end

    -- Send event
    SendReport(Report.ThiefInfiltratedBuilding, _ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
    SendReportToLocal(Report.ThiefInfiltratedBuilding, _ThiefID, _ThiefPlayerID, _BuildingID, _BuildingPlayerID);
end

function Lib.EntityEvent.Global:TriggerEntitySpawnedEvent(_EntityID, _SpawnerID)
    local PlayerID = Logic.EntityGetPlayer(_EntityID);
    SendReport(Report.EntitySpawned, _EntityID, PlayerID, _SpawnerID);
    SendReportToLocal(Report.EntitySpawned, _EntityID, PlayerID, _SpawnerID);
end

function Lib.EntityEvent.Global:TriggerSettlerArrivedEvent(_PlayerID, _EntityID)
    SendReport(Report.SettlerAttracted, _EntityID, _PlayerID);
    SendReportToLocal(Report.SettlerAttracted, _EntityID, _PlayerID);
end

function Lib.EntityEvent.Global:TriggerEntityDestroyedEvent(_EntityID, _PlayerID)
    SendReport(Report.EntityDestroyed, _EntityID, _PlayerID);
    SendReportToLocal(Report.EntityDestroyed, _EntityID, _PlayerID);
end

function Lib.EntityEvent.Global:TriggerEntityKilledEvent(_EntityID1, _PlayerID1, _EntityID2, _PlayerID2)
    SendReport(Report.EntityKilled, _EntityID1, _PlayerID1, _EntityID2, _PlayerID2);
    SendReportToLocal(Report.EntityKilled, _EntityID1, _PlayerID1, _EntityID2, _PlayerID2);
end

function Lib.EntityEvent.Global:TriggerConstructionCompleteEvent(_PlayerID, _EntityID)
    SendReport(Report.BuildingConstructed, _EntityID, _PlayerID);
    SendReportToLocal(Report.BuildingConstructed, _EntityID, _PlayerID);
end

function Lib.EntityEvent.Global:TriggerUpgradeCompleteEvent(_PlayerID, _EntityID, _NewUpgradeLevel)
    SendReport(Report.BuildingUpgraded, _EntityID, _PlayerID, _NewUpgradeLevel);
    SendReportToLocal(Report.BuildingUpgraded, _EntityID, _PlayerID, _NewUpgradeLevel);
end

function Lib.EntityEvent.Global:TriggerUpgradeCollapsedEvent(_PlayerID, _EntityID, _NewUpgradeLevel)
    SendReport(Report.BuildingUpgradeCollapsed, _EntityID, _PlayerID, _NewUpgradeLevel);
    SendReportToLocal(Report.BuildingUpgradeCollapsed, _EntityID, _PlayerID, _NewUpgradeLevel);
end

-- Local -------------------------------------------------------------------- --

function Lib.EntityEvent.Local:Initialize()
    Report.SettlerAttracted = CreateReport("Event_SettlerAttracted");
    Report.EntitySpawned = CreateReport("Event_EntitySpawned");
    Report.EntityDestroyed = CreateReport("Event_EntityDestroyed");
    Report.EntityHurt = CreateReport("Event_EntityHurt");
    Report.EntityKilled = CreateReport("Event_EntityKilled");
    Report.EntityOwnerChanged = CreateReport("Event_EntityOwnerChanged");
    Report.EntityResourceChanged = CreateReport("Event_EntityResourceChanged");

    Report.ThiefInfiltratedBuilding = CreateReport("Event_ThiefInfiltratedBuilding");
    Report.ThiefDeliverEarnings = CreateReport("Event_ThiefDeliverEarnings");
    Report.BuildingConstructed = CreateReport("Event_BuildingConstructed");
    Report.BuildingUpgradeCollapsed = CreateReport("Event_BuildingUpgradeCollapsed");
    Report.BuildingUpgraded = CreateReport("Event_BuildingUpgraded");
end

function Lib.EntityEvent.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.EntityEvent.Name);

Lib.Register("module/entity/EntitySelection_Text");

Lib.EntitySelection = Lib.EntitySelection or {};
Lib.EntitySelection.Text = {
    Tooltips = {
        KnightButton = {
            Title = {
                de = "Ritter selektieren",
                en = "Select Knight",
                fr = "Sélectionner le chevalier",
            },
            Text = {
                de = "- Klick selektiert den Ritter {cr}- Doppelklick springt zum Ritter{cr}- UMSCH halten selektiert alle Ritter",
                en = "- Click selects the knight {cr}- Double click jumps to knight{cr}- Press SHIFT to select all knights",
                fr = "- Clic sélectionne le chevalier {cr}- Double-clic saute au chevalier{cr}- Maintenir SHIFT sélectionne tous les chevaliers",
            },
        },

        BattalionButton = {
            Title = {
                de = "Militär selektieren",
                en = "Select Units",
                fr = "Sélectionner les unitées",
            },
            Text = {
                de = "- Selektiert alle Einheiten {cr}- UMSCH halten selektiert Militär {cr}- ALT halten selektiert Kriegsmaschinen {cr}- STRG halten selektiert Diebe",
                en = "- Selects all units {cr}- Holding SHIFT selects military {cr}- Holding ALT selects siege engines {cr}- Holding CTRL selects thieves",
                fr = "- Sélectionne toutes les unités {cr}- Maintenir SHIFT sélectionne les militaires {cr}- Maintenir ALT sélectionne les machines de guerre {cr}- Maintenir CTRL sélectionne les voleurs",
            },
        },

        ReleaseSoldiers = {
            Title = {
                de = "Militär entlassen",
                en = "Release military unit",
                fr = "licencier l'unitées",
            },
            Text = {
                de = "- Eine Militäreinheit entlassen {cr}- Soldaten werden nacheinander entlassen",
                en = "- Dismiss a military unit {cr}- Soldiers will be dismissed each after another",
                fr = "- Licencier une unité militaire {cr}- Les soldats sont licenciés les uns après les autres",
            },
            Disabled = {
                de = "Kann nicht entlassen werden!",
                en = "Releasing is impossible!",
                fr = "Ne peut pas être licencié!",
            },
        },

        TrebuchetCart = {
            Title = {
                de = "Trebuchetwagen",
                en = "Trebuchet cart",
                fr = "Chariot à trébuchet",
            },
            Text = {
                de = "- Kann einmalig zum Trebuchet ausgebaut werden",
                en = "- Can uniquely be transmuted into a trebuchet",
                fr = "- Peut être transformé une seule fois en trébuchet",
            },
        },

        Trebuchet = {
            Title = {
                de = "Trebuchet",
                en = "Trebuchet",
                fr = "Trébuchet",
            },
            Text = {
                de = "- Kann über weite Strecken Gebäude angreifen {cr}- Kann Gebäude in Brand stecken {cr}- Trebuchet kann manuell zurückgeschickt werden",
                en = "- Can perform long range attacks on buildings {cr}- Can set buildings on fire {cr}- The trebuchet can be manually send back to the city",
                fr = "- Peut attaquer des bâtiments sur de longues distances {cr}- Peut mettre le feu à des bâtiments {cr}- Le trébuchet peut être renvoyé manuellement",
            },
        },
    },
};

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/entity/EntitySelection_API");

function DisableReleaseThieves(_Flag)
    if not GUI then
        ExecuteLocal([[DisableReleaseThieves(%s)]], tostring(_Flag));
        return;
    end
    Lib.EntitySelection.AquireContext();
    this.ThiefRelease = not _Flag;
    Lib.EntitySelection.ReleaseContext();
end
API.DisableReleaseThieves = DisableReleaseThieves;

function DisableReleaseSiegeEngines(_Flag)
    if not GUI then
        ExecuteLocal([[DisableReleaseSiegeEngines(%s)]], tostring(_Flag));
        return;
    end
    Lib.EntitySelection.AquireContext();
    this.SiegeEngineRelease = not _Flag;
    Lib.EntitySelection.ReleaseContext();
end
API.DisableReleaseSiegeEngines = DisableReleaseSiegeEngines;

function DisableReleaseSoldiers(_Flag)
    if not GUI then
        ExecuteLocal([[DisableReleaseSoldiers(%s)]], tostring(_Flag));
        return;
    end
    Lib.EntitySelection.AquireContext();
    this.MilitaryRelease = not _Flag;
    Lib.EntitySelection.ReleaseContext();
end
API.DisableReleaseSoldiers = DisableReleaseSoldiers;

function IsEntitySelected(_Entity, _PlayerID)
    local Existing = false;
    local EntityID = GetID(_Entity);
    if IsExisting(EntityID) then
        Lib.EntitySelection.AquireContext();
        for i= 1, #this.SelectedEntities[_PlayerID], 1 do
            if this.SelectedEntities[_PlayerID][i] == EntityID then
                Existing = true;
                break;
            end
        end
        Lib.EntitySelection.ReleaseContext();
    end
    return Existing;
end
API.IsEntityInSelection = IsEntitySelected;

function GetSelectedEntity(_PlayerID)
    Lib.EntitySelection.AquireContext();
    SelectedEntity = this.SelectedEntities[_PlayerID][1];
    Lib.EntitySelection.ReleaseContext();
    return SelectedEntity or 0;
end
API.GetSelectedEntity = GetSelectedEntity;

function GetSelectedEntities(_PlayerID)
    Lib.EntitySelection.AquireContext();
    local SelectedEntities = this.SelectedEntities[_PlayerID];
    Lib.EntitySelection.ReleaseContext();
    return SelectedEntities;
end
API.GetSelectedEntities = GetSelectedEntities;

Lib.EntitySelection = Lib.EntitySelection or {};
Lib.EntitySelection.Name = "EntitySelection";
Lib.EntitySelection.Global = {
    TrebuchetIDToCart = {},
    SelectedEntities = {},
};
Lib.EntitySelection.Local  = {
    SelectedEntities = {},
    TrebuchetDisassemble = false,
    TrebuchetErect = false,
    ThiefRelease = false,
    SiegeEngineRelease = true,
    MilitaryRelease = true,
};

Lib.Require("comfort/IsHistoryEdition");
Lib.Require("comfort/IsMultiplayer");
Lib.Require("core/Core");
Lib.Require("module/ui/UITools");
Lib.Require("module/entity/EntitySelection_API");
Lib.Require("module/entity/EntitySelection_Text");
Lib.Register("module/entity/EntitySelection");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.EntitySelection.Global:Initialize()
    if not self.IsInstalled then
        --- A entity has been expelled.
        ---
        --- #### Parameters
        --- * `EntityID` - ID of entity
        Report.ExpelSettler = CreateReport("Event_ExpelSettler");

        --- The selection of entities of a player has changed.
        ---
        --- #### Parameters
        --- * `PlayerID` - ID of player
        --- * `...`      - List of entities
        Report.SelectionChanged = CreateReport("Event_SelectionChanged");

        --- A trebuchet is forced to stop.
        ---
        --- #### Parameters
        --- * `EntityID` - ID of entity
        --- * `TaskList` - ID of Tasklist
        Report.ForceTrebuchetTasklist = CreateReport("Event_ForceTrebuchetTasklist");

        --- A trebuchet is build from a siege engine cart.
        --- (Currently not used)
        ---
        --- #### Parameters
        --- * `EntityID` - ID of entity
        Report.ErectTrebuchet = CreateReport("Event_ErectTrebuchet");

        --- A trebuchet is broken down to a siege engine cart.
        --- (Currently not used)
        ---
        --- #### Parameters
        --- * `EntityID` - ID of entity
        Report.DisambleTrebuchet = CreateReport("Event_DisambleTrebuchet");

        for i= 1, 8 do
            self.SelectedEntities[i] = {};
        end

        -- Garbage collection
        Lib.EntitySelection.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.EntitySelection.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.EntitySelection.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.ForceTrebuchetTasklist then
        Logic.SetTaskList(arg[1], arg[2]);
    elseif _ID == Report.ErectTrebuchet then
        Lib.EntitySelection.Global:MilitaryErectTrebuchet(arg[1]);
    elseif _ID == Report.DisambleTrebuchet then
        Lib.EntitySelection.Global:MilitaryDisambleTrebuchet(arg[1]);
    elseif _ID == Report.ExpelSettler then
        DestroyEntity(arg[1]);
    elseif _ID == Report.SelectionChanged then
        local PlayerID = table.remove(arg, 1);
        Lib.EntitySelection.Global.SelectedEntities[PlayerID] = {unpack(arg)};
    end
end

function Lib.EntitySelection.Global:MilitaryDisambleTrebuchet(_EntityID)
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local PlayerID = Logic.EntityGetPlayer(_EntityID);

    -- Extern callback for the mapscript
    if GameCallback_Lib_OnDisambleTrebuchet then
        GameCallback_Lib_OnDisambleTrebuchet(_EntityID, PlayerID, x, y, z);
        return;
    end

    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);
    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);
    Logic.SetEntitySelectableFlag(_EntityID, 0);
    Logic.SetVisible(_EntityID, false);

    local TrebuchetCart = self.TrebuchetIDToCart[_EntityID];
    if TrebuchetCart ~= nil then
        Logic.SetEntityInvulnerabilityFlag(TrebuchetCart, 0);
        Logic.SetEntitySelectableFlag(TrebuchetCart, 1);
        Logic.SetVisible(TrebuchetCart, true);
    else
        TrebuchetCart = Logic.CreateEntity(Entities.U_SiegeEngineCart, x, y, 0, PlayerID);
        self.TrebuchetIDToCart[_EntityID] = TrebuchetCart;
    end

    Logic.DEBUG_SetSettlerPosition(TrebuchetCart, x, y);
    Logic.SetTaskList(TrebuchetCart, TaskLists.TL_NPC_IDLE);
    ExecuteLocal([[GUI.SelectEntity(%d)]], TrebuchetCart);
end

function Lib.EntitySelection.Global:MilitaryErectTrebuchet(_EntityID)
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local PlayerID = Logic.EntityGetPlayer(_EntityID);

    -- Extern callback for the mapscript
    if GameCallback_Lib_OnErectTrebuchet then
        GameCallback_Lib_OnErectTrebuchet(_EntityID, PlayerID, x, y, z);
        return;
    end

    Logic.CreateEffect(EGL_Effects.E_Shockwave01, x, y, 0);
    Logic.SetEntityInvulnerabilityFlag(_EntityID, 1);
    Logic.SetEntitySelectableFlag(_EntityID, 0);
    Logic.SetVisible(_EntityID, false);

    local Trebuchet;
    for k, v in pairs(self.TrebuchetIDToCart) do
        if v == _EntityID then
            Trebuchet = tonumber(k);
        end
    end
    if Trebuchet == nil then
        Trebuchet = Logic.CreateEntity(Entities.U_Trebuchet, x, y, 0, PlayerID);
        self.TrebuchetIDToCart[Trebuchet] = _EntityID;
    end

    Logic.SetEntityInvulnerabilityFlag(Trebuchet, 0);
    Logic.SetEntitySelectableFlag(Trebuchet, 1);
    Logic.SetVisible(Trebuchet, true);
    Logic.DEBUG_SetSettlerPosition(Trebuchet, x, y);
    ExecuteLocal([[GUI.SelectEntity(%d)]], Trebuchet);
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.EntitySelection.Local:Initialize()
    if not self.IsInstalled then
        Report.ExpelSettler = CreateReport("Event_ExpelSettler");
        Report.SelectionChanged = CreateReport("Event_SelectionChanged");
        Report.ForceTrebuchetTasklist = CreateReport("Event_ForceTrebuchetTasklist");
        Report.ErectTrebuchet = CreateReport("Event_ErectTrebuchet");
        Report.DisambleTrebuchet = CreateReport("Event_DisambleTrebuchet");

        -- Deactivated because the synch method for the HE is... meh...
        if not (IsHistoryEdition() and IsMultiplayer()) then
            self:OverrideSelection();
            self:OverwriteMilitaryCommands();
            self:OverwriteMilitaryErect();
            self:OverwriteMilitaryDisamble();
            self:OverwriteMultiselectIcon();
            self:OverwriteMilitaryDismount();
            self:OverwriteThiefDeliver();
            self:OverwriteSelectKnight();
            self:OverwriteSelectAllUnits();
            self:OverwriteNamesAndDescription();
        end

        for i= 1, 8 do
            self.SelectedEntities[i] = {};
        end

        -- Garbage collection
        Lib.EntitySelection.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.EntitySelection.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.EntitySelection.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

function Lib.EntitySelection.Local:OverrideSelection()
    self.Orig_GameCallback_GUI_SelectionChanged = GameCallback_GUI_SelectionChanged;
    GameCallback_GUI_SelectionChanged = function(_Source)
        Lib.EntitySelection.Local.Orig_GameCallback_GUI_SelectionChanged(_Source);
        Lib.EntitySelection.Local:OnSelectionCanged(_Source);
    end
end

function Lib.EntitySelection.Local:OverwriteMilitaryCommands()
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Military.StandGroundClicked = function()
        Sound.FXPlay2DSound( "ui\\menu_click");
        local SelectedEntities = {GUI.GetSelectedEntities()};
        for i=1,#SelectedEntities do
            local LeaderID = SelectedEntities[i];
            local eType = Logic.GetEntityType(LeaderID);
            GUI.SendCommandStationaryDefend(LeaderID);
            if eType == Entities.U_Trebuchet then
                SendReportToGlobal(Report.ForceTrebuchetTasklist, LeaderID, TaskLists.TL_NPC_IDLE);
                SendReport(Report.ForceTrebuchetTasklist, LeaderID, TaskLists.TL_NPC_IDLE);
            end
        end
    end

    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Military.StandGroundUpdate = function()
        local WidgetAttack = "/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack";
        local SelectedEntities = {GUI.GetSelectedEntities()};
        SetIcon(WidgetAttack, {12, 4});
        if #SelectedEntities == 1 then
            local eID = SelectedEntities[1];
            local eType = Logic.GetEntityType(eID);
            if eType == Entities.U_Trebuchet then
                if Logic.GetAmmunitionAmount(eID) > 0 then
                    XGUIEng.ShowWidget(WidgetAttack, 0);
                else
                    XGUIEng.ShowWidget(WidgetAttack, 1);
                end
                SetIcon(WidgetAttack, {1, 10});
            else
                XGUIEng.ShowWidget(WidgetAttack, 1);
            end
        end
    end
end

function Lib.EntitySelection.Local:OverwriteMilitaryErect()
    GUI_Military.ErectClicked_Orig_Selection = GUI_Military.ErectClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Military.ErectClicked = function()
        GUI_Military.ErectClicked_Orig_Selection();
        local SelectedEntities = {GUI.GetSelectedEntities()};
        for i=1, #SelectedEntities, 1 do
            local EntityType = Logic.GetEntityType(SelectedEntities[i]);
            if EntityType == Entities.U_SiegeEngineCart then
                SendReportToGlobal(Report.ErectTrebuchet, SelectedEntities[i]);
                SendReport(Report.ErectTrebuchet, SelectedEntities[i]);
            end
        end
    end

    GUI_Military.ErectUpdate_Orig_Selection = GUI_Military.ErectUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Military.ErectUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local SiegeCartID = GUI.GetSelectedEntity();
        local EntityType = Logic.GetEntityType(SiegeCartID);
        if EntityType == Entities.U_SiegeEngineCart then
            local Disabled = (Lib.EntitySelection.Local.TrebuchetErect and 0) or 1;
            XGUIEng.DisableButton(CurrentWidgetID, Disabled);
            SetIcon(CurrentWidgetID, {12, 6});
        else
            GUI_Military.ErectUpdate_Orig_Selection();
        end
    end

    GUI_Military.ErectMouseOver_Orig_Selection = GUI_Military.ErectMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Military.ErectMouseOver = function()
        local SiegeCartID = GUI.GetSelectedEntity();
        local TooltipTextKey;
        if Logic.GetEntityType(SiegeCartID) == Entities.U_SiegeEngineCart then
            TooltipTextKey = "ErectCatapult";
        else
            GUI_Military.ErectMouseOver_Orig_Selection();
            return;
        end
        GUI_Tooltip.TooltipNormal(TooltipTextKey, "Erect");
    end
end

function Lib.EntitySelection.Local:OverwriteMilitaryDisamble()
    GUI_Military.DisassembleClicked_Orig_Selection = GUI_Military.DisassembleClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Military.DisassembleClicked = function()
        GUI_Military.DisassembleClicked_Orig_Selection();
        local SelectedEntities = {GUI.GetSelectedEntities()};
        for i=1, #SelectedEntities, 1 do
            local EntityType = Logic.GetEntityType(SelectedEntities[i]);
            if EntityType == Entities.U_Trebuchet then
                SendReportToGlobal(Report.DisambleTrebuchet, SelectedEntities[i]);
                SendReport(Report.DisambleTrebuchet, SelectedEntities[i]);
            end
        end
    end

    GUI_Military.DisassembleMouseOver_Orig_Selection = GUI_Military.DisassembleMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Military.DisassembleMouseOver = function()
        local SiegeEngineID = GUI.GetSelectedEntity()
        local TooltipDisabledTextKey
        if Logic.IsSiegeEngineUnderConstruction(SiegeEngineID) == true then
            TooltipDisabledTextKey = "Disassemble"
        else
            TooltipDisabledTextKey = "DisassembleNoSoldiersAttached"
            if not Lib.EntitySelection.Local.TrebuchetDisassemble then
                TooltipDisabledTextKey = "Disassemble";
            end
        end
        GUI_Tooltip.TooltipNormal(nil, TooltipDisabledTextKey)
    end

    GUI_Military.DisassembleUpdate_Orig_Selection = GUI_Military.DisassembleUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Military.DisassembleUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local SiegeEngineID = GUI.GetSelectedEntity();
        local EntityType = Logic.GetEntityType(SiegeEngineID);
        if EntityType == Entities.U_Trebuchet then
            local Disabled = (Lib.EntitySelection.Local.TrebuchetDisassemble and 0) or 1;
            XGUIEng.DisableButton(CurrentWidgetID, Disabled);
            SetIcon(CurrentWidgetID, {12, 9});
        else
            GUI_Military.DisassembleUpdate_Orig_Selection();
        end
    end
end

function Lib.EntitySelection.Local:OnSelectionCanged(_Source)
    local PlayerID = GUI.GetPlayerID();
    local EntityID = GUI.GetSelectedEntity();
    local EntityType = Logic.GetEntityType(EntityID);

    local SelectedEntities = {GUI.GetSelectedEntities()};
    self.SelectedEntities[PlayerID] = SelectedEntities;

    SendReportToGlobal(Report.SelectionChanged, PlayerID, unpack(SelectedEntities));
    SendReport(Report.SelectionChanged, PlayerID, unpack(SelectedEntities));

    if EntityID ~= nil then
        if EntityType == Entities.U_SiegeEngineCart then
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngineCart", 1);
        elseif EntityType == Entities.U_Trebuchet then
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/Selection", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/BGMilitary", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons", 0);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);
            XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military", 1);
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/Military/Attack", 0);
            GUI_Military.StrengthUpdate();
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/DialogButtons/SiegeEngine", 1);
        end
    end
end

function Lib.EntitySelection.Local:OverwriteMultiselectIcon()
    GUI_MultiSelection.IconUpdate_Orig_Selection = GUI_MultiSelection.IconUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_MultiSelection.IconUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);
        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);
        local Index = CurrentMotherName + 0;
        local CurrentMotherPath = XGUIEng.GetWidgetPathByID(CurrentMotherID);
        local HealthWidgetPath = CurrentMotherPath .. "/Health";
        local EntityID = g_MultiSelection.EntityList[Index];
        local EntityType = Logic.GetEntityType(EntityID);
        local HealthState = Logic.GetEntityHealth(EntityID);
        local EntityMaxHealth = Logic.GetEntityMaxHealth(EntityID);
        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then
            GUI_MultiSelection.IconUpdate_Orig_Selection();
            return;
        end
        if Logic.IsEntityAlive(EntityID) == false then
            XGUIEng.ShowWidget(CurrentMotherID, 0);
            GUI_MultiSelection.CreateEX();
            return;
        end
        SetIcon(CurrentWidgetID, g_TexturePositions.Entities[EntityType]);
        HealthState = math.floor(HealthState / EntityMaxHealth * 100);
        if HealthState < 50 then
            local green = math.floor(2*255* (HealthState/100));
            XGUIEng.SetMaterialColor(HealthWidgetPath,0,255,green, 20,255);
        else
            local red = 2*255 - math.floor(2*255* (HealthState/100));
            XGUIEng.SetMaterialColor(HealthWidgetPath,0,red, 255, 20,255);
        end
        XGUIEng.SetProgressBarValues(HealthWidgetPath,HealthState, 100);
    end

    GUI_MultiSelection.IconMouseOver_Orig_Selection = GUI_MultiSelection.IconMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_MultiSelection.IconMouseOver = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local CurrentMotherID = XGUIEng.GetWidgetsMotherID(CurrentWidgetID);
        local CurrentMotherName = XGUIEng.GetWidgetNameByID(CurrentMotherID);
        local Index = tonumber(CurrentMotherName);
        local EntityID = g_MultiSelection.EntityList[Index];
        local EntityType = Logic.GetEntityType(EntityID);
        if EntityType ~= Entities.U_SiegeEngineCart and EntityType ~= Entities.U_Trebuchet then
            GUI_MultiSelection.IconMouseOver_Orig_Selection();
            return;
        end
        if EntityType == Entities.U_SiegeEngineCart then
            SetTooltipNormal(
                Localize(Lib.EntitySelection.Text.Tooltips.TrebuchetCart.Title),
                Localize(Lib.EntitySelection.Text.Tooltips.TrebuchetCart.Text)
            );
        elseif EntityType == Entities.U_Trebuchet then
            SetTooltipNormal(
                Localize(Lib.EntitySelection.Text.Tooltips.Trebuchet.Title),
                Localize(Lib.EntitySelection.Text.Tooltips.Trebuchet.Text)
            );
        end
    end
end

function Lib.EntitySelection.Local:OverwriteMilitaryDismount()
    GUI_Military.DismountClicked_Orig_Selection = GUI_Military.DismountClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Military.DismountClicked = function()
        local Selected = GUI.GetSelectedEntity();
        local Type = Logic.GetEntityType(Selected);
        local Guarded = Logic.GetGuardedEntityID(Selected);
        local Guardian = Logic.GetGuardianEntityID(Selected);
        if Guarded ~= 0 and Logic.EntityGetPlayer(Guarded) ~= GUI.GetPlayerID() then
            GUI_Military.DismountClicked_Orig_Selection();
            return;
        end
        if Logic.IsKnight(Selected) or Logic.IsEntityInCategory(Selected, EntityCategories.AttackableMerchant) == 1 then
            GUI_Military.DismountClicked_Orig_Selection();
            return;
        end
        if Logic.IsLeader(Selected) == 1 and Guarded == 0 then
            if Lib.EntitySelection.Local.MilitaryRelease then
                Sound.FXPlay2DSound( "ui\\menu_click");
                local Soldiers = {Logic.GetSoldiersAttachedToLeader(Selected)};
                SendReportToGlobal(Report.ExpelSettler, Soldiers[#Soldiers]);
                SendReport(Report.ExpelSettler, Soldiers[#Soldiers]);
                return;
            end
        end
        if Type == Entities.U_AmmunitionCart or Type == Entities.U_BatteringRamCart
        or Type == Entities.U_CatapultCart or Type == Entities.U_SiegeTowerCart
        or Type == Entities.U_MilitaryBatteringRam or Entities.U_MilitaryCatapult
        or Type == Entities.U_MilitarySiegeTower then
            if Lib.EntitySelection.Local.SiegeEngineRelease and Guardian == 0 then
                Sound.FXPlay2DSound( "ui\\menu_click");
                SendReportToGlobal(Report.ExpelSettler, Selected);
                SendReport(Report.ExpelSettler, Selected);
            else
                GUI_Military.DismountClicked_Orig_Selection();
            end
        end
    end

    GUI_Military.DismountUpdate_Orig_Selection = GUI_Military.DismountUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Military.DismountUpdate = function()
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local Selected = GUI.GetSelectedEntity();
        local Type = Logic.GetEntityType(Selected);
        local Guarded = Logic.GetGuardedEntityID(Selected);
        local Guardian = Logic.GetGuardianEntityID(Selected);
        SetIcon(CurrentWidgetID, {12, 1});
        if Guarded ~= 0 and Logic.EntityGetPlayer(Guarded) ~= GUI.GetPlayerID() then
            XGUIEng.DisableButton(CurrentWidgetID, 0);
            GUI_Military.DismountUpdate_Orig_Selection();
            return;
        end
        if Logic.IsKnight(Selected) or Logic.IsEntityInCategory(Selected, EntityCategories.AttackableMerchant) == 1 then
            XGUIEng.DisableButton(CurrentWidgetID, 0);
            GUI_Military.DismountUpdate_Orig_Selection();
            return;
        end
        SetIcon(CurrentWidgetID, {14, 12});
        if Type == Entities.U_MilitaryLeader then
            if not Lib.EntitySelection.Local.MilitaryRelease then
                XGUIEng.DisableButton(CurrentWidgetID, 1);
            else
                XGUIEng.DisableButton(CurrentWidgetID, 0);
            end
            return;
        end
        if Type == Entities.U_AmmunitionCart or Type == Entities.U_BatteringRamCart
        or Type == Entities.U_CatapultCart or Type == Entities.U_SiegeTowerCart
        or Type == Entities.U_MilitaryBatteringRam or Entities.U_MilitaryCatapult
        or Type == Entities.U_MilitarySiegeTower then
            if Guardian ~= 0 then
                SetIcon(CurrentWidgetID, {12, 1});
                XGUIEng.DisableButton(CurrentWidgetID, 0);
            else
                if not Lib.EntitySelection.Local.SiegeEngineRelease then
                    XGUIEng.DisableButton(CurrentWidgetID, 1);
                else
                    XGUIEng.DisableButton(CurrentWidgetID, 0);
                end
            end
        end
    end
end

function Lib.EntitySelection.Local:OverwriteThiefDeliver()
    GUI_Thief.ThiefDeliverClicked_Orig_Selection = GUI_Thief.ThiefDeliverClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Thief.ThiefDeliverClicked = function()
        if not Lib.EntitySelection.Local.ThiefRelease then
            GUI_Thief.ThiefDeliverClicked_Orig_Selection();
            return;
        end
        Sound.FXPlay2DSound( "ui\\menu_click");
        local ThiefID = GUI.GetSelectedEntity()
        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then
            return;
        end
        SendReportToGlobal(Report.ExpelSettler, ThiefID);
        SendReport(Report.ExpelSettler, ThiefID);
    end

    GUI_Thief.ThiefDeliverMouseOver_Orig_Selection = GUI_Thief.ThiefDeliverMouseOver;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Thief.ThiefDeliverMouseOver = function()
        if not Lib.EntitySelection.Local.ThiefRelease then
            GUI_Thief.ThiefDeliverMouseOver_Orig_Selection();
            return;
        end
        SetTooltipNormal(
            Localize(Lib.EntitySelection.Text.Tooltips.ReleaseSoldiers.Title),
            Localize(Lib.EntitySelection.Text.Tooltips.ReleaseSoldiers.Text),
            Localize(Lib.EntitySelection.Text.Tooltips.ReleaseSoldiers.Disabled)
        );
    end

    GUI_Thief.ThiefDeliverUpdate_Orig_Selection = GUI_Thief.ThiefDeliverUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Thief.ThiefDeliverUpdate = function()
        if not Lib.EntitySelection.Local.ThiefRelease then
            GUI_Thief.ThiefDeliverUpdate_Orig_Selection();
            return;
        end
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();
        local ThiefID = GUI.GetSelectedEntity();
        if ThiefID == nil or Logic.GetEntityType(ThiefID) ~= Entities.U_Thief then
            XGUIEng.DisableButton(CurrentWidgetID, 1);
        else
            XGUIEng.DisableButton(CurrentWidgetID, 0);
        end
        SetIcon(CurrentWidgetID, {14, 12});
    end
end

function Lib.EntitySelection.Local:OverwriteSelectKnight()
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Knight.JumpToButtonClicked = function()
        local PlayerID = GUI.GetPlayerID();
        local KnightID = Logic.GetKnightID(PlayerID);
        if KnightID > 0 then
            g_MultiSelection.EntityList = {};
            g_MultiSelection.Highlighted = {};
            GUI.ClearSelection();
            if XGUIEng.IsModifierPressed(Keys.ModifierShift) then
                local knights = {}
                Logic.GetKnights(PlayerID, knights);
                for i=1,#knights do
                    GUI.SelectEntity(knights[i]);
                end
            else
                GUI.SelectEntity(Logic.GetKnightID(PlayerID));
                if ((Framework.GetTimeMs() - g_Selection.LastClickTime ) < g_Selection.MaxDoubleClickTime) then
                    local pos = GetPosition(KnightID);
                    Camera.RTS_SetLookAtPosition(pos.X, pos.Y);
                else
                    Sound.FXPlay2DSound("ui\\mini_knight");
                end
                g_Selection.LastClickTime = Framework.GetTimeMs();
            end
            GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);
        else
            GUI.AddNote("Debug: You do not have a knight!");
        end
    end
end

function Lib.EntitySelection.Local:OverwriteSelectAllUnits()
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_MultiSelection.SelectAllPlayerUnitsClicked = function()
        local ModifierAlt = XGUIEng.IsModifierPressed(Keys.ModifierAlt);
        local ModifierControl = XGUIEng.IsModifierPressed(Keys.ModifierControl);
        local ModifierShift = XGUIEng.IsModifierPressed(Keys.ModifierShift);

        -- Select all units
        if not ModifierAlt and not ModifierControl and not ModifierShift then
            Lib.EntitySelection.Local:SortOrderFullSelection();
        end
        -- Select only thieves
        if ModifierAlt and not ModifierControl and not ModifierShift then
            Lib.EntitySelection.Local:SortOrderSiegeEnginesOnly();
        end
        -- Select only military and knight
        if not ModifierAlt and ModifierControl and not ModifierShift then
            Lib.EntitySelection.Local:SortOrderThievesOnly();
        end
        -- Select only siege engines
        if not ModifierAlt and not ModifierControl and ModifierShift then
            Lib.EntitySelection.Local:SortOrderMilitaryUnitsOnly();
        end

        Sound.FXPlay2DSound("ui\\menu_click");
        GUI.ClearSelection();
        local PlayerID = GUI.GetPlayerID()
        for i = 1, #LeaderSortOrder do
            local EntitiesOfThisType = GetPlayerEntities(PlayerID, LeaderSortOrder[i])
            for j = 1, #EntitiesOfThisType do
                GUI.SelectEntity(EntitiesOfThisType[j])
            end
        end

        -- Add knight only to full selection or military selection
        if (not ModifierAlt and not ModifierControl and not ModifierShift)
        or (not ModifierAlt and not ModifierControl and ModifierShift) then
            local Knights = {}
            Logic.GetKnights(PlayerID, Knights)
            for k = 1, #Knights do
                GUI.SelectEntity(Knights[k])
            end
        end

        GUI_MultiSelection.CreateMultiSelection(g_SelectionChangedSource.User);
    end
end

function Lib.EntitySelection.Local:SortOrderFullSelection()
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};

    LeaderSortOrder     = {};
    LeaderSortOrder[1]  = Entities.U_MilitarySword;
    LeaderSortOrder[2]  = Entities.U_MilitaryBow;
    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;
    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;
    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;
    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;
    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;
    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;
    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;
    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;
    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;
    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;
    LeaderSortOrder[13] = Entities.U_MilitaryCatapult;
    LeaderSortOrder[14] = Entities.U_Trebuchet;
    LeaderSortOrder[15] = Entities.U_MilitarySiegeTower;
    LeaderSortOrder[16] = Entities.U_MilitaryBatteringRam;
    LeaderSortOrder[17] = Entities.U_CatapultCart;
    LeaderSortOrder[18] = Entities.U_SiegeTowerCart;
    LeaderSortOrder[19] = Entities.U_BatteringRamCart;
    LeaderSortOrder[20] = Entities.U_AmmunitionCart;
    LeaderSortOrder[21] = Entities.U_Thief;

    if g_GameExtraNo >= 1 then
        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);
        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);
        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);
        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);
    end

    -- Community Patch
    if Entities.U_MilitaryPoleArm then
        table.insert(LeaderSortOrder,  1, Entities.U_MilitaryPoleArm);
    end
    if Entities.U_MilitaryCavalry then
        table.insert(LeaderSortOrder,  1, Entities.U_MilitaryCavalry);
    end
    if Entities.U_MilitaryCannon then
        table.insert(LeaderSortOrder,  17, Entities.U_MilitaryCannon);
    end

end

function Lib.EntitySelection.Local:SortOrderMilitaryUnitsOnly()
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};

    LeaderSortOrder     = {};
    LeaderSortOrder[1]  = Entities.U_MilitarySword;
    LeaderSortOrder[2]  = Entities.U_MilitaryBow;
    LeaderSortOrder[3]  = Entities.U_MilitarySword_RedPrince;
    LeaderSortOrder[4]  = Entities.U_MilitaryBow_RedPrince;
    LeaderSortOrder[5]  = Entities.U_MilitaryBandit_Melee_ME;
    LeaderSortOrder[6]  = Entities.U_MilitaryBandit_Melee_NA;
    LeaderSortOrder[7]  = Entities.U_MilitaryBandit_Melee_NE;
    LeaderSortOrder[8]  = Entities.U_MilitaryBandit_Melee_SE;
    LeaderSortOrder[9]  = Entities.U_MilitaryBandit_Ranged_ME;
    LeaderSortOrder[10] = Entities.U_MilitaryBandit_Ranged_NA;
    LeaderSortOrder[11] = Entities.U_MilitaryBandit_Ranged_NE;
    LeaderSortOrder[12] = Entities.U_MilitaryBandit_Ranged_SE;

    if g_GameExtraNo >= 1 then
        table.insert(LeaderSortOrder,  4, Entities.U_MilitarySword_Khana);
        table.insert(LeaderSortOrder,  6, Entities.U_MilitaryBow_Khana);
        table.insert(LeaderSortOrder,  7, Entities.U_MilitaryBandit_Melee_AS);
        table.insert(LeaderSortOrder, 12, Entities.U_MilitaryBandit_Ranged_AS);
    end

    -- Community Patch
    if Entities.U_MilitaryPoleArm then
        table.insert(LeaderSortOrder,  1, Entities.U_MilitaryPoleArm);
    end
    if Entities.U_MilitaryCavalry then
        table.insert(LeaderSortOrder,  1, Entities.U_MilitaryCavalry);
    end

end

function Lib.EntitySelection.Local:SortOrderSiegeEnginesOnly()
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};

    LeaderSortOrder     = {};
    LeaderSortOrder[1] = Entities.U_MilitaryCatapult;
    LeaderSortOrder[2] = Entities.U_Trebuchet;
    LeaderSortOrder[3] = Entities.U_MilitarySiegeTower;
    LeaderSortOrder[4] = Entities.U_MilitaryBatteringRam;
    LeaderSortOrder[5] = Entities.U_CatapultCart;
    LeaderSortOrder[6] = Entities.U_SiegeTowerCart;
    LeaderSortOrder[7] = Entities.U_BatteringRamCart;
    LeaderSortOrder[8] = Entities.U_AmmunitionCart;

    -- Community Patch
    if Entities.U_MilitaryCannon then
        table.insert(LeaderSortOrder,  1, Entities.U_MilitaryCannon);
    end
end

function Lib.EntitySelection.Local:SortOrderThievesOnly()
    g_MultiSelection = {};
    g_MultiSelection.EntityList = {};
    g_MultiSelection.Highlighted = {};

    LeaderSortOrder     = {};
    LeaderSortOrder[1] = Entities.U_Thief;
end

function Lib.EntitySelection.Local:OverwriteNamesAndDescription()
    GUI_Tooltip.SetNameAndDescription_Orig_Selection = GUI_Tooltip.SetNameAndDescription;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Tooltip.SetNameAndDescription = function(
        _TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName,
        _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean
    )
        local MotherWidget = "/InGame/Root/Normal/AlignBottomRight";
        local CurrentWidgetID = XGUIEng.GetCurrentWidgetID();

        if XGUIEng.GetWidgetID(MotherWidget.. "/MapFrame/KnightButton") == CurrentWidgetID then
            SetTooltipNormal(
                Localize(Lib.EntitySelection.Text.Tooltips.KnightButton.Title),
                Localize(Lib.EntitySelection.Text.Tooltips.KnightButton.Text)
            );
            return;
        end

        if XGUIEng.GetWidgetID(MotherWidget.. "/MapFrame/BattalionButton") == CurrentWidgetID then
            SetTooltipNormal(
                Localize(Lib.EntitySelection.Text.Tooltips.BattalionButton.Title),
                Localize(Lib.EntitySelection.Text.Tooltips.BattalionButton.Text)
            );
            return;
        end

        if XGUIEng.GetWidgetID(MotherWidget.. "/DialogButtons/SiegeEngineCart/Dismount") == CurrentWidgetID
        or XGUIEng.GetWidgetID(MotherWidget.. "/DialogButtons/AmmunitionCart/Dismount") == CurrentWidgetID
        or XGUIEng.GetWidgetID(MotherWidget.. "/DialogButtons/Military/Dismount") == CurrentWidgetID
        then
            local SelectedEntity = GUI.GetSelectedEntity();
            if SelectedEntity ~= 0 then
                if Logic.IsEntityInCategory(SelectedEntity, EntityCategories.Military) == 1 then
                    local GuardianEntity = Logic.GetGuardianEntityID(SelectedEntity);
                    local GuardedEntity = Logic.GetGuardedEntityID(SelectedEntity);
                    if GuardianEntity == 0 and GuardedEntity == 0 then
                        SetTooltipNormal(
                            Localize(Lib.EntitySelection.Text.Tooltips.ReleaseSoldiers.Title),
                            Localize(Lib.EntitySelection.Text.Tooltips.ReleaseSoldiers.Text),
                            Localize(Lib.EntitySelection.Text.Tooltips.ReleaseSoldiers.Disabled)
                        );
                        return;
                    end
                end
            end
        end

        GUI_Tooltip.SetNameAndDescription_Orig_Selection(
            _TooltipNameWidget, _TooltipDescriptionWidget, _OptionalTextKeyName,
            _OptionalDisabledTextKeyName, _OptionalMissionTextFileBoolean
        );
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.EntitySelection.Name);

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/balancing/Damage_API");

function SetEntityTypeDamage(_Type, _Damage, ...)
    assert(not IsLocalScript());
    assert(type(_Damage) == "number");
    local Categories = {...};

    Lib.Damage.AquireContext();
    this.EntityTypeDamage[_Type] = this.EntityTypeDamage[_Type] or {};
    if #Categories ~= 0 then
        for i= 1, #Categories do
            this.EntityTypeDamage[_Type][Categories[i]] = _Damage;
        end
    else
        this.EntityTypeDamage[_Type][0] = _Damage;
    end
    Lib.Damage.ReleaseContext();
end
API.SetEntityTypeDamage = SetEntityTypeDamage;

function SetEntityNameDamage(_Name, _Damage, ...)
    assert(not IsLocalScript());
    assert(type(_Damage) == "number");
    local Categories = {...};

    Lib.Damage.AquireContext();
    this.EntityNameDamage[_Name] = this.EntityNameDamage[_Name] or {};
    if #Categories ~= 0 then
        for i= 1, #Categories do
            this.EntityNameDamage[_Name][Categories[i]] = _Damage;
        end
    else
        this.EntityNameDamage[_Name][0] = _Damage;
    end
    Lib.Damage.ReleaseContext();
end
API.SetEntityNameDamage = SetEntityNameDamage;

function SetEntityTypeArmor(_Type, _Armor)
    assert(not IsLocalScript());
    assert(type(_Armor) == "number");
    Lib.Damage.AquireContext();
    this.EntityTypeArmor[_Type] = _Armor;
    Lib.Damage.ReleaseContext();
end
API.SetEntityTypeArmor = SetEntityTypeArmor;

function SetEntityNameArmor(_Name, _Armor)
    assert(not IsLocalScript());
    assert(type(_Armor) == "number");
    Lib.Damage.AquireContext();
    this.EntityNameArmor[_Name] = _Armor;
    Lib.Damage.ReleaseContext();
end
API.SetEntityNameArmor = SetEntityNameArmor;

function SetTerritoryBonus(_PlayerID, _Bonus)
    assert(not IsLocalScript());
    assert(type(_Bonus) == "number");
    Lib.Damage.AquireContext();
    this.TerritoryBonus[_PlayerID] = _Bonus or 1;
    Lib.Damage.ReleaseContext();
end
API.SetTerritoryBonus = SetTerritoryBonus;

function SetHeightModifier(_PlayerID, _Bonus)
    assert(not IsLocalScript());
    assert(type(_Bonus) == "number");
    Lib.Damage.AquireContext();
    this.HeightModifier[_PlayerID] = _Bonus or 1;
    Lib.Damage.ReleaseContext();
end
API.SetHeightModifier = SetHeightModifier;

function IsInvulnerable(_Entity)
    local Result = false;
    if not IsLocalScript() then
        Lib.Damage.AquireContext();
        Result = this.InvulnerableList[GetID(_Entity)] ~= nil;
        Lib.Damage.ReleaseContext();
    end
    return Result;
end
API.IsInvulnerable = IsInvulnerable;

Lib.Damage = Lib.Damage or {};
Lib.Damage.Name = "Damage";
Lib.Damage.Global = {
    InvulnerableList = {},
    --
    EntityTypeDamage = {},
    EntityNameDamage = {},
    EntityTypeArmor = {},
    EntityNameArmor = {},
    --
    TerritoryBonus = {},
    HeightModifier = {},
};
Lib.Damage.Local  = {};

Lib.Require("core/Core");
Lib.Require("module/entity/EntityEvent");
Lib.Require("module/balancing/Damage_API");
Lib.Register("module/balancing/Damage");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.Damage.Global:Initialize()
    if not self.IsInstalled then
        for PlayerID = 0, 8 do
            self.TerritoryBonus[PlayerID] = 1;
            self.HeightModifier[PlayerID] = 1;
        end
        self:OverwriteVulnerabilityFunctions();

        -- Garbage collection
        Lib.Damage.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.Damage.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Damage.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
        self:InitEntityBaseDamageBsg();
        self:InitEntityBaseDamageExt();
    elseif _ID == Report.EntityDestroyed then
        self.InvulnerableList[arg[1]] = nil;
    elseif _ID == Report.EntityHurt then
        self:OnEntityHurtEntity(arg[1], arg[2], arg[3], arg[4]);
    end
end

function Lib.Damage.Global:IsInvulnerable(_Entity)
    return self.InvulnerableList[GetID(_Entity)] ~= nil;
end

function Lib.Damage.Global:InitEntityBaseDamageBsg()
    SetEntityTypeDamage(Entities.U_MilitaryBow, 20);
    SetEntityTypeDamage(Entities.U_MilitaryBow, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitaryBow_RedPrince, 20);
    SetEntityTypeDamage(Entities.U_MilitaryBow_RedPrince, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitarySword, 30);
    SetEntityTypeDamage(Entities.U_MilitarySword, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitarySword_RedPrince, 30);
    SetEntityTypeDamage(Entities.U_MilitarySword_RedPrince, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    --
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Melee_ME, 30);
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Melee_ME, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Ranged_ME, 20);
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Ranged_ME, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Melee_NA, 30);
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Melee_NA, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Ranged_NA, 20);
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Ranged_NA, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Melee_NE, 30);
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Melee_NE, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Ranged_NE, 20);
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Ranged_NE, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Melee_SE, 30);
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Melee_SE, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Ranged_SE, 20);
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Ranged_SE, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    --
    SetEntityTypeDamage(Entities.U_MilitaryBallista, 50);
    SetEntityTypeDamage(Entities.U_MilitaryBallista, 10,
        EntityCategories.CityWallGate
    );
    SetEntityTypeDamage(Entities.U_MilitaryCatapult, 50);
    SetEntityTypeDamage(Entities.U_MilitaryCatapult, 10,
        EntityCategories.CityWallGate
    );
    SetEntityTypeDamage(Entities.U_MilitaryBatteringRam, 120);
    SetEntityTypeDamage(Entities.U_MilitaryBatteringRam, 20,
        EntityCategories.CityWallSegment
    );
    SetEntityTypeDamage(Entities.U_MilitarySiegeTower, 0);
    SetEntityTypeDamage(Entities.U_MilitaryTrap, 800);
    --
    SetEntityTypeDamage(Entities.A_ME_Bear, 120);
    SetEntityTypeDamage(Entities.A_ME_Bear_black, 120);
    SetEntityTypeDamage(Entities.A_ME_Wolf, 20);
    SetEntityTypeDamage(Entities.A_NA_Lion_Female, 40);
    SetEntityTypeDamage(Entities.A_NA_Lion_Male, 40);
    SetEntityTypeDamage(Entities.A_NE_PolarBear, 120);
end

function Lib.Damage.Global:InitEntityBaseDamageExt()
    if g_GameExtraNo == 0 then
        return;
    end

    SetEntityTypeDamage(Entities.U_MilitaryBow_Khana, 20);
    SetEntityTypeDamage(Entities.U_MilitaryBow_Khana, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitarySword_Khana, 30);
    SetEntityTypeDamage(Entities.U_MilitarySword_Khana, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    --
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Melee_AS, 30);
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Melee_AS, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Ranged_AS, 20);
    SetEntityTypeDamage(Entities.U_MilitaryBandit_Ranged_AS, 5,
        EntityCategories.AttackableBuilding,
        EntityCategories.PalisadeSegment,
        EntityCategories.SpecialBuilding
    );
    --
    SetEntityTypeDamage(Entities.A_AS_BearBlack, 120);
    SetEntityTypeDamage(Entities.A_AS_Tiger, 40);
end

function Lib.Damage.Global:OverwriteVulnerabilityFunctions()
    MakeInvulnerable = function(_Entity)
        if IsExisting(_Entity) then
            local ID = GetID(_Entity);
            Lib.Damage.Global.InvulnerableList[ID] = nil;
            Logic.SetEntityInvulnerabilityFlag(ID, 1);
        end
    end

    MakeVulnerable = function(_Entity)
        if IsExisting(_Entity) then
            local ID = GetID(_Entity);
            Lib.Damage.Global.InvulnerableList[ID] = true;
            Logic.SetEntityInvulnerabilityFlag(ID, 0);
        end
    end
end

function Lib.Damage.Global:OnEntityHurtEntity(_EntityID1, _PlayerID1, _EntityID2, _PlayerID2)
    -- Get involved entities
    local AggressorID = self:GetTrueEntityID(_EntityID1);
    local TargetID = self:GetTrueEntityID(_EntityID2);
    if AggressorID == 0 or TargetID == 0 then
        return;
    end

    -- Set initial invulnerability
    Logic.SetEntityInvulnerabilityFlag(TargetID, 1);

    -- Do not touch the invincible
    if self.InvulnerableList[TargetID] then
        return;
    end

    local Damage = 25;

    -- Player properties
    local TerritoryBonus = Logic.GetTerritoryBonus(AggressorID) * self.TerritoryBonus[_PlayerID1];
    local HeightModifier = Logic.GetHeightDamageModifier(AggressorID) * self.HeightModifier[_PlayerID1];
    local EntityType1 = Logic.GetEntityType(AggressorID);
    local EntityType2 = Logic.GetEntityType(TargetID);
    local EntityName1 = Logic.GetEntityName(AggressorID);
    local EntityName2 = Logic.GetEntityName(TargetID);

    -- Get attacker properties
    local MoralFactor  = Logic.GetPlayerMorale(_PlayerID1);
    Damage = self:GetEntityTypeBaseDamage(EntityType1, EntityType2) or Damage;
    Damage = self:GetEntityNameBaseDamage(EntityName1, EntityType2) or Damage;

    -- Get defender properties
    local Armor = 0;
    if self.EntityTypeArmor[EntityType2] then
        Armor = self.EntityTypeArmor[EntityType2];
    end
    if self.EntityNameArmor[EntityName2] then
        Armor = self.EntityNameArmor[EntityName2];
    end

    -- Calculate damage
    Damage = Damage * (math.max(MoralFactor, 0.5) + TerritoryBonus) * HeightModifier;
    Damage = self:ApllyRangedCloseCombatDamage(AggressorID, Damage);
    Damage = self:ApllyWallCatapultCombatDamage(AggressorID, Damage);
    Damage = math.abs(Damage - Armor);
    if GameCallback_Lib_CalculateBattleDamage ~= nil then
        Damage = GameCallback_Lib_CalculateBattleDamage(AggressorID, _PlayerID1, TargetID, _PlayerID2, Damage);
    end

    -- Apply damage
    local Health = Logic.GetEntityHealth(TargetID);
    Damage = math.min(Health, math.max(1, math.ceil(Damage)));
    Logic.SetEntityInvulnerabilityFlag(TargetID, 0);
    Logic.HurtEntity(TargetID, Damage);

    -- Reset invulnerability
    if Health > Damage then
        Logic.SetEntityInvulnerabilityFlag(TargetID, 1);
    end
end

-- Returns the base damage of the entity type depending on the target type.
function Lib.Damage.Global:GetEntityTypeBaseDamage(_Type1, _Type2)
    if self.EntityTypeDamage[_Type1] then
        for Category, Damage in pairs(self.EntityTypeDamage[_Type1]) do
            if Category > 0 and Logic.IsEntityTypeInCategory(_Type2, Category) == 1 then
                return Damage;
            end
        end
        return self.EntityTypeDamage[_Type1][0] or 25;
    end
end

-- Returns the base damage of the entity type depending on the target type.
function Lib.Damage.Global:GetEntityNameBaseDamage(_Name1, _Type2)
    if self.EntityNameDamage[_Name1] then
        for Category, Damage in pairs(self.EntityNameDamage[_Name1]) do
            if Category > 0 and Logic.IsEntityTypeInCategory(_Type2, Category) == 1 then
                return Damage;
            end
        end
        return self.EntityNameDamage[_Name1][0] or 25;
    end
end

-- Returns a valid entity ID or 0. If entity is a leader the first soldier
-- of the battalion is returned.
function Lib.Damage.Global:GetTrueEntityID(_EntityID)
    -- Find first alive soldier if entity is leader
    if Logic.IsLeader(_EntityID) == 1 then
        local Soldiers = {Logic.GetSoldiersAttachedToLeader(_EntityID)};
        for i= 2, Soldiers[1] +1 do
            if Logic.GetEntityHealth(Soldiers[i]) > 0 then
                return Soldiers[i];
            end
        end
        return 0;
    end
    -- Otherwise check if entity has health
    if Logic.GetEntityHealth(_EntityID) == 0 then
        return 0;
    end
    return _EntityID;
end

-- Emulates the reduced close combat damage of archers.
function Lib.Damage.Global:ApllyRangedCloseCombatDamage(_EntityID, _Damage)
    local Damage = _Damage;
    if Logic.GetCurrentTaskList(_EntityID) == "TL_BATTLE_BOW_CLOSECOMBAT" then
        local Factor = 0.3;
        if GameCallback_Lib_CalculateRangedCloseCombatDamageFactor then
            local PlayerID = Logic.EntityGetPlayer(_EntityID);
            Factor = GameCallback_Lib_CalculateRangedCloseCombatDamageFactor(PlayerID, _EntityID, _Damage);
        end
        Damage = Damage * Factor;
    end
    return Damage;
end

-- Reduces the damage of wall catapult depending on the distance to the
-- next clostest wall catapult. (Only for human players)
function Lib.Damage.Global:ApllyWallCatapultCombatDamage(_EntityID, _Damage)
    local Damage = _Damage;
    local Type = Logic.GetEntityType(_EntityID);
    if Type == Entities.U_MilitaryBallista then
        local Factor = 1;
        local PlayerID = Logic.EntityGetPlayer(_EntityID);
        if GameCallback_Lib_CalculateWallCatapultDamageFactor then
            Factor = GameCallback_Lib_CalculateWallCatapultDamageFactor(PlayerID, _EntityID, _Damage);
        elseif Logic.PlayerGetIsHumanFlag(PlayerID) == true then
            local x,y,z = Logic.EntityGetPos(_EntityID);
            local Ballista = {Logic.GetPlayerEntitiesInArea(PlayerID, Type, x, y, 1500, 16)};
            Factor = (Ballista[1] > 1 and Factor / Ballista[1]) or 1;
        end
        Damage = Damage * Factor;
    end
    return Damage;
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.Damage.Local:Initialize()
    if not self.IsInstalled then

        -- Garbage collection
        Lib.Damage.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.Damage.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.Damage.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.Damage.Name);

Lib.Register("module/quest/Quest_Behavior");

function Goal_WinQuest(...)
    return B_Goal_WinQuest:new(...);
end

B_Goal_WinQuest = {
    Name = "Goal_WinQuest",
    Description = {
        en = "Goal: The player has to win a given quest.",
        de = "Ziel: Der Spieler muss eine angegebene Quest erfolgreich abschliessen.",
        fr = "Objectif: Le joueur doit réussir une quête indiquée.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name",  de = "Questname", fr = "Nom de la quête" },
    },
}

function B_Goal_WinQuest:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_WinQuest:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Quest = _Parameter;
    end
end

function B_Goal_WinQuest:CustomFunction(_Quest)
    local quest = Quests[GetQuestID(self.Quest)];
    if quest then
        if quest.Result == QuestResult.Failure then
            return false;
        end
        if quest.Result == QuestResult.Success then
            return true;
        end
    end
    return nil;
end

function B_Goal_WinQuest:Debug(_Quest)
    if Quests[GetQuestID(self.Quest)] == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Quest '"..self.Quest.."' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_WinQuest);

-- -------------------------------------------------------------------------- --

function Goal_DiscoverPlayers(...)
    return B_Goal_DiscoverPlayers:new(...);
end

B_Goal_DiscoverPlayers = {
    Name = "Goal_DiscoverPlayers",
    Description = {
        en = "Goal: Discover the home territory of some other players.",
        de = "Ziel: Entdecke das Heimatterritorium einiger Spieler.",
        fr = "Objectif: Découvrir le territoire d'origine d'un joueur.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Player amount", de = "Spieleranzahl", fr = "Montant du Joueur" },
        { ParameterType.PlayerID, en = "Player 1", de = "Spieler 1", fr = "Joueur 1" },
        { ParameterType.PlayerID, en = "Player 2", de = "Spieler 2", fr = "Joueur 2" },
        { ParameterType.PlayerID, en = "Player 3", de = "Spieler 3", fr = "Joueur 3" },
        { ParameterType.PlayerID, en = "Player 4", de = "Spieler 4", fr = "Joueur 4" },
        { ParameterType.PlayerID, en = "Player 5", de = "Spieler 5", fr = "Joueur 5" },
    },
}

function B_Goal_DiscoverPlayers:GetGoalTable()
    return {Objective.Discover, 2, { unpack(self.PlayerList) } }
end

function B_Goal_DiscoverPlayers:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    end
    if (_Index > 0) then
        self.PlayerList = self.PlayerList or {};
        if _Index <= self.Amount then
            local PlayerID = _Parameter * 1;
            table.insert(self.PlayerList, PlayerID);
        end
    end
end

function B_Goal_DiscoverPlayers:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_Discover",
        [PlayerCategories.City] = "Quest_Discover_City",
        [PlayerCategories.Cloister] = "Quest_Discover_Cloister",
        [PlayerCategories.Harbour] = "Quest_Discover",
        [PlayerCategories.Village] = "Quest_Discover_Village",
    };
    local PlayerCategory = GetPlayerCategoryType(self.PlayerList[1] or 1);
    if PlayerCategory then
        local Key = tMapping[PlayerCategory];
        if Key then
            return Key;
        end
    end
    return "Quest_Discover";
end

RegisterBehavior(B_Goal_DiscoverPlayers);

-- -------------------------------------------------------------------------- --

function Goal_DiscoverTerritories(...)
    return B_Goal_DiscoverTerritories:new(...);
end

B_Goal_DiscoverTerritories = {
    Name = "Goal_DiscoverTerritories",
    Description = {
        en = "Goal: Discover multiple territories",
        de = "Ziel: Entdecke mehrere Territorien",
        fr = "Objectif : Découvrez plusieurs territoires",
    },
    Parameter = {
        { ParameterType.Custom, en = "Territory amount", de = "Territorienanzahl", fr = "Montant du territoire" },
        { ParameterType.TerritoryName, en = "Territory 1", de = "Territorium 1", fr = "Territoire 1" },
        { ParameterType.TerritoryName, en = "Territory 2", de = "Territorium 2", fr = "Territoire 2" },
        { ParameterType.TerritoryName, en = "Territory 3", de = "Territorium 3", fr = "Territoire 3" },
        { ParameterType.TerritoryName, en = "Territory 4", de = "Territorium 4", fr = "Territoire 4" },
        { ParameterType.TerritoryName, en = "Territory 5", de = "Territorium 5", fr = "Territoire 5" },
    },
}

function B_Goal_DiscoverTerritories:GetGoalTable()
    return { Objective.Discover, 1, { unpack(self.TerritoryList) } };
end

function B_Goal_DiscoverTerritories:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    end
    if (_Index > 0) then
        self.TerritoryList = self.TerritoryList or {};
        if _Index <= self.Amount then
            local TerritoryID = tonumber(_Parameter);
            if not TerritoryID then
                TerritoryID = GetTerritoryIDByName(_Parameter);
            end
            assert(TerritoryID > 0);
            table.insert(self.TerritoryList, TerritoryID);
        end
    end
end

function B_Goal_DiscoverTerritories:GetMsgKey()
    return "Quest_Discover_Territory";
end

RegisterBehavior(B_Goal_DiscoverTerritories);

-- -------------------------------------------------------------------------- --

function Trigger_OnAtLeastXOfYQuestsSuccess(...)
    return B_Trigger_OnAtLeastXOfYQuestsSuccess:new(...);
end

B_Trigger_OnAtLeastXOfYQuestsSuccess = {
    Name = "Trigger_OnAtLeastXOfYQuestsSuccess",
    Description = {
        en = "Trigger: if at least X of Y given quests has been finished successfully.",
        de = "Auslöser: wenn X von Y angegebener Quests erfolgreich abgeschlossen wurden.",
        fr = "Déclencheur: lorsque X des Y quêtes indiquées ont été accomplies avec succès.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl", fr = "Nombre minimum" },
        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl",   fr = "Nombre de quêtes" },
        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1", fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2", fr = "Nom de la quête 2" },
        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3", fr = "Nom de la quête 3" },
        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4", fr = "Nom de la quête 4" },
        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5", fr = "Nom de la quête 5" },
    },
}

function B_Trigger_OnAtLeastXOfYQuestsSuccess:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.LeastAmount = tonumber(_Parameter)
    elseif (_Index == 1) then
        self.QuestAmount = tonumber(_Parameter)
    elseif (_Index == 2) then
        self.QuestName1 = _Parameter
    elseif (_Index == 3) then
        self.QuestName2 = _Parameter
    elseif (_Index == 4) then
        self.QuestName3 = _Parameter
    elseif (_Index == 5) then
        self.QuestName4 = _Parameter
    elseif (_Index == 6) then
        self.QuestName5 = _Parameter
    end
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:CustomFunction()
    local least = 0
    for i = 1, self.QuestAmount do
        ---@diagnostic disable-next-line: param-type-mismatch
        local QuestID = GetQuestID(self["QuestName"..i]);
        if IsValidQuest(QuestID) then
            if (Quests[QuestID].Result == QuestResult.Success) then
                least = least + 1
                if least >= self.LeastAmount then
                    return true
                end
            end
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:Debug(_Quest)
    local leastAmount = self.LeastAmount
    local questAmount = self.QuestAmount
    if leastAmount <= 0 or leastAmount >5 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is wrong")
        return true
    elseif questAmount <= 0 or questAmount > 5 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": QuestAmount is wrong")
        return true
    elseif leastAmount > questAmount then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is greater than QuestAmount")
        return true
    end
    for i = 1, questAmount do
        if not IsValidQuest(self["QuestName"..i]) then
            debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")
            return true
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:GetCustomData(_Index)
    if (_Index == 0) or (_Index == 1) then
        return {"1", "2", "3", "4", "5"}
    end
end

RegisterBehavior(B_Trigger_OnAtLeastXOfYQuestsSuccess)

-- -------------------------------------------------------------------------- --

function Trigger_OnAtLeastXOfYQuestsFailed(...)
    return B_Trigger_OnAtLeastXOfYQuestsFailed:new(...);
end

B_Trigger_OnAtLeastXOfYQuestsFailed = {
    Name = "Trigger_OnAtLeastXOfYQuestsFailed",
    Description = {
        en = "Trigger: if at least X of Y given quests has been finished successfully.",
        de = "Auslöser: wenn X von Y angegebener Quests fehlgeschlagen sind.",
        fr = "Déclencheur: lorsque X des Y quêtes indiquées ont échoué.",
    },
    Parameter = {
        { ParameterType.Custom,    en = "Least Amount", de = "Mindest Anzahl",  fr = "Nombre minimum" },
        { ParameterType.Custom,    en = "Quest Amount", de = "Quest Anzahl",    fr = "Nombre de quêtes" },
        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1",     fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2",     fr = "Nom de la quête 2" },
        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3",     fr = "Nom de la quête 3" },
        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4",     fr = "Nom de la quête 4" },
        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5",     fr = "Nom de la quête 5" },
    },
}

function B_Trigger_OnAtLeastXOfYQuestsFailed:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.LeastAmount = tonumber(_Parameter)
    elseif (_Index == 1) then
        self.QuestAmount = tonumber(_Parameter)
    elseif (_Index == 2) then
        self.QuestName1 = _Parameter
    elseif (_Index == 3) then
        self.QuestName2 = _Parameter
    elseif (_Index == 4) then
        self.QuestName3 = _Parameter
    elseif (_Index == 5) then
        self.QuestName4 = _Parameter
    elseif (_Index == 6) then
        self.QuestName5 = _Parameter
    end
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:CustomFunction()
    local least = 0
    for i = 1, self.QuestAmount do
		local QuestID = GetQuestID(self["QuestName"..i]);
        if IsValidQuest(QuestID) then
			if (Quests[QuestID].Result == QuestResult.Failure) then
				least = least + 1
				if least >= self.LeastAmount then
					return true
				end
			end
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:Debug(_Quest)
    local leastAmount = self.LeastAmount
    local questAmount = self.QuestAmount
    if leastAmount <= 0 or leastAmount >5 then
        error(_Quest.Identifier .. ":" .. self.Name .. ": LeastAmount is wrong")
        return true
    elseif questAmount <= 0 or questAmount > 5 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": QuestAmount is wrong")
        return true
    elseif leastAmount > questAmount then
        error(_Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is greater than QuestAmount")
        return true
    end
    for i = 1, questAmount do
        if not IsValidQuest(self["QuestName"..i]) then
            error(_Quest.Identifier.. ": " ..self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")
            return true
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:GetCustomData(_Index)
    if (_Index == 0) or (_Index == 1) then
        return {"1", "2", "3", "4", "5"}
    end
end

RegisterBehavior(B_Trigger_OnAtLeastXOfYQuestsFailed);

-- -------------------------------------------------------------------------- --

function Trigger_OnExactOneQuestIsWon(...)
    return B_Trigger_OnExactOneQuestIsWon:new(...);
end

B_Trigger_OnExactOneQuestIsWon = {
    Name = "Trigger_OnExactOneQuestIsWon",
    Description = {
        en = "Trigger: if one of two given quests has been finished successfully, but NOT both.",
        de = "Auslöser: wenn eine von zwei angegebenen Quests (aber NICHT beide) erfolgreich abgeschlossen wurde.",
        fr = "Déclencheur: lorsque l'une des deux quêtes indiquées (mais PAS les deux) a été accomplie avec succès.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1", },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2", },
    },
}

function B_Trigger_OnExactOneQuestIsWon:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnExactOneQuestIsWon:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnExactOneQuestIsWon:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if Quest2 and Quest1 then
        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success);
        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success);
        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then
            return true;
        end
    end
    return false;
end

function B_Trigger_OnExactOneQuestIsWon:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_OnExactOneQuestIsWon);

-- -------------------------------------------------------------------------- --

function Trigger_OnExactOneQuestIsLost(...)
    return B_Trigger_OnExactOneQuestIsLost:new(...);
end

B_Trigger_OnExactOneQuestIsLost = {
    Name = "Trigger_OnExactOneQuestIsLost",
    Description = {
        en = "Trigger: If one of two given quests has been lost, but NOT both.",
        de = "Auslöser: Wenn einer von zwei angegebenen Quests (aber NICHT beide) fehlschlägt.",
        fr = "Déclencheur: Si l'une des deux quêtes indiquées (mais PAS les deux) échoue.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1", },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2", },
    },
}

function B_Trigger_OnExactOneQuestIsLost:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnExactOneQuestIsLost:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnExactOneQuestIsLost:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if Quest2 and Quest1 then
        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure);
        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure);
        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then
            return true;
        end
    end
    return false;
end

function B_Trigger_OnExactOneQuestIsLost:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_OnExactOneQuestIsLost);

-- -------------------------------------------------------------------------- --

---@diagnostic disable: missing-return-value
---@diagnostic disable: return-type-mismatch

Lib.Register("module/quest/Quest_API");

function SetupQuest(_Data)
    if GUI then
        return;
    end
    error(not _Data.Name or not Quests[GetQuestID(_Data.Name)], "SetupQuest: A quest named '%s' already exists!", tostring(_Data.Name));
    return Lib.Quest.Global:CreateSimpleQuest(_Data);
end
API.CreateQuest = SetupQuest;

function SetupNestedQuest(_Data)
    if GUI or type(_Data) ~= "table" then
        return;
    end
    error(_Data.Segments ~= nil and #_Data.Segments ~= 0, "SetupNestedQuest: Segmented quest '%s' is missing it's segments!", tostring(_Data.Name));
    return Lib.Quest.Global:CreateNestedQuest(_Data);
end
API.CreateNestedQuest = SetupNestedQuest;

function AddDisableTriggerCondition(_Function)
    if GUI then
        return;
    end
    table.insert(Lib.Quest.Global.ExternalTriggerConditions, _Function);
end
API.AddDisableTriggerCondition = AddDisableTriggerCondition;

function AddDisableTimerCondition(_Function)
    if GUI then
        return;
    end
    table.insert(Lib.Quest.Global.ExternalTimerConditions, _Function);
end
API.AddDisableTimerCondition = AddDisableTimerCondition;

function AddDisableDecisionCondition(_Function)
    if GUI then
        return;
    end
    table.insert(Lib.Quest.Global.ExternalDecisionConditions, _Function);
end
API.AddDisableDecisionCondition = AddDisableDecisionCondition;



function Debug_FailQuest(_Name)
    SendReportToGlobal(Report.Internal_DebugFailQuest, _Name);
end

function Debug_WinQuest(_Name)
    SendReportToGlobal(Report.Internal_DebugWinQuest, _Name);
end

function Debug_StartQuest(_Name)
    SendReportToGlobal(Report.Internal_DebugStartQuest, _Name);
end

function Debug_RestartQuest(_Name)
    SendReportToGlobal(Report.Internal_DebugRestartQuest, _Name);
end

function Debug_StopQuest(_Name)
    SendReportToGlobal(Report.Internal_DebugStopQuest, _Name);
end

function Debug_FindQuests(_Name)
    SendReportToGlobal(Report.Internal_DebugListNamedQuests, _Name);
end

function Debug_FailedQuests()
    SendReportToGlobal(Report.Internal_DebugListFailedQuests);
end

function Debug_StoppedQuests()
    SendReportToGlobal(Report.Internal_DebugListStoppedQuests);
end

function Debug_ActiveQuests()
    SendReportToGlobal(Report.Internal_DebugListActiveQuests);
end

function Debug_WonQuests()
    SendReportToGlobal(Report.Internal_DebugListWonQuests);
end

function Debug_WaitingQuests()
    SendReportToGlobal(Report.Internal_DebugListWaitingQuests);
end

---@diagnostic disable: missing-return-value

Lib.Quest = Lib.Quest or {};
Lib.Quest.Name = "Quest";
Lib.Quest.Global = {
    ExternalTriggerConditions = {},
    ExternalTimerConditions = {},
    ExternalDecisionConditions = {},
    SegmentsOfQuest = {},
};
Lib.Quest.Local = {};

SegmentResult = {
    Success = 1,
    Failure = 2,
    Ignore  = 3,
}

Lib.Require("comfort/GetQuestID");
Lib.Require("comfort/IsValidQuest");
Lib.Require("comfort/IsValidQuestName");
Lib.Require("core/core");
Lib.Require("module/quest/Quest_API");
Lib.Require("module/quest/Quest_Behavior");
Lib.Register("module/quest/Quest");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.Quest.Global:Initialize()
    if not self.IsInstalled then
        Report.Internal_DebugFailQuest = CreateReport("Event_Internal_DebugFailQuest");
        Report.Internal_DebugWinQuest = CreateReport("Event_Internal_DebugWinQuest");
        Report.Internal_DebugStartQuest = CreateReport("Event_Internal_DebugStartQuest");
        Report.Internal_DebugRestart = CreateReport("Event_Internal_DebugRestart");
        Report.Internal_DebugStopQuests = CreateReport("Event_Internal_DebugStopQuests");

        Report.Internal_DebugListFailedQuests = CreateReport("Event_Internal_DebugListFailedQuests");
        Report.Internal_DebugListWonQuests = CreateReport("Event_Internal_DebugListWonQuests");
        Report.Internal_DebugListActiveQuests = CreateReport("Event_Internal_DebugListActiveQuests");
        Report.Internal_DebugListStoppedQuests = CreateReport("Event_Internal_DebugListStoppedQuests");
        Report.Internal_DebugListWaitingQuests = CreateReport("Event_Internal_DebugListWaitingQuests");
        Report.Internal_DebugListNamedQuests = CreateReport("Event_Internal_DebugListNamedQuests");

        Quest_Loop = self.QuestLoop;
        self:OverrideKernelQuestApi();

        -- Garbage collection
        Lib.Quest.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.Quest.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Quest.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;

    elseif _ID == Report.Internal_DebugFailQuest then
        local FoundQuests = self:FindQuestsByExactName(arg[1], 1);
        error(#FoundQuests == 1, "Unable to find quest containing '" ..arg[1].. "'");
        FailQuest(FoundQuests[1].Identifier);
        log("forced quest to fail: '" ..FoundQuests[1].Identifier.. "'");
    elseif _ID == Report.Internal_DebugWinQuest then
        local FoundQuests = self:FindQuestsByExactName(arg[1], 1);
        error(#FoundQuests == 1, "Unable to find quest containing '" ..arg[1].. "'");
        RestartQuest(FoundQuests[1].Identifier);
        log("forced quest to restart: '" ..FoundQuests[1].Identifier.. "'");
    elseif _ID == Report.Internal_DebugStartQuest then
        local FoundQuests = self:FindQuestsByExactName(arg[1], 1);
        error(#FoundQuests == 1, "Unable to find quest containing '" ..arg[1].. "'");
        StartQuest(FoundQuests[1].Identifier);
        log("forced quest to start: '" ..FoundQuests[1].Identifier.. "'");
    elseif _ID == Report.Internal_DebugRestart then
        local FoundQuests = self:FindQuestsByExactName(arg[1], 1);
        error(#FoundQuests == 1, "Unable to find quest containing '" ..arg[1].. "'");
        StopQuest(FoundQuests[1].Identifier);
        log("forced quest to stop: '" ..FoundQuests[1].Identifier.. "'");
    elseif _ID == Report.Internal_DebugStopQuests then
        local FoundQuests = self:FindQuestsByExactName(arg[1], 1);
        error(#FoundQuests == 1, "Unable to find quest containing '" ..arg[1].. "'");
        WinQuest(FoundQuests[1].Identifier);
        log("forced quest to succeed: '" ..FoundQuests[1].Identifier.. "'");
    elseif _ID == Report.Internal_DebugListFailedQuests then
        AddStaticNote(self:ListQuestsByResult(QuestResult.Failure, 15));
        log(self:ListQuestsByResult(QuestResult.Failure));
    elseif _ID == Report.Internal_DebugListWonQuests then
        AddStaticNote(self:ListQuestsByResult(QuestResult.Success, 15));
        log(self:ListQuestsByResult(QuestResult.Success));
    elseif _ID == Report.Internal_DebugListActiveQuests then
        AddStaticNote(self:ListQuestsByState(QuestState.Active, 15));
        log(self:ListQuestsByState(QuestState.Active));
    elseif _ID == Report.Internal_DebugListStoppedQuests then
        AddStaticNote(self:ListQuestsByResult(QuestResult.Interrupted, 15));
        log(self:ListQuestsByResult(QuestResult.Interrupted));
    elseif _ID == Report.Internal_DebugListWaitingQuests then
        AddStaticNote(self:ListQuestsByState(QuestState.NotTriggered, 15));
        log(self:ListQuestsByState(QuestState.NotTriggered));
    elseif _ID == Report.Internal_DebugListNamedQuests then
        AddStaticNote(self:ListQuestsByName(arg[1], 15));
        log(self:ListQuestsByName(arg[1]));
    end
end

-- -------------------------------------------------------------------------- --

function Lib.Quest.Global:CreateNestedQuest(_Data)
    if not _Data.Segments then
        return;
    end
    -- Add behavior to check on segments
    table.insert(
        _Data,
        Goal_MapScriptFunction(self:GetCheckQuestSegmentsInlineGoal(), _Data.Name)
    );
    -- Create quest
    local Name = self:CreateSimpleQuest(_Data);
    if Name ~= nil then
        Quests[GetQuestID(Name)].Visible = false;
        self.SegmentsOfQuest[Name] = {};
        -- Create segments
        for i= 1, #_Data.Segments, 1 do
            self:CreateSegmentForSegmentedQuest(_Data.Segments[i], Name, i);
        end
    end
    return Name;
end

function Lib.Quest.Global:CreateSegmentForSegmentedQuest(_Data, _ParentName, _Index)
    local Name = _Data.Name or _ParentName.. "@Segment" .._Index;
    local Parent = Quests[GetQuestID(_ParentName)];

    local QuestDescription = {
        Name        = Name,
        Segments    = _Data.Segments,
        Result      = _Data.Result or SegmentResult.Success,
        Sender      = _Data.Sender or Parent.SendingPlayer,
        Receiver    = _Data.Receiver or Parent.ReceivingPlayer,
        Time        = _Data.Time,
        Suggestion  = _Data.Suggestion,
        Success     = _Data.Success,
        Failure     = _Data.Failure,
        Description = _Data.Description,
        Loop        = _Data.Loop,
        Callback    = _Data.Callback,
    };
    for i= 1, #_Data do
        table.insert(QuestDescription, _Data[i]);
    end

    table.insert(QuestDescription, Trigger_OnQuestActive(_ParentName, 0));
    if QuestDescription.Segments then
        self:CreateNestedQuest(QuestDescription);
    else
        self:CreateSimpleQuest(QuestDescription);
    end
    table.insert(self.SegmentsOfQuest[_ParentName], QuestDescription);
end

function Lib.Quest.Global:GetCheckQuestSegmentsInlineGoal()
    return function (_QuestName)
        local AllSegmentsConcluded = true;
        local SegmentList = Lib.Quest.Global.SegmentsOfQuest[_QuestName];
        for i= 1, #SegmentList, 1 do
            local SegmentQuest = Quests[GetQuestID(SegmentList[i].Name)];
            -- Non existing segment fails quest
            if not SegmentQuest then
                return false;
            end
            -- Not expected result of segment fails quest
            if  SegmentQuest.State == QuestState.Over
            and SegmentQuest.Result ~= QuestResult.Interrupted then
                if  SegmentQuest.Outcome == SegmentResult.Success
                and SegmentQuest.Result ~= QuestResult.Success then
                    Lib.Quest.Global:AbortAllQuestSegments(_QuestName);
                    return false;
                end
                if  SegmentQuest.Outcome == SegmentResult.Failure
                and SegmentQuest.Result ~= QuestResult.Failure then
                    Lib.Quest.Global:AbortAllQuestSegments(_QuestName);
                    return false;
                end
            end
            -- Check if segment is still running
            if  SegmentQuest.Outcome ~= SegmentResult.Ignore
            and SegmentQuest.State ~= QuestState.Over then
                AllSegmentsConcluded = false;
            end
        end
        -- Success after all segments have been completed or are ignored
        if AllSegmentsConcluded then
            return true;
        end
    end;
end

function Lib.Quest.Global:AbortAllQuestSegments(_QuestName)
    for i= 1, #self.SegmentsOfQuest[_QuestName], 1 do
        local SegmentName = self.SegmentsOfQuest[_QuestName][i].Name;
        local SegmentQuest = Quests[GetQuestID(SegmentName)];
        if  SegmentQuest and SegmentQuest.State ~= QuestState.Over then
            StopQuest(SegmentName, true);
        end
    end
end

function Lib.Quest.Global:CreateSimpleQuest(_Data)
    if not _Data.Name then
        AutomaticQuestNameCounter = (AutomaticQuestNameCounter or 0) +1;
        _Data.Name = string.format("AutoNamed_Quest_%d", AutomaticQuestNameCounter);
    end
    error(IsValidQuestName(_Data.Name), "Quest '%s': invalid questname! Contains forbidden characters!", tostring(_Data.Name));

    -- Fill quest data
    local QuestData = {
        _Data.Name,
        (_Data.Sender ~= nil and _Data.Sender) or 1,
        (_Data.Receiver ~= nil and _Data.Receiver) or 1,
        {},
        {},
        (_Data.Time ~= nil and _Data.Time) or 0,
        {},
        {},
        _Data.Callback,
        _Data.Loop,
        _Data.Visible == true or _Data.Suggestion ~= nil,
        _Data.EndMessage == true or (_Data.Failure ~= nil or _Data.Success ~= nil),
        ConvertPlaceholders((type(_Data.Description) == "table" and Localize(_Data.Description)) or _Data.Description),
        ConvertPlaceholders((type(_Data.Suggestion) == "table" and Localize(_Data.Suggestion)) or _Data.Suggestion),
        ConvertPlaceholders((type(_Data.Success) == "table" and Localize(_Data.Success)) or _Data.Success),
        ConvertPlaceholders((type(_Data.Failure) == "table" and Localize(_Data.Failure)) or _Data.Failure)
    };

    -- Validate data
    if not self:QuestValidateQuestData(QuestData) then
        DumpTable(QuestData, "Quest");
        error(false, "ModuleQuest: Failed to vaidate quest data. Table has been copied to log.");
    end

    -- Behaviour
    for k,v in pairs(_Data) do
        if tonumber(k) ~= nil then
            if type(v) == "table" then
                if v.GetGoalTable then
                    table.insert(QuestData[4], v:GetGoalTable());

                    local Idx = #QuestData[4];
                    QuestData[4][Idx].Context            = v;
                    QuestData[4][Idx].FuncOverrideIcon   = QuestData[4][Idx].Context.GetIcon;
                    QuestData[4][Idx].FuncOverrideMsgKey = QuestData[4][Idx].Context.GetMsgKey;
                elseif v.GetReprisalTable then
                    table.insert(QuestData[8], v:GetReprisalTable());
                elseif v.GetRewardTable then
                    table.insert(QuestData[7], v:GetRewardTable());
                else
                    table.insert(QuestData[5], v:GetTriggerTable());
                end
            end
        end
    end

    -- Default goal
    if #QuestData[4] == 0 then
        table.insert(QuestData[4], {Objective.Dummy});
    end
    -- Default trigger
    if #QuestData[5] == 0 then
        table.insert(QuestData[5], {Triggers.Time, 0 });
    end
    -- Enough space behavior
    if QuestData[11] then
        table.insert(QuestData[5], self:GetFreeSpaceInlineTrigger());
    end

    -- Create quest
    local QuestID, Quest = QuestTemplate:New(unpack(QuestData, 1, 16));
    Quest.MsgTableOverride = _Data.MSGKeyOverwrite;
    Quest.IconOverride = _Data.IconOverwrite;
    Quest.QuestInfo = _Data.InfoText;
    Quest.Arguments = (_Data.Arguments ~= nil and table.copy(_Data.Arguments)) or {};
    return _Data.Name, Quests[0];
end

function Lib.Quest.Global:QuestValidateQuestData(_Data)
    return (
        (type(_Data[1]) == "string" and IsValidQuestName(_Data[1]) and Quests[GetQuestID(_Data[1])] == nil) and
        (type(_Data[2]) == "number" and _Data[2] >= 1 and _Data[2] <= 8) and
        (type(_Data[3]) == "number" and _Data[3] >= 1 and _Data[3] <= 8) and
        (type(_Data[6]) == "number" and _Data[6] >= 0) and
        ((_Data[9] ~= nil and type(_Data[9]) == "function") or (_Data[9] == nil)) and
        ((_Data[10] ~= nil and type(_Data[10]) == "function") or (_Data[10] == nil)) and
        (type(_Data[11]) == "boolean") and
        (type(_Data[12]) == "boolean") and
        ((_Data[13] ~= nil and type(_Data[13]) == "string") or (_Data[13] == nil)) and
        ((_Data[14] ~= nil and type(_Data[14]) == "string") or (_Data[14] == nil)) and
        ((_Data[15] ~= nil and type(_Data[15]) == "string") or (_Data[15] == nil)) and
        ((_Data[16] ~= nil and type(_Data[16]) == "string") or (_Data[16] == nil))
    );
end

-- This prevents from triggering a quest when all slots are occupied. But the
-- mapper who uses this automation must also keep in mind that they might soft
-- lock the game if fully relying on this trigger without thinking! This is
-- only here to ensure functionality in case of errors and NOT to support the
-- sloth of mappers!
function Lib.Quest.Global:GetFreeSpaceInlineTrigger()
    return {
        Triggers.Custom2, {
            {},
            function(_Data, _Quest)
                local VisbleQuests = 0;
                if Quests[0] > 0 then
                    for i= 1, Quests[0], 1 do
                        if  Quests[i].State == QuestState.Active
                        and Quests[i].Visible == true then
                            VisbleQuests = VisbleQuests +1;
                        end
                    end
                end
                return VisbleQuests < 6;
            end
        }
    };
end

-- -------------------------------------------------------------------------- --

function Lib.Quest.Global:OverrideKernelQuestApi()
    -- FIX: FailQuest wpn't be overwritten, because failing all segments
    -- automatically might break quests.

    RestartQuest_Orig_ModuleQuest = RestartQuest;
    RestartQuest = function(_QuestName, _NoMessage)
        -- Restart segments of quest first
        if Lib.Quest.Global.SegmentsOfQuest[_QuestName] then
            for k, v in pairs(Lib.Quest.Global.SegmentsOfQuest[_QuestName]) do
                if IsValidQuest(v.Name) then
                    StopQuest_Orig_ModuleQuest(v.Name, true);
                    RestartQuest_Orig_ModuleQuest(v.Name, true);
                end
            end
        end
        -- Proceed with restarting
        RestartQuest_Orig_ModuleQuest(_QuestName, _NoMessage);
    end

    -- FIX: StartQuest won't be overwritten, because all segments are
    -- triggered automatically if no other triggers are present.

    StopQuest_Orig_ModuleQuest = StopQuest;
    StopQuest = function(_QuestName, _NoMessage)
        -- Stop segments of quest first
        if Lib.Quest.Global.SegmentsOfQuest[_QuestName] then
            for k, v in pairs(Lib.Quest.Global.SegmentsOfQuest[_QuestName]) do
                local Quest = Quests[GetQuestID(v.Name)];
                if Quest and Quest.State ~= QuestState.Over then
                    StopQuest_Orig_ModuleQuest(v.Name, true);
                end
            end
        end
        -- Proceed with stopping
        StopQuest_Orig_ModuleQuest(_QuestName, _NoMessage);
    end

    -- FIX: WinQuest wpn't be overwritten, because winning all segments
    -- automatically might break quests.
end

-- -------------------------------------------------------------------------- --

function Lib.Quest.Global.QuestLoop(_arguments)
    local self = JobQueue_GetParameter(_arguments);
    if self.LoopCallback ~= nil then
        self:LoopCallback();
    end
    if self.State == QuestState.NotTriggered then
        local triggered = true;
        -- Are triggers active?
        for i= 1, #Lib.Quest.Global.ExternalTriggerConditions, 1 do
            if not Lib.Quest.Global.ExternalTriggerConditions[i](self.ReceivingPlayer, self) then
                triggered = false;
                break;
            end
        end
        -- Normal condition
        if triggered then
            for i = 1, self.Triggers[0] do
                -- Write Trigger to Log
                local Text = Lib.Quest.Global:SerializeBehavior(self.Triggers[i], Triggers.Custom2, 4);
                if Text and Lib.Core.Debug.TraceQuests then
                    log("Quest '" ..self.Identifier.. "' " ..Text, true);
                end
                -- Check Trigger
                triggered = triggered and self:IsTriggerActive(self.Triggers[i]);
            end
        end
        if triggered then
            self:SetMsgKeyOverride();
            self:SetIconOverride();
            self:Trigger();
        end
    elseif self.State == QuestState.Active then
        -- Do timers tick?
        for i= 1, #Lib.Quest.Global.ExternalTimerConditions, 1 do
            if not Lib.Quest.Global.ExternalTimerConditions[i](self.ReceivingPlayer, self) then
                self.StartTime = self.StartTime +1;
                break;
            end
        end
        -- Are goals checked?
        local CheckBehavior = true;
        for i= 1, #Lib.Quest.Global.ExternalDecisionConditions, 1 do
            if not Lib.Quest.Global.ExternalDecisionConditions[i](self.ReceivingPlayer, self) then
                CheckBehavior = false;
                break;
            end
        end
        if CheckBehavior then
            local allTrue = true;
            local anyFalse = false;
            for i = 1, self.Objectives[0] do
                -- Write Trigger to Log
                local Text = Lib.Quest.Global:SerializeBehavior(self.Objectives[i], Objective.Custom2, 1);
                if Text and Lib.Core.Debug.TraceQuests then
                    log("Quest '" ..self.Identifier.. "' " ..Text, true);
                end
                -- Check Goal
                local completed = self:IsObjectiveCompleted(self.Objectives[i]);
                if self.Objectives[i].Type == Objective.Deliver and completed == nil then
                    if self.Objectives[i].Data[4] == nil then
                        self.Objectives[i].Data[4] = 0;
                    end
                    if self.Objectives[i].Data[3] ~= nil then
                        self.Objectives[i].Data[4] = self.Objectives[i].Data[4] + 1;
                    end
                    local st = self.StartTime;
                    local sd = self.Duration;
                    local dt = self.Objectives[i].Data[4];
                    local sum = self.StartTime + self.Duration - self.Objectives[i].Data[4];
                    if self.Duration > 0 and self.StartTime + self.Duration + self.Objectives[i].Data[4] < Logic.GetTime() then
                        completed = false;
                    end
                else
                    if self.Duration > 0 and self.StartTime + self.Duration < Logic.GetTime() then
                        if completed == nil and
                            (self.Objectives[i].Type == Objective.Protect or self.Objectives[i].Type == Objective.Dummy or self.Objectives[i].Type == Objective.NoChange) then
                            completed = true;
                        elseif completed == nil or self.Objectives[i].Type == Objective.DummyFail then
                            completed = false;
                    end
                    end
                end
                allTrue = (completed == true) and allTrue;
                anyFalse = completed == false or anyFalse;
            end
            if allTrue then
                self:Success();
            elseif anyFalse then
                self:Fail();
            end
        end
    else
        if self.IsEventQuest == true then
            Logic.ExecuteInLuaLocalState("StopEventMusic(nil, "..self.ReceivingPlayer..")");
        end
        if self.Result == QuestResult.Success then
            for i = 1, self.Rewards[0] do
                -- Write Trigger to Log
                local Text = Lib.Quest.Global:SerializeBehavior(self.Rewards[i], Reward.Custom, 3);
                if Text and Lib.Core.Debug.TraceQuests then
                    log("Quest '" ..self.Identifier.. "' " ..Text, true);
                end
                -- Add Reward
                self:AddReward(self.Rewards[i]);
            end
        elseif self.Result == QuestResult.Failure then
            for i = 1, self.Reprisals[0] do
                -- Write Trigger to Log
                local Text = Lib.Quest.Global:SerializeBehavior(self.Reprisals[i], Reprisal.Custom, 3);
                if Text and Lib.Core.Debug.TraceQuests then
                    log("Quest '" ..self.Identifier.. "' " ..Text, true);
                end
                -- Add Reward
                self:AddReprisal(self.Reprisals[i]);
            end
        end
        if self.EndCallback ~= nil then
            self:EndCallback();
        end
        return true;
    end
end

function Lib.Quest.Global:SerializeBehavior(_Data, _CustomType, _Typ)
    local BehaviorType = "Objective";
    local BehaTable = Objective;
    if _Typ == 2 then
        BehaviorType = "Reprisal";
        BehaTable = Reprisal;
    elseif _Typ == 3 then
        BehaviorType = "Reward";
        BehaTable = Reward;
    elseif _Typ == 4 then
        BehaviorType = "Trigger";
        BehaTable = Triggers;
    end

    local Info = "Running {";
    local Beha = GetNameOfKeyInTable(BehaTable, _Data.Type);

    if _Data.Type == _CustomType then
        local FunctionName = _Data.Data[1].FuncName;
        Info = Info.. BehaviorType.. "." ..Beha.. "";
        if FunctionName == nil then
            return;
        else
            Info = Info.. ", " ..tostring(FunctionName);
        end
        if _Data.Data and _Data.Data[1].i47ya_6aghw_frxil and #_Data.Data[1].i47ya_6aghw_frxil > 0 then
            for j= 1, #_Data.Data[1].i47ya_6aghw_frxil, 1 do
                Info = Info.. ", (" ..type(_Data.Data[1].i47ya_6aghw_frxil[j]).. ") " ..tostring(_Data.Data[1].i47ya_6aghw_frxil[j]);
            end
        end
    else
        Info = Info.. BehaviorType.. "." ..Beha.. "";
        if _Data.Data then
            if type(_Data.Data) == "table" then
                for j= 1, #_Data.Data do
                    Info = Info.. ", (" ..type(_Data.Data[j]).. ") " ..tostring(_Data.Data[j]);
                end
            else
                Info = Info.. ", (" ..type(_Data.Data).. ") " ..tostring(_Data.Data);
            end
        end
    end
    Info = Info.. "}";
    return Info;
end

-- -------------------------------------------------------------------------- --
-- Chat Commands

function Lib.Quest.Global:FindQuestsByAttribute(_MaxResults, ...)
    _MaxResults = math.max(_MaxResults or 65565, 1);
    local arg = {...};
    local MatchingQuests = {};
    for i= 1, Quests[0], 1 do
        local IsMatching = true;
        for j= 1, #arg, 2 do
            if arg[j] == "Name" then
                if not string.find(Quests[i].Identifier, "^" .. arg[j+1]) then
                    IsMatching = false;
                    break;
                end
            else
                if Quests[i][arg[j]] ~= arg[j+1] then
                    IsMatching = false;
                    break;
                end
            end
        end
        if IsMatching then
            table.insert(MatchingQuests, Quests[i]);
        end
    end
    return MatchingQuests;
end

function Lib.Quest.Global:FindQuestsByExactName(_QuestName, _MaxResults)
    return self:FindQuestsByAttribute(_MaxResults, "Identifier", _QuestName);
end

function Lib.Quest.Global:ListQuestsByAttribute(_MaxResults, ...)
    _MaxResults = math.max(_MaxResults or 65565, 1);
    local MatchingQuests = self:FindQuestsByAttribute(_MaxResults, ...);
    local QuestNames = "";
    local ResultCount = 0;
    for i= 1, #MatchingQuests, 1 do
        if ResultCount >= _MaxResults then
            QuestNames = QuestNames .. "... (" .. (#MatchingQuests - ResultCount) .. " more)";
            break;
        end
        QuestNames = QuestNames .. "> " .. MatchingQuests[i].Identifier .. "{cr}";
        ResultCount = ResultCount +1;
    end
    return "Found quests:{cr}"..QuestNames;
end

function Lib.Quest.Global:ListQuestsByState(_QuestState, _MaxResults)
    return self:ListQuestsByAttribute(_MaxResults, "State", _QuestState);
end

function Lib.Quest.Global:ListQuestsByResult(_QuestResult, _MaxResults)
    return self:ListQuestsByAttribute(_MaxResults, "Result", _QuestResult);
end

function Lib.Quest.Global:ListQuestsByName(_QuestName, _MaxResults)
    -- HACK: Name will be converted to Identifier but it's a like search.
    return self:ListQuestsByAttribute(_MaxResults, "Name", _QuestName);
end

function Lib.Quest.Global:ProcessChatInput(_Text, _PlayerID, _IsDebug)
    if _IsDebug and IsHistoryEdition() then
        local Commands = Lib.Core.Debug:CommandTokenizer(_Text);
        for i= 1, #Commands, 1 do
            if Commands[i][1] == "fail"
            or Commands[i][1] == "start"
            or Commands[i][1] == "restart"
            or Commands[i][1] == "stop"
            or Commands[i][1] == "win" then
                local FoundQuests = self:FindQuestsByExactName(Commands[i][2], 1);
                error(#FoundQuests == 1, "Unable to find quest containing '" ..Commands[i][2].. "'");
                if Commands[i][1] == "fail" then
                    FailQuest(FoundQuests[1].Identifier);
                    log("forced quest to fail: '" ..FoundQuests[1].Identifier.. "'");
                elseif Commands[i][1] == "restart" then
                    RestartQuest(FoundQuests[1].Identifier);
                    log("forced quest to restart: '" ..FoundQuests[1].Identifier.. "'");
                elseif Commands[i][1] == "start" then
                    StartQuest(FoundQuests[1].Identifier);
                    log("forced quest to start: '" ..FoundQuests[1].Identifier.. "'");
                elseif Commands[i][1] == "stop" then
                    StopQuest(FoundQuests[1].Identifier);
                    log("forced quest to stop: '" ..FoundQuests[1].Identifier.. "'");
                elseif Commands[i][1] == "win" then
                    WinQuest(FoundQuests[1].Identifier);
                    log("forced quest to succeed: '" ..FoundQuests[1].Identifier.. "'");
                end
            end

            if Commands[i][1] == "stopped" then
                AddNote(self:ListQuestsByResult(QuestResult.Interrupted, 15));
                log(self:ListQuestsByResult(QuestResult.Interrupted));
            elseif Commands[i][1] == "active" then
                AddNote(self:ListQuestsByState(QuestState.Active, 15));
                log(self:ListQuestsByState(QuestState.Active));
            elseif Commands[i][1] == "won" then
                AddNote(self:ListQuestsByResult(QuestResult.Success, 15));
                log(self:ListQuestsByResult(QuestResult.Success));
            elseif Commands[i][1] == "failed" then
                AddNote(self:ListQuestsByResult(QuestResult.Failure, 15));
                log(self:ListQuestsByResult(QuestResult.Failure));
            elseif Commands[i][1] == "waiting" then
                AddNote(self:ListQuestsByState(QuestState.NotTriggered, 15));
                log(self:ListQuestsByState(QuestState.NotTriggered));
            elseif Commands[i][1] == "find" then
                AddNote(self:ListQuestsByName(Commands[i][2], 15));
                log(self:ListQuestsByName(Commands[i][2]));
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.Quest.Local:Initialize()
    if not self.IsInstalled then
        Report.Internal_DebugFailQuest = CreateReport("Event_Internal_DebugFailQuest");
        Report.Internal_DebugWinQuest = CreateReport("Event_Internal_DebugWinQuest");
        Report.Internal_DebugStartQuest = CreateReport("Event_Internal_DebugStartQuest");
        Report.Internal_DebugRestart = CreateReport("Event_Internal_DebugRestart");
        Report.Internal_DebugStopQuests = CreateReport("Event_Internal_DebugStopQuests");

        Report.Internal_DebugListFailedQuests = CreateReport("Event_Internal_DebugListFailedQuests");
        Report.Internal_DebugListWonQuests = CreateReport("Event_Internal_DebugListWonQuests");
        Report.Internal_DebugListActiveQuests = CreateReport("Event_Internal_DebugListActiveQuests");
        Report.Internal_DebugListStoppedQuests = CreateReport("Event_Internal_DebugListStoppedQuests");
        Report.Internal_DebugListWaitingQuests = CreateReport("Event_Internal_DebugListWaitingQuests");
        Report.Internal_DebugListNamedQuests = CreateReport("Event_Internal_DebugListNamedQuests");

        self:OverwriteQuestTexts();

        -- Garbage collection
        Lib.Quest.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.Quest.Local:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Quest.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.ChatClosed then
        self:ProcessChatInput(arg[1], arg[2], arg[3]);
    end
end

function Lib.Quest.Local:ProcessChatInput(_Text, _PlayerID, _IsDebug)
    if not _IsDebug or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    ExecuteGlobal(
        [[Lib.Quest.Global:ProcessChatInput("%s", %d, %s)]],
        _Text, _PlayerID, tostring(_IsDebug == true)
    );
end

function Lib.Quest.Local:OverwriteQuestTexts()
    self.Orig_QuestLog_GetQuestTypeCaption = QuestLog.GetQuestTypeCaption;
    --- Returns the caption of the quest in the quest log.
    ---
    --- This overwrite allows to define custom string tables instead of the
    --- scheme dictated by the game.
    ---
    --- @param _QuestType integer Type of quest
    --- @param _Quest table Quest
    --- @return string Text String table text 
    ---
    --- @diagnostic disable-next-line: duplicate-set-field
    QuestLog.GetQuestTypeCaption = function(_QuestType, _Quest)
        if _QuestType == Objective.Custom
        or _QuestType == Objective.Custom2
        or _QuestType == Objective.NoChange
        or _QuestType == Objective.Dummy
        or _QuestType == Objective.DummyFail then
            local Text = _Quest.QuestDescription or "";
            if string.find(Text, "^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                return XGUIEng.GetStringTableText(Text);
            end
        end
        return Lib.Quest.Local.Orig_QuestLog_GetQuestTypeCaption(_QuestType, _Quest);
    end

    --- Returns the string table text of the quest.
    ---
    --- This overwrite allows to define custom string tables instead of the
    --- scheme dictated by the game.
    ---
    --- @param _QuestIndex integer Index of quest
    --- @param _MessageKey string String table key of message
    --- @return string Text String table text
    Wrapped_GetStringTableText = function(_QuestIndex, _MessageKey)
        local MessageText = XGUIEng.GetStringTableText(_MessageKey);
        if MessageText ~= "" then
            return MessageText;
        end
        if _QuestIndex == 0 then
            return "";
        end
        local Quest = Quests[_QuestIndex];
        if not Quest then
            return "";
        end
        if string.find(_MessageKey, "speech") then
            local MessageKeyPos = string.find(_MessageKey, "/");
            if not MessageKeyPos then
                return "";
            end
            local MessageKey = string.sub(_MessageKey, MessageKeyPos + 1)
            if  Quest.Identifier == MessageKey
            and Quest.QuestStartMsg
            and not string.find(Quest.QuestStartMsg, g_OverrideTextKeyPattern) then
                return Quest.QuestStartMsg;
            end
            if  Quest.Identifier .. "_Success" == MessageKey
            and Quest.QuestSuccessMsg
            and not string.find(Quest.QuestSuccessMsg, g_OverrideTextKeyPattern) then
                return Quest.QuestSuccessMsg;
            end
            if Quest.Identifier .. "_Failure" == MessageKey
            and Quest.QuestFailureMsg
            and not string.find(Quest.QuestFailureMsg, g_OverrideTextKeyPattern) then
                return Quest.QuestFailureMsg;
            end
        else
            if Quest.QuestDescription then
                local Text = Quest.QuestDescription or "";
                if string.find(Text, "^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                    Text = XGUIEng.GetStringTableText(Text);
                end
                return string.match(Text, "^[^~]+ ~ (.+)$") or Text;
            end
        end
        return "";
    end

    --- Returns the quest text dependend on the state of the quest.
    ---
    --- This overwrite allows to define custom string tables instead of the
    --- scheme dictated by the game.
    --- 
    --- * Quest triggered: Quest.QuestStartMsg
    --- * Quest failed: Quest.QuestFailureMsg
    --- * Quest succeed: Quest.QuestSuccessMsg
    ---
    --- @param _Quest table Quest
    --- @return string Name Name of string
    --- @return string? File Name of file
    GetTextOverride = function(_Quest)
        local Result;
        if not _Quest then
            return;
        end
        assert(type( _Quest ) == "table");
        if _Quest.State == QuestState.Over then
            if _Quest.Result == QuestResult.Success then
                local Text = _Quest.QuestSuccessMsg or "";
                if string.find(Text, "^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                    Text = "KEY(" .._Quest.QuestSuccessMsg.. ")";
                end
                Result = string.match(Text, g_OverrideTextKeyPattern);
            elseif _Quest.Result == QuestResult.Failure then
                local Text = _Quest.QuestFailureMsg or "";
                if string.find(Text, "^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                    Text = "KEY(" .._Quest.QuestFailureMsg.. ")";
                end
                Result = string.match(Text, g_OverrideTextKeyPattern);
            end
        else
            local Text = _Quest.QuestStartMsg or "";
            if string.find(Text, "^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
                Text = "KEY(" .._Quest.QuestStartMsg.. ")";
            end
            Result = string.match(Text, g_OverrideTextKeyPattern);
        end
        if Result then
            local OverrideTable, OverrideKey = string.match(Result, "^([^/]+)/([^/]+)$");
            if OverrideTable and OverrideKey then
                return OverrideKey, OverrideTable;
            end
        end
        return Result;
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.Quest.Name);

Lib.Register("module/quest/QuestBehavior_Behavior");

function Goal_MoveToPosition(...)
    return B_Goal_MoveToPosition:new(...);
end

B_Goal_MoveToPosition = {
    Name = "Goal_MoveToPosition",
    Description = {
        en = "Goal: A entity have to moved as close as the distance to another entity. The target can be marked with a static marker.",
        de = "Ziel: Ein Entity muss sich einer anderen bis auf eine bestimmte Distanz nähern. Die Lupe wird angezeigt, das Ziel kann markiert werden.",
        fr = "Objectif: une entité doit s'approcher d'une autre à une distance donnée. La loupe est affichée, la cible peut être marquée.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",   de = "Entity",         fr = "Entité" },
        { ParameterType.ScriptName, en = "Target",   de = "Ziel",           fr = "Cible" },
        { ParameterType.Number,     en = "Distance", de = "Entfernung",     fr = "Distance" },
        { ParameterType.Custom,     en = "Marker",   de = "Ziel markieren", fr = "Marquer la cible" },
    },
}

function B_Goal_MoveToPosition:GetGoalTable()
    return {Objective.Distance, self.Entity, self.Target, self.Distance, self.Marker}
end

function B_Goal_MoveToPosition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity = _Parameter
    elseif (_Index == 1) then
        self.Target = _Parameter
    elseif (_Index == 2) then
        self.Distance = _Parameter * 1
    elseif (_Index == 3) then
        self.Marker = ToBoolean(_Parameter)
    end
end

function B_Goal_MoveToPosition:GetCustomData( _Index )
    local Data = {};
    if _Index == 3 then
        Data = {"true", "false"}
    end
    return Data
end

RegisterBehavior(B_Goal_MoveToPosition);

-- -------------------------------------------------------------------------- --

function Goal_AmmunitionAmount(...)
    return B_Goal_AmmunitionAmount:new(...);
end

B_Goal_AmmunitionAmount = {
    Name = "Goal_AmmunitionAmount",
    Description = {
        en = "Goal: Reach a smaller or bigger value than the given amount of ammunition in a war machine.",
        de = "Ziel: Über- oder unterschreite die angegebene Anzahl Munition in einem Kriegsgerät.",
        fr = "Objectif : Dépasser ou ne pas dépasser le nombre de munitions indiqué dans un engin de guerre.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname",  fr = "Nom de l'entité" },
        { ParameterType.Custom,     en = "Relation",    de = "Relation",    fr = "Relation" },
        { ParameterType.Number,     en = "Amount",      de = "Menge",       fr = "Quantité" },
    },
}

function B_Goal_AmmunitionAmount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_AmmunitionAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    elseif (_Index == 1) then
        self.bRelSmallerThan = tostring(_Parameter) == "true" or _Parameter == "<"
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1
    end
end

function B_Goal_AmmunitionAmount:CustomFunction()
    local EntityID = GetID(self.Scriptname);
    if not IsExisting(EntityID) then
        return false;
    end
    local HaveAmount = Logic.GetAmmunitionAmount(EntityID);
    if ( self.bRelSmallerThan and HaveAmount < self.Amount ) or ( not self.bRelSmallerThan and HaveAmount >= self.Amount ) then
        return true;
    end
    return nil;
end

function B_Goal_AmmunitionAmount:Debug(_Quest)
    if self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount is negative");
        return true
    end
end

function B_Goal_AmmunitionAmount:GetCustomData( _Index )
    if _Index == 1 then
        return {"<", ">="};
    end
end

RegisterBehavior(B_Goal_AmmunitionAmount);

-- -------------------------------------------------------------------------- --

function Goal_CityReputation(...)
    return B_Goal_CityReputation:new(...);
end

B_Goal_CityReputation = {
    Name = "Goal_CityReputation",
    Description = {
        en = "Goal: The reputation of the quest receivers city must at least reach the desired hight.",
        de = "Ziel: Der Ruf der Stadt des Empfängers muss mindestens so hoch sein, wie angegeben.",
        fr = "Objectif: la réputation de la ville du receveur doit être au moins aussi élevée que celle indiquée.",
    },
    Parameter = {
        { ParameterType.Number, en = "City reputation", de = "Ruf der Stadt", fr = "Réputation de la ville" },
    },
    Text = {
        de = "RUF DER STADT{cr}{cr}Hebe den Ruf der Stadt durch weise Herrschaft an!{cr}Benötigter Ruf: %d",
        en = "CITY REPUTATION{cr}{cr}Raise your reputation by fair rulership!{cr}Needed reputation: %d",
        fr = "RÉPUTATION DE LA VILLE{cr}{cr} Augmente la réputation de la ville en la gouvernant sagement!{cr}Réputation requise : %d",
    }
}

function B_Goal_CityReputation:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_CityReputation:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Reputation = _Parameter * 1;
    end
end

function B_Goal_CityReputation:CustomFunction(_Quest)
    self:SetCaption(_Quest);
    local CityReputation = Logic.GetCityReputation(_Quest.ReceivingPlayer) * 100;
    if CityReputation >= self.Reputation then
        return true;
    end
end

function B_Goal_CityReputation:SetCaption(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local Text = string.format(Localize(self.Text), self.Reputation);
        Lib.Core.Quest:ChangeCustomQuestCaptionText(Text .."%", _Quest);
    end
end

function B_Goal_CityReputation:GetIcon()
    return {5, 14};
end

function B_Goal_CityReputation:Debug(_Quest)
    if type(self.Reputation) ~= "number" or self.Reputation < 0 or self.Reputation > 100 then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Reputation must be between 0 and 100!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_CityReputation);

-- -------------------------------------------------------------------------- --

function Goal_DestroySpawnedEntities(...)
    return B_Goal_DestroySpawnedEntities:new(...);
end

B_Goal_DestroySpawnedEntities = {
    Name = "Goal_DestroySpawnedEntities",
    Description = {
        en = "Goal: Destroy all entities spawned at the spawnpoint.",
        de = "Ziel: Zerstöre alle Entitäten, die bei dem Spawnpoint erzeugt wurde.",
        fr = "Objectif: Détruire toutes les entités créées au point d'apparition.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Spawnpoint",       de = "Spawnpoint",         fr = "Point d'émergence" },
        { ParameterType.Number,     en = "Amount",           de = "Menge",              fr = "Quantité" },
        { ParameterType.Custom,     en = "Name is prefixed", de = "Name ist Präfix",    fr = "Le nom est un préfixe" },
    },
};

function B_Goal_DestroySpawnedEntities:GetGoalTable()
    if self.Prefixed then
        local Parameter = table.remove(self.SpawnPoint);
        local i = 1;
        while (IsExisting(Parameter .. i)) do
            table.insert(self.SpawnPoint, Parameter .. i);
            i = i +1;
        end
        assert(#self.SpawnPoint > 0, "No spawnpoints found!");
    end
    return {Objective.DestroyEntities, 3, self.SpawnPoint, self.Amount};
end

function B_Goal_DestroySpawnedEntities:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SpawnPoint = {_Parameter};
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or "false";
        self.Prefixed = ToBoolean(_Parameter);
    end
end

function B_Goal_DestroySpawnedEntities:GetMsgKey()
    local ID = GetID(self.SpawnPoint[1]);
    if ID ~= 0 then
        local TypeName = Logic.GetEntityTypeName(Logic.GetEntityType(ID));
        if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
            return "Quest_Destroy_Leader";
        elseif TypeName:find("Bear") or TypeName:find("Lion") or TypeName:find("Tiger") or TypeName:find("Wolf") then
            return "Quest_DestroyEntities_Predators";
        elseif TypeName:find("Military") or TypeName:find("Cart") then
            return "Quest_DestroyEntities_Unit";
        end
    end
    return "Quest_DestroyEntities";
end

function B_Goal_DestroySpawnedEntities:GetCustomData(_Index)
    if _Index == 2 then
        return {"false", "true"};
    end
end

RegisterBehavior(B_Goal_DestroySpawnedEntities);

-- -------------------------------------------------------------------------- --

function Goal_StealGold(...)
    return B_Goal_StealGold:new(...)
end

B_Goal_StealGold = {
    Name = "Goal_StealGold",
    Description = {
        en = "Goal: Steal an explicit amount of gold from a players or any players city buildings.",
        de = "Ziel: Diebe sollen eine bestimmte Menge Gold aus feindlichen Stadtgebäuden stehlen.",
        fr = "Objectif: les voleurs doivent dérober une certaine quantité d'or dans les bâtiments urbains ennemis.",
    },
    Parameter = {
        { ParameterType.Number,   en = "Amount on Gold", de = "Zu stehlende Menge",             fr = "Quantité à voler" },
        { ParameterType.Custom,   en = "Target player",  de = "Spieler von dem gestohlen wird", fr = "Joueur à qui l'on vole" },
        { ParameterType.Custom,   en = "Cheat earnings", de = "Einnahmen generieren",           fr = "Générer des revenus" },
        { ParameterType.Custom,   en = "Print progress", de = "Fortschritt ausgeben",           fr = "Afficher les progrès" },
    },
}

function B_Goal_StealGold:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_StealGold:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 1) then
        local PlayerID = tonumber(_Parameter) or -1;
        self.Target = PlayerID * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or "false"
        self.CheatEarnings = ToBoolean(_Parameter);
    elseif (_Index == 3) then
        _Parameter = _Parameter or "true"
        self.Printout = ToBoolean(_Parameter);
    end
    self.StohlenGold = 0;
end

function B_Goal_StealGold:GetCustomData(_Index)
    if _Index == 1 then
        return { "-", 1, 2, 3, 4, 5, 6, 7, 8 };
    elseif _Index == 2 then
        return { "true", "false" };
    end
end

function B_Goal_StealGold:SetDescriptionOverwrite(_Quest)
    local TargetPlayerName = Localize({
        de = " anderen Spielern ",
        en = " different parties ",
        fr = " d'autres joueurs ",
    });

    if self.Target ~= -1 then
        TargetPlayerName = GetPlayerName(self.Target);
        if TargetPlayerName == nil or TargetPlayerName == "" then
            TargetPlayerName = " PLAYER_NAME_MISSING ";
        end
    end

    -- Cheat earnings
    if self.CheatEarnings then
        local PlayerIDs = {self.Target};
        if self.Target == -1 then
            PlayerIDs = {1, 2, 3, 4, 5, 6, 7, 8};
        end
        for i= 1, #PlayerIDs, 1 do
            if i ~= _Quest.ReceivingPlayer and Logic.GetStoreHouse(i) ~= 0 then
                local CityBuildings = {Logic.GetPlayerEntitiesInCategory(i, EntityCategories.CityBuilding)};
                for j= 1, #CityBuildings, 1 do
                    local CurrentEarnings = Logic.GetBuildingProductEarnings(CityBuildings[j]);
                    if CurrentEarnings < 45 and Logic.GetTime() % 5 == 0 then
                        Logic.SetBuildingEarnings(CityBuildings[j], CurrentEarnings +1);
                    end
                end
            end
        end
    end

    local amount = self.Amount - self.StohlenGold;
    amount = (amount > 0 and amount) or 0;
    local text = {
        de = "Gold von %s stehlen {cr}{cr}Aus Stadtgebäuden zu stehlende Goldmenge: %d",
        en = "Steal gold from %s {cr}{cr}Amount on gold to steal from city buildings: %d",
        fr = "Voler l'or de %s {cr}{cr}Quantité d'or à voler dans les bâtiments de la ville : %d",
    };
    return "{center}" ..string.format(Localize(text), TargetPlayerName, amount);
end

function B_Goal_StealGold:CustomFunction(_Quest)
    if Lib.Core.Quest then
        Lib.Core.Quest:ChangeCustomQuestCaptionText(self:SetDescriptionOverwrite(_Quest), _Quest);
    end
    if self.StohlenGold >= self.Amount then
        return true;
    end
    return nil;
end

function B_Goal_StealGold:GetIcon()
    return {5,13};
end

function B_Goal_StealGold:Debug(_Quest)
    if tonumber(self.Amount) == nil and self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

function B_Goal_StealGold:Reset(_Quest)
    self.StohlenGold = 0;
end

RegisterBehavior(B_Goal_StealGold)

-- -------------------------------------------------------------------------- --

function Goal_StealFromBuilding(...)
    return B_Goal_StealFromBuilding:new(...)
end

B_Goal_StealFromBuilding = {
    Name = "Goal_StealFromBuilding",
    Description = {
        en = "Goal: The player has to steal from a building. Not a castle and not a village storehouse!",
        de = "Ziel: Der Spieler muss ein bestimmtes Gebäude bestehlen. Dies darf keine Burg und kein Dorflagerhaus sein!",
        fr = "Objectif: Le joueur doit voler un bâtiment spécifique. Il ne peut s'agir ni d'un château ni d'un entrepôt de village !",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Building",        de = "Gebäude",              fr = "Bâtiment" },
        { ParameterType.Custom,     en = "Cheat earnings",  de = "Einnahmen generieren", fr = "Générer des revenus" },
    },
}

function B_Goal_StealFromBuilding:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_StealFromBuilding:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Building = _Parameter
    elseif (_Index == 1) then
        _Parameter = _Parameter or "false"
        self.CheatEarnings = ToBoolean(_Parameter);
    end
    self.RobberList = {};
end

function B_Goal_StealFromBuilding:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" };
    end
end

function B_Goal_StealFromBuilding:SetDescriptionOverwrite(_Quest)
    local isCathedral = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Cathedrals) == 1;
    local isWarehouse = Logic.GetEntityType(GetID(self.Building)) == Entities.B_StoreHouse;
    local isCistern = Logic.GetEntityType(GetID(self.Building)) == Entities.B_Cistern;
    local text;

    if isCathedral then
        text = {
            de = "Sabotage {cr}{cr} Sendet einen Dieb und sabotiert die markierte Kirche.",
            en = "Sabotage {cr}{cr} Send a thief to sabotage the marked chapel.",
            fr = "Sabotage {cr}{cr} Envoyez un voleur pour saboter la chapelle marquée.",
        };
    elseif isWarehouse then
        text = {
            de = "Lagerhaus bestehlen {cr}{cr} Sendet einen Dieb in das markierte Lagerhaus.",
            en = "Steal from storehouse {cr}{cr} Steal from the marked storehouse.",
            fr = "Voler un entrepôt {cr}{cr} Envoie un voleur dans l'entrepôt marqué.",
        };
    elseif isCistern then
        text = {
            de = "Sabotage {cr}{cr} Sendet einen Dieb und sabotiert den markierten Brunnen.",
            en = "Sabotage {cr}{cr} Send a thief and break the marked well of the enemy.",
            fr = "Sabotage {cr}{cr} Envoie un voleur et sabote le puits marqué.",
        };
    else
        text = {
            de = "Gebäude bestehlen {cr}{cr} Sendet einen Dieb und bestehlt das markierte Gebäude.",
            en = "Steal from building {cr}{cr} Send a thief to steal from the marked building.",
            fr = "Voler un bâtiment {cr}{cr} Envoie un voleur et vole le bâtiment marqué.",
        };
    end
    return "{center}" .. Localize(text);
end

function B_Goal_StealFromBuilding:CustomFunction(_Quest)
    if not IsExisting(self.Building) then
        if self.Marker then
            Logic.DestroyEffect(self.Marker);
        end
        return false;
    end

    if not self.Marker then
        local pos = GetPosition(self.Building);
        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);
    end

    -- Cheat earnings
    if self.CheatEarnings then
        local BuildingID = GetID(self.Building);
        local CurrentEarnings = Logic.GetBuildingProductEarnings(BuildingID);
        if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1
        and CurrentEarnings < 45 and Logic.GetTime() % 5 == 0 then
            Logic.SetBuildingEarnings(BuildingID, CurrentEarnings +1);
        end
    end

    if self.SuccessfullyStohlen then
        Logic.DestroyEffect(self.Marker);
        return true;
    end
    return nil;
end

function B_Goal_StealFromBuilding:GetIcon()
    return {5,13};
end

function B_Goal_StealFromBuilding:Debug(_Quest)
    local eTypeName = Logic.GetEntityTypeName(Logic.GetEntityType(GetID(self.Building)));
    local IsHeadquarter = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Headquarters) == 1;
    if Logic.IsBuilding(GetID(self.Building)) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is not a building");
        return true;
    elseif not IsExisting(self.Building) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is destroyed :(");
        return true;
    elseif string.find(eTypeName, "B_NPC_BanditsHQ") or string.find(eTypeName, "B_NPC_Cloister") or string.find(eTypeName, "B_NPC_StoreHouse") then
        error(_Quest.Identifier.. ": " ..self.Name .. ": village storehouses are not allowed!");
        return true;
    elseif IsHeadquarter then
        error(_Quest.Identifier.. ": " ..self.Name .. ": use Goal_StealInformation for headquarters!");
        return true;
    end
    return false;
end

function B_Goal_StealFromBuilding:Reset(_Quest)
    self.SuccessfullyStohlen = false;
    self.RobberList = {};
    self.Marker = nil;
end

function B_Goal_StealFromBuilding:Interrupt(_Quest)
    Logic.DestroyEffect(self.Marker);
end

RegisterBehavior(B_Goal_StealFromBuilding)

-- -------------------------------------------------------------------------- --

function Goal_SpyOnBuilding(...)
    return B_Goal_SpyOnBuilding:new(...)
end

B_Goal_SpyOnBuilding = {
    Name = "Goal_SpyOnBuilding",
    IconOverwrite = {5,13},
    Description = {
        en = "Goal: Infiltrate a building with a thief. A thief must be able to steal from the target building.",
        de = "Ziel: Infiltriere ein Gebäude mit einem Dieb. Nur mit Gebaueden möglich, die bestohlen werden koennen.",
        fr = "Objectif: Infiltrer un bâtiment avec un voleur. Seulement possible avec des bâtiments qui peuvent être volés.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target Building", de = "Zielgebäude",           fr = "Bâtiment cible" },
        { ParameterType.Custom,     en = "Cheat earnings",  de = "Einnahmen generieren",  fr = "Générer des revenus" },
        { ParameterType.Custom,     en = "Destroy Thief",   de = "Dieb löschen",          fr = "Supprimer le voleur" },
    },
}

function B_Goal_SpyOnBuilding:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_SpyOnBuilding:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Building = _Parameter
    elseif (_Index == 1) then
        _Parameter = _Parameter or "false"
        self.CheatEarnings = ToBoolean(_Parameter);
    elseif (_Index == 2) then
        _Parameter = _Parameter or "true"
        self.Delete = ToBoolean(_Parameter)
    end
end

function B_Goal_SpyOnBuilding:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" };
    end
end

function B_Goal_SpyOnBuilding:SetDescriptionOverwrite(_Quest)
    if not _Quest.QuestDescription then
        local text = {
            de = "Gebäude infriltrieren {cr}{cr}Spioniere das markierte Gebäude mit einem Dieb aus!",
            en = "Infiltrate building {cr}{cr}Spy on the highlighted buildings with a thief!",
            fr = "Infiltrer un bâtiment {cr}{cr}Espionner le bâtiment marqué avec un voleur!",
        };
        return Localize(text);
    else
        return _Quest.QuestDescription;
    end
end

function B_Goal_SpyOnBuilding:CustomFunction(_Quest)
    if not IsExisting(self.Building) then
        if self.Marker then
            Logic.DestroyEffect(self.Marker);
        end
        return false;
    end

    if not self.Marker then
        local pos = GetPosition(self.Building);
        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);
    end

    -- Cheat earnings
    if self.CheatEarnings then
        local BuildingID = GetID(self.Building);
        if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1
        and Logic.GetBuildingEarnings(BuildingID) < 5 then
            Logic.SetBuildingEarnings(BuildingID, 5);
        end
    end

    if self.Infiltrated then
        Logic.DestroyEffect(self.Marker);
        return true;
    end
    return nil;
end

function B_Goal_SpyOnBuilding:GetIcon()
    return self.IconOverwrite;
end

function B_Goal_SpyOnBuilding:Debug(_Quest)
    if Logic.IsBuilding(GetID(self.Building)) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is not a building");
        return true;
    elseif not IsExisting(self.Building) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is destroyed :(");
        return true;
    end
    return false;
end

function B_Goal_SpyOnBuilding:Reset(_Quest)
    self.Infiltrated = false;
    self.Marker = nil;
end

function B_Goal_SpyOnBuilding:Interrupt(_Quest)
    Logic.DestroyEffect(self.Marker);
end

RegisterBehavior(B_Goal_SpyOnBuilding);

-- -------------------------------------------------------------------------- --

function Goal_DestroySoldiers(...)
    return B_Goal_DestroySoldiers:new(...);
end

B_Goal_DestroySoldiers = {
    Name = "Goal_DestroySoldiers",
    Description = {
        en = "Goal: Destroy a given amount of enemy soldiers",
        de = "Ziel: Zerstöre eine Anzahl gegnerischer Soldaten",
        fr = "Objectif: Détruire un certain nombre de soldats ennemis",
    },
    Parameter = {
        {ParameterType.PlayerID, en = "Attacking Player",   de = "Angreifer",   fr = "Attaquant", },
        {ParameterType.PlayerID, en = "Defending Player",   de = "Verteidiger", fr = "Défenseur", },
        {ParameterType.Number,   en = "Amount",             de = "Anzahl",      fr = "Quantité", },
    },

    Text = {
        de = "{center}SOLDATEN ZERSTÖREN {cr}{cr}von der Partei: %s{cr}{cr}Anzahl: %d",
        en = "{center}DESTROY SOLDIERS {cr}{cr}from faction: %s{cr}{cr}Amount: %d",
        fr = "{center}DESTRUIRE DES SOLDATS {cr}{cr}de la faction: %s{cr}{cr}Nombre : %d",
    }
}

function B_Goal_DestroySoldiers:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_DestroySoldiers:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AttackingPlayer = _Parameter * 1
    elseif (_Index == 1) then
        self.AttackedPlayer = _Parameter * 1
    elseif (_Index == 2) then
        self.KillsNeeded = _Parameter * 1
    end
end

function B_Goal_DestroySoldiers:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local PlayerName = GetPlayerName(self.AttackedPlayer) or
                           ("Player " ..self.AttackedPlayer);
        Lib.Core.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Lib.Core.Text:Localize(self.Text),
                PlayerName, self.KillsNeeded
            ),
            _Quest
        );
    end

    local KillsCurrent = GetEnemySoldierKillsOfPlayer(
        self.AttackingPlayer,
        self.AttackedPlayer
    );
    if not self.KillstStart then
        self.KillstStart = KillsCurrent;
    end
    if self.KillsNeeded <= KillsCurrent - self.KillstStart then
        return true;
    end
end

function B_Goal_DestroySoldiers:Debug(_Quest)
    if Logic.GetStoreHouse(self.AttackingPlayer) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AttackinPlayer .. " is dead :-(")
        return true
    elseif Logic.GetStoreHouse(self.AttackedPlayer) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AttackedPlayer .. " is dead :-(")
        return true
    elseif self.KillsNeeded < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount negative")
        return true
    end
end

function B_Goal_DestroySoldiers:Reset()
    self.KillstStart = nil;
end

function B_Goal_DestroySoldiers:GetIcon()
    return {7,12}
end

RegisterBehavior(B_Goal_DestroySoldiers);

-- -------------------------------------------------------------------------- --

function Reprisal_SetPosition(...)
    return B_Reprisal_SetPosition:new(...);
end

B_Reprisal_SetPosition = {
    Name = "Reprisal_SetPosition",
    Description = {
        en = "Reprisal: Places an entity relative to the position of another. The entity can look the target.",
        de = "Vergeltung: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.",
        fr = "Rétribution: place une Entity vis-à-vis de l'emplacement d'une autre. L'entité peut être orientée vers la cible.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",          de = "Entity",          fr = "Entité", },
        { ParameterType.ScriptName, en = "Target position", de = "Zielposition",    fr = "Position cible", },
        { ParameterType.Custom,     en = "Face to face",    de = "Ziel ansehen",    fr = "Voir la cible", },
        { ParameterType.Number,     en = "Distance",        de = "Zielentfernung",  fr = "Distance de la cible", },
    },
}

function B_Reprisal_SetPosition:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetPosition:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Target = _Parameter;
    elseif (_Index == 2) then
        self.FaceToFace = ToBoolean(_Parameter)
    elseif (_Index == 3) then
        self.Distance = (_Parameter ~= nil and tonumber(_Parameter)) or 100;
    end
end

function B_Reprisal_SetPosition:CustomFunction(_Quest)
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        return;
    end

    local entity = GetID(self.Entity);
    local target = GetID(self.Target);
    local x,y,z = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x,y = Logic.GetBuildingApproachPosition(target);
    end
    local ori = Logic.GetEntityOrientation(target)+90;

    if self.FaceToFace then
        x = x + self.Distance * math.cos( math.rad(ori) );
        y = y + self.Distance * math.sin( math.rad(ori) );
        Logic.DEBUG_SetSettlerPosition(entity, x, y);
        LookAt(self.Entity, self.Target);
    else
        if Logic.IsBuilding(target) == 1 then
            x,y = Logic.GetBuildingApproachPosition(target);
        end
        Logic.DEBUG_SetSettlerPosition(entity, x, y);
    end
end

function B_Reprisal_SetPosition:GetCustomData(_Index)
    if _Index == 2 then
        return { "true", "false" }
    end
end

function B_Reprisal_SetPosition:Debug(_Quest)
    if self.FaceToFace then
        if tonumber(self.Distance) == nil or self.Distance < 50 then
            error(_Quest.Identifier.. ": " ..self.Name.. ": Distance is nil or to short!");
            return true;
        end
    end
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Mover entity or target entity does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_SetPosition);

-- -------------------------------------------------------------------------- --

function Reprisal_ChangePlayer(...)
    return B_Reprisal_ChangePlayer:new(...)
end

B_Reprisal_ChangePlayer = {
    Name = "Reprisal_ChangePlayer",
    Description = {
        en = "Reprisal: Changes the owner of the entity or a battalion.",
        de = "Vergeltung: Aendert den Besitzer einer Entity oder eines Battalions.",
        fr = "Rétribution : Change le propriétaire d'une entité ou d'un bataillon.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",     de = "Entity",   fr = "Entité", },
        { ParameterType.Custom,     en = "Player",     de = "Spieler",  fr = "Joueur", },
    },
}

function B_Reprisal_ChangePlayer:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_ChangePlayer:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Player = tostring(_Parameter);
    end
end

function B_Reprisal_ChangePlayer:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    if Logic.IsLeader(eID) == 1 then
        Logic.ChangeSettlerPlayerID(eID, self.Player);
    else
        Logic.ChangeEntityPlayerID(eID, self.Player);
    end
end

function B_Reprisal_ChangePlayer:GetCustomData(_Index)
    if _Index == 1 then
        return {"0", "1", "2", "3", "4", "5", "6", "7", "8"}
    end
end

function B_Reprisal_ChangePlayer:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_ChangePlayer);

-- -------------------------------------------------------------------------- --

function Reprisal_SetVisible(...)
    return B_Reprisal_SetVisible:new(...)
end

B_Reprisal_SetVisible = {
    Name = "Reprisal_SetVisible",
    Description = {
        en = "Reprisal: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.",
        de = "Vergeltung: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.",
        fr = "Rétribution: fixe la visibilité d'une Entité. S'il s'agit d'un spawn, les Entities spawnées sont également affectées.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",      de = "Entity",   fr = "Entité", },
        { ParameterType.Custom,     en = "Visible",     de = "Sichtbar", fr = "Visible", },
    },
}

function B_Reprisal_SetVisible:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetVisible:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Visible = ToBoolean(_Parameter)
    end
end

function B_Reprisal_SetVisible:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end

    local eID = GetID(self.Entity);
    local pID = Logic.EntityGetPlayer(eID);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);

    if string.find(tName, "^S_") or string.find(tName, "^B_NPC_Bandits")
    or string.find(tName, "^B_NPC_Barracks") then
        local spawned = {Logic.GetSpawnedEntities(eID)};
        for i=1, #spawned do
            if Logic.IsLeader(spawned[i]) == 1 then
                local soldiers = {Logic.GetSoldiersAttachedToLeader(spawned[i])};
                for j=2, #soldiers do
                    Logic.SetVisible(soldiers[j], self.Visible);
                end
            else
                Logic.SetVisible(spawned[i], self.Visible);
            end
        end
    else
        if Logic.IsLeader(eID) == 1 then
            local soldiers = {Logic.GetSoldiersAttachedToLeader(eID)};
            for j=2, #soldiers do
                Logic.SetVisible(soldiers[j], self.Visible);
            end
        else
            Logic.SetVisible(eID, self.Visible);
        end
    end
end

function B_Reprisal_SetVisible:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" }
    end
end

function B_Reprisal_SetVisible:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_SetVisible);

-- -------------------------------------------------------------------------- --

function Reprisal_SetVulnerability(...)
    return B_Reprisal_SetVulnerability:new(...);
end

B_Reprisal_SetVulnerability = {
    Name = "Reprisal_SetVulnerability",
    Description = {
        en = "Reprisal: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.",
        de = "Vergeltung: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen.",
        fr = "Rétribution: rend une Entité vulnérable ou invulnérable. S'il s'agit d'un spawn, les Entities spawnées sont affectées.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",             de = "Entity",     fr = "Entité", },
        { ParameterType.Custom,     en = "Vulnerability",      de = "Verwundbar", fr = "Vulnérabilité", },
    },
}

function B_Reprisal_SetVulnerability:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetVulnerability:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Vulnerability = ToBoolean(_Parameter)
    end
end

function B_Reprisal_SetVulnerability:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);
    local EntitiesToCheck = {eID};
    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        EntitiesToCheck = {Logic.GetSpawnedEntities(eID)};
    end
    local MethodToUse = "MakeInvulnerable";
    if self.Vulnerability then
        MethodToUse = "MakeVulnerable";
    end
    for i= 1, #EntitiesToCheck, 1 do
        if Logic.IsLeader(EntitiesToCheck[i]) == 1 then
            local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntitiesToCheck[i])};
            for j=2, #Soldiers, 1 do
                _G[MethodToUse](Soldiers[j]);
            end
        end
        _G[MethodToUse](EntitiesToCheck[i]);
    end
end

function B_Reprisal_SetVulnerability:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" }
    end
end

function B_Reprisal_SetVulnerability:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_SetVulnerability);

-- -------------------------------------------------------------------------- --

function Reprisal_SetModel(...)
    return B_Reprisal_SetModel:new(...);
end

B_Reprisal_SetModel = {
    Name = "Reprisal_SetModel",
    Description = {
        en = "Reprisal: Changes the model of the entity. Be careful, some models crash the game.",
        de = "Vergeltung: Ändert das Model einer Entity. Achtung: Einige Modelle führen zum Absturz.",
        fr = "Rétribution: modifie le modèle d'une entité. Attention: certains modèles entraînent un crash.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",    de = "Entity", fr = "Entité", },
        { ParameterType.Custom,     en = "Model",     de = "Model",  fr = "Modèle", },
    },
}

function B_Reprisal_SetModel:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetModel:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Model = _Parameter;
    end
end

function B_Reprisal_SetModel:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    Logic.SetModel(eID, Models[self.Model]);
end

function B_Reprisal_SetModel:GetCustomData(_Index)
    if _Index == 1 then
        local Data = {};
        -- Add generic models
        for k, v in pairs(Models) do
            if  not string.find(k, "Animals_")
            and not string.find(k, "MissionMap_")
            and not string.find(k, "R_Fish")
            and not string.find(k, "^[GEHUVXYZgt][ADSTfm]*")
            and not string.find(string.lower(k), "goods|tools_") then
                table.insert(Data, k);
            end
        end
        -- Add specific models
        table.insert(Data, "Effects_Dust01");
        table.insert(Data, "Effects_E_DestructionSmoke");
        table.insert(Data, "Effects_E_DustLarge");
        table.insert(Data, "Effects_E_DustSmall");
        table.insert(Data, "Effects_E_Firebreath");
        table.insert(Data, "Effects_E_Fireworks01");
        table.insert(Data, "Effects_E_Flies01");
        table.insert(Data, "Effects_E_Grasshopper03");
        table.insert(Data, "Effects_E_HealingFX");
        table.insert(Data, "Effects_E_Knight_Chivalry_Aura");
        table.insert(Data, "Effects_E_Knight_Plunder_Aura");
        table.insert(Data, "Effects_E_Knight_Song_Aura");
        table.insert(Data, "Effects_E_Knight_Trader_Aura");
        table.insert(Data, "Effects_E_Knight_Wisdom_Aura");
        table.insert(Data, "Effects_E_KnightFight");
        table.insert(Data, "Effects_E_NA_BlowingSand01");
        table.insert(Data, "Effects_E_NE_BlowingSnow01");
        table.insert(Data, "Effects_E_Oillamp");
        table.insert(Data, "Effects_E_SickBuilding");
        table.insert(Data, "Effects_E_Splash");
        table.insert(Data, "Effects_E_Torch");
        table.insert(Data, "Effects_Fire01");
        table.insert(Data, "Effects_FX_Lantern");
        table.insert(Data, "Effects_FX_SmokeBIG");
        table.insert(Data, "Effects_XF_BuildingSmoke");
        table.insert(Data, "Effects_XF_BuildingSmokeLarge");
        table.insert(Data, "Effects_XF_BuildingSmokeMedium");
        table.insert(Data, "Effects_XF_HouseFire");
        table.insert(Data, "Effects_XF_HouseFireLo");
        table.insert(Data, "Effects_XF_HouseFireMedium");
        table.insert(Data, "Effects_XF_HouseFireSmall");
        if g_GameExtraNo > 0 then
            table.insert(Data, "Effects_E_KhanaTemple_Fire");
            table.insert(Data, "Effects_E_Knight_Saraya_Aura");
        end
        -- Sort list
        table.sort(Data);
        return Data;
    end
end

function B_Reprisal_SetModel:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    if not Models[self.Model] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": model '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_SetModel);

-- -------------------------------------------------------------------------- --

function Reward_SetPosition(...)
    return B_Reward_SetPosition:new(...);
end

B_Reward_SetPosition = CopyTable(B_Reprisal_SetPosition);
B_Reward_SetPosition.Name = "Reward_SetPosition";
B_Reward_SetPosition.Description.en = "Reward: Places an entity relative to the position of another. The entity can look the target.";
B_Reward_SetPosition.Description.de = "Lohn: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.";
B_Reward_SetPosition.Description.fr = "Récompense: Définit une Entity vis-à-vis de la position d'une autre. L'entité peut être orientée vers la cible.";
B_Reward_SetPosition.GetReprisalTable = nil;

B_Reward_SetPosition.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

RegisterBehavior(B_Reward_SetPosition);

-- -------------------------------------------------------------------------- --

function Reward_ChangePlayer(...)
    return B_Reward_ChangePlayer:new(...);
end

B_Reward_ChangePlayer = CopyTable(B_Reprisal_ChangePlayer);
B_Reward_ChangePlayer.Name = "Reward_ChangePlayer";
B_Reward_ChangePlayer.Description.en = "Reward: Changes the owner of the entity or a battalion.";
B_Reward_ChangePlayer.Description.de = "Lohn: Ändert den Besitzer einer Entity oder eines Battalions.";
B_Reward_ChangePlayer.Description.fr = "Récompense: Change le propriétaire d'une entité ou d'un bataillon.";
B_Reward_ChangePlayer.GetReprisalTable = nil;

B_Reward_ChangePlayer.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

RegisterBehavior(B_Reward_ChangePlayer);

-- -------------------------------------------------------------------------- --

function Reward_MoveToPosition(...)
    return B_Reward_MoveToPosition:new(...);
end

B_Reward_MoveToPosition = {
    Name = "Reward_MoveToPosition",
    Description = {
        en = "Reward: Moves an entity relative to another entity. If angle is zero the entities will be standing directly face to face.",
        de = "Lohn: Bewegt eine Entity relativ zur Position einer anderen. Wenn Winkel 0 ist, stehen sich die Entities direkt gegenüber.",
        fr = "Récompense: Déplace une entité par rapport à la position d'une autre. Si l'angle est égal à 0, les entités sont directement opposées.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Settler",     de = "Siedler",     fr = "Settler" },
        { ParameterType.ScriptName, en = "Destination", de = "Ziel",        fr = "Destination" },
        { ParameterType.Number,     en = "Distance",    de = "Entfernung",  fr = "Distance" },
        { ParameterType.Number,     en = "Angle",       de = "Winkel",      fr = "Angle" },
    },
}

function B_Reward_MoveToPosition:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function B_Reward_MoveToPosition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Target = _Parameter;
    elseif (_Index == 2) then
        self.Distance = _Parameter * 1;
    elseif (_Index == 3) then
        self.Angle = _Parameter * 1;
    end
end

function B_Reward_MoveToPosition:CustomFunction(_Quest)
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        return;
    end
    self.Angle = self.Angle or 0;

    local entity = GetID(self.Entity);
    local target = GetID(self.Target);
    local orientation = Logic.GetEntityOrientation(target);
    local x,y,z = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x, y = Logic.GetBuildingApproachPosition(target);
        orientation = orientation -90;
    end
    x = x + self.Distance * math.cos(math.rad(orientation+self.Angle));
    y = y + self.Distance * math.sin(math.rad(orientation+self.Angle));
    Logic.MoveSettler(entity, x, y);
    self.EntityMovingJob = RequestJob( function(_entityID, _targetID)
        if Logic.IsEntityMoving(_entityID) == false then
            LookAt(_entityID, _targetID);
            return true;
        end
    end, entity, target);
end

function B_Reward_MoveToPosition:Reset(_Quest)
    if self.EntityMovingJob then
        EndJob(self.EntityMovingJob);
    end
end

function B_Reward_MoveToPosition:Debug(_Quest)
    if tonumber(self.Distance) == nil or self.Distance < 50 then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Distance is nil or to short!");
        return true;
    elseif not IsExisting(self.Entity) or not IsExisting(self.Target) then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Mover entity or target entity does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_MoveToPosition);

-- -------------------------------------------------------------------------- --

function Reward_VictoryWithParty()
    return B_Reward_VictoryWithParty:new();
end

B_Reward_VictoryWithParty = {
    Name = "Reward_VictoryWithParty",
    Description = {
        en = "Reward: (Singleplayer) The player wins the game with an animated festival on the market. Continue playing deleates the festival.",
        de = "Lohn: (Einzelspieler) Der Spieler gewinnt das Spiel mit einer animierten Siegesfeier. Bei weiterspielen wird das Fest gelöscht.",
        fr = "Récompense: (Joueur unique) Le joueur gagne la partie avec une fête de la victoire animée. Si le joueur continue à jouer, la fête est effacée.",
    },
    Parameter = {}
};

function B_Reward_VictoryWithParty:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction}};
end

function B_Reward_VictoryWithParty:AddParameter(_Index, _Parameter)
end

function B_Reward_VictoryWithParty:CustomFunction(_Quest)
    if not Lib.QuestBehavior then
        return;
    end
    if Framework.IsNetworkGame() then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Can not be used in multiplayer!");
        return;
    end
    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);
    local PlayerID = _Quest.ReceivingPlayer;

    local MarketID = Logic.GetMarketplace(PlayerID);
    if IsExisting(MarketID) then
        local pos = GetPosition(MarketID);
        Logic.CreateEffect(EGL_Effects.FXFireworks01,pos.X,pos.Y,0);
        Logic.CreateEffect(EGL_Effects.FXFireworks02,pos.X,pos.Y,0);

        local Generated = self:GenerateParty(PlayerID);
        Lib.QuestBehavior.Global.VictoryWithPartyEntities[PlayerID] = Generated;

        Logic.ExecuteInLuaLocalState(string.format(
            [[
                local MarketID = %d
                if IsExisting(MarketID) then
                    CameraAnimation.AllowAbort = false
                    CameraAnimation.QueueAnimation(CameraAnimation.SetCameraToEntity, MarketID)
                    CameraAnimation.QueueAnimation(CameraAnimation.StartCameraRotation, 5)
                    CameraAnimation.QueueAnimation(CameraAnimation.Stay ,9999)
                end

                GUI_Window.ContinuePlayingClicked_Orig_Reward_VictoryWithParty = GUI_Window.ContinuePlayingClicked
                GUI_Window.ContinuePlayingClicked = function()
                    GUI_Window.ContinuePlayingClicked_Orig_Reward_VictoryWithParty()
                    
                    local PlayerID = GUI.GetPlayerID()
                    GUI.SendScriptCommand("B_Reward_VictoryWithParty:ClearParty(" ..PlayerID.. ")")

                    CameraAnimation.AllowAbort = true
                    CameraAnimation.Abort()
                end
            ]],
            MarketID
        ));
    end
end

function B_Reward_VictoryWithParty:ClearParty(_PlayerID)
    if Lib.QuestBehavior.Global.VictoryWithPartyEntities[_PlayerID] then
        for k, v in pairs(Lib.QuestBehavior.Global.VictoryWithPartyEntities[_PlayerID]) do
            DestroyEntity(v);
        end
        Lib.QuestBehavior.Global.VictoryWithPartyEntities[_PlayerID] = nil;
    end
end

function B_Reward_VictoryWithParty:GenerateParty(_PlayerID)
    local GeneratedEntities = {};
    local Marketplace = Logic.GetMarketplace(_PlayerID);
    if Marketplace ~= nil and Marketplace ~= 0 then
        local MarketX, MarketY = Logic.GetEntityPosition(Marketplace);
        local ID = Logic.CreateEntity(Entities.D_X_Garland, MarketX, MarketY, 0, _PlayerID)
        table.insert(GeneratedEntities, ID);
        for j=1, 10 do
            for k=1,10 do
                local SettlersX = MarketX -700+ (j*150);
                local SettlersY = MarketY -700+ (k*150);
                local rand = math.random(1, 100);
                if rand > 70 then
                    local SettlerType = GetRandomSettlerType();
                    local Orientation = math.random(1, 359);
                    local WorkerID = Logic.CreateEntityOnUnblockedLand(SettlerType, SettlersX, SettlersY, Orientation, _PlayerID);
                    Logic.SetTaskList(WorkerID, TaskLists.TL_WORKER_FESTIVAL_APPLAUD_SPEECH);
                    table.insert(GeneratedEntities, WorkerID);
                end
            end
        end
    end
    return GeneratedEntities;
end

function B_Reward_VictoryWithParty:Debug(_Quest)
    if Lib.QuestBehavior then
        if Lib.QuestBehavior.Global.VictoryWithPartyEntities[_Quest.ReceivingPlayer] then
            error(_Quest.Identifier.. ": " ..self.Name..": Victory festival already started for player ".._Quest.ReceivingPlayer.."!");
            return true;
        end
    end
    return false;
end

RegisterBehavior(B_Reward_VictoryWithParty);

-- -------------------------------------------------------------------------- --

function Reward_SetVisible(...)
    return B_Reward_SetVisible:new(...)
end

B_Reward_SetVisible = CopyTable(B_Reprisal_SetVisible);
B_Reward_SetVisible.Name = "Reward_SetVisible";
B_Reward_SetVisible.Description.en = "Reward: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.";
B_Reward_SetVisible.Description.de = "Lohn: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.";
B_Reward_SetVisible.Description.fr = "Récompense: Définit la visibilité d'une Entity. S'il s'agit d'un spawn, les entités spawnées sont également influencées.";
B_Reward_SetVisible.GetReprisalTable = nil;

B_Reward_SetVisible.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

RegisterBehavior(B_Reward_SetVisible);

-- -------------------------------------------------------------------------- --

function Reward_SetVulnerability(...)
    return B_Reward_SetVulnerability:new(...);
end

B_Reward_SetVulnerability = CopyTable(B_Reprisal_SetVulnerability);
B_Reward_SetVulnerability.Name = "Reward_SetVulnerability";
B_Reward_SetVulnerability.Description.en = "Reward: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.";
B_Reward_SetVulnerability.Description.de = "Lohn: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen.";
B_Reward_SetVulnerability.Description.fr = "Récompense: Rend une Entité vulnérable ou invulnérable. S'il s'agit d'un spawn, les entités spawnées sont affectées.";
B_Reward_SetVulnerability.GetReprisalTable = nil;

B_Reward_SetVulnerability.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

RegisterBehavior(B_Reward_SetVulnerability);

-- -------------------------------------------------------------------------- --

function Reward_SetModel(...)
    return B_Reward_SetModel:new(...);
end

B_Reward_SetModel = CopyTable(B_Reprisal_SetModel);
B_Reward_SetModel.Name = "Reward_SetModel";
B_Reward_SetModel.Description.en = "Reward: Changes the model of the entity. Be careful, some models crash the game.";
B_Reward_SetModel.Description.de = "Lohn: Ändert das Model einer Entity. Achtung: Einige Modelle führen zum Absturz.";
B_Reward_SetModel.Description.fr = "Récompense: Modifie le modèle d'une entité. Attention : certains modèles entraînent un plantage.";
B_Reward_SetModel.GetReprisalTable = nil;

B_Reward_SetModel.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

RegisterBehavior(B_Reward_SetModel);

-- -------------------------------------------------------------------------- --

function Reward_AI_SetEntityControlled(...)
    return B_Reward_AI_SetEntityControlled:new(...);
end

B_Reward_AI_SetEntityControlled = {
    Name = "Reward_AI_SetEntityControlled",
    Description = {
        en = "Reward: Bind or Unbind an entity or a battalion to/from an AI player. The AI player must be activated!",
        de = "Lohn: Die KI kontrolliert die Entity oder der KI die Kontrolle entziehen. Die KI muss aktiv sein!",
        fr = "Récompense: L'IA contrôle l'entité ou retirer le contrôle à l'IA. L'IA doit être active !",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",            de = "Entity",                 fr = "Entité", },
        { ParameterType.Custom,     en = "AI control entity", de = "KI kontrolliert Entity", fr = "L'IA contrôle l'entité", },
    },
}

function B_Reward_AI_SetEntityControlled:GetRewardTable()
    return { Reward.Custom, { self, self.CustomFunction } }
end

function B_Reward_AI_SetEntityControlled:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Hidden = ToBoolean(_Parameter)
    end
end

function B_Reward_AI_SetEntityControlled:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    local pID = Logic.EntityGetPlayer(eID);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);
    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        local spawned = {Logic.GetSpawnedEntities(eID)};
        for i=1, #spawned do
            if Logic.IsLeader(spawned[i]) == 1 then
                AICore.HideEntityFromAI(pID, spawned[i], not self.Hidden);
            end
        end
    else
        AICore.HideEntityFromAI(pID, eID, not self.Hidden);
    end
end

function B_Reward_AI_SetEntityControlled:GetCustomData(_Index)
    if _Index == 1 then
        return { "false", "true" }
    end
end

function B_Reward_AI_SetEntityControlled:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_AI_SetEntityControlled);

-- -------------------------------------------------------------------------- --

function Trigger_AmmunitionDepleted(...)
    return B_Trigger_AmmunitionDepleted:new(...);
end

B_Trigger_AmmunitionDepleted = {
    Name = "Trigger_AmmunitionDepleted",
    Description = {
        en = "Trigger: if the ammunition of the entity is depleted.",
        de = "Auslöser: wenn die Munition der Entity aufgebraucht ist.",
        fr = "Déclencheur: lorsque les munitions de l'entité sont épuisées.",
    },
    Parameter = {
        { ParameterType.Scriptname, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Trigger_AmmunitionDepleted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_AmmunitionDepleted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    end
end

function B_Trigger_AmmunitionDepleted:CustomFunction()
    if not IsExisting(self.Scriptname) then
        return false;
    end

    local EntityID = GetID(self.Scriptname);
    if Logic.GetAmmunitionAmount(EntityID) > 0 then
        return false;
    end

    return true;
end

function B_Trigger_AmmunitionDepleted:Debug(_Quest)
    if not IsExisting(self.Scriptname) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": '"..self.Scriptname.."' is destroyed!");
        return true
    end
    return false
end

RegisterBehavior(B_Trigger_AmmunitionDepleted);

-- -------------------------------------------------------------------------- --

Lib.Register("module/quest/QuestBehavior_API");

-- QuestBehavior_API: currently unused

Lib.QuestBehavior = Lib.QuestBehavior or {};
Lib.QuestBehavior.Name = "QuestBehavior";
Lib.QuestBehavior.Global = {
    VictoryWithPartyEntities = {},
    SoldierKillsCounter = {},
};
Lib.QuestBehavior.Local = {};

--- @diagnostic disable: undefined-field

Lib.Require("comfort/GetRandomSettlerType");
Lib.Require("comfort/LookAt");
Lib.Require("comfort/ToBoolean");
Lib.Require("core/core");
Lib.Require("module/quest/Quest");
Lib.Require("module/quest/QuestBehavior_API");
Lib.Require("module/quest/QuestBehavior_Behavior");
Lib.Register("module/quest/QuestBehavior");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.QuestBehavior.Global:Initialize()
    if not self.IsInstalled then
        for PlayerID = 0, 8 do
            self.SoldierKillsCounter[PlayerID] = {};
        end
        self:OverrideIsObjectiveCompleted();
        self:OverrideOnQuestTriggered();

        -- Garbage collection
        Lib.QuestBehavior.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.QuestBehavior.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.QuestBehavior.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.ThiefInfiltratedBuilding then
        self:OnThiefInfiltratedBuilding(arg[1], arg[2], arg[3], arg[4]);
    elseif _ID == Report.ThiefDeliverEarnings then
        self:OnThiefDeliverEarnings(arg[1], arg[2], arg[3], arg[4], arg[5]);
    elseif _ID == Report.EntityKilled then
        self:OnEntityKilled(arg[1], arg[2], arg[3], arg[4]);
    end
end

function Lib.QuestBehavior.Global:OverrideOnQuestTriggered()
    QuestTemplate.Trigger_Orig_QSB_NewBehaviors = QuestTemplate.Trigger;
    --- @diagnostic disable-next-line: duplicate-set-field
    QuestTemplate.Trigger = function(self)
        for b= 1, #self.Objectives, 1 do
            if self.Objectives[b] then
                -- Special Objective.DestroyEntities for spawners
                if self.Objectives[b].Type == Objective.DestroyEntities and self.Objectives[b].Data[1] == 3 then
                    -- Refill spawner once at quest start
                    if self.Objectives[b].Data[5] ~= true then
                        local SpawnPoints = self.Objectives[b].Data[2][0];
                        local SpawnAmount = self.Objectives[b].Data[3];
                        -- Delete remaining entities
                        for i=1, SpawnPoints, 1 do
                            local ID = GetID(self.Objectives[b].Data[2][i]);
                            local SpawnedEntities = {Logic.GetSpawnedEntities(ID)};
                            for j= 1, #SpawnedEntities, 1 do
                                DestroyEntity(SpawnedEntities[j]);
                            end
                        end
                        -- Spawn new entities and distribute them equally over
                        -- all spawner entities
                        while (SpawnAmount > 0) do
                            for i=1, SpawnPoints, 1 do
                                if SpawnAmount < 1 then
                                    break;
                                end
                                local ID = GetID(self.Objectives[b].Data[2][i]);
                                Logic.RespawnResourceEntity_Spawn(ID);
                                SpawnAmount = SpawnAmount -1;
                            end
                        end
                        -- Set icon
                        local CategoryDefinigEntity = Logic.GetSpawnedEntities(self.Objectives[b].Data[2][1]);
                        if not self.Objectives[b].Data[6] then
                            self.Objectives[b].Data[6] = {7, 12};
                            if Logic.IsEntityInCategory(CategoryDefinigEntity, EntityCategories.AttackableAnimal) == 1 then
                                self.Objectives[b].Data[6] = {13, 8};
                            end
                        end
                        self.Objectives[b].Data[5] = true;
                    end
                end
            end
        end
        self:Trigger_Orig_QSB_NewBehaviors();
    end
end

function Lib.QuestBehavior.Global:OverrideIsObjectiveCompleted()
    QuestTemplate.IsObjectiveCompleted_Orig_QSB_NewBehaviors = QuestTemplate.IsObjectiveCompleted;
    --- @diagnostic disable-next-line: duplicate-set-field
    QuestTemplate.IsObjectiveCompleted = function(self, objective)
        local objectiveType = objective.Type;
        if objective.Completed ~= nil then
            if objectiveType == Objective.DestroyEntities and objective.Data[1] == 3 then
                objective.Data[5] = nil;
            end
            return objective.Completed;
        end

        if objectiveType == Objective.DestroyEntities then
            if objective.Data[1] == 3 then
                objective.Completed = self:AreSpawnedQuestEntitiesDestroyed(objective);
            else
                return self:IsObjectiveCompleted_Orig_QSB_NewBehaviors(objective);
            end
        else
            return self:IsObjectiveCompleted_Orig_QSB_NewBehaviors(objective);
        end
    end

    QuestTemplate.AreSpawnedQuestEntitiesDestroyed = function(self, _Objective)
        if _Objective.Data[1] == 3 then
            local AllSpawnedEntities = {};
            for i=1, _Objective.Data[2][0], 1 do
                local ID = GetID(_Objective.Data[2][i]);
                AllSpawnedEntities = Array_Append(
                    AllSpawnedEntities,
                    {Logic.GetSpawnedEntities(ID)}
                );
            end
            if #AllSpawnedEntities == 0 then
                return true;
            end
        end
    end
end

function Lib.QuestBehavior.Global:GetPossibleModels()
    local Data = {};
    -- Add generic models
    for k, v in pairs(Models) do
        if  not string.find(k, "Animals_")
        and not string.find(k, "MissionMap_")
        and not string.find(k, "R_Fish")
        and not string.find(k, "^[GEHUVXYZgt][ADSTfm]*")
        and not string.find(string.lower(k), "goods|tools_") then
            table.insert(Data, k);
        end
    end
    -- Add specific models
    table.insert(Data, "Effects_Dust01");
    table.insert(Data, "Effects_E_DestructionSmoke");
    table.insert(Data, "Effects_E_DustLarge");
    table.insert(Data, "Effects_E_DustSmall");
    table.insert(Data, "Effects_E_Firebreath");
    table.insert(Data, "Effects_E_Fireworks01");
    table.insert(Data, "Effects_E_Flies01");
    table.insert(Data, "Effects_E_Grasshopper03");
    table.insert(Data, "Effects_E_HealingFX");
    table.insert(Data, "Effects_E_Knight_Chivalry_Aura");
    table.insert(Data, "Effects_E_Knight_Plunder_Aura");
    table.insert(Data, "Effects_E_Knight_Song_Aura");
    table.insert(Data, "Effects_E_Knight_Trader_Aura");
    table.insert(Data, "Effects_E_Knight_Wisdom_Aura");
    table.insert(Data, "Effects_E_KnightFight");
    table.insert(Data, "Effects_E_NA_BlowingSand01");
    table.insert(Data, "Effects_E_NE_BlowingSnow01");
    table.insert(Data, "Effects_E_Oillamp");
    table.insert(Data, "Effects_E_SickBuilding");
    table.insert(Data, "Effects_E_Splash");
    table.insert(Data, "Effects_E_Torch");
    table.insert(Data, "Effects_Fire01");
    table.insert(Data, "Effects_FX_Lantern");
    table.insert(Data, "Effects_FX_SmokeBIG");
    table.insert(Data, "Effects_XF_BuildingSmoke");
    table.insert(Data, "Effects_XF_BuildingSmokeLarge");
    table.insert(Data, "Effects_XF_BuildingSmokeMedium");
    table.insert(Data, "Effects_XF_HouseFire");
    table.insert(Data, "Effects_XF_HouseFireLo");
    table.insert(Data, "Effects_XF_HouseFireMedium");
    table.insert(Data, "Effects_XF_HouseFireSmall");
    if g_GameExtraNo > 0 then
        table.insert(Data, "Effects_E_KhanaTemple_Fire");
        table.insert(Data, "Effects_E_Knight_Saraya_Aura");
    end
    -- Sort list
    table.sort(Data);
    return Data;
end

function Lib.QuestBehavior.Global:OnThiefInfiltratedBuilding(_ThiefID, _PlayerID, _BuildingID, _BuildingPlayerID)
    for i=1, Quests[0] do
        if Quests[i] and Quests[i].State == QuestState.Active and Quests[i].ReceivingPlayer == _PlayerID then
            for j=1, Quests[i].Objectives[0] do
                if Quests[i].Objectives[j].Type == Objective.Custom2 then
                    if Quests[i].Objectives[j].Data[1].Name == "Goal_SpyOnBuilding" then
                        if GetID(Quests[i].Objectives[j].Data[1].Building) == _BuildingID then
                            Quests[i].Objectives[j].Data[1].Infiltrated = true;
                            if Quests[i].Objectives[j].Data[1].Delete then
                                DestroyEntity(_ThiefID);
                            end
                        end

                    elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealFromBuilding" then
                        local found;
                        local isCistern = Logic.GetEntityType(_BuildingID) == Entities.B_Cistern;
                        local isCathedral = Logic.IsEntityInCategory(_BuildingID, EntityCategories.Cathedrals) == 1;
                        local isWarehouse = Logic.GetEntityType(_BuildingID) == Entities.B_StoreHouse;
                        if isWarehouse or isCathedral or isCistern then
                            Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;
                        else
                            for k=1, #Quests[i].Objectives[j].Data[1].RobberList do
                                local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];
                                if stohlen[1] == _BuildingID and stohlen[2] == _ThiefID then
                                    found = true;
                                    break;
                                end
                            end
                        end
                        if not found then
                            table.insert(Quests[i].Objectives[j].Data[1].RobberList, {_BuildingID, _ThiefID});
                        end
                    end
                end
            end
        end
    end
end

function Lib.QuestBehavior.Global:OnThiefDeliverEarnings(_ThiefID, _PlayerID, _BuildingID, _BuildingPlayerID, _GoldAmount)
    for i=1, Quests[0] do
        if Quests[i] and Quests[i].State == QuestState.Active and Quests[i].ReceivingPlayer == _PlayerID then
            for j=1, Quests[i].Objectives[0] do
                if Quests[i].Objectives[j].Type == Objective.Custom2 then
                    if Quests[i].Objectives[j].Data[1].Name == "Goal_StealFromBuilding" then
                        for k=1, #Quests[i].Objectives[j].Data[1].RobberList do
                            local stohlen = Quests[i].Objectives[j].Data[1].RobberList[k];
                            if stohlen[1] == GetID(Quests[i].Objectives[j].Data[1].Building) and stohlen[2] == _ThiefID then
                                Quests[i].Objectives[j].Data[1].SuccessfullyStohlen = true;
                                break;
                            end
                        end

                    elseif Quests[i].Objectives[j].Data[1].Name == "Goal_StealGold" then
                        local CurrentObjective = Quests[i].Objectives[j].Data[1];
                        if CurrentObjective.Target == -1 or CurrentObjective.Target == _BuildingPlayerID then
                            Quests[i].Objectives[j].Data[1].StohlenGold = Quests[i].Objectives[j].Data[1].StohlenGold + _GoldAmount;
                            if CurrentObjective.Printout then
                                AddNote(string.format(
                                    "%d/%d %s",
                                    CurrentObjective.StohlenGold,
                                    CurrentObjective.Amount,
                                    Localize({de = "Talern gestohlen",en = "gold stolen",})
                                ));
                            end
                        end
                    end
                end
            end
        end
    end
end

function Lib.QuestBehavior.Global:OnEntityKilled(_KilledEntityID, _KilledPlayerID, _KillerEntityID, _KillerPlayerID)
    if _KilledPlayerID ~= 0 and _KillerPlayerID ~= 0 then
        self.SoldierKillsCounter[_KillerPlayerID][_KilledPlayerID] = self.SoldierKillsCounter[_KillerPlayerID][_KilledPlayerID] or 0
        if Logic.IsEntityInCategory(_KilledEntityID, EntityCategories.Soldier) == 1 then
            self.SoldierKillsCounter[_KillerPlayerID][_KilledPlayerID] = self.SoldierKillsCounter[_KillerPlayerID][_KilledPlayerID] +1
        end
    end
end

function Lib.QuestBehavior.Global:GetEnemySoldierKillsOfPlayer(_PlayerID1, _PlayerID2)
    return self.SoldierKillsCounter[_PlayerID1][_PlayerID2] or 0;
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.QuestBehavior.Local:Initialize()
    if not self.IsInstalled then
        -- Garbage collection
        Lib.QuestBehavior.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.QuestBehavior.Local:OnSaveGameLoaded()
end

-- Global report listener
function Lib.QuestBehavior.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.QuestBehavior.Name);

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/quest/QuestJornal_API");

function ShowJournalForQuest(_Quest, _Flag)
    assert(not IsLocalScript(), "Can not be used in local script!");
    local Quest = Quests[GetQuestID(_Quest)];
    if Quest then
        Quest.QuestNotes = _Flag == true;
    end
end

function AllowNotesForQuest(_Quest, _Flag)
    assert(not IsLocalScript(), "Can not be used in local script!");
    local Quest = Quests[GetQuestID(_Quest)];
    if Quest then
        Lib.QuestJornal.Global.CustomInputAllowed[_Quest] = _Flag == true;
    end
end

function CreateJournalEntry(_Text)
    assert(not IsLocalScript(), "Can not be used in local script!");
    _Text = _Text:gsub("{@[A-Za-z0-9:,]+}", "");
    _Text = _Text:gsub("{[A-Za-z0-9_]+}", "");
    return Lib.QuestJornal.Global:CreateJournalEntry(_Text, 0, false);
end

function AlterJournalEntry(_ID, _Text)
    assert(not IsLocalScript(), "Can not be used in local script!");
    _Text = _Text:gsub("{@[A-Za-z0-9:,]+}", "");
    _Text = _Text:gsub("{[A-Za-z0-9_]+}", "");
    local Entry = Lib.QuestJornal.Global:GetJournalEntry(_ID);
    if Entry then
        Lib.QuestJornal.Global:UpdateJournalEntry(
            _ID,
            _Text,
            Entry.Rank,
            Entry.AlwaysVisible,
            Entry.Deleted
        );
    end
end

function HighlightJournalEntry(_ID, _Important)
    assert(not IsLocalScript(), "Can not be used in local script!");
    local Entry = Lib.QuestJornal.Global:GetJournalEntry(_ID);
    if Entry then
        Lib.QuestJornal.Global:UpdateJournalEntry(
            _ID,
            Entry[1],
            (_Important == true and 1) or 0,
            Entry.AlwaysVisible,
            Entry.Deleted
        );
    end
end

function DeleteJournalEntry(_ID)
    assert(not IsLocalScript(), "Can not be used in local script!");
    local Entry = Lib.QuestJornal.Global:GetJournalEntry(_ID);
    if Entry then
        Lib.QuestJornal.Global:UpdateJournalEntry(
            _ID,
            Entry[1],
            Entry.Rank,
            Entry.AlwaysVisible,
            true
        );
    end
end

function RestoreJournalEntry(_ID)
    assert(not IsLocalScript(), "Can not be used in local script!");
    local Entry = Lib.QuestJornal.Global:GetJournalEntry(_ID);
    if Entry then
        Lib.QuestJornal.Global:UpdateJournalEntry(
            _ID,
            Entry[1],
            Entry.Rank,
            Entry.AlwaysVisible,
            false
        );
    end
end

function AddJournalEntryToQuest(_ID, _Quest)
    assert(not IsLocalScript(), "Can not be used in local script!");
    local Entry = Lib.QuestJornal.Global:GetJournalEntry(_ID);
    if Entry then
        Lib.QuestJornal.Global:AssociateJournalEntryWithQuest(_ID, _Quest, true);
    end
end

function RemoveJournalEntryFromQuest(_ID, _Quest)
    assert(not IsLocalScript(), "Can not be used in local script!");
    local Entry = Lib.QuestJornal.Global:GetJournalEntry(_ID);
    if Entry then
        Lib.QuestJornal.Global:AssociateJournalEntryWithQuest(_ID, _Quest, false);
    end
end

function GetEnemySoldierKillsOfPlayer(_PlayerID1, _PlayerID2)
    return Lib.QuestBehavior.Global:GetEnemySoldierKillsOfPlayer(_PlayerID1, _PlayerID2);
end

Lib.QuestJornal = Lib.QuestJornal or {};
Lib.QuestJornal.Name = "QuestJornal";
Lib.QuestJornal.Global = {
    Journal = {ID = 0},
    CustomInputAllowed = {},
    InputShown = {},
    TextColor  = "{tooltip}",
};
Lib.QuestJornal.Local = {
    NextButton = "/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/TutorialNextButton",
    NextButtonIcon = {16, 10},
};
Lib.QuestJornal.Text = {
    Next  = {de = "Tagebuch anzeigen", en = "Show Journal", fr = "Afficher le journal"},
    Title = {de = "Tagebuch",          en = "Journal",      fr = "Journal"},
    Note  = {de = "Notiz",             en = "Note",         fr = "Note"},
};

Lib.Require("core/core");
Lib.Require("module/information/Requester");
Lib.Require("module/quest/Quest");
Lib.Require("module/quest/QuestJornal_API");
Lib.Register("module/quest/QuestJornal");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.QuestJornal.Global:Initialize()
    if not self.IsInstalled then
        Report.QuestJournalDisplayed = CreateReport("Event_QuestJournalDisplayed");
        Report.QuestJournalPlayerNote = CreateReport("Event_QuestJournalPlayerNote");
        Report.TutorialNextClicked = CreateReport("Event_TutorialNextClicked");

        -- Garbage collection
        Lib.QuestJornal.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.QuestJornal.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.QuestJornal.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.TutorialNextClicked then
        self:DisplayJournal(arg[1], arg[2]);
    elseif _ID == Report.ChatClosed then
        self:ProcessChatInput(arg[1], arg[2]);
    elseif _ID == Report.QuestJournalPlayerNote then
        self.InputShown[arg[1]] = arg[2];
        SendReportToLocal(Report.QuestJournalPlayerNote, arg[1], arg[2], arg[3] == true);
    elseif _ID == Report.QuestJournalDisplayed then
        SendReportToLocal(Report.QuestJournalDisplayed, arg[1], arg[2], arg[3], arg[4]);
    end
end

function Lib.QuestJornal.Global:DisplayJournal(_QuestName, _PlayerID)
    local CustomInput = self.CustomInputAllowed[_QuestName] == true;
    local FullText = self:FormatJournalEntry(_QuestName, _PlayerID);
    SendReport(
        Report.QuestJournalDisplayed,
        _PlayerID, _QuestName, FullText, CustomInput
    );
end

function Lib.QuestJornal.Global:CreateJournalEntry(_Text, _Rank, _AlwaysVisible)
    self.Journal.ID = self.Journal.ID +1;
    table.insert(self.Journal, {
        ID            = self.Journal.ID,
        AlwaysVisible = _AlwaysVisible == true,
        Quests        = {},
        Rank          = _Rank,
        _Text
    });
    return self.Journal.ID;
end

function Lib.QuestJornal.Global:GetJournalEntry(_ID)
    for i= 1, #self.Journal do
        if self.Journal[i].ID == _ID then
            return self.Journal[i];
        end
    end
end

function Lib.QuestJornal.Global:UpdateJournalEntry(_ID, _Text, _Rank, _AlwaysVisible, _Deleted)
    for i= 1, #self.Journal do
        if self.Journal[i].ID == _ID then
            self.Journal[i].AlwaysVisible = _AlwaysVisible == true;
            self.Journal[i].Deleted       = _Deleted == true;
            self.Journal[i].Rank          = _Rank;

            self.Journal[i][1] = self.Journal[i][1] or _Text;
        end
    end
end

function Lib.QuestJornal.Global:AssociateJournalEntryWithQuest(_ID, _Quest, _Flag)
    for i= 1, #self.Journal do
        if self.Journal[i].ID == _ID then
            self.Journal[i].Quests[_Quest] = _Flag == true;
        end
    end
end

function Lib.QuestJornal.Global:FormatJournalEntry(_QuestName, _PlayerID)
    local Quest = Quests[GetQuestID(_QuestName)];
    --- @diagnostic disable-next-line: undefined-field
    if Quest and Quest.QuestNotes and Quest.ReceivingPlayer == _PlayerID then
        local Journal = self:GetJournalEntriesSorted();
        local SeperateImportant = false;
        local SeperateNormal = false;
        local Info = "";
        local Color = "";
        for i= 1, #Journal, 1 do
            if Journal[i].AlwaysVisible or Journal[i].Quests[_QuestName] then
                if not Journal[i].Deleted then
                    local Text = ConvertPlaceholders(Localize(Journal[i][1]));

                    if Journal[i].Rank == 1 then
                        Text = "{scarlet}" .. Text .. self.TextColor;
                        SeperateImportant = true;
                    end
                    if Journal[i].Rank == 0 then
                        if SeperateImportant then
                            SeperateImportant = false;
                            Text = "{cr}----------{cr}{cr}" .. Text;
                        end
                        SeperateNormal = true;
                    end
                    if Journal[i].Rank == -1 then
                        if SeperateNormal then
                            SeperateNormal = false;
                            Color = "{violet}";
                            Text = "{cr}----------{cr}{cr}" .. Text;
                        end
                        Text = Color .. Text .. self.TextColor;
                    end

                    Info = Info .. ((Info ~= "" and "{cr}") or "") .. Text;
                end
            end
        end
        return Info;
    end
end

function Lib.QuestJornal.Global:GetJournalEntriesSorted()
    local Journal = {};
    for i= 1, #self.Journal, 1 do
        table.insert(Journal, self.Journal[i]);
    end
    table.sort(Journal, function(a, b)
        return a.Rank > b.Rank;
    end)
    return Journal;
end

function Lib.QuestJornal.Global:ProcessChatInput(_Text, _PlayerID)
    if self.InputShown[_PlayerID] then
        if _Text and _Text ~= "" then
            local QuestName = self.InputShown[_PlayerID];
            local CustomInput = self.CustomInputAllowed[QuestName] == true;
            local ID = self:CreateJournalEntry(_Text, -1, false)
            self:AssociateJournalEntryWithQuest(ID, QuestName, true);
            local FullText = self:FormatJournalEntry(QuestName, _PlayerID);

            SendReport(
                Report.QuestJournalDisplayed,
                _PlayerID, QuestName, FullText, CustomInput
            );
        end
        self.InputShown[_PlayerID] = nil;
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.QuestJornal.Local:Initialize()
    if not self.IsInstalled then
        Report.QuestJournalDisplayed = CreateReport("Event_QuestJournalDisplayed");
        Report.QuestJournalPlayerNote = CreateReport("Event_QuestJournalPlayerNote");
        Report.TutorialNextClicked = CreateReport("Event_TutorialNextClicked");

        self:OverrideUpdateVoiceMessage();
        self:OverrideTutorialNext();
        self:OverrideStringKeys();
        self:OverrideTimerButtons();

        -- Garbage collection
        Lib.QuestJornal.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.QuestJornal.Local:OnSaveGameLoaded()
end

-- Global report listener
function Lib.QuestJornal.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.QuestJournalPlayerNote then
        if arg[1] == GUI.GetPlayerID() and arg[3] then
            --- @diagnostic disable-next-line: param-type-mismatch
            ShowTextInput(arg[1], false);
        end
    elseif _ID == Report.QuestJournalDisplayed then
        if arg[1] == GUI.GetPlayerID() then
            self:DisplayQuestJournal(arg[2], arg[1], arg[3], arg[4]);
        end
    end
end

function Lib.QuestJornal.Local:DisplayQuestJournal(_QuestName, _PlayerID, _Info, _Input)
    if _Info and GUI.GetPlayerID() == _PlayerID then
        local Title = Localize(Lib.QuestJornal.Text.Title);
        local Data = {
            PlayerID  = _PlayerID,
            Caption   = Title,
            Content   = ConvertPlaceholders(_Info),
            QuestName = _QuestName
        }
        if _Input then
            Data.Button = {
                Text   = Localize{de = "Notiz", en = "Note", fr = "Note"},
                Action = function(_Data)
                    SendReportToGlobal(Report.QuestJournalPlayerNote, _Data.PlayerID, _Data.QuestName, _Input);
                end
            }
        end
        Lib.Requester.Local:ShowTextWindow(Data);
    end
end

function Lib.QuestJornal.Local:OverrideUpdateVoiceMessage()
    GUI_Interaction.UpdateVoiceMessage_Orig_QuestJornal = GUI_Interaction.UpdateVoiceMessage;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Interaction.UpdateVoiceMessage = function()
        GUI_Interaction.UpdateVoiceMessage_Orig_QuestJornal();
        if not QuestLog.IsQuestLogShown() then
            if Lib.QuestJornal.Local:IsShowingJournalButton(g_Interaction.CurrentMessageQuestIndex) then
                XGUIEng.ShowWidget(Lib.QuestJornal.Local.NextButton, 1);
                SetIcon(
                    Lib.QuestJornal.Local.NextButton,
                    Lib.QuestJornal.Local.NextButtonIcon
                );
            else
                XGUIEng.ShowWidget(Lib.QuestJornal.Local.NextButton, 0);
            end
        end
    end
end

function Lib.QuestJornal.Local:IsShowingJournalButton(_ID)
    if not g_Interaction.CurrentMessageQuestIndex then
        return false;
    end
    local Quest = Quests[_ID];
    if type(Quest) == "table" and Quest.QuestNotes then
        return true;
    end
    return false;
end

function Lib.QuestJornal.Local:OverrideTimerButtons()
    GUI_Interaction.TimerButtonClicked_Orig_QuestJornal = GUI_Interaction.TimerButtonClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Interaction.TimerButtonClicked = function()
        if  XGUIEng.IsWidgetShown("/InGame/Root/Normal/ChatOptions") == 1
        and XGUIEng.IsWidgetShown("/InGame/Root/Normal/ChatOptions/ToggleWhisperTarget") == 1 then
            return;
        end
        GUI_Interaction.TimerButtonClicked_Orig_QuestJornal();
    end
end

function Lib.QuestJornal.Local:OverrideTutorialNext()
    GUI_Interaction.TutorialNext_Orig_QuestJornal = GUI_Interaction.TutorialNext;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Interaction.TutorialNext = function()
        if g_Interaction.CurrentMessageQuestIndex then
            local QuestID = g_Interaction.CurrentMessageQuestIndex;
            local Quest = Quests[QuestID];
            --- @diagnostic disable-next-line: undefined-field
            SendReportToGlobal(Report.TutorialNextClicked, Quest.Identifier, GUI.GetPlayerID());
            --- @diagnostic disable-next-line: undefined-field
            SendReport(Report.TutorialNextClicked, Quest.Identifier, GUI.GetPlayerID());
        end
    end
end

function Lib.QuestJornal.Local:OverrideStringKeys()
    AddStringText("UI_ObjectNames/TutorialNextButton", Lib.QuestJornal.Text.Next);
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.QuestJornal.Name);

Lib.Register("module/trade/Warehouse_Behavior");

B_Reward_TradePost.DEBUG_Orig_Warehouse = B_Reward_TradePost.DEBUG;
--- @diagnostic disable-next-line: duplicate-set-field
B_Reward_TradePost.DEBUG = function(self, _Quest)
    local Index = Lib.Warehouse.Global:GetIndex(self.ScriptName);
    if Index ~= 0 then
        debug(false, _Quest.Identifier .. ": Error in " .. self.Name ..": Can not use a tradepost that is already a warehouse!");
        return false;
    end
    return self:DEBUG_Orig_Warehouse(_Quest);
end

B_Reward_TradePost.CustomFunction_Orig_Warehouse = B_Reward_TradePost.CustomFunction;
--- @diagnostic disable-next-line: duplicate-set-field
B_Reward_TradePost.CustomFunction = function(self, _Quest)
    local Index = Lib.Warehouse.Global:GetIndex(self.ScriptName);
    if Index ~= 0 then
        debug(false, _Quest.Identifier .. ": Error in " .. self.Name ..": Can not use a tradepost that is already a warehouse!");
        return;
    end
    self:CustomFunction_Orig_Warehouse(_Quest);
end

-- -------------------------------------------------------------------------- --

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/trade/Warehouse_API");

function CreateWarehouse(_Data)
    assert(not IsLocalScript(), "Can not be used in local script!");
    Lib.Warehouse.AquireContext();
    this:CreateWarehouse(_Data);
    Lib.Warehouse.ReleaseContext();
end
API.CreateWarehouse = CreateWarehouse;

function CreateWarehouseOffer(_Name, _Amount, _GoodOrEntityType, __GoodOrEntityTypeAmount, _Payment, _BasePrice, _Refresh)
    assert(not IsLocalScript(), "Can not be used in local script!");
    Lib.Warehouse.AquireContext();
    local Offer = this:CreateOffer(_Name, _Amount, _GoodOrEntityType, __GoodOrEntityTypeAmount, _Payment, _BasePrice, _Refresh);
    Lib.Warehouse.ReleaseContext();
    return Offer;
end
API.CreateWarehouseOffer = CreateWarehouseOffer;

function RemoveWarehouseOffer(_Name, _ID)
    assert(not IsLocalScript(), "Can not be used in local script!");
    Lib.Warehouse.AquireContext();
    this:RemoveOffer(_Name, _ID);
    Lib.Warehouse.ReleaseContext();
end
API.RemoveWarehouseOffer = RemoveWarehouseOffer;

function DeactivateWarehouseOffer(_Name, _ID, _Deactivate)
    assert(not IsLocalScript(), "Can not be used in local script!");
    Lib.Warehouse.AquireContext();
    this:ActivateOffer(_Name, _ID, not _Deactivate);
    Lib.Warehouse.ReleaseContext();
end
API.DeactivateWarehouseOffer = DeactivateWarehouseOffer;

function GetWarehouseInflation(_PlayerID, _GoodOrEntityType)
    Lib.Warehouse.AquireContext();
    local Inflation = this:GetInflation(_PlayerID, _GoodOrEntityType);
    Lib.Warehouse.ReleaseContext();
    return Inflation;
end
API.GetWarehouseInflation = GetWarehouseInflation;

function SetWarehouseInflation(_PlayerID, _GoodOrEntityType, _Inflation)
    assert(not IsLocalScript(), "Can not be used in local script!");
    Lib.Warehouse.AquireContext();
    this:SetInflation(_PlayerID, _GoodOrEntityType, _Inflation);
    Lib.Warehouse.ReleaseContext();
end
API.SetWarehouseInflation = SetWarehouseInflation;

function GetWarehouseOfferByID(_Name, _ID)
    Lib.Warehouse.AquireContext();
    local Offer = this:GetOfferByID(_Name, _ID);
    Lib.Warehouse.ReleaseContext();
    return Offer;
end
API.GetWarehouseOfferByID = GetWarehouseOfferByID;

function GetActivWarehouseOffers(_Name, _VisibleOnly)
    Lib.Warehouse.AquireContext();
    local Active = this:GetActivOffers(_Name, _VisibleOnly);
    Lib.Warehouse.ReleaseContext();
    return Active;
end
API.GetActivWarehouseOffers = GetActivWarehouseOffers;

Lib.Warehouse = Lib.Warehouse or {};
Lib.Warehouse.Name = "Warehouse";
Lib.Warehouse.CinematicEvents = {};
Lib.Warehouse.Global = {
    OfferSequence = 0,
    Warehouses = {Job = 0},
    Inflation = {
        Players = {},
        Inc = 0.12,
        Min = 0.50,
        Max = 1.75,
    },
};
Lib.Warehouse.Local = {
    Warehouses = {},
    Inflation = {
        Players = {},
        Inc = 0.12,
        Min = 0.50,
        Max = 1.75,
    },
};
Lib.Warehouse.Text = {
    OfferTitle = {
        {de = "Keine Angebote", en = "No Offers",},
        {de = "%d %s kaufen%s", en = "Purchase %d %s%s",},
        {de = "%s anheuern", en = "Hire %s",},
        {de = "%s anheuern%s", en = "Hire %s%s",},
        {de = "%s kaufen%s", en = "Purchase %s%s",},
    },
};

Lib.Require("comfort/GetSiegeengineTypeByCartType");
Lib.Require("comfort/IsMultiplayer");
Lib.Require("comfort/KeyOf");
Lib.Require("comfort/ReplaceEntity");
Lib.Require("comfort/SendCart");
Lib.Require("core/Core");
Lib.Require("module/ui/UITools");
Lib.Require("module/io/IO");
Lib.Require("module/ui/UIBuilding");
Lib.Require("module/trade/Warehouse_API");
Lib.Require("module/trade/Warehouse_Behavior");
Lib.Register("module/trade/Warehouse");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.Warehouse.Global:Initialize()
    if not self.IsInstalled then
        --- The player clicked an offer.
        ---
        --- #### Parameter
        --- * `PlayerID`      - ID of player
        --- * `ScriptName`    - Scriptname of warehouse
        --- * `Inflation`     - Calculated inflation
        --- * `OfferIndex`    - Index of offer
        --- * `OfferGood`     - Good or entity type purchased
        --- * `GoodAmount`    - Amount of goods
        --- * `PaymentType`   - Money good
        --- * `BasePrice`     - Base price
        Report.WarehouseOfferClicked = CreateReport("Event_WarehouseOfferClicked");

        --- The player bought an offer.
        ---
        --- #### Parameter
        --- * `PlayerID`      - ID of player
        --- * `ScriptName`    - Scriptname of warehouse
        --- * `OfferGood`     - Good or entity type purchased
        --- * `GoodAmount`    - Amount of goods
        --- * `PaymentGood`   - Good of payment
        --- * `PaymentAmount` - Amount of payment
        Report.WarehouseOfferBought = CreateReport("Event_WarehouseOfferBought");

        self:OverwriteGameCallbacks();

        for i= 1, 8 do
            self.Inflation.Players[i] = {};
        end
        self.Warehouses.Job = RequestJob(function()
            Lib.Warehouse.Global:ControlWarehouse();
        end);

        -- Garbage collection
        Lib.Warehouse.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.Warehouse.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.Warehouse.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.WarehouseOfferClicked then
        self:PerformTrade(unpack(arg));
        SendReportToLocal(_ID, unpack(arg));
    end
end

function Lib.Warehouse.Global:CreateWarehouse(_Data)
    local Warehouse = {
        ScriptName      = _Data.ScriptName,
        BuildingName    = _Data.ScriptName.. "_Post",
        Costs           = _Data.Costs,
        Offers          = {};
    }
    table.insert(self.Warehouses, Warehouse);

    local ID = GetID(_Data.ScriptName);
    local x,y,z = Logic.EntityGetPos(ID);
    local Orientation = Logic.GetEntityOrientation(ID);
    local PlayerID = Logic.EntityGetPlayer(ID);
    local Type = Logic.GetEntityType(ID);
    DestroyEntity(Warehouse.ScriptName);
    local SiteID = Logic.CreateEntity(Entities.I_X_TradePostConstructionSite, x, y, Orientation, PlayerID);
    Logic.SetEntityName(SiteID, Warehouse.ScriptName);
    if Type == Entities.B_TradePost then
        SiteID = ReplaceEntity(SiteID, Entities.XD_ScriptEntity);
        local BuildingID = Logic.CreateEntity(Entities.B_TradePost, x, y, Orientation, PlayerID);
        Logic.SetEntityName(BuildingID, Warehouse.BuildingName);
    end

    if _Data.Costs then
        Logic.InteractiveObjectClearCosts(GetID(Warehouse.ScriptName));
        if _Data.Costs[1] then
            Logic.InteractiveObjectAddCosts(GetID(Warehouse.ScriptName), _Data.Costs[1], _Data.Costs[2]);
        end
        if _Data.Costs[3] then
            Logic.InteractiveObjectAddCosts(GetID(Warehouse.ScriptName), _Data.Costs[3], _Data.Costs[4]);
        end
    end

    for i= 1, #_Data.Offers do
        if _Data.Offers[i] then
            self:CreateOffer(
                Warehouse.ScriptName,
                _Data.Offers[i].Amount,
                _Data.Offers[i].GoodType,
                _Data.Offers[i].GoodAmount,
                _Data.Offers[i].PaymentType,
                _Data.Offers[i].BasePrice,
                _Data.Offers[i].Refresh
            );
        end
    end
    ExecuteLocal([[Lib.Warehouse.Local:InitTradeButtons("%s")]], Warehouse.BuildingName);
end

function Lib.Warehouse.Global:GetIndex(_Name)
    for i= 1, #self.Warehouses do
        if self.Warehouses[i].ScriptName == _Name then
            return i;
        end
    end
    return 0;
end

function Lib.Warehouse.Global:CreateOffer(_Name, _Amount, _GoodType, _GoodAmount, _Payment, _BasePrice, _Refresh)
    local Index = self:GetIndex(_Name);
    if Index ~= 0 then
        -- Get amount
        local Amount = _Amount or 1;
        if  KeyOf(_GoodType, Goods) == nil and KeyOf(_GoodType, Entities) ~= nil
        and Logic.IsEntityTypeInCategory(_GoodType, EntityCategories.Military) == 0 then
            Amount = 1;
        end
        -- Insert offer
        self.OfferSequence = self.OfferSequence + 1;
        local ID = self.OfferSequence;
        table.insert(self.Warehouses[Index].Offers, {
            ID = ID,
            BuyLock = false,
            Active = true,
            Current = Amount,
            Amount = Amount,
            Timer = _Refresh or (3*60),
            Refresh = _Refresh or (3*60),
            GoodType = _GoodType,
            GoodAmount = _GoodAmount or 9,
            PaymentType = _Payment or Goods.G_Gold,
            BasePrice = _BasePrice or 3,
        });
        return ID;
    end
    return 0;
end

function Lib.Warehouse.Global:RemoveOffer(_Name, _ID)
    local Index = self:GetIndex(_Name);
    if Index ~= 0 then
        for i= #self.Warehouses[Index].Offers, 1, -1 do
            if self.Warehouses[Index].Offers[i].ID == _ID then
                table.remove(self.Warehouses[Index].Offers, i);
                break;
            end
        end
    end
end

function Lib.Warehouse.Global:ActivateOffer(_Name, _ID, _Active)
    local Index = self:GetIndex(_Name);
    if Index ~= 0 then
        for i= #self.Warehouses[Index].Offers, 1, -1 do
            if self.Warehouses[Index].Offers[i].ID == _ID then
                self.Warehouses[Index].Offers[i].Active = _Active == true;
                break;
            end
        end
    end
end

function Lib.Warehouse.Global:GetOfferByID(_Name, _ID)
    local Offer, OfferIndex
    local Index = self:GetIndex(_Name);
    if Index ~= 0 then
        for i= #self.Warehouses[Index].Offers, 1, -1 do
            if self.Warehouses[Index].Offers[i].ID == _ID then
                Offer = self.Warehouses[Index].Offers[i];
                OfferIndex = i;
            end
        end
    end
    return Offer, OfferIndex;
end

function Lib.Warehouse.Global:GetActivOffers(_Name, _VisibleOnly)
    local Offers = {};
    local Index = self:GetIndex(_Name);
    if Index ~= 0 then
        for i= 1, #self.Warehouses[Index].Offers do
            if (not _VisibleOnly or #Offers < 6) and self.Warehouses[Index].Offers[i].Active then
                table.insert(Offers, self.Warehouses[Index].Offers[i].ID);
            end
        end
    end
    return Offers;
end

function Lib.Warehouse.Global:ChangeOfferAmount(_Name, _ID, _Amount)
    local Index = self:GetIndex(_Name);
    if Index ~= 0 then
        for i= #self.Warehouses[Index].Offers, 1, -1 do
            if self.Warehouses[Index].Offers[i].ID == _ID then
                local Max = self.Warehouses[Index].Offers[_ID].Amount;
                self.Warehouses[Index].Offers[_ID].Current = math.min(_Amount, Max);
                break;
            end
        end
    end
end

function Lib.Warehouse.Global:GetInflation(_PlayerID, _GoodType)
    return self.Inflation.Players[_PlayerID][_GoodType] or 1.0;
end

function Lib.Warehouse.Global:SetInflation(_PlayerID, _GoodType, _Inflation)
    self.Inflation.Players[_PlayerID][_GoodType] = _Inflation or 1.0;
    ExecuteLocal(
        [[Lib.Warehouse.Local.Inflation.Players[%d][%d] = %f]],
        _PlayerID,
        _GoodType,
        _Inflation or 1.0
    )
end

function Lib.Warehouse.Global:CalculateInflation(_PlayerID, _GoodType)
    local Factor = (self.Inflation.Players[_PlayerID][_GoodType] or 1.0) + self.Inflation.Inc;
    Factor = math.max(self.Inflation.Min, Factor);
    Factor = math.min(Factor, self.Inflation.Max);
    return Factor;
end

function Lib.Warehouse.Global:PerformTrade(_PlayerID, _ScriptName, _Inflation, _OfferIndex, _OfferGood, _GoodAmount, _PaymentGood, _BasePrice)
    local BuildingID = GetID(_ScriptName.. "_Post");
    local Amount = _GoodAmount or 1;
    -- Send good type
    if KeyOf(_OfferGood, Goods) ~= nil then
        SendCart(_ScriptName.. "_Post", _PlayerID, _OfferGood, Amount);
    -- Create units
    elseif KeyOf(_OfferGood, Entities) ~= nil then
        if Logic.IsEntityTypeInCategory(_OfferGood, EntityCategories.Military) == 1 then
            local x,y = Logic.GetBuildingApproachPosition(GetID(_ScriptName.. "_Post"));
            local Orientation = Logic.GetEntityOrientation(GetID(_ScriptName.. "_Post")) - 90;
            local ID  = Logic.CreateBattalionOnUnblockedLand(_OfferGood, x, y, Orientation, _PlayerID);
            Logic.MoveSettler(ID, x, y, -1);
        else
            if Logic.IsEntityTypeInCategory(_OfferGood, EntityCategories.CattlePasture) == 1
            or Logic.IsEntityTypeInCategory(_OfferGood, EntityCategories.SheepPasture) == 1 then
                Amount = 5;
            end
            for i= 1, Amount do
                ExecuteLocal([[GUI.CreateEntityAtBuilding(%d, %d, 0)]], BuildingID, _OfferGood);
            end
        end
    end
    -- Pay offer
    local PaymentAmount = math.floor((_BasePrice * _Inflation) + 0.5);
    AddGood(_PaymentGood, (-1) * PaymentAmount, _PlayerID);
    ExecuteLocal([[GUI_FeedbackWidgets.GoldAdd(%d, nil, {3, 1, 1}, g_TexturePositions.Goods[%d])]], (-1) * PaymentAmount, _PaymentGood);
    -- Uodate offer
    self:UpdateOnPurchase(_PlayerID, _ScriptName, _OfferIndex);
    -- Send reports
    SendReport(Report.WarehouseOfferBought, _PlayerID, _ScriptName, _OfferGood, _GoodAmount, _PaymentGood, PaymentAmount);
    SendReportToLocal(Report.WarehouseOfferBought, _PlayerID, _ScriptName, _OfferGood, _GoodAmount, _PaymentGood, PaymentAmount);
end

function Lib.Warehouse.Global:UpdateOnPurchase(_PlayerID, _ScriptName, _OfferIndex)
    local Index = self:GetIndex(_ScriptName);
    if Index ~= 0 then
        local Offer = self.Warehouses[Index].Offers[_OfferIndex];
        -- Update offer amount
        self.Warehouses[Index].Offers[_OfferIndex].Current = Offer.Current - 1;
        -- Update inflation
        local Inflation = self:CalculateInflation(_PlayerID, Offer.GoodType);
        self:SetInflation(_PlayerID, Offer.GoodType, Inflation);
    end
end

function Lib.Warehouse.Global:OverwriteGameCallbacks()
    self.Orig_GameCallback_OnBuildingConstructionComplete = GameCallback_OnBuildingConstructionComplete;
    GameCallback_OnBuildingConstructionComplete = function(_PlayerID, _EntityID)
        Lib.Warehouse.Global.Orig_GameCallback_OnBuildingConstructionComplete(_PlayerID, _EntityID);
        if Logic.GetEntityType(_EntityID) == Entities.B_TradePost then
            Lib.Warehouse.Global:OnTradepostConstructed(_EntityID);
        end
    end

    self.Orig_GameCallback_BuildingDestroyed = GameCallback_BuildingDestroyed;
    GameCallback_BuildingDestroyed = function(_EntityID, _PlayerID, _KnockedDown)
        Lib.Warehouse.Global.Orig_GameCallback_BuildingDestroyed(_EntityID, _PlayerID, _KnockedDown);
        if Logic.GetEntityType(_EntityID) == Entities.B_TradePost then
            Lib.Warehouse.Global:OnTradepostDestroyed(_PlayerID, _EntityID);
        end
    end
end

-- When a tradepost is constructed from a site and the site is a warehouse then
-- the created building becomes a script name.
function Lib.Warehouse.Global:OnTradepostConstructed(_EntityID)
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local n, SiteID = Logic.GetEntitiesInArea(Entities.I_X_TradePostConstructionSite, x, y, 100, 1);
    if SiteID ~= 0 then
        local ScriptName = Logic.GetEntityName(SiteID);
        local Index = self:GetIndex(ScriptName);
        if Index ~= 0 then
            Logic.SetEntityName(_EntityID, self.Warehouses[Index].BuildingName);
        end
    end
end

-- When a tradepost is destroyed that was a warehouse an new construction site
-- is created if it don't exist anymore.
function Lib.Warehouse.Global:OnTradepostDestroyed(_PlayerID, _EntityID)
    local x,y,z = Logic.EntityGetPos(_EntityID);
    local Orientation = Logic.GetEntityOrientation(_EntityID);
    local ScriptName = Logic.GetEntityName(_EntityID);
    local Index = (ScriptName and self:GetIndex(ScriptName:sub(1, ScriptName:len() -5))) or 0;
    if Index ~= 0 then
        local Data = self.Warehouses[Index];
        local ID = ReplaceEntity(Data.ScriptName, Entities.I_X_TradePostConstructionSite);
        for i= 1, 8 do
            Logic.InteractiveObjectSetPlayerState(ID, i, 1);
        end
    end
end

function Lib.Warehouse.Global:ControlWarehouse()
    -- Refresh goods
    for i= 1, #self.Warehouses do
        if self.Warehouses[i] then
            for j= 1, #self.Warehouses[i].Offers do
                local Offer = self.Warehouses[i].Offers[j];
                if Offer.Active and Offer.Refresh > 0 then
                    if self.Warehouses[i].Offers[j].Current < Offer.Amount then
                        self.Warehouses[i].Offers[j].Timer = Offer.Timer - 1;
                        if Offer.Timer == 0 then
                            self.Warehouses[i].Offers[j].Current = Offer.Current + 1;
                            self.Warehouses[i].Offers[j].Timer = Offer.Refresh;
                        end
                    end
                end
            end
        end
    end
    -- Mirror in local script
    local Table = table.tostring(self.Warehouses);
    ExecuteLocal([[Lib.Warehouse.Local.Warehouses = %s]], Table);
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.Warehouse.Local:Initialize()
    if not self.IsInstalled then
        Report.WarehouseOfferClicked = CreateReport("Event_WarehouseOfferClicked");
        Report.WarehouseOfferBought = CreateReport("Event_WarehouseOfferBought");

        for i= 1, 8 do
            self.Inflation.Players[i] = {};
        end

        -- Garbage collection
        Lib.Warehouse.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.Warehouse.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.Warehouse.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.WarehouseOfferClicked then
        if GUI.GetPlayerID() == arg[2] then
            local Index = self:GetIndex(arg[2]);
            if self.Warehouses[Index] then
                self.Warehouses[Index].Offers[arg[4]].BuyLock = false;
            end
        end
    end
end

function Lib.Warehouse.Local:GetIndex(_Name)
    for i= 1, #self.Warehouses do
        if self.Warehouses[i].ScriptName == _Name then
            return i;
        end
    end
    return 0;
end

function Lib.Warehouse.Local:GetPrice(_PlayerID, _GoodType, _BasePrice)
    return math.floor(((self.Inflation.Players[_PlayerID][_GoodType] or 1.0) * _BasePrice) + 0.5);
end

function Lib.Warehouse.Local:GetInflation(_PlayerID, _GoodType)
    return self.Inflation.Players[_PlayerID][_GoodType] or 1.0;
end

function Lib.Warehouse.Local:GetOfferByID(_Name, _ID)
    local Offer, OfferIndex
    local Index = self:GetIndex(_Name);
    if Index ~= 0 then
        for i= #self.Warehouses[Index].Offers, 1, -1 do
            if self.Warehouses[Index].Offers[i].ID == _ID then
                Offer = self.Warehouses[Index].Offers[i];
                OfferIndex = i;
            end
        end
    end
    return Offer, OfferIndex;
end

function Lib.Warehouse.Local:GetActivOffers(_Name, _VisibleOnly)
    local Offers = {};
    local Index = self:GetIndex(_Name);
    if Index ~= 0 then
        for i= 1, #self.Warehouses[Index].Offers do
            if (not _VisibleOnly or #Offers < 6) and self.Warehouses[Index].Offers[i].Active then
                table.insert(Offers, self.Warehouses[Index].Offers[i].ID);
            end
        end
    end
    return Offers;
end

-- -------------------------------------------------------------------------- --

function Lib.Warehouse.Local:InitTradeButtons(_ScriptName)
    -- Button 1
    AddBuildingButtonByEntity(
        _ScriptName,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonAction(1, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonTooltip(1, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonUpdate(1, _WidgetID, _EntityID) end
    );
    -- Button 2
    AddBuildingButtonByEntity(
        _ScriptName,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonAction(2, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonTooltip(2, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonUpdate(2, _WidgetID, _EntityID) end
    );
    -- Button 3
    AddBuildingButtonByEntity(
        _ScriptName,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonAction(3, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonTooltip(3, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonUpdate(3, _WidgetID, _EntityID) end
    );
    -- Button 4
    AddBuildingButtonByEntity(
        _ScriptName,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonAction(4, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonTooltip(4, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonUpdate(4, _WidgetID, _EntityID) end
    );
    -- Button 5
    AddBuildingButtonByEntity(
        _ScriptName,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonAction(5, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonTooltip(5, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonUpdate(5, _WidgetID, _EntityID) end
    );
    -- Button 6
    AddBuildingButtonByEntity(
        _ScriptName,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonAction(6, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonTooltip(6, _WidgetID, _EntityID) end,
        function(_WidgetID, _EntityID) Lib.Warehouse.Local:WarehouseButtonUpdate(6, _WidgetID, _EntityID) end
    );
end

function Lib.Warehouse.Local:WarehouseButtonAction(_ButtonIndex, _WidgetID, _EntityID)
    local PlayerID = GUI.GetPlayerID();
    local ScriptName = Logic.GetEntityName(_EntityID);
    local s,e = string.find(ScriptName, "_Post");
    ScriptName = string.sub(ScriptName, 1, s-1);
    local Index = self:GetIndex(ScriptName);
    if Index == 0 then
        return;
    end

    local Offers = self:GetActivOffers(ScriptName);
    local Data, OfferIndex = self:GetOfferByID(ScriptName, Offers[_ButtonIndex]);
    if not Data then
        return;
    end
    if Data.BuyLock then
        return;
    end

    -- Get price
    local Price = self:GetPrice(PlayerID, Data.GoodType, Data.BasePrice);
    local Inflation = self:GetInflation(PlayerID, Data.GoodType);
    if GetPlayerGoodsInSettlement(Data.PaymentType, PlayerID) < Price then
        return;
    end
    -- Prevent click spam
    self.Warehouses[Index].Offers[OfferIndex].BuyLock = true;
    -- Send repot to global
    SendReportToGlobal(
        Report.WarehouseOfferClicked,
        PlayerID,
        ScriptName,
        Inflation,
        OfferIndex,
        Data.GoodType,
        Data.GoodAmount,
        Data.PaymentType,
        Data.BasePrice
    );
end

function Lib.Warehouse.Local:WarehouseButtonTooltip(_ButtonIndex, _WidgetID, _EntityID)
    local PlayerID = GUI.GetPlayerID();
    local ScriptName = Logic.GetEntityName(_EntityID);
    local s,e = string.find(ScriptName, "_Post");
    ScriptName = string.sub(ScriptName, 1, s-1);
    if XGUIEng.IsButtonDisabled(_WidgetID) == 1 then
        SetTooltipCosts(ConvertPlaceholders(Localize(Lib.Warehouse.Text.OfferTitle[1])), "");
        return;
    end
    local Index = self:GetIndex(ScriptName);
    if Index == 0 then
        return;
    end

    local Offers = self:GetActivOffers(ScriptName);
    local Data, OfferIndex = self:GetOfferByID(ScriptName, Offers[_ButtonIndex]);
    if not Data then
        return;
    end

    -- Get price
    local Price = self:GetPrice(PlayerID, Data.GoodType, Data.BasePrice);
    local InSettlement = true;
    -- Get name and description
    local OfferName = "";
    local OfferDescription = "";
    local GoodTypeName = Logic.GetGoodTypeName(Data.GoodType);
    local EntityTypeName = Logic.GetEntityTypeName(Data.GoodType);
    if GoodTypeName ~= nil and GoodTypeName ~= "" then
        OfferName = GetStringText("UI_ObjectNames/" ..GoodTypeName);
        OfferDescription = GetStringText("UI_ObjectDescription/" ..GoodTypeName);
    else
        OfferName = GetStringText("UI_ObjectNames/HireEntertainer");
        OfferDescription = GetStringText("UI_ObjectDescription/HireEntertainer");
        if Logic.IsEntityTypeInCategory(Data.GoodType, EntityCategories.Soldier) == 1 then
            OfferName = GetStringText("UI_ObjectNames/HireMercenaries");
            OfferDescription = GetStringText("UI_ObjectDescription/HireMercenaries");
        elseif Logic.IsEntityTypeInCategory(Data.GoodType, EntityCategories.CattlePasture) == 1 then
            OfferName = GetStringText("UI_ObjectNames/G_Cow");
            OfferDescription = GetStringText("UI_ObjectDescription/G_Sheep");
        elseif Logic.IsEntityTypeInCategory(Data.GoodType, EntityCategories.SheepPasture) == 1 then
            OfferName = GetStringText("UI_ObjectNames/G_Sheep");
            OfferDescription = GetStringText("UI_ObjectDescription/G_Sheep");
        elseif Logic.IsEntityTypeInCategory(Data.GoodType, EntityCategories.HeavyWeapon) == 1 then
            OfferName = GetStringText("Names/" ..EntityTypeName);
            local EngineType = GetSiegeengineTypeByCartType(Data.GoodType);
            local EngineTypeName = Logic.GetEntityTypeName(EngineType);
            OfferDescription = GetStringText("UI_ObjectDescription/Abilities_" ..EngineTypeName);
        end
    end

    -- Format quantity text
    local Quantity = "";
    if Data.Amount > 1 then
        Quantity = string.format(" (%d/%d)", Data.Current, Data.Amount);
    end
    -- Format tooltip text
    local OfferTitle = "";
    if KeyOf(Data.GoodType, Goods) ~= nil then
        OfferTitle = string.format(Localize(Lib.Warehouse.Text.OfferTitle[2]), Data.GoodAmount, OfferName, Quantity);
    elseif KeyOf(Data.GoodType, Entities) ~= nil then
        if Logic.IsEntityTypeInCategory(Data.GoodType, EntityCategories.Military) == 1 then
            OfferTitle = string.format(Localize(Lib.Warehouse.Text.OfferTitle[4]), OfferName, Quantity);
        elseif Logic.IsEntityTypeInCategory(Data.GoodType, EntityCategories.SiegeEngine) == 1 then
            OfferTitle = string.format(Localize(Lib.Warehouse.Text.OfferTitle[5]), OfferName, Quantity);
        elseif Logic.IsEntityTypeInCategory(Data.GoodType, EntityCategories.CattlePasture) == 1
            or Logic.IsEntityTypeInCategory(Data.GoodType, EntityCategories.SheepPasture) == 1 then
            OfferTitle = string.format(Localize(Lib.Warehouse.Text.OfferTitle[5]), OfferName, Quantity);
        else
            OfferTitle = string.format(Localize(Lib.Warehouse.Text.OfferTitle[3]), OfferName);
        end
    end
    -- Set text
    SetTooltipCosts(
        OfferTitle,
        OfferDescription,
        nil,
        {Data.PaymentType, Price},
        InSettlement
    );
end

function Lib.Warehouse.Local:WarehouseButtonUpdate(_ButtonIndex, _WidgetID, _EntityID)
    local ScriptName = Logic.GetEntityName(_EntityID);
    local s,e = string.find(ScriptName, "_Post");
    ScriptName = string.sub(ScriptName, 1, s-1);
    -- Hide if tradepost is no warehouse
    local Index = self:GetIndex(ScriptName);
    if Index == 0 then
        XGUIEng.ShowWidget(_WidgetID, 0);
        return;
    end
    -- Hide if offer is invalid
    local Offers = self:GetActivOffers(ScriptName);
    local Data, OfferIndex = self:GetOfferByID(ScriptName, Offers[_ButtonIndex]);
    if not Data or not Data.Active then
        XGUIEng.ShowWidget(_WidgetID, 0);
        return;
    end
    -- Disable button if locked or sold out
    if not Data.BuyLock and Data.Current > 0 then
        XGUIEng.DisableButton(_WidgetID, 0);
    else
        XGUIEng.DisableButton(_WidgetID, 1);
    end
    -- Set icon
    local Good = Data.GoodType;
    local Icon = g_TexturePositions.Goods[Good] or g_TexturePositions.Entities[Good];
    ChangeIcon(_WidgetID, Icon);
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.Warehouse.Name);

Lib.Register("module/mode/SettlementSurvival_Text");

Lib.SettlementSurvival = Lib.SettlementSurvival or {};
Lib.SettlementSurvival.Text = {
    Alarms = {
        AnimalDiedFromIllness = {
            de = "{scarlet}Eure Nutztiere sterben an Krankheiten!",
            en = "{scarlet}Your farm animals succumb to the plague!",
            fr = "{scarlet}Vos animaux de ferme succombent à la peste!",
        },
        BuildingBurning = {
            de = "{scarlet}Brände wüten in Eurer Stadt!",
            en = "{scarlet}Fires are raging in your city!",
            fr = "{scarlet}Les incendies font rage dans votre ville !",
        },
        SettlerTemperature = {
            de = "{scarlet}Eure Siedler haben kein Feuerholz und frieren!",
            en = "{scarlet}Your settlers lack of firewood to warm themselves!",
            fr = "{scarlet}Vos colons manquent de bois de chauffage pour se réchauffer!",
        },
        SettlerNegligence = {
            de = "{scarlet}Eure Siedler verwahrlosen und werden krank!",
            en = "{scarlet}Your settlers are neglected and getting sick!",
            fr = "{scarlet}Vos colons sont négligés et tombent malades!",
        },
        SettlerDiedFromHunger = {
            de = "{scarlet}Eure Siedler haben nichts zu essen und verhungern!",
            en = "{scarlet}Your settlers are starving to death!",
            fr = "{scarlet}Vos colons meurent de faim!",
        },
        SettlerDiedFromIllness = {
            de = "{scarlet}Eure Siedler sterben an Krankheiten!",
            en = "{scarlet}Your settlers succumb to the plague!",
            fr = "{scarlet}Vos colons succombent à la peste!",
        },
    },
    Messages = {
        BuildingMourning = {
            de = "Keine Baumaßnahmen möglich, solange Siedler trauern.",
            en = "No construction work possible as long as settlers mourn.",
            fr = "Aucun travail de construction possible tant que les colons pleurent.",
        },
    }
};

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/mode/SettlementSurvival_API");

function AnimalPlagueActivate(_Flag)
    Lib.SettlementSurvival.Global.AnimalPlague.IsActive = _Flag == true;
end
API.AnimalPlagueActivate = AnimalPlagueActivate;

function AnimalPlagueActivateForAI(_Flag)
    Lib.SettlementSurvival.Global.AnimalPlague.AffectAI = _Flag == true;
end
API.AnimalPlagueActivateForAI = AnimalPlagueActivateForAI;

function AnimalInfectionActivateAutomatic(_Flag)
    Lib.SettlementSurvival.Global.AnimalPlague.AnimalsBecomeSick = _Flag == true;
end
API.AnimalInfectionActivateAutomatic = AnimalInfectionActivateAutomatic;

function AnimalPlagueSetDeathInterval(_Interval)
    Lib.SettlementSurvival.Shared.AnimalPlague.DeathTimer = _Interval;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.AnimalPlague.DeathTimer = %d]], _Interval);
end
API.AnimalPlagueSetDeathInterval = AnimalPlagueSetDeathInterval;

function AnimalPlagueSetDeathChance(_Chance)
    Lib.SettlementSurvival.Shared.AnimalPlague.DeathChance = _Chance;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.AnimalPlague.DeathChance = %d]], _Chance);
end
API.AnimalPlagueSetDeathChance = AnimalPlagueSetDeathChance;

function AnimalPlagueSetInfectionInterval(_Interval)
    Lib.SettlementSurvival.Shared.AnimalPlague.InfectionTimer = _Interval;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.AnimalPlague.InfectionTimer = %d]], _Interval);
end
API.AnimalPlagueSetInfectionInterval = AnimalPlagueSetInfectionInterval;

function AnimalPlagueSetInfectionChance(_Chance)
    Lib.SettlementSurvival.Shared.AnimalPlague.InfectionChance = _Chance;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.AnimalPlague.InfectionChance = %d]], _Chance);
end
API.AnimalPlagueSetInfectionChance = AnimalPlagueSetInfectionChance;

function HotWeatherActivate(_Flag)
    Lib.SettlementSurvival.Global.HotWeather.IsActive = _Flag == true;
end
API.HotWeatherActivate = HotWeatherActivate;

function HotWeatherActivateForAI(_Flag)
    Lib.SettlementSurvival.Global.HotWeather.AffectAI = _Flag == true;
end
API.HotWeatherActivateForAI = HotWeatherActivateForAI;

function HotWeatherSetTemperature(_Temperature)
    Lib.SettlementSurvival.Shared.HotWeather.Temperature = _Temperature;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.HotWeather.Temperature = %d]], _Temperature);
end
API.HotWeatherSetTemperature = HotWeatherSetTemperature;

function HotWeatherSetIgnitionChance(_Chance)
    Lib.SettlementSurvival.Shared.HotWeather.IgnitionChance = _Chance;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.HotWeather.IgnitionChance = %d]], _Chance);
end
API.HotWeatherSetIgnitionChance = HotWeatherSetIgnitionChance;

function ColdWeatherActivate(_Flag)
    Lib.SettlementSurvival.Global.ColdWeather.IsActive = _Flag == true;
end
API.ColdWeatherActivate = ColdWeatherActivate;

function ColdWeatherActivateForAI(_Flag)
    Lib.SettlementSurvival.Global.ColdWeather.AffectAI = _Flag == true;
end
API.ColdWeatherActivateForAI = ColdWeatherActivateForAI;

function ColdWeatherSetTemperature(_Temperature)
    Lib.SettlementSurvival.Shared.ColdWeather.Temperature = _Temperature;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.ColdWeather.Temperature = %d]], _Temperature);
end
API.ColdWeatherSetTemperature = ColdWeatherSetTemperature;

function ColdWeatherSetConsumptionInterval(_Interval)
    Lib.SettlementSurvival.Shared.ColdWeather.ConsumptionTimer = _Interval;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.ColdWeather.ConsumptionTimer = %d]], _Interval);
end
API.ColdWeatherSetConsumptionInterval = ColdWeatherSetConsumptionInterval;

function ColdWeatherSetInfectionChance(_Chance)
    Lib.SettlementSurvival.Shared.ColdWeather.InfectionChance = _Chance;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.ColdWeather.InfectionChance = %d]], _Chance);
end
API.ColdWeatherSetInfectionChance = ColdWeatherSetInfectionChance;

function FamineActivate(_Flag)
    Lib.SettlementSurvival.Global.Famine.IsActive = _Flag == true;
end
API.FamineActivate = FamineActivate;

function FamineActivateForAI(_Flag)
    Lib.SettlementSurvival.Global.Famine.AffectAI = _Flag == true;
end
API.FamineActivateForAI = FamineActivateForAI;

function FamineSetDeathInterval(_Interval)
    Lib.SettlementSurvival.Shared.Famine.DeathTimer = _Interval;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.Famine.DeathTimer = %d]], _Interval);
end
API.FamineSetDeathInterval = FamineSetDeathInterval;

function FamineSetDeathChance(_Chance)
    Lib.SettlementSurvival.Shared.Famine.DeathChance = _Chance;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.Famine.DeathChance = %d]], _Chance);
end
API.FamineSetDeathChance = FamineSetDeathChance;

function NegligenceActivate(_Flag)
    Lib.SettlementSurvival.Global.Negligence.IsActive = _Flag == true;
end
API.NegligenceActivate = NegligenceActivate;

function NegligenceActivateForAI(_Flag)
    Lib.SettlementSurvival.Global.Negligence.AffectAI = _Flag == true;
end
API.NegligenceActivateForAI = NegligenceActivateForAI;

function NegligenceSetInfectionInterval(_Interval)
    Lib.SettlementSurvival.Shared.Negligence.InfectionTimer = _Interval;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.Negligence.InfectionTimer = %d]], _Interval);
end
API.NegligenceSetInfectionInterval = NegligenceSetInfectionInterval;

function NegligenceSetInfectionChance(_Chance)
    Lib.SettlementSurvival.Shared.Negligence.InfectionChance = _Chance;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.Negligence.InfectionChance = %d]], _Chance);
end
API.NegligenceSetInfectionChance = NegligenceSetInfectionChance;

function PlagueActivate(_Flag)
    Lib.SettlementSurvival.Global.Plague.IsActive = _Flag == true;
end
API.PlagueActivate = PlagueActivate;

function PlagueActivateForAI(_Flag)
    Lib.SettlementSurvival.Global.Plague.AffectAI = _Flag == true;
end
API.PlagueActivateForAI = PlagueActivateForAI;

function PlagueSetDeathInterval(_Interval)
    Lib.SettlementSurvival.Shared.Plague.DeathTimer = _Interval;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.Plague.DeathTimer = %d]], _Interval);
end
API.PlagueSetDeathInterval = PlagueSetDeathInterval;

function PlagueSetDeathChance(_Chance)
    Lib.SettlementSurvival.Shared.Plague.DeathChance = _Chance;
    ExecuteLocal([[Lib.SettlementSurvival.Shared.Plague.DeathChance = %d]], _Chance);
end
API.PlagueSetDeathChance = PlagueSetDeathChance;

function PredatorBlockClaimActivate(_Flag)
    Lib.SettlementSurvival.Global.Misc.PredatorBlockClaim = _Flag == true;
end
API.PredatorBlockClaimActivate = PredatorBlockClaimActivate;

function BanditsBlockClaimActivate(_Flag)
    Lib.SettlementSurvival.Global.Misc.BanditsBlockClaim = _Flag == true;
end
API.BanditsBlockClaimActivate = BanditsBlockClaimActivate;

function ClothesForOuterRimActivate(_Flag)
    Lib.SettlementSurvival.Global.Misc.ClothesForOuterRim = _Flag == true;
    ExecuteLocal(
        [[Lib.SettlementSurvival.Local.Misc.ClothesForOuterRim = %s]],
        tostring(_Flag == true)
    );
    Lib.SettlementSurvival.Global:UpdateClothesStateForOuterRim();
end
API.ClothesForOuterRimActivate = ClothesForOuterRimActivate;

Lib.Register("comfort/GetPredatorSpawnerTypes");

function GetPredatorSpawnerTypes()
    local Types = {
        Entities.S_Bear,
        Entities.S_Bear_Black,
        Entities.S_LionPack_NA,
        Entities.S_PolarBear_NE,
        Entities.S_WolfPack,
    };
    if Framework.GetGameExtraNo() > 0 then
        table.insert(Types, Entities.S_BearBlack);
        table.insert(Types, Entities.S_TigerPack_AS);
    end
    return Types;
end

Lib.SettlementSurvival = Lib.SettlementSurvival or {};
Lib.SettlementSurvival.Name = "SettlementSurvival";
Lib.SettlementSurvival.Global = {
    AnimalPlague = {
        AnimalsBecomeSick = false,
        IsActive = false,
        AffectAI = false,
    },
    Famine = {
        IsActive = false,
        AffectAI = false,
    },
    ColdWeather = {
        IsActive = false,
        AffectAI = false,
    },
    HotWeather = {
        IsActive = false,
        AffectAI = false,
    },
    Negligence = {
        IsActive = false,
        AffectAI = false,
    },
    Plague = {
        IsActive = false,
        AffectAI = false,
    },
    Misc = {
        PredatorBlockClaim = false,
        BanditsBlockClaim = false,
        ClothesForOuterRim = false,
    },

    SuspendedSettlers = {},
    SettlerLives = {},
};
Lib.SettlementSurvival.Local  = {
    Misc = {
        ClothesForOuterRim = false,
    },

    SuspendedSettlers = {},
    SettlerLives = {},
};
Lib.SettlementSurvival.Shared = {
    AnimalPlague = {
        InfectionChance = 4,
        InfectionTimer = 60,
        DeathChance = 12,
        DeathTimer = 30,
    },
    ColdWeather = {
        ConsumptionFactor = 0.01,
        ConsumptionTimer = 30,
        Temperature = 5,
        InfectionChance = 12,
    },
    HotWeather = {
        IgnitionChance = 5,
        IgnitionTimer = 30,
        Temperature = 30,
    },
    Famine = {
        DeathChance = 4,
        DeathTimer = 30,
    },
    Negligence = {
        InfectionChance = 4,
        InfectionTimer = 90,
    },
    Plague = {
        DeathChance = 9,
        DeathTimer = 30,
    },
    SuspendedSettlers = {
        MourningTime = 5*60,
    },
    SettlerLives = {
        PerMonth = 2,
        Max = 9,
    },
};

Lib.Require("comfort/GetPredatorSpawnerTypes");
Lib.Require("comfort/GetHealth");
Lib.Require("comfort/SetHealth");
Lib.Require("core/Core");
Lib.Require("module/city/Construction");
Lib.Require("module/ui/UIBuilding");
Lib.Require("module/ui/UITools");
Lib.Require("module/mode/SettlementSurvival_API");
Lib.Require("module/mode/SettlementSurvival_Text");
Lib.Register("module/mode/SettlementSurvival");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.SettlementSurvival.Global:Initialize()
    if not self.IsInstalled then
        Report.FireAlarmDeactivated_Internal = CreateReport("Event_FireAlarmDeactivated_Internal");
        Report.FireAlarmActivated_Internal = CreateReport("Event_FireAlarmActivated_Internal");
        Report.RepairAlarmDeactivated_Internal = CreateReport("Event_RepairAlarmFeactivated");
        Report.ReRepairAlarmActivated_Internal = CreateReport("Event_ReRepairAlarmActivated_Internal");

        --- An animal has died from illness.
        ---
        --- #### Parameters
        --- `EntityID` - ID of animal
        Report.AnimalDiedFromIllness = CreateReport("Event_AnimalDiedFromIllness");

        --- A settler has starved to death.
        ---
        --- #### Parameters
        --- `EntityID` - ID of settler
        Report.SettlerDiedFromStarvation = CreateReport("Event_SettlerDiedFromStarvation");

        --- A settler has died from illness.
        ---
        --- #### Parameters
        --- `EntityID` - ID of settler
        Report.SettlerDiedFromIllness = CreateReport("Event_SettlerDiedFromIllness");

        for PlayerID= 1,8 do
            self.AnimalPlague[PlayerID] = {};
            self.ColdWeather[PlayerID] = {Consumption = 0};
            self.Famine[PlayerID] = {};
            self.Negligence[PlayerID] = {};
            self.Plague[PlayerID] = {};
            self.SuspendedSettlers[PlayerID] = {};
        end

        RequestJobByEventType(
            Events.LOGIC_EVENT_EVERY_TURN,
            function()
                local Turn = Logic.GetCurrentTurn();
                Lib.SettlementSurvival.Global:ResumeSettlersAfterMourning(Turn);
                Lib.SettlementSurvival.Global:ControlSettlersBecomeIllDueToNegligence(Turn);
                Lib.SettlementSurvival.Global:ControlBuildingsDuringHotWeather(Turn);
                Lib.SettlementSurvival.Global:ControlBuildingsDuringColdWeather(Turn);
                Lib.SettlementSurvival.Global:ControlSettlersSuccumToFamine(Turn);
                Lib.SettlementSurvival.Global:ControlAnimalInfections(Turn);
                Lib.SettlementSurvival.Global:ControlAnimalCorpsesDecay(Turn);
                Lib.SettlementSurvival.Global:ControlAnimalsSuccumToPlague(Turn);
                Lib.SettlementSurvival.Global:ControlSettlersSuccumToPlague(Turn);
            end
        );

        self:OverwriteNeeds();
        self:InitLimitations();

        -- Garbage collection
        Lib.SettlementSurvival.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.SettlementSurvival.Global:OnSaveGameLoaded()
    self:RestoreSettlerSuspension();
end

-- Global report listener
function Lib.SettlementSurvival.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
        for PlayerID = 1, 8 do
            CustomRuleConstructBuilding(PlayerID, "SettlementSurvival_Global_ClaimTerritoryPredatorRule");
            CustomRuleConstructBuilding(PlayerID, "SettlementSurvival_Global_ClaimTerritoryBanditRule");
        end
    elseif _ID == Report.FireAlarmDeactivated_Internal then
        self:RestoreSettlerSuspension();
    elseif _ID == Report.FireAlarmActivated_Internal then
        self:RestoreSettlerSuspension();
    elseif _ID == Report.RepairAlarmDeactivated_Internal then
        self:RestoreSettlerSuspension();
    elseif _ID == Report.ReRepairAlarmActivated_Internal then
        self:RestoreSettlerSuspension();
    end
end

-- -------------------------------------------------------------------------- --

function Lib.SettlementSurvival.Global:InitLimitations()
    -- Check predators in territory
    SettlementSurvival_Global_ClaimTerritoryPredatorRule = function(_PlayerID, _Type, _X, _Y)
        if Lib.SettlementSurvival.Global.Misc.PredatorBlockClaim then
            if Logic.IsEntityTypeInCategory(_Type, EntityCategories.Outpost) == 1 then
                local TerritoryID1 = Logic.GetTerritoryAtPosition(_X, _Y);
                for _, SpawnerType in pairs(GetPredatorSpawnerTypes()) do
                    for _, SpawnerID in pairs(Logic.GetEntitiesOfType(SpawnerType)) do
                        local TerritoryID2 = GetTerritoryUnderEntity(SpawnerID);
                        if TerritoryID1 == TerritoryID2 then
                            for _, ID in pairs({Logic.GetSpawnedEntities(SpawnerID)}) do
                                local PlayerID = Logic.EntityGetPlayer(ID);
                                if PlayerID == 0 or (PlayerID ~= _PlayerID and GetDiplomacyState(PlayerID, _PlayerID) == -2) then
                                    return false;
                                end
                            end
                        end
                    end
                end
            end
        end
        return true;
    end

    -- Check bandits in territory
    SettlementSurvival_Global_ClaimTerritoryBanditRule = function(_PlayerID, _Type, _X, _Y)
        if Lib.SettlementSurvival.Global.Misc.BanditsBlockClaim then
            if Logic.IsEntityTypeInCategory(_Type, EntityCategories.Outpost) == 1 then
                local TerritoryID = Logic.GetTerritoryAtPosition(_X, _Y);
                for PlayerID = 1, 8 do
                    if PlayerID ~= _PlayerID and GetDiplomacyState(PlayerID, _PlayerID) == -2 then
                        local Bandits = {Logic.GetEntitiesOfCategoryInTerritory(TerritoryID, PlayerID, EntityCategories.BanditsCamp, 0)};
                        if #Bandits > 0 then
                            return false;
                        end
                    end
                end
            end
        end
        return true;
    end
end

-- -------------------------------------------------------------------------- --

-- Makes infected animals succum to their sickness if not treated. As an
-- intended exploit only animals in a pasture can die.
function Lib.SettlementSurvival.Global:ControlAnimalsSuccumToPlague(_Turn)
    local CurrentTime = math.floor(Logic.GetTime());
    local PlayerID = _Turn % 10;
    if self.AnimalPlague.IsActive and PlayerID >= 1 and PlayerID <= 8 then
        if self.AnimalPlague.AffectAI or Logic.PlayerGetIsHumanFlag(PlayerID) then
            -- Get animals
            local SheepList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.SheepPasture)};
            local CowList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.CattlePasture)};
            local AnimalList = Array_Append(SheepList, CowList);
            -- Register ill animals
            for i= 1, #AnimalList do
                if  not self.AnimalPlague[PlayerID][AnimalList[i]]
                and Logic.IsFarmAnimalInPasture(AnimalList[i])
                and Logic.IsFarmAnimalIll(AnimalList[i]) then
                    self.AnimalPlague[PlayerID][AnimalList[i]] = {CurrentTime};
                end
            end
            -- Unregister animals who recovered
            for AnimalID,v in pairs(self.AnimalPlague[PlayerID]) do
                if not IsExisting(AnimalID)
                or not Logic.IsFarmAnimalInPasture(AnimalID)
                or not Logic.IsFarmAnimalIll(AnimalID) then
                    self.AnimalPlague[PlayerID][AnimalID] = nil;
                end
            end
            -- Check who has to die
            local DeathTime = Lib.SettlementSurvival.Shared.AnimalPlague.DeathTimer;
            local ShowMessage = false;
            if CurrentTime % DeathTime == 0 then
                for AnimalID,_ in pairs(self.AnimalPlague[PlayerID]) do
                    local Chance = Lib.SettlementSurvival.Shared.AnimalPlague.DeathChance;
                    if GetPlayerResources(Goods.G_Herb, PlayerID) > 10 then
                        AddGood(Goods.G_Herb, -1, PlayerID);
                        Chance = Chance / 2;
                    end
                    if Chance >= 1 and math.random(1, 100) <= math.min(Chance, 100) then
                        SendReport(Report.AnimalDiedFromIllness, AnimalID);
                        SendReportToLocal(Report.AnimalDiedFromIllness, AnimalID);
                        SetHealth(AnimalID, 0);
                        ShowMessage = true;
                    end
                end
            end
            -- Show info
            if ShowMessage then
                self:Print(PlayerID, Lib.SettlementSurvival.Text.Alarms.AnimalDiedFromIllness);
            end
        end
    end
end

-- Job that makes animal corpses inside pastures decay if the lifestock module
-- is not installed what would do that automatically.
function Lib.SettlementSurvival.Global:ControlAnimalCorpsesDecay(_Turn)
    if not Lib.LifestockSystem or not Lib.LifestockSystem.Global.IsInstalled then
        if Logic.GetTime() % 10 == 0 then
            -- Cattle
            local CattleCorpses = Logic.GetEntitiesOfType(Entities.R_DeadCow);
            for k,v in pairs(CattleCorpses) do
                local x,y,z = Logic.EntityGetPos(v);
                local _,PastureID = Logic.GetEntitiesInArea(Entities.B_CattlePasture, x, y, 900, 1);
                if IsExisting(PastureID) then
                    local GoodAmount = Logic.GetResourceDoodadGoodAmount(v);
                    Logic.SetResourceDoodadGoodAmount(v, GoodAmount -1);
                end
            end
            -- Sheep
            local SheepCorpses = Logic.GetEntitiesOfType(Entities.R_DeadSheep);
            for k,v in pairs(SheepCorpses) do
                local x,y,z = Logic.EntityGetPos(v);
                local _,PastureID = Logic.GetEntitiesInArea(Entities.B_SheepPasture, x, y, 900, 1);
                if IsExisting(PastureID) then
                    local GoodAmount = Logic.GetResourceDoodadGoodAmount(v);
                    Logic.SetResourceDoodadGoodAmount(v, GoodAmount -1);
                end
            end
        end
    end
end

-- Controls the automatic infection of animals if activated. Animals not in
-- a pasture can not become sick.
function Lib.SettlementSurvival.Global:ControlAnimalInfections(_Turn)
    local CurrentTime = math.floor(Logic.GetTime())
    local PlayerID = _Turn % 10;
    if self.AnimalPlague.AnimalsBecomeSick then
        if self.AnimalPlague.IsActive and PlayerID >= 1 and PlayerID <= 8 then
            if self.AnimalPlague.AffectAI or Logic.PlayerGetIsHumanFlag(PlayerID) then
                local InfectionTimer = Lib.SettlementSurvival.Shared.AnimalPlague.InfectionTimer;
                if CurrentTime % InfectionTimer == 0 then
                    -- Get animals
                    local SheepList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.SheepPasture)};
                    local CowList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.CattlePasture)};
                    local AnimalList = Array_Append(SheepList, CowList);
                    -- Infect animals
                    local Chance = Lib.SettlementSurvival.Shared.AnimalPlague.InfectionChance;
                    for i= #AnimalList, 1, -1 do
                        if  Logic.IsFarmAnimalInPasture(AnimalList[i])
                        and not Logic.IsFarmAnimalIll(AnimalList[i]) then
                            if math.random(1, 100) <= Chance then
                                Logic.MakeFarmAnimalIll(AnimalList[i]);
                            end
                        end
                    end
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

-- When it is hot outside (usually 30°C ore more), buildings might catch fire
-- and water will be needed to extinguish them.
function Lib.SettlementSurvival.Global:ControlBuildingsDuringHotWeather(_Turn)
    local CurrentTime = math.floor(Logic.GetTime());
    local PlayerID = _Turn % 10;
    if self.HotWeather.IsActive and PlayerID >= 1 and PlayerID <= 8 then
        if self.HotWeather.AffectAI or Logic.PlayerGetIsHumanFlag(PlayerID) then
            if Logic.GetCurrentTemperature() >= Lib.SettlementSurvival.Shared.HotWeather.Temperature then
                local FireFrequency = Lib.SettlementSurvival.Shared.HotWeather.IgnitionTimer;
                if CurrentTime % FireFrequency == 0 then
                    -- Get buildings
                    local OuterRim = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.OuterRimBuilding)};
                    local City = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.CityBuilding)};
                    local BuildingList = Array_Append(OuterRim, City);
                    local AnyIgnited = false;
                    for i= 1, #BuildingList do
                        if  Logic.IsConstructionComplete(BuildingList[i]) == 1
                        and GetHealth(BuildingList[i]) >= 100
                        and not Logic.IsBurning(BuildingList[i]) then
                            local IgnitionChance = Lib.SettlementSurvival.Shared.HotWeather.IgnitionChance;
                            if math.random(1, 100) <= IgnitionChance then
                                Logic.DEBUG_SetBuildingOnFire(BuildingList[i], 10);
                                AnyIgnited = true;
                            end
                        end
                    end
                    if AnyIgnited then
                        self:Print(PlayerID, Lib.SettlementSurvival.Text.Alarms.BuildingBurning);
                    end
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

-- When it is cold outside (usually 5°C or less), wood will be consumed by all
-- buildings according to the amount of settlers. If there is not enough
-- firewood available, settlers will start to become sick.
function Lib.SettlementSurvival.Global:ControlBuildingsDuringColdWeather(_Turn)
    local CurrentTime = math.floor(Logic.GetTime());
    local PlayerID = _Turn % 10;
    if self.ColdWeather.IsActive and PlayerID >= 1 and PlayerID <= 8 then
        if self.ColdWeather.AffectAI or Logic.PlayerGetIsHumanFlag(PlayerID) then
            if Logic.GetCurrentTemperature() <= Lib.SettlementSurvival.Shared.ColdWeather.Temperature then
                local FirewoodFrequency = Lib.SettlementSurvival.Shared.ColdWeather.ConsumptionTimer;
                if CurrentTime % FirewoodFrequency == 0 then
                    -- Get settler amount
                    local EmployedSettlers = 0;
                    local OuterRim = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.OuterRimBuilding)};
                    local City = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.CityBuilding)};
                    local BuildingList = Array_Append(OuterRim, City);
                    for i= 1, #BuildingList do
                        if Logic.IsConstructionComplete(BuildingList[i]) == 1 then
                            local AttachedSettlersAmount = 0;
                            for _, SettlerID in pairs({Logic.GetWorkersAndSpousesForBuilding(BuildingList[i])}) do
                                if not self:IsSettlerSuspended(SettlerID) then
                                    AttachedSettlersAmount = AttachedSettlersAmount +1
                                end
                            end
                            if  Logic.IsNeedActive(BuildingList[i], Needs.Clothes)
                            and Logic.GetNeedState(BuildingList[i], Needs.Clothes) > 0.5 then
                                AttachedSettlersAmount = AttachedSettlersAmount * 0.5;
                            end
                            EmployedSettlers = EmployedSettlers + AttachedSettlersAmount;
                        end
                    end
                    -- Subtract firewood
                    local WoodCost = Lib.SettlementSurvival.Shared.ColdWeather.ConsumptionFactor * EmployedSettlers;
                    local WoodAmount = GetPlayerResources(Goods.G_Wood, PlayerID);
                    self.ColdWeather[PlayerID].Consumption = self.ColdWeather[PlayerID].Consumption + WoodCost;
                    if self.ColdWeather[PlayerID].Consumption > 1 then
                        local WoodCostFloored = math.floor(WoodCost);
                        AddGood(Goods.G_Wood, (-1) * math.min(WoodCostFloored, WoodAmount), PlayerID);
                        self.ColdWeather[PlayerID].Consumption = self.ColdWeather[PlayerID].Consumption - WoodCostFloored;
                    end
                    -- Enforce punishment
                    if WoodCost > WoodAmount then
                        local InfectionChance = Lib.SettlementSurvival.Shared.ColdWeather.InfectionChance;
                        for i= 1, #BuildingList do
                            if math.random(1, 100) <= InfectionChance then
                                Logic.MakeBuildingIll(BuildingList[i]);
                            end
                        end
                        self:Print(PlayerID, Lib.SettlementSurvival.Text.Alarms.SettlerTemperature);
                    end
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

-- When the need for hygiene or entertainment is not fulfilled, settlers will
-- become sick because of dirt or depression. Or maybe both...
function Lib.SettlementSurvival.Global:ControlSettlersBecomeIllDueToNegligence(_Turn)
    local CurrentTime = math.floor(Logic.GetTime());
    local PlayerID = _Turn % 10;
    if  self.Negligence.IsActive and PlayerID >= 1 and PlayerID <= 8 then
        if self.Negligence.AffectAI or Logic.PlayerGetIsHumanFlag(PlayerID) then
            -- Get settlers
            local SpouseList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.Spouse)};
            local WorkerList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.Worker)};
            WorkerList = Array_Append(SpouseList, WorkerList);
            -- Register settlers
            for i= 1, #WorkerList do
                if  not self.Negligence[PlayerID][WorkerList[i]]
                and Logic.GetEntityType(WorkerList[i]) ~= Entities.U_Pharmacist
                and (self:IsSettlerDirty(WorkerList[i]) or self:IsSettlerBored(WorkerList[i]))
                and not self:IsSettlerSuspended(WorkerList[i])
                and not Logic.IsIll(WorkerList[i]) then
                    self.Negligence[PlayerID][WorkerList[i]] = {CurrentTime};
                end
            end
            -- Unregister settlers
            for SettlerID,v in pairs(self.Negligence[PlayerID]) do
                if  not self:IsSettlerBored(SettlerID) and not self:IsSettlerDirty(SettlerID) then
                    self.Negligence[PlayerID][SettlerID] = nil;
                end
            end
            -- Check who becomes ill
            local InfectionTimer = Lib.SettlementSurvival.Shared.Negligence.InfectionTimer;
            local ShowMessage = false;
            if CurrentTime % InfectionTimer == 0 then
                for SettlerID,v in pairs(self.Negligence[PlayerID]) do
                    if v[1] + InfectionTimer < CurrentTime then
                        local Chance = Lib.SettlementSurvival.Shared.AnimalPlague.InfectionChance;
                        if math.random(1, 100) <= Chance then
                            if  not self:IsSettlerCarryingHygiene(SettlerID)
                            and not self:IsSettlerCarryingBeer(SettlerID)
                            and not self:IsSettlerSuspended(SettlerID)
                            and self:IsSettlerStriking(SettlerID) then
                                Logic.MakeSettlerIll(SettlerID);
                                ShowMessage = true;
                            end
                        end
                    end
                end
            end

            -- Show info
            if ShowMessage then
                self:Print(PlayerID, Lib.SettlementSurvival.Text.Alarms.SettlerNegligence);
            end
        end
    end
end

function Lib.SettlementSurvival.Global:IsSettlerDirty(_Entity)
    local EntityID = GetID(_Entity);
    local BuildingID = Logic.GetSettlersWorkBuilding(EntityID);
    return Logic.IsNeedCritical(BuildingID, Needs.Hygiene);
end

function Lib.SettlementSurvival.Global:IsSettlerBored(_Entity)
    local EntityID = GetID(_Entity);
    local BuildingID = Logic.GetSettlersWorkBuilding(EntityID);
    return Logic.IsNeedCritical(BuildingID, Needs.Entertainment);
end

function Lib.SettlementSurvival.Global:IsSettlerCarryingHygiene(_Entity)
    local EntityID = GetID(_Entity);
    local TaskList = Logic.GetCurrentTaskList(EntityID);
    return TaskList and TaskList:find("_HYGIENE");
end

function Lib.SettlementSurvival.Global:IsSettlerCarryingBeer(_Entity)
    local EntityID = GetID(_Entity);
    local TaskList = Logic.GetCurrentTaskList(EntityID);
    return TaskList and TaskList:find("_ENTERTAINMENT");
end

-- -------------------------------------------------------------------------- --

-- Controls if a settler starves to death.
function Lib.SettlementSurvival.Global:ControlSettlersSuccumToFamine(_Turn)
    local CurrentTime = math.floor(Logic.GetTime());
    local PlayerID = _Turn % 10;
    if  self.Famine.IsActive and PlayerID >= 1 and PlayerID <= 8 then
        if self.Famine.AffectAI or Logic.PlayerGetIsHumanFlag(PlayerID) then
            -- Get settlers
            local SpouseList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.Spouse)};
            local WorkerList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.Worker)};
            WorkerList = Array_Append(SpouseList, WorkerList);
            -- Register ill settlers
            for i= 1, #WorkerList do
                if  not self.Famine[PlayerID][WorkerList[i]]
                and self:IsSettlerHungry(WorkerList[i])
                and not self:IsSettlerSuspended(WorkerList[i]) then
                    self.Famine[PlayerID][WorkerList[i]] = {CurrentTime};
                end
            end
            -- Unregister settlers who recovered
            for SettlerID,v in pairs(self.Famine[PlayerID]) do
                if not IsExisting(SettlerID) or not self:IsSettlerHungry(SettlerID) then
                    self.Famine[PlayerID][SettlerID] = nil;
                end
            end
            -- Check who has to die
            local DeathTime = Lib.SettlementSurvival.Shared.Famine.DeathTimer;
            local ShowMessage = false;
            if CurrentTime % DeathTime == 0 then
                for SettlerID,v in pairs(self.Famine[PlayerID]) do
                    if  not self:IsSettlerCarryingFood(SettlerID)
                    and not self:IsSettlerSuspended(SettlerID)
                    and self:IsSettlerStriking(SettlerID) then
                        local Chance = Lib.SettlementSurvival.Shared.Famine.DeathChance;
                        if Chance >= 1 and math.random(1, 100) <= math.ceil(Chance) then
                            SendReport(Report.SettlerDiedFromStarvation, SettlerID);
                            SendReportToLocal(Report.SettlerDiedFromStarvation, SettlerID);
                            self:SuspendSettler(SettlerID, true);
                            ShowMessage = true;
                        end
                    end
                end
            end
            -- Show info
            if ShowMessage then
                self:Print(PlayerID, Lib.SettlementSurvival.Text.Alarms.SettlerDiedFromHunger);
            end
        end
    end
end

function Lib.SettlementSurvival.Global:IsSettlerHungry(_Entity)
    local EntityID = GetID(_Entity);
    local BuildingID = Logic.GetSettlersWorkBuilding(EntityID);
    return Logic.IsNeedCritical(BuildingID, Needs.Nutrition);
end

function Lib.SettlementSurvival.Global:IsSettlerCarryingFood(_Entity)
    local EntityID = GetID(_Entity);
    local TaskList = Logic.GetCurrentTaskList(EntityID);
    return TaskList and (TaskList:find("_NUTRITION") or TaskList:find("_FOOD"));
end

-- -------------------------------------------------------------------------- --

-- Makes settler die from illness if not treated.
function Lib.SettlementSurvival.Global:ControlSettlersSuccumToPlague(_Turn)
    local CurrentTime = math.floor(Logic.GetTime());
    local PlayerID = _Turn % 10;
    if  self.Plague.IsActive and PlayerID >= 1 and PlayerID <= 8 then
        if self.Plague.AffectAI or Logic.PlayerGetIsHumanFlag(PlayerID) then
            -- Get settlers
            local SpouseList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.Spouse)};
            local WorkerList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.Worker)};
            WorkerList = Array_Append(SpouseList, WorkerList);
            -- Register ill settlers
            for i= 1, #WorkerList do
                if  not self.Plague[PlayerID][WorkerList[i]]
                and Logic.GetEntityType(WorkerList[i]) ~= Entities.U_Pharmacist
                and Logic.IsIll(WorkerList[i])
                and not self:IsSettlerSuspended(WorkerList[i]) then
                    self.Plague[PlayerID][WorkerList[i]] = {CurrentTime};
                end
            end
            -- Unregister settlers who recovered
            for SettlerID,v in pairs(self.Plague[PlayerID]) do
                if not IsExisting(SettlerID) or not Logic.IsIll(SettlerID) then
                    self.Plague[PlayerID][SettlerID] = nil;
                end
            end
            -- Check who has to die
            local DeathTime = Lib.SettlementSurvival.Shared.Plague.DeathTimer;
            local ShowMessage = false;
            if CurrentTime % DeathTime == 0 then
                for SettlerID,v in pairs(self.Plague[PlayerID]) do
                    if  not self:IsSettlerCarryingMedicine(SettlerID)
                    and not self:IsSettlerSuspended(SettlerID)
                    and self:IsSettlerStriking(SettlerID) then
                        local Chance = Lib.SettlementSurvival.Shared.Plague.DeathChance;
                        if GetPlayerResources(Goods.G_Herb, PlayerID) > 10 then
                            AddGood(Goods.G_Herb, -1, PlayerID);
                            Chance = Chance / 2;
                        end
                        if Chance >= 1 and math.random(1, 100) <= math.ceil(Chance) then
                            SendReport(Report.SettlerDiedFromIllness, SettlerID);
                            SendReportToLocal(Report.SettlerDiedFromIllness, SettlerID);
                            self:SuspendSettler(SettlerID, true);
                            ShowMessage = true;
                        end
                    end
                end
            end
            -- Show info
            if ShowMessage then
                self:Print(PlayerID, Lib.SettlementSurvival.Text.Alarms.SettlerDiedFromIllness);
            end
        end
    end
end

function Lib.SettlementSurvival.Global:IsSettlerCarryingMedicine(_Entity)
    local EntityID = GetID(_Entity);
    local TaskList = Logic.GetCurrentTaskList(EntityID);
    return TaskList and TaskList:find("_MEDICINE");
end

-- -------------------------------------------------------------------------- --

-- Resumes a settler.
function Lib.SettlementSurvival.Global:ResumeSettler(_Entity)
    local EntityID = GetID(_Entity);
    local PlayerID = Logic.EntityGetPlayer(EntityID);
    local StoreHouseID = Logic.GetStoreHouse(PlayerID);
    if StoreHouseID ~= 0 then
        -- Resume settler
        Logic.SetTaskList(EntityID, TaskLists.TL_WAIT_THEN_WALK);
        Logic.SetVisible(EntityID, true);
        -- Remove from suspension list
        if self.SuspendedSettlers[PlayerID][EntityID] then
            ExecuteLocal("Lib.SettlementSurvival.Local.SuspendedSettlers[%d][%d] = nil", PlayerID, EntityID);
            self.SuspendedSettlers[PlayerID][EntityID] = nil;
        end
    end
end

-- Suspend a settler.
function Lib.SettlementSurvival.Global:SuspendSettler(_Entity, _Mourn)
    local EntityID = GetID(_Entity);
    local PlayerID = Logic.EntityGetPlayer(EntityID);
    local StoreHouseID = Logic.GetStoreHouse(PlayerID);
    if StoreHouseID ~= 0 then
        -- Reset needs if building empty
        local BuildingID = Logic.GetSettlersWorkBuilding(EntityID);
        local AttachedSettlers = {Logic.GetWorkersAndSpousesForBuilding(BuildingID)};
        local AnyNotSuspended = false;
        for i= 1, #AttachedSettlers do
            if not self:IsSettlerSuspended(_Entity) then
                AnyNotSuspended = true;
                break;
            end
        end
        if AnyNotSuspended == false then
            Logic.SetNeedState(EntityID, Needs.Nutrition, 1.0);
            Logic.SetNeedState(EntityID, Needs.Entertainment, 1.0);
            Logic.SetNeedState(EntityID, Needs.Clothes, 1.0);
            Logic.SetNeedState(EntityID, Needs.Hygiene, 1.0);
            Logic.SetNeedState(EntityID, Needs.Medicine, 1.0);
        end
        -- Relocate inside storehouse and make invisible
        local x,y,z = Logic.EntityGetPos(StoreHouseID);
        Logic.DEBUG_SetSettlerPosition(EntityID, x, y);
        Logic.SetVisible(EntityID, false);
        Logic.SetTaskList(EntityID, TaskLists.TL_NPC_IDLE);
        -- Add to suspended settler map
        if not self.SuspendedSettlers[PlayerID][EntityID] then
            local Time = (_Mourn and Logic.GetTime()) or -1;
            ExecuteLocal("Lib.SettlementSurvival.Local.SuspendedSettlers[%d][%d] = {%d}", PlayerID, EntityID, Time);
            self.SuspendedSettlers[PlayerID][EntityID] = {Time};
        end
    end
end

function Lib.SettlementSurvival.Global:IsSettlerSuspended(_Entity)
    local EntityID = GetID(_Entity);
    local PlayerID = Logic.EntityGetPlayer(EntityID);
    return self.SuspendedSettlers[PlayerID] and self.SuspendedSettlers[PlayerID][EntityID] ~= nil;
end

function Lib.SettlementSurvival.Global:HasSuspendedInhabitants(_Entity)
    local BuildingID = GetID(_Entity)
    local AttachedSettlers = {Logic.GetWorkersAndSpousesForBuilding(BuildingID)};
    for i= 1, #AttachedSettlers do
        if self:IsSettlerSuspended(AttachedSettlers[i]) then
            return true;
        end
    end
    return false;
end

-- Restores tasklist and position of fake dead settlers.
function Lib.SettlementSurvival.Global:RestoreSettlerSuspension()
    for PlayerID = 1, 8 do
        for k,v in pairs(self.SuspendedSettlers[PlayerID]) do
            if not IsExisting(k) then
                ExecuteLocal("Lib.SettlementSurvival.Local.SuspendedSettlers[%d][%d] = nil", PlayerID, k);
                self.SuspendedSettlers[PlayerID][k] = nil;
            else
                self:SuspendSettler(k);
            end
        end
    end
end

-- Removes the suspended settler after the mourning time is over.
function Lib.SettlementSurvival.Global:ResumeSettlersAfterMourning(_Turn)
    local MournTime = Lib.SettlementSurvival.Shared.SuspendedSettlers.MourningTime;
    local CurrentTime = Logic.GetTime();
    local PlayerID = _Turn % 10;
    if PlayerID >= 1 and PlayerID <= 8 then
        for k,v in pairs(self.SuspendedSettlers[PlayerID]) do
            if v[1] > -1 and v[1] + MournTime <= CurrentTime then
                self:ResumeSettler(k);
                DestroyEntity(k);
            end
        end
    end
end

function Lib.SettlementSurvival.Global:IsSettlerStriking(_Entity)
    local EntityID = GetID(_Entity);
    local PlayerID = Logic.EntityGetPlayer(EntityID);
    local TaskList = Logic.GetCurrentTaskList(EntityID);
    local MarketID = Logic.GetMarketplace(PlayerID);
    if MarketID ~= 0 and TaskList == "TL_WORKER_IDLE_UNFIT" then
        if Logic.IsEntityMoving(EntityID) == false then
            return Logic.CheckEntitiesDistance(EntityID, MarketID, 1500) == true;
        end
    end
    return false;
end

-- -------------------------------------------------------------------------- --

function Lib.SettlementSurvival.Global:OverwriteNeeds()
    ActivateNeedsForBuilding = function(_PlayerID, _EntityID)
        for Need, _ in pairs (PlayerActiveNeeds[_PlayerID]) do
            if Logic.IsEntityInCategory(_EntityID, EntityCategories.OuterRimBuilding) == 1 then
                if Need == Needs.Nutrition
                or Need == Needs.Medicine then
                    Logic.SetNeedActive(_EntityID, Need, true);
                end
                if Need == Needs.Clothes then
                    local Active = Lib.SettlementSurvival.Global.Misc.ClothesForOuterRim;
                    Logic.SetNeedActive(_EntityID, Need, Active == true);
                end
            end
            if Logic.IsEntityInCategory(_EntityID, EntityCategories.CityBuilding) == 1 then
                Logic.SetNeedActive(_EntityID, Need, true);
            end
        end
        Logic.ExecuteInLuaLocalState("GUI_BuildingInfo.UpdateActiveNeedsGUI()");
    end

    ActivateNeedForPlayer = function(_PlayerID, _NeedTable)
        if _NeedTable == nil then
            return;
        end

        local OuterRimNeeds = {
            [Needs.Nutrition] = true,
            [Needs.Medicine] = true,
        };
        if Lib.SettlementSurvival.Global.Misc.ClothesForOuterRim then
            OuterRimNeeds[Needs.Clothes] = true;
        end

        for k =1, #_NeedTable do
            local Need = _NeedTable[k];
            PlayerActiveNeeds[_PlayerID][Need] = true;
            local Buildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID,EntityCategories.CityBuilding)};
            if OuterRimNeeds[Need] then
                local OuterRimBuildings = {Logic.GetPlayerEntitiesInCategory(_PlayerID,EntityCategories.OuterRimBuilding)};
                for j=1, #OuterRimBuildings do
                    local BuildingID = OuterRimBuildings[j];
                    table.insert(Buildings, BuildingID);
                end
            end
            for i=1, #Buildings do
                local BuildingID = Buildings[i];
                Logic.SetNeedActive(BuildingID, Need, true);
            end
            Logic.ExecuteInLuaLocalState("GUI_BuildingInfo.UpdateActiveNeedsGUI()");
        end
    end
end

function Lib.SettlementSurvival.Global:UpdateClothesStateForOuterRim()
    for PlayerID = 1, 8 do
        local OuterRimBuildings = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.OuterRimBuilding)};
        for i=1, #OuterRimBuildings do
            local BuildingID = OuterRimBuildings[i];
            if  Lib.SettlementSurvival.Global.Misc.ClothesForOuterRim
            and PlayerActiveNeeds[PlayerID][Needs.Clothes] then
                Logic.SetNeedActive(BuildingID, Needs.Clothes, true);
            else
                Logic.SetNeedActive(BuildingID, Needs.Clothes, false);
            end
        end
    end
end

function Lib.SettlementSurvival.Global:Print(_PlayerID, _Text)
    local Text = ConvertPlaceholders(Localize(_Text));
    ExecuteLocal([[
        if GUI.GetPlayerID() == %d then
            GUI.ClearNotes()
            GUI.AddNote("%s")
        end
    ]], _PlayerID, Text);
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.SettlementSurvival.Local:Initialize()
    if not self.IsInstalled then
        Report.FireAlarmDeactivated_Internal = CreateReport("Event_FireAlarmDeactivated_Internal");
        Report.FireAlarmActivated_Internal = CreateReport("Event_FireAlarmActivated_Internal");
        Report.RepairAlarmDeactivated_Internal = CreateReport("Event_RepairAlarmFeactivated");
        Report.ReRepairAlarmActivated_Internal = CreateReport("Event_ReRepairAlarmActivated_Internal");
        Report.AnimalDiedFromIllness = CreateReport("Event_AnimalDiedFromIllness");
        Report.SettlerDiedFromStarvation = CreateReport("Event_SettlerDiedFromStarvation");
        Report.SettlerDiedFromIllness = CreateReport("Event_SettlerDiedFromIllness");

        self:OverrideSelectionChanged();
        self:OverwriteAlarmButtons();
        self:OverwriteGameCallbacks();
        self:OverwriteJumpToWorker();
        self:OverwriteUpgradeButton();

        for PlayerID = 1,8 do
            self.SuspendedSettlers[PlayerID] = {};
        end

        -- Garbage collection
        Lib.SettlementSurvival.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.SettlementSurvival.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.SettlementSurvival.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

function Lib.SettlementSurvival.Local:OverwriteJumpToWorker()
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingInfo.JumpToWorkerClicked = function()
        Sound.FXPlay2DSound( "ui\\menu_click");
        local PlayerID = GUI.GetPlayerID();
        local SelectedEntityID = GUI.GetSelectedEntity();
        local InhabitantsBuildingID = 0;
        local IsSettlerSelected;
        if Logic.IsBuilding(SelectedEntityID) == 1 then
            InhabitantsBuildingID = SelectedEntityID;
            IsSettlerSelected = false;
        else
            if Logic.IsWorker(SelectedEntityID) == 1
            or Logic.IsSpouse(SelectedEntityID) == true
            or Logic.GetEntityType(SelectedEntityID) == Entities.U_Priest then
                InhabitantsBuildingID = Logic.GetSettlersWorkBuilding(SelectedEntityID);
                IsSettlerSelected = true;
            end
        end
        if InhabitantsBuildingID ~= 0 then
            local WorkersAndSpousesInBuilding = {Logic.GetWorkersAndSpousesForBuilding(InhabitantsBuildingID)}

            -- To pretend settlers of the building have died, we need to remove
            -- them from the intabitants list.
            for i = #WorkersAndSpousesInBuilding, 1, -1 do
                local SettlerID = WorkersAndSpousesInBuilding[i];
                if Lib.SettlementSurvival.Local.SuspendedSettlers[PlayerID] then
                    if Lib.SettlementSurvival.Local.SuspendedSettlers[PlayerID][SettlerID] then
                        table.remove(WorkersAndSpousesInBuilding, i);
                    end
                end
            end

            local InhabitantID
            if g_CloseUpView.Active == false and IsSettlerSelected == true then
                InhabitantID = SelectedEntityID;
            else
                local InhabitantPosition = 1;
                for i = 1, #WorkersAndSpousesInBuilding do
                    if WorkersAndSpousesInBuilding[i] == g_LastSelectedInhabitant then
                        InhabitantPosition = i + 1;
                        break;
                    end
                end
                InhabitantID = WorkersAndSpousesInBuilding[InhabitantPosition];
                if InhabitantID == 0 then
                    InhabitantID = WorkersAndSpousesInBuilding[InhabitantPosition + 1];
                end
            end
            if InhabitantID == nil then
                local x,y = Logic.GetEntityPosition(InhabitantsBuildingID);
                g_LastSelectedInhabitant = nil;
                ShowCloseUpView(0, x, y);
                GUI.SetSelectedEntity(InhabitantsBuildingID);
            else
                GUI.SetSelectedEntity(InhabitantID);
                ShowCloseUpView(InhabitantID);
                g_LastSelectedInhabitant = InhabitantID;
            end
        end
    end
end

function Lib.SettlementSurvival.Local:IsSettlerSuspended(_Entity)
    local EntityID = GetID(_Entity);
    local PlayerID = Logic.EntityGetPlayer(EntityID);
    return self.SuspendedSettlers[PlayerID] and self.SuspendedSettlers[PlayerID][EntityID] ~= nil;
end

function Lib.SettlementSurvival.Local:HasSuspendedInhabitants(_Entity)
    local BuildingID = GetID(_Entity);
    local AttachedSettlers = {Logic.GetWorkersAndSpousesForBuilding(BuildingID)};
    for i= 1, #AttachedSettlers do
        if self:IsSettlerSuspended(AttachedSettlers[i]) then
            return true;
        end
    end
    return false;
end

function Lib.SettlementSurvival.Local:OverwriteGameCallbacks()
    self.Orig_GameCallback_Feedback_OnBuildingBurning = GameCallback_Feedback_OnBuildingBurning;
    GameCallback_Feedback_OnBuildingBurning = function(_PlayerID, _EntityID)
        Lib.SettlementSurvival.Local.Orig_GameCallback_Feedback_OnBuildingBurning(_PlayerID, _EntityID);
        SendReportToGlobal(Report.FireAlarmActivated_Internal, _EntityID);
    end

    self.Orig_GameCallback_GUI_DeleteEntityStateBuilding = GameCallback_GUI_DeleteEntityStateBuilding;
    GameCallback_GUI_DeleteEntityStateBuilding = function(_BuildingID, _State)
        if Lib.SettlementSurvival.Local:HasSuspendedInhabitants(_BuildingID) then
            Message(Localize(Lib.SettlementSurvival.Text.Messages.BuildingMourning));
            GUI.CancelBuildingKnockDown(_BuildingID);
            return;
        end
        Lib.SettlementSurvival.Local.Orig_GameCallback_GUI_DeleteEntityStateBuilding(_BuildingID, _State);
    end
end

function Lib.SettlementSurvival.Local:OverwriteAlarmButtons()
    GUI_BuildingButtons.StartStopFireAlarmClicked_Orig_SettlementSurvival = GUI_BuildingButtons.StartStopFireAlarmClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.StartStopFireAlarmClicked = function()
        GUI_BuildingButtons.StartStopFireAlarmClicked_Orig_SettlementSurvival();
        local EntityID = GUI.GetSelectedEntity()
        if Logic.IsFireAlarmActiveAtBuilding(EntityID) == true then
            SendReportToGlobal(Report.FireAlarmActivated_Internal, EntityID);
        else
            SendReportToGlobal(Report.FireAlarmDeactivated_Internal, EntityID);
        end
    end

    GUI_BuildingButtons.StartStopRepairAlarmClicked_Orig_SettlementSurvival = GUI_BuildingButtons.StartStopRepairAlarmClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.StartStopRepairAlarmClicked = function()
        GUI_BuildingButtons.StartStopRepairAlarmClicked_Orig_SettlementSurvival();
        local EntityID = GUI.GetSelectedEntity()
        if Logic.IsRepairAlarmActiveAtBuilding(EntityID) == true then
            SendReportToGlobal(Report.ReRepairAlarmActivated_Internal, EntityID);
        else
            SendReportToGlobal(Report.RepairAlarmDeactivated_Internal, EntityID);
        end
    end
end

function Lib.SettlementSurvival.Local:OverwriteUpgradeButton()
    -- This creates a dependency to module/ui/uibuilding
    GUI_BuildingButtons.UpgradeClicked_Orig_SettlementSurvival = GUI_BuildingButtons.UpgradeClicked;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_BuildingButtons.UpgradeClicked = function()
        local BuildingID = GUI.GetSelectedEntity();
        if Lib.SettlementSurvival.Local:HasSuspendedInhabitants(BuildingID) then
            Message(Localize(Lib.SettlementSurvival.Text.Messages.BuildingMourning));
            GUI.CancelBuildingKnockDown(BuildingID);
            return;
        end
        GUI_BuildingButtons.UpgradeClicked_Orig_SettlementSurvival();
    end
end

function Lib.SettlementSurvival.Local:OverrideSelectionChanged()
    self.Orig_GameCallback_GUI_SelectionChanged = GameCallback_GUI_SelectionChanged;
    GameCallback_GUI_SelectionChanged = function(_Source)
        Lib.SettlementSurvival.Local.Orig_GameCallback_GUI_SelectionChanged(_Source);
        Lib.SettlementSurvival.Local:OnBuildingSelected();
    end
end

function Lib.SettlementSurvival.Local:OnBuildingSelected()
    local EntityID = GUI.GetSelectedEntity();
    if Logic.IsEntityInCategory(EntityID, EntityCategories.OuterRimBuilding) == 1 then
        if self.Misc.ClothesForOuterRim then
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Needs/Clothes", 1);
        else
            XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomRight/Selection/Needs/Clothes", 0);
        end
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.SettlementSurvival.Name);

Lib.Register("module/mode/SettlementLimitation_Text");

Lib.SettlementLimitation = Lib.SettlementLimitation or {};
Lib.SettlementLimitation.Text = {
    DevelopTerritory = {
        Title = {
            de = "Territorium entwickeln",
            en = "Develop territory",
            fr = "Développer le territoire",
        },
        Text = {
            de = "Entwickelt das Territorium fort, um ein weiteres Gebäude zu errichten.",
            en = "Develop the territory to be able to build another building.",
            fr = "Aménager le territoire pour construire un autre bâtiment.",
        },
        DisabledUpgrade = {
            de = "Benötigt Ausbau!",
            en = "Requires Upgrade!",
            fr = "Nécessite une mise à jour!",
        },
        DisabledDone = {
            de = "Wurde bereits entwickelt!",
            en = "Territory already developed!",
            fr = "Territoire déjà aménagé!",
        }
    },

    BuildingLimit = {
        de = "Gebäude: ",
        en = "Buildings: ",
        fr = "Imeuble: ",
    },
}

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/mode/SettlementLimitation_API");

function ActivateSettlementLimitation(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("ActivateSettlementLimitation(%s)", tostring(_Flag == true));
    end
    Lib.SettlementLimitation.AquireContext();
    this.Active = _Flag == true;
    Lib.SettlementLimitation.ReleaseContext();
end
API.ActivateSettlementLimitation = ActivateSettlementLimitation;

function UseWallUpkeepCosts(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("UseWallUpkeepCosts(%s)", tostring(_Flag == true));
    end
    Lib.SettlementLimitation.AquireContext();
    this.WallUpkeepCosts = _Flag == true;
    Lib.SettlementLimitation.ReleaseContext();
end
API.UseWallUpkeepCosts = UseWallUpkeepCosts;

function UseWallDeteriation(_Flag)
    if not IsLocalScript() then
        ExecuteLocal("UseWallDeteriation(%s)", tostring(_Flag == true));
    end
    Lib.SettlementLimitation.AquireContext();
    this.WallDeteriation = _Flag == true;
    Lib.SettlementLimitation.ReleaseContext();
end
API.UseWallDeteriation = UseWallDeteriation;

function RequireTitleToDevelopTerritory(_Title)
    assert(not IsLocalScript(), "Can not be used in local script!");
    ExecuteLocal([[
        table.insert(NeedsAndRightsByKnightTitle[%d][4], 1, Technologies.R_RuralLogistics)
        CreateTechnologyKnightTitleTable()
    ]], _Title);
    table.insert(NeedsAndRightsByKnightTitle[_Title][4], 1, Technologies.R_RuralLogistics);
    CreateTechnologyKnightTitleTable()
    for i= 1, 8 do
        Logic.TechnologySetState(i, Technologies.R_RuralLogistics, 0);
    end
end
API.RequireTitleToDevelopTerritory = RequireTitleToDevelopTerritory;

function AllowDevelopTerritory(_PlayerID, _Allowed)
    assert(not IsLocalScript(), "Can not be used in local script!");
    Logic.TechnologySetState(_PlayerID, Technologies.R_RuralLogistics, (_Allowed and 3 or 1));
end
API.AllowDevelopTerritory = AllowDevelopTerritory;

function SetTerritoryBuildingLimit(_PlayerID, _Territory, _Limit)
    local TerritoryID = GetTerritoryID(_Territory);
    if not IsLocalScript() then
        ExecuteLocal("SetTerritoryBuildingLimit(%d,%d,%d)", _PlayerID, TerritoryID, _Limit);
    end
    Lib.SettlementLimitation.AquireContext();
    this.TerritoryRestriction[_PlayerID][TerritoryID] = _Limit;
    Lib.SettlementLimitation.ReleaseContext();
end
API.SetTerritoryBuildingLimit = SetTerritoryBuildingLimit;

function SetTerritoryBuildingTypeLimit(_PlayerID, _Territory, _Type, _Limit)
    local TerritoryID = GetTerritoryID(_Territory);
    if not IsLocalScript() then
        ExecuteLocal("SetTerritoryBuildingTypeLimit(%d,%d,%d,%d)", _PlayerID, TerritoryID, _Type, _Limit);
    end
    Lib.SettlementLimitation.AquireContext();
    if not this.TerritoryTypeRestriction[_PlayerID][TerritoryID] then
        this.TerritoryTypeRestriction[_PlayerID][TerritoryID] = {};
    end
    this.TerritoryTypeRestriction[_PlayerID][TerritoryID][_Type] = _Limit;
    Lib.SettlementLimitation.ReleaseContext();
end
API.SetTerritoryBuildingTypeLimit = SetTerritoryBuildingTypeLimit;

function ClearTerritoryBuildingLimit(_PlayerID, _Territory)
    local TerritoryID = GetTerritoryID(_Territory);
    if not IsLocalScript() then
        ExecuteLocal("SetTerritoryBuildingTypeLimit(%d,%d)", _PlayerID, TerritoryID);
    end
    Lib.SettlementLimitation.AquireContext();
    this.TerritoryRestriction[_PlayerID][TerritoryID] = nil;
    Lib.SettlementLimitation.ReleaseContext();
end
API.ClearTerritoryBuildingLimit = ClearTerritoryBuildingLimit;

function ClearTerritoryBuildingTypeLimit(_PlayerID, _Territory, _Type)
    local TerritoryID = GetTerritoryID(_Territory);
    if not IsLocalScript() then
        ExecuteLocal("ClearTerritoryBuildingTypeLimit(%d,%d,%d)", _PlayerID, TerritoryID, _Type);
    end
    Lib.SettlementLimitation.AquireContext();
    if not this.TerritoryTypeRestriction[_PlayerID][TerritoryID] then
        this.TerritoryTypeRestriction[_PlayerID][TerritoryID] = {};
    end
    this.TerritoryTypeRestriction[_PlayerID][TerritoryID][_Type] = nil;
    Lib.SettlementLimitation.ReleaseContext();
end
API.ClearTerritoryBuildingTypeLimit = ClearTerritoryBuildingTypeLimit;

function SetTerritoryDevelopmentCost(_CostType1, _Amount1, _CostType2, _Amount2)
    if not IsLocalScript() then
        ExecuteLocal(
            "SetTerritoryDevelopmentCost(%s,%s,%s,%s)",
            tostring(_CostType1),
            tostring(_Amount1),
            tostring(_CostType2 or nil),
            tostring(_Amount2 or nil)
        );
    end
    Lib.SettlementLimitation.AquireContext();
    this.DevelopTerritoryCosts = {_CostType1, _Amount1, _CostType2, _Amount2};
    Lib.SettlementLimitation.ReleaseContext();
end
API.SetTerritoryDevelopmentCost = SetTerritoryDevelopmentCost;

Lib.SettlementLimitation = Lib.SettlementLimitation or {};
Lib.SettlementLimitation.Name = "SettlementLimitation";
Lib.SettlementLimitation.Global = {
    Active = false,
    TerritoryRestriction = {},
    TerritoryTypeRestriction = {},
    AdditionalBuildingBonus = {},
    MultiConstructionBonus = {},
    WallUpkeepCosts = false,
    WallDeteriation = false,
};
Lib.SettlementLimitation.Local  = {
    Active = false,
    TerritoryRestriction = {},
    TerritoryTypeRestriction = {},
    AdditionalBuildingBonus = {},
    MultiConstructionBonus = {},
    WallUpkeepCosts = false,
    WallDeteriation = false,
};
Lib.SettlementLimitation.Shared = {
    DevelopTerritoryCosts = {Goods.G_Gold, 500},
    CityBuildings = {},
    OuterRimBuildings = {},
    WallDeteriation = {
        Health = 10,
        Chance = 15,
    },
    Upkeep = {
        Palisade = 0.3,
        Wall = 1.5,
    },
    AbsolutLimitIgnore = {
        ["B_Beehive"] = true,
        ["B_GrainField_AS"] = true,
        ["B_GrainField_ME"] = true,
        ["B_GrainField_NA"] = true,
        ["B_GrainField_NE"] = true,
        ["B_GrainField_SE"] = true,
    },
};

Lib.Require("comfort/GetDistance");
Lib.Require("comfort/GetTerritoryID");
Lib.Require("core/Core");
Lib.Require("module/city/Construction");
Lib.Require("module/entity/EntityEvent");
Lib.Require("module/faker/Technology");
Lib.Require("module/ui/UIBuilding");
Lib.Require("module/ui/UITools");
Lib.Require("module/mode/SettlementLimitation_API");
Lib.Require("module/mode/SettlementLimitation_Text");
Lib.Register("module/mode/SettlementLimitation");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.SettlementLimitation.Global:Initialize()
    if not self.IsInstalled then
        for PlayerID = 1, 8 do
            self.TerritoryRestriction[PlayerID] = {};
            self.TerritoryTypeRestriction[PlayerID] = {};
            self.AdditionalBuildingBonus[PlayerID] = {};
            self.MultiConstructionBonus[PlayerID] = {};
        end
        Lib.SettlementLimitation.Shared:CreateTypeLists();

        self:InitConstructionLimitRules();
        self:InitWallUpkeep();

        -- Garbage collection
        Lib.SettlementLimitation.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.SettlementLimitation.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.SettlementLimitation.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
        for PlayerID = 1, 8 do
            self:InitDefaultRules(PlayerID);
            CustomRuleConstructBuilding(PlayerID, "SettlementLimitation_Global_TerritoryBuildingGeneralLimitRule");
            CustomRuleConstructBuilding(PlayerID, "SettlementLimitation_Global_TerritoryBuildingTypeLimitRule");
            CustomRuleConstructBuilding(PlayerID, "SettlementLimitation_Global_HomeTerritoryBuildingGeneralLimitRule");
            CustomRuleConstructBuilding(PlayerID, "SettlementLimitation_Global_HomeTerritoryBuildingTypeLimitRule");
        end
    elseif _ID == Report.BuildingUpgraded then
        local Costs = Lib.SettlementLimitation.Shared.DevelopTerritoryCosts;
        local IsOutpost = Logic.IsEntityInCategory(arg[1], EntityCategories.Outpost) == 1;
        local TerritoryID = GetTerritoryUnderEntity(arg[1]);
        local Bonus = self:GetMultiConstructionBonusAmount(arg[2], TerritoryID);
        if IsOutpost and Bonus == 0 then
            AddGood(Costs[1], Costs[2], arg[1]);
            self:SetMultiConstructionBonusAmount(arg[2], TerritoryID, 1);
        end
    end
end

function Lib.SettlementLimitation.Global:InitDefaultRules(_PlayerID)
    local Territories = {Logic.GetTerritories()};
    for i = 1, #Territories do
        SetTerritoryBuildingLimit(_PlayerID, Territories[i], 3);
        for Type, _ in pairs(Lib.SettlementLimitation.Shared.CityBuildings) do
            SetTerritoryBuildingTypeLimit(_PlayerID, Territories[i], Type, 0);
        end
        for Type, _ in pairs(Lib.SettlementLimitation.Shared.OuterRimBuildings) do
            SetTerritoryBuildingTypeLimit(_PlayerID, Territories[i], Type, 1);
        end
    end
end

function Lib.SettlementLimitation.Global:InitConstructionLimitRules()
    -- Check general amount of buildings in a territory.
    SettlementLimitation_Global_TerritoryBuildingGeneralLimitRule = function(_PlayerID, _Type, _X, _Y)
        local MainBuilding = Logic.GetStoreHouse(_PlayerID);
        local MainTerritoryID = GetTerritoryUnderEntity(MainBuilding);
        local TerritoryID = Logic.GetTerritoryAtPosition(_X, _Y);
        local OutpostID = Logic.GetTerritoryAcquiringBuildingID(TerritoryID);
        if  Lib.SettlementLimitation.Global.Active
        and MainTerritoryID ~= TerritoryID then
            if Lib.SettlementLimitation.Global.TerritoryRestriction[_PlayerID] then
                local IgnoreList = Lib.SettlementLimitation.Shared.AbsolutLimitIgnore;
                local TypeName = Logic.GetEntityTypeName(_Type);
                if IgnoreList[TypeName] then
                    return true;
                end

                local Limit = -1;
                if Lib.SettlementLimitation.Global.TerritoryRestriction[_PlayerID][TerritoryID] then
                    Limit = Lib.SettlementLimitation.Global.TerritoryRestriction[_PlayerID][TerritoryID];
                end
                if Limit == -1 and Lib.SettlementLimitation.Global.TerritoryRestriction[_PlayerID][0] then
                    Limit = Lib.SettlementLimitation.Global.TerritoryRestriction[_PlayerID][0];
                end
    	        local Bonus = Lib.SettlementLimitation.Global:GetAdditionalBuildingBonusAmount(_PlayerID, TerritoryID);
                local Current = 0;
                Current = Current + #{Logic.GetEntitiesOfCategoryInTerritory(TerritoryID, _PlayerID, EntityCategories.CityBuilding, 0)};
                Current = Current + #{Logic.GetEntitiesOfCategoryInTerritory(TerritoryID, _PlayerID, EntityCategories.OuterRimBuilding, 0)};
                -- Current = Current - ((OutpostID ~= 0 and 1) or 0);
                if (Limit or -1) ~= -1 then
                    return Current < ((Limit > 0 and Limit + Bonus) or Limit);
                end
            end
        end
        return true;
    end

    -- Check type amount of buildings in a territory.
    SettlementLimitation_Global_TerritoryBuildingTypeLimitRule = function(_PlayerID, _Type, _X, _Y)
        local MainBuilding = Logic.GetStoreHouse(_PlayerID);
        local MainTerritoryID = GetTerritoryUnderEntity(MainBuilding);
        local TerritoryID = Logic.GetTerritoryAtPosition(_X, _Y);
        local OutpostID = Logic.GetTerritoryAcquiringBuildingID(TerritoryID);
        if  Lib.SettlementLimitation.Global.Active
        and MainTerritoryID ~= TerritoryID then
            if Lib.SettlementLimitation.Global.TerritoryTypeRestriction[_PlayerID] then
                local IgnoreList = Lib.SettlementLimitation.Shared.AbsolutLimitIgnore;
                local TypeName = Logic.GetEntityTypeName(_Type);
                if IgnoreList[TypeName] then
                    return true;
                end

                local Limit = -1;
                if Lib.SettlementLimitation.Global.TerritoryTypeRestriction[_PlayerID][TerritoryID] then
                    Limit = Lib.SettlementLimitation.Global.TerritoryTypeRestriction[_PlayerID][TerritoryID][_Type] or -1;
                end
                if Limit == -1 and Lib.SettlementLimitation.Global.TerritoryTypeRestriction[_PlayerID][0] then
                    Limit = Lib.SettlementLimitation.Global.TerritoryTypeRestriction[_PlayerID][0][_Type] or -1;
                end
                local Bonus = Lib.SettlementLimitation.Global:GetMultiConstructionBonusAmount(_PlayerID, TerritoryID);
                local Current = #{Logic.GetEntitiesOfTypeInTerritory(TerritoryID, _PlayerID, _Type, 0)};
                if (Limit or -1) ~= -1 then
                    return Current < ((Limit > 0 and Limit + Bonus) or Limit);
                end
            end
        end
        return true;
    end

    -- Check amount of outer rim buildings in home territory
    SettlementLimitation_Global_HomeTerritoryBuildingGeneralLimitRule = function(_PlayerID, _Type, _X, _Y)
        local MainBuilding = Logic.GetStoreHouse(_PlayerID);
        local MainTerritoryID = GetTerritoryUnderEntity(MainBuilding);
        local TerritoryID = Logic.GetTerritoryAtPosition(_X, _Y);
        local OutpostID = Logic.GetTerritoryAcquiringBuildingID(TerritoryID);
        if  Lib.SettlementLimitation.Global.Active
        and Logic.IsEntityTypeInCategory(_Type, EntityCategories.OuterRimBuilding) == 1
        and MainTerritoryID == TerritoryID then
            if Lib.SettlementLimitation.Global.TerritoryRestriction[_PlayerID] then
                local IgnoreList = Lib.SettlementLimitation.Shared.AbsolutLimitIgnore;
                local TypeName = Logic.GetEntityTypeName(_Type);
                if IgnoreList[TypeName] then
                    return true;
                end
                local Current = #{Logic.GetEntitiesOfCategoryInTerritory(TerritoryID, _PlayerID, EntityCategories.OuterRimBuilding, 0)};
                return Current < 3;
            end
        end
        return true;
    end

    -- Check amount of type of outer rim building in home territory
    SettlementLimitation_Global_HomeTerritoryBuildingTypeLimitRule = function(_PlayerID, _Type, _X, _Y)
        local MainBuilding = Logic.GetStoreHouse(_PlayerID);
        local MainTerritoryID = GetTerritoryUnderEntity(MainBuilding);
        local TerritoryID = Logic.GetTerritoryAtPosition(_X, _Y);
        local OutpostID = Logic.GetTerritoryAcquiringBuildingID(TerritoryID);
        if  Lib.SettlementLimitation.Global.Active
        and Logic.IsEntityTypeInCategory(_Type, EntityCategories.OuterRimBuilding) == 1
        and MainTerritoryID == TerritoryID then
            if Lib.SettlementLimitation.Global.TerritoryTypeRestriction[_PlayerID] then
                local IgnoreList = Lib.SettlementLimitation.Shared.AbsolutLimitIgnore;
                local TypeName = Logic.GetEntityTypeName(_Type);
                if IgnoreList[TypeName] then
                    return true;
                end
                local Current = #{Logic.GetEntitiesOfTypeInTerritory(TerritoryID, _PlayerID, _Type, 0)};
                return Current < 1;
            end
        end
        return true;
    end
end

function Lib.SettlementLimitation.Global:ActivateSettlementLimitation(_Flag)
    self.Active = _Flag == true;

    ExecuteLocal(
        [[Lib.SettlementLimitation.Local.Active = %s == true]],
        tostring(_Flag == true)
    );
end

function Lib.SettlementLimitation.Global:GetAdditionalBuildingBonusAmount(_PlayerID, _ID)
    if self.AdditionalBuildingBonus[_PlayerID] then
        return self.AdditionalBuildingBonus[_PlayerID][_ID] or 0;
    end
    return 0;
end

function Lib.SettlementLimitation.Global:SetAdditionalBuildingBonusAmount(_PlayerID, _ID, _Amount)
    if self.AdditionalBuildingBonus[_PlayerID] then
        local CurrentAmount = self.AdditionalBuildingBonus[_PlayerID][_ID] or 0;
        self.AdditionalBuildingBonus[_PlayerID][_ID] = CurrentAmount + _Amount;

        ExecuteLocal(
            [[Lib.SettlementLimitation.Local.AdditionalBuildingBonus[%d][%d] = %d]],
            _PlayerID,
            _ID,
            CurrentAmount + _Amount
        );
    end
end

function Lib.SettlementLimitation.Global:GetMultiConstructionBonusAmount(_PlayerID, _ID)
    if self.MultiConstructionBonus[_PlayerID] then
        return self.MultiConstructionBonus[_PlayerID][_ID] or 0;
    end
    return 0;
end

function Lib.SettlementLimitation.Global:SetMultiConstructionBonusAmount(_PlayerID, _ID, _Amount)
    if self.MultiConstructionBonus[_PlayerID] then
        local CurrentAmount = self.MultiConstructionBonus[_PlayerID][_ID] or 0;
        self.MultiConstructionBonus[_PlayerID][_ID] = CurrentAmount + _Amount;

        ExecuteLocal(
            [[Lib.SettlementLimitation.Local.MultiConstructionBonus[%d][%d] = %d]],
            _PlayerID,
            _ID,
            CurrentAmount + _Amount
        );
    end
end

-- -------------------------------------------------------------------------- --

function Lib.SettlementLimitation.Global:InitWallUpkeep()
    self.Orig_GameCallback_TaxCollectionFinished = GameCallback_TaxCollectionFinished;
    GameCallback_TaxCollectionFinished = function(_PlayerID, _Total, _Bonus)
        Lib.SettlementLimitation.Global.Orig_GameCallback_TaxCollectionFinished(_PlayerID, _Total, _Bonus);
        Lib.SettlementLimitation.Global:PayFacilityUpkeep(_PlayerID);
    end
end

function Lib.SettlementLimitation.Global:PayFacilityUpkeep(_PlayerID)
    if self.WallUpkeepCosts then
        if Logic.PlayerGetIsHumanFlag(_PlayerID) then
            local WallCost = self:GetWallUpkeep(_PlayerID);
            local MoneyCost = WallCost;

            if WallCost > 0 then
                if GetPlayerResources(Goods.G_Gold, _PlayerID) < WallCost then
                    local WallList = {Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.Wall)};
                    local Deteriation = Lib.SettlementLimitation.Shared.WallDeteriation;
                    for _,ID in pairs(WallList) do
                        if math.random(1, 100) <= Deteriation.Chance then
                            local Health = Logic.GetEntityHealth(ID);
                            local MaxHealth = Logic.GetEntityHealth(ID);
                            local Damage = math.ceil(MaxHealth * 0.05);
                            if Health > 0 and Damage >= Health then
                                Logic.HurtEntity(ID, Damage);
                            end
                        end
                    end
                else
                    AddGood(Goods.G_Gold, (-1) * WallCost, _PlayerID);
                end
            end

            RequestHiResDelay(
                0,
                ExecuteLocal,
                [[GUI_FeedbackWidgets.GoldAdd(%d, nil, {3, 11, 0}, {1, 8, 0})]],
                (-1) * MoneyCost
            );
        end
    end
end

function Lib.SettlementLimitation.Global:GetWallUpkeep(_PlayerID)
    local Upkeep = 0;
    local UpkeepPalisade = Lib.SettlementLimitation.Shared.Upkeep.Palisade;
    local UpkeepWall = Lib.SettlementLimitation.Shared.Upkeep.Wall;
    for _, ID in pairs{Logic.GetPlayerEntitiesInCategory(_PlayerID, EntityCategories.Wall)} do
        if Logic.IsEntityInCategory(ID, EntityCategories.Wall) == 1 then
            if Logic.IsEntityInCategory(ID, EntityCategories.PalisadeSegment) == 1 then
                Upkeep = Upkeep + UpkeepPalisade;
            else
                Upkeep = Upkeep + UpkeepWall;
            end
        end
    end
    return math.ceil(Upkeep);
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.SettlementLimitation.Local:Initialize()
    if not self.IsInstalled then
        for PlayerID = 1, 8 do
            self.TerritoryRestriction[PlayerID] = {};
            self.TerritoryTypeRestriction[PlayerID] = {};
            self.AdditionalBuildingBonus[PlayerID] = {};
            self.MultiConstructionBonus[PlayerID] = {};
        end
        Lib.SettlementLimitation.Shared:CreateTypeLists();

        self:OverwritePlacementUpdate();

        -- Garbage collection
        Lib.SettlementLimitation.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.SettlementLimitation.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.SettlementLimitation.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    end
end

function Lib.SettlementLimitation.Local:OverwritePlacementUpdate()
    self.Orig_GUI_Construction_PlacementUpdate = GUI_Construction.PlacementUpdate;
    --- @diagnostic disable-next-line: duplicate-set-field
    GUI_Construction.PlacementUpdate = function()
        if PlacementState ~= 0 then
            Lib.SettlementLimitation.Local.Orig_GUI_Construction_PlacementUpdate();
            return;
        end

        local this = Lib.SettlementLimitation.Local;

        local PlayerID = GUI.GetPlayerID();
        local x,y = GUI.Debug_GetMapPositionUnderMouse();
        local TerritoryPlayerID;
        local TerritoryID;
        if x ~= -1 then
            TerritoryID = Logic.GetTerritoryAtPosition(x,y);
            FoWState = Logic.GetFoWState(PlayerID, x, y);
            if TerritoryID ~= nil then
                TerritoryName = GetTerritoryName(TerritoryID);
                TerritoryPlayerID = Logic.GetTerritoryPlayerID(TerritoryID);
            end
        end

        if TerritoryID == nil or TerritoryPlayerID == 0
        or g_Construction.CurrentPlacementType == 1 then
            return;
        end

        local R, G, B = GUI.GetPlayerColor(TerritoryPlayerID);
        PlayerColor = "{@color:" .. R .. ",".. G ..",".. B .. ",255}";
        local TerritoryName = GetTerritoryName(TerritoryID);
        local UpgradeCategory = Lib.Construction.Local.LastSelectedBuildingType;
        local _, BuildingType = Logic.GetBuildingTypesInUpgradeCategory(UpgradeCategory);
        local RestrictionTerritoryString = this:GetRestrictionText(PlayerID, TerritoryID, BuildingType);
        local RestrictionTypeString = this:GetRestrictionTypeText(PlayerID, TerritoryID, BuildingType);
        local RestrictionString = "";
        if RestrictionTerritoryString == "" and RestrictionTypeString == "" then
            TerritoryName = "";
        else
            RestrictionString = RestrictionTerritoryString .. RestrictionTypeString;
        end

        for i = 0, 4 do
            XGUIEng.SetText("/Ingame/Root/Normal/PlacementStatus/TerritoryName" .. i, "{center}" ..PlayerColor.. " " ..TerritoryName);
            XGUIEng.SetText("/Ingame/Root/Normal/PlacementStatus/TerritoryReason" .. i, "{center}" ..RestrictionString);
            XGUIEng.SetText("/Ingame/Root/Normal/PlacementStatus/OtherReason" .. i, "");
        end
    end
end

function Lib.SettlementLimitation.Local:GetRestrictionText(_PlayerID, _TerritoryID, _Type)
    local MainBuilding = Logic.GetStoreHouse(_PlayerID);
    if GetTerritoryUnderEntity(MainBuilding) == _TerritoryID
    or not Lib.SettlementLimitation.Local.Active then
        return "";
    end

    local getRestrictionText = function(playerID, territoryID, buildingLimit)
        local this = Lib.SettlementLimitation.Local;
        local Current = 0;
        Current = Current + #{Logic.GetEntitiesOfCategoryInTerritory(territoryID, playerID, EntityCategories.CityBuilding, 0)};
        Current = Current + #{Logic.GetEntitiesOfCategoryInTerritory(territoryID, playerID, EntityCategories.OuterRimBuilding, 0)};
        local Bonus = this:GetAdditionalBuildingBonusAmount(playerID, territoryID);
        local Limit = buildingLimit;
        Limit = (Limit > 0 and Limit + Bonus) or Limit;
        local Text = string.format(
            "%s%s %d / %d{@color:255,255,255,255}{cr}",
            (Current >= Limit and "{@color:255,0,0,255}") or "{@color:255,255,255,255}",
            Localize(Lib.SettlementLimitation.Text.BuildingLimit),
            Current,
            Limit
        );
        return Text;
    end

    if Lib.SettlementLimitation.Shared:IsCheckedType(_Type) then
        local TerritoryRestriction = self.TerritoryRestriction[_PlayerID];
        if TerritoryRestriction then
            local SpecificLimit = TerritoryRestriction[_TerritoryID];
            if SpecificLimit and SpecificLimit ~= -1 then
                return getRestrictionText(_PlayerID, _TerritoryID, SpecificLimit);
            end

            local GeneralLimit = TerritoryRestriction[0]
            if GeneralLimit and GeneralLimit ~= -1 then
                return getRestrictionText(_PlayerID, _TerritoryID, GeneralLimit);
            end
        end
    end
    return "";
end

function Lib.SettlementLimitation.Local:GetRestrictionTypeText(_PlayerID, _TerritoryID, _Type)
    local MainBuilding = Logic.GetStoreHouse(_PlayerID);
    if GetTerritoryUnderEntity(MainBuilding) == _TerritoryID
    or not Lib.SettlementLimitation.Local.Active then
        return "";
    end

    local getRestrictionText = function (playerID, territoryID, entityType, typeRestriction)
        local this = Lib.SettlementLimitation.Local;
        local TypeName = Logic.GetEntityTypeName(entityType);
        local Current = #{Logic.GetEntitiesOfTypeInTerritory(territoryID, playerID, entityType, 0)};
        local Limit = typeRestriction;
        local Bonus = this:GetMultiConstructionBonusAmount(playerID, territoryID);
        Limit = (Limit > 0 and Limit + Bonus) or Limit;
        local Text = string.format(
            "%s%s %d / %d{@color:255,255,255,255}{cr}",
            (Current >= Limit and "{@color:255,0,0,255}") or "{@color:255,255,255,255}",
            XGUIEng.GetStringTableText("Names/" .. TypeName),
            Current,
            Limit
        );
        return Text;
    end

    if Lib.SettlementLimitation.Shared:IsCheckedType(_Type) then
        local TypeRestriction = self.TerritoryTypeRestriction[_PlayerID];
        if TypeRestriction then
            local TerritoryRestriction = TypeRestriction[_TerritoryID];
            if TerritoryRestriction and TerritoryRestriction[_Type] and TerritoryRestriction[_Type] ~= -1 then
                return getRestrictionText(_PlayerID, _TerritoryID, _Type, TerritoryRestriction[_Type]);
            end
            local GeneralRestriction = TypeRestriction[0]
            if GeneralRestriction and GeneralRestriction[_Type] and GeneralRestriction[_Type] ~= -1 then
                return getRestrictionText(_PlayerID, _TerritoryID, _Type, GeneralRestriction[_Type]);
            end
        end
    end

    return "";
end

function Lib.SettlementLimitation.Local:GetAdditionalBuildingBonusAmount(_PlayerID, _ID)
    if self.AdditionalBuildingBonus[_PlayerID] then
        return self.AdditionalBuildingBonus[_PlayerID][_ID] or 0;
    end
    return 0;
end

function Lib.SettlementLimitation.Local:GetMultiConstructionBonusAmount(_PlayerID, _ID)
    if self.MultiConstructionBonus[_PlayerID] then
        return self.MultiConstructionBonus[_PlayerID][_ID] or 0;
    end
    return 0;
end

-- -------------------------------------------------------------------------- --
-- Shared

function Lib.SettlementLimitation.Shared:CreateTypeLists()
    self.CityBuildings = {};
    self.OuterRimBuildings = {};

    local CityBuildings = {Logic.GetEntityTypesInCategory(EntityCategories.CityBuilding)};
    for _, Type in pairs(CityBuildings) do
        self.CityBuildings[Type] = true;
    end
    local OuterRimBuildings = {Logic.GetEntityTypesInCategory(EntityCategories.OuterRimBuilding)};
    for _, Type in pairs(OuterRimBuildings) do
        self.OuterRimBuildings[Type] = true;
    end
end

function Lib.SettlementLimitation.Shared:IsCheckedType(_Type)
    if self.CityBuildings[_Type] then
        return true;
    end
    if self.OuterRimBuildings[_Type] then
        return true;
    end
    return false;
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.SettlementLimitation.Name);

Lib.Register("module/information/BriefingSystem_Behavior");

function Reprisal_Briefing(_Name, _Briefing)
    return B_Reprisal_Briefing:new(_Name, _Briefing);
end

B_Reprisal_Briefing = {
    Name = "Reprisal_Briefing",
    Description = {
        en = "Reprisal: Calls a function to start an new briefing.",
        de = "Vergeltung: Ruft die Funktion auf und startet das enthaltene Briefing.",
        fr = "Rétribution: Appelle la fonction et démarre le briefing qu'elle contient.",
    },
    Parameter = {
        { ParameterType.Default, en = "Briefing name",     de = "Name des Briefing",     fr = "Nom du briefing" },
        { ParameterType.Default, en = "Briefing function", de = "Funktion mit Briefing", fr = "Fonction avec briefing" },
    },
}

function B_Reprisal_Briefing:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_Briefing:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.BriefingName = _Parameter;
    elseif (_Index == 1) then
        self.Function = _Parameter;
    end
end

function B_Reprisal_Briefing:CustomFunction(_Quest)
    _G[self.Function](self.BriefingName, _Quest.ReceivingPlayer);
end

function B_Reprisal_Briefing:Debug(_Quest)
    if self.BriefingName == nil or self.BriefingName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    if not type(_G[self.Function]) == "function" then
        debug(false, _Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_Briefing);

-- -------------------------------------------------------------------------- --

function Reward_Briefing(_Name, _Briefing)
    return B_Reward_Briefing:new(_Name, _Briefing);
end

B_Reward_Briefing = CopyTable(B_Reprisal_Briefing);
B_Reward_Briefing.Name = "Reward_Briefing";
B_Reward_Briefing.Description.en = "Reward: Calls a function to start an new briefing.";
B_Reward_Briefing.Description.de = "Lohn: Ruft die Funktion auf und startet das enthaltene Briefing.";
B_Reward_Briefing.Description.fr = "Récompense: Appelle la fonction et démarre le briefing qu'elle contient.";
B_Reward_Briefing.GetReprisalTable = nil;

B_Reward_Briefing.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_Briefing);

-- -------------------------------------------------------------------------- --

function Trigger_Briefing(_Name, _PlayerID, _Waittime)
    return B_Trigger_Briefing:new(_Name, _PlayerID, _Waittime);
end

B_Trigger_Briefing = {
    Name = "Trigger_Briefing",
    Description = {
        en = "Trigger: Checks if an briefing has concluded and starts the quest if so.",
        de = "Auslöser: Prüft, ob ein Briefing beendet ist und startet dann den Quest.",
        fr = "Déclencheur: Vérifie si un briefing est terminé et lance ensuite la quête.",
    },
    Parameter = {
        { ParameterType.Default,  en = "Briefing name", de = "Name des Briefing", fr = "Nom du briefing" },
        { ParameterType.PlayerID, en = "Player ID",     de = "Player ID",         fr = "Player ID" },
        { ParameterType.Number,   en = "Wait time",     de = "Wartezeit",         fr = "Temps d'attente" },
    },
}

function B_Trigger_Briefing:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_Briefing:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.BriefingName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function B_Trigger_Briefing:CustomFunction(_Quest)
    if GetCinematicEvent(self.BriefingName, self.PlayerID) == CinematicEventState.Concluded then
        if self.WaitTime and self.WaitTime > 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function B_Trigger_Briefing:Debug(_Quest)
    if self.WaitTime < 0 then
        debug(false, string.format("%s: %s: Wait time must be 0 or greater!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, string.format("%s: %s: Player-ID must be between 1 and 8!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.BriefingName == nil or self.BriefingName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_Briefing);

-- -------------------------------------------------------------------------- --

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/information/BriefingSystem_API");

function StartBriefing(_Briefing, _Name, _PlayerID)
    if GUI then
        return;
    end
    local PlayerID = _PlayerID;
    if not PlayerID and not Framework.IsNetworkGame() then
        PlayerID = 1; -- Human Player
    end
    assert(_Name ~= nil);
    assert(_PlayerID ~= nil);
    assert(type(_Briefing) == "table", "Briefing must be a table!");
    assert(#_Briefing > 0, "Briefing does not contain pages!");
    for i=1, #_Briefing do
        assert(
            type(_Briefing[i]) ~= "table" or _Briefing[i].__Legit,
            "A page is not initalized!"
        );
    end
    if _Briefing.EnableSky == nil then
        _Briefing.EnableSky = true;
    end
    if _Briefing.EnableFoW == nil then
        _Briefing.EnableFoW = false;
    end
    if _Briefing.EnableGlobalImmortality == nil then
        _Briefing.EnableGlobalImmortality = true;
    end
    if _Briefing.EnableBorderPins == nil then
        _Briefing.EnableBorderPins = false;
    end
    if _Briefing.RestoreGameSpeed == nil then
        _Briefing.RestoreGameSpeed = true;
    end
    if _Briefing.RestoreCamera == nil then
        _Briefing.RestoreCamera = true;
    end
    Lib.BriefingSystem.Global:StartBriefing(_Name, PlayerID, _Briefing);
end
API.StartBriefing = StartBriefing;

function RequestBriefingAlternateGraphics()
    if not GUI then
        ExecuteLocal("RequestBriefingAlternateGraphics()");
        return;
    end
    Lib.BriefingSystem.Local:RequestAlternateGraphics();
end
API.RequestBriefingAlternateGraphics = RequestBriefingAlternateGraphics;

function IsBriefingActive(_PlayerID)
    if not IsLocalScript() then
        return Lib.BriefingSystem.Global:GetCurrentBriefing(_PlayerID) ~= nil;
    end
    return Lib.BriefingSystem.Local:GetCurrentBriefing(_PlayerID) ~= nil;
end
API.IsBriefingActive = IsBriefingActive;

function GetFramePosition(_Entity, _ZOffset)
    local x,y,z = Logic.EntityGetPos(GetID(_Entity));
    local zNew = (_ZOffset < 0 and math.abs(_ZOffset)) or (z + (_ZOffset or 0));
    return x, y, zNew;
end

function GetFrameVector(_Entity1, _ZOffset1, _Entity2, _ZOffset2)
    local x1,y1,z1 = Logic.EntityGetPos(GetID(_Entity1));
    local x2,y2,z2 = Logic.EntityGetPos(GetID(_Entity2));
    local z1New = (_ZOffset1 < 0 and math.abs(_ZOffset1)) or (z1 + (_ZOffset1 or 0));
    local z2New = (_ZOffset2 < 0 and math.abs(_ZOffset2)) or (z2 + (_ZOffset2 or 0));
    return x1, y1, z1New, x2, y2, z2New;
end

function AddBriefingPages(_Briefing)
    Lib.BriefingSystem.Global:CreateBriefingGetPage(_Briefing);
    Lib.BriefingSystem.Global:CreateBriefingAddPage(_Briefing);
    Lib.BriefingSystem.Global:CreateBriefingAddMCPage(_Briefing);
    Lib.BriefingSystem.Global:CreateBriefingAddRedirect(_Briefing);

    local AP = function(_Page)
        local Page;
        if type(_Page) == "table" then
            if _Page.MC then
                Page = _Briefing:AddMCPage(_Page);
            else
                Page = _Briefing:AddPage(_Page);
            end
        else
            Page = _Briefing:AddRedirect(_Page);
        end
        return Page;
    end

    local ASP = function(...)
        _Briefing.PageAnimation = _Briefing.PageAnimation or {};

        local Name, Title,Text, Position;
        local DialogCam = false;
        local Action = function() end;

        -- Set page parameters
        if (#arg == 3 and type(arg[1]) == "string")
        or (#arg >= 4 and type(arg[4]) == "boolean") then
            Name = table.remove(arg, 1);
        end
        Title = table.remove(arg, 1);
        Text = table.remove(arg, 1);
        if #arg > 0 then
            DialogCam = table.remove(arg, 1) == true;
        end
        if #arg > 0 then
            Position = table.remove(arg, 1);
        end
        if #arg > 0 then
            Action = table.remove(arg, 1);
        end

        -- Calculate camera rotation
        local Rotation;
        if Position then
            Rotation = CONST_BRIEFING.CAMERA_ROTATIONDEFAULT;
            if Position and Logic.IsSettler(GetID(Position)) == 1 then
                Rotation = Logic.GetEntityOrientation(GetID(Position)) + 90;
            end
        end

        -- Create page
        return _Briefing:AddPage {
            Name            = Name,
            Title           = Title,
            Text            = Text,
            Action          = Action,
            Position        = Position,
            DisableSkipping = false,
            Duration        = -1,
            DialogCamera    = DialogCam,
            Rotation        = Rotation,
        };
    end

    return AP, ASP;
end
API.AddBriefingPages = AddBriefingPages;

function AP(_Data)
    assert(false);
end

function ASP(...)
    assert(false);
end

Lib.Register("module/information/BriefingSystem_Text");

Lib.BriefingSystem.Text = {
    NextButton = {de = "Weiter",  en = "Forward",  fr = "Continuer"},
    PrevButton = {de = "Zurück",  en = "Previous", fr = "Retour"},
    EndButton  = {de = "Beenden", en = "Close",    fr = "Quitter"},

    Request = {
        Title = {
            de = "Grafik ändern",
            en = "Alternate Graphics",
            fr = "Graphiques alternatifs",
        },
        Text  = {
            de = "Während des Spiels können die Grafikeinstellungen durch das Mapscript vorübergehend geändert werden. Willst du das zulassen?",
            en = "During gameplay the graphic settings might be changed temporarily by the mapscript. Do you want to allow that?",
            fr = "Pendant le jeu, les paramètres graphiques peuvent être modifiés temporairement par le mapscript. Voulez-vous autoriser cela?",
        },
    },
};

Lib.BriefingSystem = Lib.BriefingSystem or {};
Lib.BriefingSystem.Name = "BriefingSystem";
Lib.BriefingSystem.Global = {
    Briefing = {},
    BriefingQueue = {},
    BriefingCounter = 0,
};
Lib.BriefingSystem.Local = {
    Config = {
        DoAlternateGraphics = true,
    },
    ParallaxWidgets = {
        Pushed = {},
        -- Can not set UV coordinates for this... :(
        -- {"/EndScreen/EndScreen/BG", "/EndScreen/EndScreen"},
        {"/EndScreen/EndScreen/BackGround", "/EndScreen/EndScreen"},
        -- Can not set UV coordinates for this... :(
        -- {"/InGame/MissionStatistic/BG", "/InGame/MissionStatistic"},
        {"/InGame/Root/EndScreen/BlackBG", "/InGame/Root/EndScreen"},
        {"/InGame/Root/EndScreen/BG", "/InGame/Root/EndScreen"},
        {"/InGame/Root/BlackStartScreen/BG", "/InGame/Root/BlackStartScreen"},
        -- Can not set UV coordinates for this... :(
        -- {"/InGame/Root/PresentationLoadingScreen/BG", "/InGame/Root/PresentationLoadingScreen"},
    },
    Briefing = {},
};

CONST_BRIEFING = {
    TIMER_PER_CHAR = 0.175,
    CAMERA_ANGLEDEFAULT = 43,
    CAMERA_ROTATIONDEFAULT = -45,
    CAMERA_ZOOMDEFAULT = 9000,
    CAMERA_FOVDEFAULT = 42,
    DLGCAMERA_ANGLEDEFAULT = 36,
    DLGCAMERA_ROTATIONDEFAULT = -45,
    DLGCAMERA_ZOOMDEFAULT = 3500,
    DLGCAMERA_FOVDEFAULT = 25,
};

Lib.Require("comfort/IsMultiplayer");
Lib.Require("core/Core");
Lib.Require("module/settings/Sound");
Lib.Require("module/ui/UIEffects");
Lib.Require("module/ui/UITools");
Lib.Require("module/information/Requester");
Lib.Require("module/information/BriefingSystem_Text");
Lib.Require("module/information/BriefingSystem_API");
Lib.Require("module/information/BriefingSystem_Behavior");
Lib.Register("module/information/BriefingSystem");

CinematicEventTypes.Briefing = 2;

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.BriefingSystem.Global:Initialize()
    if not self.IsInstalled then
        Report.BriefingStarted = CreateReport("Event_BriefingStarted");
        Report.BriefingEnded = CreateReport("Event_BriefingEnded");
        Report.BriefingPageShown = CreateReport("Event_BriefingPageShown");
        Report.BriefingOptionSelected = CreateReport("Event_BriefingOptionSelected");
        Report.BriefingLeftClick = CreateReport("Event_BriefingLeftClick");
        Report.BriefingSkipButtonPressed = CreateReport("Event_BriefingSkipButtonPressed");

        for i= 1, 8 do
            self.BriefingQueue[i] = {};
        end
        -- Updates the dialog queue for all players
        RequestHiResJob(function()
            Lib.BriefingSystem.Global:UpdateQueue();
            Lib.BriefingSystem.Global:BriefingExecutionController();
        end);

        -- Garbage collection
        Lib.BriefingSystem.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.BriefingSystem.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.BriefingSystem.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.EscapePressed then
        -- TODO fix problem with throneroom
    elseif _ID == Report.BriefingStarted then
        self:NextPage(arg[1]);
    elseif _ID == Report.BriefingEnded then
        SendReportToLocal(Report.BriefingEnded, arg[1], arg[2]);
    elseif _ID == Report.BriefingPageShown then
        SendReportToLocal(Report.BriefingPageShown, arg[1], arg[2]);
    elseif _ID == Report.BriefingOptionSelected then
        self:OnOptionSelected(arg[1], arg[2]);
    elseif _ID == Report.BriefingSkipButtonPressed then
        self:SkipButtonPressed(arg[1]);
    end
end

function Lib.BriefingSystem.Global:UpdateQueue()
    for i= 1, 8 do
        if self:CanStartBriefing(i) then
            local Next = Lib.UIEffects.Global:LookUpCinematicInQueue(i);
            if Next and Next[1] == CinematicEventTypes.Briefing then
                self:NextBriefing(i);
            end
        end
    end
end

function Lib.BriefingSystem.Global:BriefingExecutionController()
    for i= 1, 8 do
        if self.Briefing[i] and not self.Briefing[i].DisplayIngameCutscene then
            local PageID = self.Briefing[i].CurrentPage;
            local Page = self.Briefing[i][PageID];
            -- Auto Skip
            if Page and not Page.MC and Page.Duration > 0 then
                if (Page.Started + Page.Duration) < Logic.GetTime() then
                    self:NextPage(i);
                end
            end
        end
    end
end

function Lib.BriefingSystem.Global:CreateBriefingGetPage(_Briefing)
    _Briefing.GetPage = _Briefing.GetPage or function(this, _NameOrID)
        local ID = Lib.BriefingSystem.Global:GetPageIDByName(_Briefing.PlayerID, _NameOrID);
        return Lib.BriefingSystem.Global.Briefing[_Briefing.PlayerID][ID];
    end
end

function Lib.BriefingSystem.Global:CreateBriefingAddPage(_Briefing)
    _Briefing.AddPage = _Briefing.AddPage or function(this, _Page)
        -- Briefing length
        this.Length = (this.Length or 0) +1;
        -- Animations
        _Briefing.PageAnimation = _Briefing.PageAnimation or {};
        -- Parallaxes
        _Briefing.PageParallax = _Briefing.PageParallax or {};

        -- Set page name
        local Identifier = "Page" ..(#this +1);
        if _Page.Name then
            Identifier = _Page.Name;
        else
            _Page.Name = Identifier;
        end

        -- Make page legit
        _Page.__Legit = true;
        -- Language
        _Page.Title = Localize(_Page.Title or "");
        _Page.Text = Localize(_Page.Text or "");

        -- Bars
        if _Page.BigBars == nil then
            _Page.BigBars = true;
        end

        -- Simple camera animation
        if _Page.Position then
            -- Fill angle
            if not _Page.Angle then
                _Page.Angle = CONST_BRIEFING.CAMERA_ANGLEDEFAULT;
                if _Page.DialogCamera then
                    _Page.Angle = CONST_BRIEFING.DLGCAMERA_ANGLEDEFAULT;
                end
            end
            -- Fill rotation
            if not _Page.Rotation then
                _Page.Rotation = CONST_BRIEFING.CAMERA_ROTATIONDEFAULT;
                if _Page.DialogCamera then
                    _Page.Rotation = CONST_BRIEFING.DLGCAMERA_ROTATIONDEFAULT;
                end
            end
            -- Fill zoom
            if not _Page.Zoom then
                _Page.Zoom = CONST_BRIEFING.CAMERA_ZOOMDEFAULT;
                if _Page.DialogCamera then
                    _Page.Zoom = CONST_BRIEFING.DLGCAMERA_ZOOMDEFAULT;
                end
            end
            -- Optional fly to
            local Position2, Rotation2, Zoom2, Angle2;
            if _Page.FlyTo then
                Position2 = _Page.FlyTo.Position or _Page.Position;
                Rotation2 = _Page.FlyTo.Rotation or _Page.Rotation;
                Zoom2     = _Page.FlyTo.Zoom or _Page.Zoom;
                Angle2    = _Page.FlyTo.Angle or _Page.Angle;
            end
            -- Create the animation
            _Briefing.PageAnimation[Identifier] = {
                Clear = true,
                {math.abs(_Page.Duration or 1),
                 _Page.Position, _Page.Rotation, _Page.Zoom, _Page.Angle,
                 Position2, Rotation2, Zoom2, Angle2}
            };
        end

        -- Field of View
        if not _Page.FOV then
            if _Page.DialogCamera then
                _Page.FOV = CONST_BRIEFING.DLGCAMERA_FOVDEFAULT;
            else
                _Page.FOV = CONST_BRIEFING.CAMERA_FOVDEFAULT;
            end
        end

        -- Display time
        if not _Page.Duration then
            if not _Page.Position then
                _Page.DisableSkipping = false;
                _Page.Duration = -1;
            else
                if _Page.DisableSkipping == nil then
                    _Page.DisableSkipping = false;
                end
                _Page.Duration = _Page.Text:len() * CONST_BRIEFING.TIMER_PER_CHAR;
                _Page.Duration = (_Page.Duration < 6 and 6) or _Page.Duration;
            end
        end

        -- Multiple choice selection
        _Page.GetSelected = function(_Data)
            return 0;
        end
        -- Return page
        table.insert(this, _Page);
        return _Page;
    end
end

function Lib.BriefingSystem.Global:CreateBriefingAddMCPage(_Briefing)
    _Briefing.AddMCPage = _Briefing.AddMCPage or function(this, _Page)
        -- Create base page
        local Page = this:AddPage(_Page);

        -- Multiple choice selection
        Page.GetSelected = function(_Data)
            if _Data.MC then
                return _Data.MC.Selected;
            end
            return 0;
        end

        -- Multiple Choice
        if Page.MC then
            for i= 1, #Page.MC do
                Page.MC[i][1] = Localize(Page.MC[i][1]);
                Page.MC[i].ID = Page.MC[i].ID or i;
            end
            Page.BigBars = true;
            Page.DisableSkipping = true;
            Page.Duration = -1;
        end
        -- Return page
        return Page;
    end
end

function Lib.BriefingSystem.Global:CreateBriefingAddRedirect(_Briefing)
    _Briefing.AddRedirect = _Briefing.AddRedirect or function(this, _Target)
        -- Dialog length
        this.Length = (this.Length or 0) +1;
        -- Return page
        local Page = (_Target == nil and -1) or _Target;
        table.insert(this, Page);
        return Page;
    end
end

function Lib.BriefingSystem.Global:StartBriefing(_Name, _PlayerID, _Data)
    self.BriefingQueue[_PlayerID] = self.BriefingQueue[_PlayerID] or {};
    Lib.UIEffects.Global:PushCinematicEventToQueue(
        _PlayerID,
        CinematicEventTypes.Briefing,
        _Name,
        _Data
    );
end

function Lib.BriefingSystem.Global:EndBriefing(_PlayerID)
    Logic.SetGlobalInvulnerability(0);
    local Briefing = self.Briefing[_PlayerID];
    SendReport(Report.BriefingEnded, _PlayerID, Briefing.Name);
    if Briefing.Finished then
        Briefing:Finished();
    end
    FinishCinematicEvent(Briefing.Name, _PlayerID);
    self.Briefing[_PlayerID] = nil;
end

function Lib.BriefingSystem.Global:NextBriefing(_PlayerID)
    if self:CanStartBriefing(_PlayerID) then
        local BriefingData = Lib.UIEffects.Global:PopCinematicEventFromQueue(_PlayerID);
        assert(BriefingData[1] == CinematicEventTypes.Briefing);
        StartCinematicEvent(BriefingData[2], _PlayerID);

        local Briefing = BriefingData[3];
        Briefing.Name = BriefingData[2];
        Briefing.PlayerID = _PlayerID;
        Briefing.CurrentPage = 0;
        self.Briefing[_PlayerID] = Briefing;
        self:TransformAnimations(_PlayerID);
        self:TransformParallaxes(_PlayerID);

        if Briefing.EnableGlobalImmortality then
            Logic.SetGlobalInvulnerability(1);
        end
        if self.Briefing[_PlayerID].Starting then
            self.Briefing[_PlayerID]:Starting();
        end

        -- This is an exception from the rule that the global event is send
        -- before the local event! For timing reasons...
        SendReportToLocal(Report.BriefingStarted, _PlayerID, Briefing.Name, Briefing);
    end
end

function Lib.BriefingSystem.Global:TransformAnimations(_PlayerID)
    if self.Briefing[_PlayerID].PageAnimation then
        for k, v in pairs(self.Briefing[_PlayerID].PageAnimation) do
            local PageID = self:GetPageIDByName(_PlayerID, k);
            if PageID ~= 0 then
                self.Briefing[_PlayerID][PageID].Animations = {};
                self.Briefing[_PlayerID][PageID].Animations.Repeat = v.Repeat == true;
                self.Briefing[_PlayerID][PageID].Animations.Clear = v.Clear == true;
                for i= 1, #v, 1 do
                    local Entry = {};
                    Entry.Interpolation = v[i].Interpolation;
                    Entry.Duration = v[i][1] or (2 * 60);
                    if v[i][2] and type(v[i][4]) ~= "table" then
                        Entry.Start = {
                            Position = (type(v[i][2]) ~= "table" and {v[i][2],0}) or v[i][2],
                            Rotation = v[i][3] or CONST_BRIEFING.CAMERA_ROTATIONDEFAULT,
                            Zoom     = v[i][4] or CONST_BRIEFING.CAMERA_ZOOMDEFAULT,
                            Angle    = v[i][5] or CONST_BRIEFING.CAMERA_ANGLEDEFAULT,
                        };
                        local EndPosition = v[i][6] or Entry.Start.Position;
                        Entry.End = {
                            Position = (type(EndPosition) ~= "table" and {EndPosition,0}) or EndPosition,
                            Rotation = v[i][7] or Entry.Start.Rotation,
                            Zoom     = v[i][8] or Entry.Start.Zoom,
                            Angle    = v[i][9] or Entry.Start.Angle,
                        };
                        table.insert(self.Briefing[_PlayerID][PageID].Animations, Entry);
                    else
                       Entry.AnimFrames = {};
                       for j= 2, #v[i] do
                           table.insert(Entry.AnimFrames, v[i][j]);
                       end
                    end
                    table.insert(self.Briefing[_PlayerID][PageID].Animations, Entry);
                end
            end
        end
        self.Briefing[_PlayerID].PageAnimation = nil;
    end
end

function Lib.BriefingSystem.Global:TransformParallaxes(_PlayerID)
    if self.Briefing[_PlayerID].PageParallax then
        for k, v in pairs(self.Briefing[_PlayerID].PageParallax) do
            local PageID = self:GetPageIDByName(_PlayerID, k);
            if PageID ~= 0 then
                self.Briefing[_PlayerID][PageID].Parallax = {};
                self.Briefing[_PlayerID][PageID].Parallax.Repeat = v.Repeat == true;
                self.Briefing[_PlayerID][PageID].Parallax.Clear = v.Clear == true;
                for i= 1, 4, 1 do
                    if v[i] then
                        local Entry = {};
                        Entry.Image = v[i][1];
                        Entry.Interpolation = v[i].Interpolation;
                        Entry.Duration = v[i][2] or (2 * 60);
                        Entry.AnimData = {};
                        for j= 3, #v[i] do
                            table.insert(Entry.AnimData, v[i][j]);
                        end
                        self.Briefing[_PlayerID][PageID].Parallax[i] = Entry;
                    end
                end
            end
        end
        self.Briefing[_PlayerID].PageParallax = nil;
    end
end

function Lib.BriefingSystem.Global:NextPage(_PlayerID)
    if self.Briefing[_PlayerID] == nil then
        return;
    end

    self.Briefing[_PlayerID].CurrentPage = self.Briefing[_PlayerID].CurrentPage +1;
    local PageID = self.Briefing[_PlayerID].CurrentPage;
    if PageID == -1 or PageID == 0 then
        self:EndBriefing(_PlayerID);
        return;
    end

    local Page = self.Briefing[_PlayerID][PageID];
    if type(Page) == "table" then
        if PageID <= #self.Briefing[_PlayerID] then
            self.Briefing[_PlayerID][PageID].Started = Logic.GetTime();
            self.Briefing[_PlayerID][PageID].Duration = Page.Duration or -1;
            if self.Briefing[_PlayerID][PageID].Action then
                self.Briefing[_PlayerID][PageID]:Action();
            end
            self:DisplayPage(_PlayerID, PageID);
        else
            self:EndBriefing(_PlayerID);
        end
    elseif type(Page) == "number" or type(Page) == "string" then
        local Target = self:GetPageIDByName(_PlayerID, self.Briefing[_PlayerID][PageID]);
        self.Briefing[_PlayerID].CurrentPage = Target -1;
        self:NextPage(_PlayerID);
    else
        self:EndBriefing(_PlayerID);
    end
end

function Lib.BriefingSystem.Global:DisplayPage(_PlayerID, _PageID)
    if self.Briefing[_PlayerID] == nil then
        return;
    end

    local Page = self.Briefing[_PlayerID][_PageID];
    if type(Page) == "table" then
        local PageID = self.Briefing[_PlayerID].CurrentPage;
        if Page.MC then
            for i= 1, #Page.MC, 1 do
                if type(Page.MC[i][3]) == "function" then
                    self.Briefing[_PlayerID][PageID].MC[i].Visible = Page.MC[i][3](_PlayerID, PageID, i);
                end
            end
        end
    end

    SendReport(Report.BriefingPageShown, _PlayerID, _PageID);
end

function Lib.BriefingSystem.Global:SkipButtonPressed(_PlayerID, _PageID)
    if not self.Briefing[_PlayerID] then
        return;
    end
    local PageID = self.Briefing[_PlayerID].CurrentPage;
    if self.Briefing[_PlayerID][PageID].OnForward then
        self.Briefing[_PlayerID][PageID]:OnForward();
    end
    self:NextPage(_PlayerID);
end

function Lib.BriefingSystem.Global:OnOptionSelected(_PlayerID, _OptionID)
    if self.Briefing[_PlayerID] == nil then
        return;
    end
    local PageID = self.Briefing[_PlayerID].CurrentPage;
    if type(self.Briefing[_PlayerID][PageID]) ~= "table" then
        return;
    end
    local Page = self.Briefing[_PlayerID][PageID];
    if Page.MC then
        local Option;
        for i= 1, #Page.MC, 1 do
            if Page.MC[i].ID == _OptionID then
                Option = Page.MC[i];
            end
        end
        if Option ~= nil then
            local Target = Option[2];
            if type(Option[2]) == "function" then
                Target = Option[2](_PlayerID, PageID, _OptionID);
            end
            self.Briefing[_PlayerID][PageID].MC.Selected = Option.ID;
            self.Briefing[_PlayerID].CurrentPage = self:GetPageIDByName(_PlayerID, Target) -1;
            self:NextPage(_PlayerID);
        end
    end
end

function Lib.BriefingSystem.Global:GetCurrentBriefing(_PlayerID)
    return self.Briefing[_PlayerID];
end

function Lib.BriefingSystem.Global:GetCurrentBriefingPage(_PlayerID)
    if self.Briefing[_PlayerID] then
        local PageID = self.Briefing[_PlayerID].CurrentPage;
        return self.Briefing[_PlayerID][PageID];
    end
end

function Lib.BriefingSystem.Global:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Briefing[_PlayerID] ~= nil then
            for i= 1, #self.Briefing[_PlayerID], 1 do
                if type(self.Briefing[_PlayerID][i]) == "table" and self.Briefing[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function Lib.BriefingSystem.Global:CanStartBriefing(_PlayerID)
    return  self.Briefing[_PlayerID] == nil and
            not IsCinematicEventActive(_PlayerID) and
            self.LoadscreenClosed;
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.BriefingSystem.Local:Initialize()
    if not self.IsInstalled then
        Report.BriefingStarted = CreateReport("Event_BriefingStarted");
        Report.BriefingEnded = CreateReport("Event_BriefingEnded");
        Report.BriefingPageShown = CreateReport("Event_BriefingPageShown");
        Report.BriefingOptionSelected = CreateReport("Event_BriefingOptionSelected");
        Report.BriefingLeftClick = CreateReport("Event_BriefingLeftClick");
        Report.BriefingSkipButtonPressed = CreateReport("Event_BriefingSkipButtonPressed");

        self:OverrideThroneRoomFunctions();

        -- Garbage collection
        Lib.BriefingSystem.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.BriefingSystem.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.BriefingSystem.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.EscapePressed then
        -- TODO fix problem with throneroom
    elseif _ID == Report.BriefingStarted then
        self:StartBriefing(arg[1], arg[2], arg[3]);
    elseif _ID == Report.BriefingEnded then
        self:EndBriefing(arg[1], arg[2]);
    elseif _ID == Report.BriefingPageShown then
        self:DisplayPage(arg[1], arg[2]);
    elseif _ID == Report.BriefingSkipButtonPressed then
        self:SkipButtonPressed(arg[1]);
    end
end

function Lib.BriefingSystem.Local:StartBriefing(_PlayerID, _BriefingName, _Briefing)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Briefing[_PlayerID] = _Briefing;
    self.Briefing[_PlayerID].LastSkipButtonPressed = 0;
    self.Briefing[_PlayerID].CurrentPage = 0;
    local PosX, PosY = Camera.RTS_GetLookAtPosition();
    local Rotation = Camera.RTS_GetRotationAngle();
    local ZoomFactor = Camera.RTS_GetZoomFactor();
    local SpeedFactor = Game.GameTimeGetFactor(_PlayerID);
    self.Briefing[_PlayerID].Backup = {
        Camera = {PosX, PosY, Rotation, ZoomFactor},
        Throneroom = {0, 0},
        Speed  = SpeedFactor,
    };

    DeactivateNormalInterface(_PlayerID);
    DeactivateBorderScroll(_PlayerID);

    if not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, 1);
        if _Briefing.PreloadAssets then
            ActivateColoredScreen(_PlayerID, 0, 0, 0, 255);
            Lib.Core.Local:Preload_ViewWholeMap();
        end
    end

    SendReportToGlobal(Report.BriefingStarted, _PlayerID, _Briefing.Name);
    RequestHiResDelay(1, function()
        self:ActivateCinematicMode(_PlayerID);
    end);
end

function Lib.BriefingSystem.Local:EndBriefing(_PlayerID, _BriefingName)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end

    local Briefing = self.Briefing[_PlayerID];

    if not Framework.IsNetworkGame() and Briefing.PreloadAssets then
        Lib.Core.Local:Preload_ResetView();
    end
    if Briefing.RestoreGameSpeed and not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, Briefing.Backup.Speed);
    end
    if Briefing.RestoreCamera then
        Camera.RTS_SetLookAtPosition(Briefing.Backup.Camera[1], Briefing.Backup.Camera[2]);
        Camera.RTS_SetRotationAngle(Briefing.Backup.Camera[3]);
        Camera.RTS_SetZoomFactor(Briefing.Backup.Camera[4]);
    else
        Throneroom = self.Briefing[_PlayerID].Throneroom;
        Camera.RTS_SetLookAtPosition(Throneroom[1], Throneroom[2]);
    end
    StopVoice("BriefingSpeech");

    self:DeactivateCinematicMode(_PlayerID);
    ActivateNormalInterface(_PlayerID);
    ActivateBorderScroll(_PlayerID);
    Lib.UITools.Widget:UpdateHiddenWidgets();

    self.Briefing[_PlayerID] = nil;
    Display.SetRenderFogOfWar(1);
    Display.SetRenderBorderPins(1);
    Display.SetRenderSky(0);
end

function Lib.BriefingSystem.Local:DisplayPage(_PlayerID, _PageID)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Briefing[_PlayerID].AnimationQueue = self.Briefing[_PlayerID].AnimationQueue or {};
    self.Briefing[_PlayerID].ParallaxLayers = self.Briefing[_PlayerID].ParallaxLayers or {};
    self.Briefing[_PlayerID].CurrentPage = _PageID;
    if type(self.Briefing[_PlayerID][_PageID]) == "table" then
        self.Briefing[_PlayerID][_PageID].Started = Logic.GetTime();
        self:SetPageFarClipPlane(_PlayerID, _PageID);
        self:SetRender(_PlayerID, _PageID);
        self:DisplayPageBars(_PlayerID, _PageID);
        self:DisplayPageTitle(_PlayerID, _PageID);
        self:DisplayPageText(_PlayerID, _PageID);
        self:DisplayPageControls(_PlayerID, _PageID);
        self:DisplayPageAnimation(_PlayerID, _PageID);
        self:DisplayPageFader(_PlayerID, _PageID);
        self:DisplayPageParallaxes(_PlayerID, _PageID);
        if self.Briefing[_PlayerID][_PageID].MC then
            self:DisplayPageOptionsDialog(_PlayerID, _PageID);
        end
    end
end

function Lib.BriefingSystem.Local:SetPageFarClipPlane(_PlayerID, _PageID)
    ResetRenderDistance();
    local Page = self.Briefing[_PlayerID][_PageID];
    if Page.FarClipPlane then
        SetRenderDistance(Page.FarClipPlane);
    end
end

function Lib.BriefingSystem.Local:SetRender(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    if Page.Performance then
        self:SetPerformanceMode();
    else
        self:SetQualityMode();
    end
end

function Lib.BriefingSystem.Local:SetPerformanceMode()
    Display.SetUserOptionAnimationQuality(0);
    Display.SetUserOptionAnisotropy(0);
    Display.SetUserOptionReflections(0);
    Display.SetUserOptionTerrainQuality(0);
    Display.SetRenderObjectsAlphaBlendPass(0);
    Display.SetRenderParticles(0);
    Display.SetRenderUseBatching(0);
    Display.SetRenderUpdateMorphAnim(0);
    Display.SetRenderUpdateParticles(0);
    Display.SetEffectOption("DoNotUseRimLight", 1);
    Display.SetEffectOption("SimpleWater", 1);
end

function Lib.BriefingSystem.Local:SetQualityMode()
    local AnimationQuality = Display.GetUserOptionMaxAnimationQuality();
    local FilterQuality = Display.GetUserOptionMaxAnisotropy();
    local ReflectionQuality = Display.GetUserOptionMaxReflections();
    local TerrainQuality = Display.GetUserOptionMaxTerrainQuality();
    Display.SetUserOptionAnimationQuality(AnimationQuality);
    Display.SetUserOptionAnisotropy(FilterQuality);
    Display.SetUserOptionReflections(ReflectionQuality);
    Display.SetUserOptionTerrainQuality(TerrainQuality);
    Display.SetRenderObjectsAlphaBlendPass(1);
    Display.SetRenderParticles(1);
    Display.SetRenderUseBatching(1);
    Display.SetRenderUpdateMorphAnim(1);
    Display.SetRenderUpdateParticles(1);
    Display.SetEffectOption("DoNotUseRimLight", 0);
    Display.SetEffectOption("SimpleWater", 0);
end

function Lib.BriefingSystem.Local:DisplayPageBars(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    local Opacity = (Page.BarOpacity ~= nil and Page.BarOpacity) or 1;
    local OpacityBig = (255 * Opacity);
    local OpacitySmall = (255 * Opacity);

    local BigVisibility = (Page.BigBars and 1) or 0;
    local SmallVisibility = (Page.BigBars and 0) or 1;
    if Opacity == 0 then
        BigVisibility = 0;
        SmallVisibility = 0;
    end

    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", BigVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", SmallVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", BigVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", SmallVisibility);

    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, OpacityBig);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, OpacityBig);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, OpacitySmall);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, OpacitySmall);
end

function Lib.BriefingSystem.Local:DisplayPageTitle(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    local TitleWidget = "/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight";
    XGUIEng.SetText(TitleWidget, "");
    if Page.Title then
        local Title = ConvertPlaceholders(Localize(Page.Title));
        if Title:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
            Title = XGUIEng.GetStringTableText(Title);
        end
        if Title:sub(1, 1) ~= "{" then
            Title = "{@color:255,250,0,255}{center}" ..Title;
        end
        XGUIEng.SetText(TitleWidget, Title);
    end
end

function Lib.BriefingSystem.Local:DisplayPageText(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    local TextWidget = "/InGame/ThroneRoom/Main/MissionBriefing/Text";
    XGUIEng.SetText(TextWidget, "");
    if Page.Text then
        local Text = ConvertPlaceholders(Localize(Page.Text));
        if Text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
            Text = XGUIEng.GetStringTableText(Text);
        end
        if Text:sub(1, 1) ~= "{" then
            Text = "{center}" ..Text;
        end
        if not Page.BigBars then
            Text = "{cr}{cr}{cr}" .. Text;
        end
        XGUIEng.SetText(TextWidget, Text);
    end
    StopVoice("BriefingSpeech");
    if Page.Speech then
        PlayVoice(Page.Speech, "BriefingSpeech");
    end
end

function Lib.BriefingSystem.Local:DisplayPageControls(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    local SkipFlag = 1;

    SkipFlag = ((Page.Duration == nil or Page.Duration == -1) and 1) or 0;
    if Page.DisableSkipping ~= nil then
        SkipFlag = (Page.DisableSkipping and 0) or 1;
    end
    if Page.MC ~= nil then
        SkipFlag = 0;
    end
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", SkipFlag);
end

function Lib.BriefingSystem.Local:DisplayPageAnimation(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    if Page.Animations then
        if Page.Animations.Clear then
            self.Briefing[_PlayerID].CurrentAnimation = nil;
            self.Briefing[_PlayerID].AnimationQueue = {};
        end
        for i= 1, #Page.Animations, 1 do
            local Animation = table.copy(Page.Animations[i]);
            table.insert(self.Briefing[_PlayerID].AnimationQueue, Animation);
        end
    end
end

function Lib.BriefingSystem.Local:DisplayPageFader(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    g_Fade.To = Page.FaderAlpha or 0;

    local PageFadeIn = Page.FadeIn;
    if PageFadeIn then
        FadeIn(PageFadeIn);
    end

    local PageFadeOut = Page.FadeOut;
    if PageFadeOut then
        -- FIXME: This would create jobs that are only be paused at the end!
        self.Briefing[_PlayerID].FaderJob = RequestHiResJob(function(_Time, _FadeOut)
            if Logic.GetTimeMs() > _Time - (_FadeOut * 1000) then
                FadeOut(_FadeOut);
                return true;
            end
        end, Logic.GetTimeMs() + ((Page.Duration or 0) * 1000), PageFadeOut);
    end
end

function Lib.BriefingSystem.Local:DisplayPageParallaxes(_PlayerID, _PageID)
    local Page = self.Briefing[_PlayerID][_PageID];
    if Page.Parallax then
        if Page.Parallax.Clear then
            for i= 1, #self.ParallaxWidgets do
                XGUIEng.SetMaterialTexture(self.ParallaxWidgets[i][1], 1, "");
                XGUIEng.SetMaterialColor(self.ParallaxWidgets[i][1], 1, 255, 255, 255, 0);
            end
            self.Briefing[_PlayerID].ParallaxLayers = {};
        end
        for i= 1, 4, 1 do
            if Page.Parallax[i] then
                local Animation = table.copy(Page.Parallax[i]);
                Animation.Started = XGUIEng.GetSystemTime();
                self.Briefing[_PlayerID].ParallaxLayers[i] = Animation;
            end
        end
    end
end

function Lib.BriefingSystem.Local:ControlParallaxes(_PlayerID)
    if self.Briefing[_PlayerID].ParallaxLayers then
        local CurrentTime = XGUIEng.GetSystemTime();
        for Index, Data in pairs(self.Briefing[_PlayerID].ParallaxLayers) do
            local Widget = self.ParallaxWidgets[Index][1];
            local Size = {GUI.GetScreenSize()};

            local Factor = math.lerp(Data.Started, CurrentTime, Data.Duration);
            if Factor > 1 and Data.Repeat then
                self.Briefing[_PlayerID].ParallaxLayers[Index].Started = CurrentTime;
                Factor = math.lerp(Data.Started, CurrentTime, Data.Duration);
            end
            if Data.Interpolation then
                Factor = math.min(Data:Interpolation(CurrentTime), 1);
            end
            if type(Data.Modulation) == "function" then
                Factor = Data:Modulation(CurrentTime, Factor);
            end
            Factor = math.min(math.max(Factor, 0), 1);

            local Image = Data.Image;
            if type(Image) == "function" then
                Image = Data:Image(Factor, Data.Started, CurrentTime, Data.Duration);
            end
            if type(Image) == "table" then
                local CurrentImageIndex = math.min(math.ceil(#Image * Factor), #Image);
                Image = Image[CurrentImageIndex];
            end

            local u0,v0,u1,v1,Alpha = 0, 0, 1, 1, 255;
            if Data.AnimData then
                if Data.AnimData[3] and type(Data.AnimData[3]) ~= "table" then
                    u0,v0,u1,v1,Alpha = unpack(Data.AnimData);
                else
                    if #Data.AnimData >= 2 then
                        u0,v0,u1,v1,Alpha = self:BezierCurveParallax(
                            Factor,
                            unpack(Data.AnimData)
                        );
                    end
                end
            end
            if Size[1]/Size[2] < 1.6 then
                u0 = u0 + (u0 / 0.125);
                u1 = u1 - (u1 * 0.125);
            end

            XGUIEng.SetMaterialColor(Widget, 0, 255, 255, 255, Alpha or 255);
            XGUIEng.SetMaterialTexture(Widget, 0, Image);
            XGUIEng.SetMaterialUV(Widget, 0, u0, v0, u1, v1);
        end
    end
end

function Lib.BriefingSystem.Local:DisplayPageOptionsDialog(_PlayerID, _PageID)
    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
    local Screen = {GUI.GetScreenSize()};
    local Page = self.Briefing[_PlayerID][_PageID];
    local Listbox = XGUIEng.GetWidgetID(Widget .. "/ListBox");

    self.Briefing[_PlayerID].MCSelectionBoxPosition = {
        XGUIEng.GetWidgetScreenPosition(Widget)
    };

    XGUIEng.ListBoxPopAll(Listbox);
    self.Briefing[_PlayerID].MCSelectionOptionsMap = {};
    for i=1, #Page.MC, 1 do
        if Page.MC[i].Visible ~= false then
            XGUIEng.ListBoxPushItem(Listbox, Page.MC[i][1]);
            table.insert(self.Briefing[_PlayerID].MCSelectionOptionsMap, Page.MC[i].ID);
        end
    end
    XGUIEng.ListBoxSetSelectedIndex(Listbox, 0);

    local wSize = {XGUIEng.GetWidgetScreenSize(Widget)};
    local xFix = math.ceil((Screen[1] /2) - (wSize[1] /2));
    local yFix = math.ceil(Screen[2] - (wSize[2] -10));
    if Page.Text and Page.Text ~= "" then
        yFix = math.ceil((Screen[2] /2) - (wSize[2] /2));
    end
    XGUIEng.SetWidgetScreenPosition(Widget, xFix, yFix);
    XGUIEng.PushPage(Widget, false);
    XGUIEng.ShowWidget(Widget, 1);
    self.Briefing[_PlayerID].MCSelectionIsShown = true;
end

function Lib.BriefingSystem.Local:OnOptionSelected(_PlayerID)
    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
    local Position = self.Briefing[_PlayerID].MCSelectionBoxPosition;
    XGUIEng.SetWidgetScreenPosition(Widget, Position[1], Position[2]);
    XGUIEng.ShowWidget(Widget, 0);
    XGUIEng.PopPage();

    local Selected = XGUIEng.ListBoxGetSelectedIndex(Widget .. "/ListBox")+1;
    local AnswerID = self.Briefing[_PlayerID].MCSelectionOptionsMap[Selected];

    SendReport(Report.BriefingOptionSelected, _PlayerID, AnswerID);
    SendReportToGlobal(Report.BriefingOptionSelected, _PlayerID, AnswerID);
end

function Lib.BriefingSystem.Local:ThroneRoomCameraControl(_PlayerID, _Page)
    if _Page then
        -- Camera
        self:ControlCameraAnimation(_PlayerID);
        local FOV = (type(_Page) == "table" and _Page.FOV) or 42;
        local PX, PY, PZ, LX, LY, LZ = 0, 0, 0, 0, 0, 0;
        local CurrentAnimation = self.Briefing[_PlayerID].CurrentAnimation;
        if CurrentAnimation and CurrentAnimation.AnimFrames then
            if #CurrentAnimation.AnimFrames >= 2 then
                local Factor = self:GetInterpolationFactor(_PlayerID, true);
                PX, PY, PZ, LX, LY, LZ = self:BezierCurve(
                    Factor,
                    unpack(CurrentAnimation.AnimFrames)
                );
            else
                PX, PY, PZ, LX, LY, LZ = unpack(CurrentAnimation.AnimFrames[1]);
            end
        else
            PX, PY, PZ = self:GetPagePosition(_PlayerID);
            LX, LY, LZ = self:GetPageLookAt(_PlayerID);
            if PX and not LX then
                LX, LY, LZ, PX, PY, PZ, FOV = self:GetCameraProperties(_PlayerID, FOV);
            end
        end
        Camera.ThroneRoom_SetPosition(PX, PY, PZ);
        Camera.ThroneRoom_SetLookAt(LX, LY, LZ);
        Camera.ThroneRoom_SetFOV(FOV);
        self.Briefing[_PlayerID].Throneroom = {LX, LY};

        -- Parallax
        self:ControlParallaxes(_PlayerID);

        -- Multiple Choice
        if self.Briefing[_PlayerID].MCSelectionIsShown then
            local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
            if XGUIEng.IsWidgetShown(Widget) == 0 then
                self.Briefing[_PlayerID].MCSelectionIsShown = false;
                self:OnOptionSelected(_PlayerID);
            end
        end

        -- Button texts
        local SkipText = Localize(Lib.BriefingSystem.Text.NextButton);
        local PageID = self.Briefing[_PlayerID].CurrentPage;
        if PageID == #self.Briefing[_PlayerID] or self.Briefing[_PlayerID][PageID+1] == -1 then
            SkipText = Localize(Lib.BriefingSystem.Text.EndButton);
        end
        XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..SkipText);
    end
end

function Lib.BriefingSystem.Local:ControlCameraAnimation(_PlayerID)
    if self.Briefing[_PlayerID].CurrentAnimation then
        local CurrentTime = XGUIEng.GetSystemTime();
        local Animation = self.Briefing[_PlayerID].CurrentAnimation;
        if CurrentTime > Animation.Started + Animation.Duration then
            if #self.Briefing[_PlayerID].AnimationQueue > 0 then
                self.Briefing[_PlayerID].CurrentAnimation = nil;
            end
        end
    end
    if self.Briefing[_PlayerID].CurrentAnimation == nil then
        if self.Briefing[_PlayerID].AnimationQueue and #self.Briefing[_PlayerID].AnimationQueue > 0 then
            local PageID = self.Briefing[_PlayerID].CurrentPage;
            local Page = self.Briefing[_PlayerID][PageID];
            local Next = table.remove(self.Briefing[_PlayerID].AnimationQueue, 1);
            if Page and Page.Animations and Page.Animations.Repeat then
                table.insert(self.Briefing[_PlayerID].AnimationQueue, Next);
            end
            Next.Started = XGUIEng.GetSystemTime();
            self.Briefing[_PlayerID].CurrentAnimation = Next;
        end
    end
end

function Lib.BriefingSystem.Local:GetPagePosition(_PlayerID)
    local x, y, z = 0,0,0;
    local Position, FlyTo;
    if self.Briefing[_PlayerID].CurrentAnimation then
        Position = self.Briefing[_PlayerID].CurrentAnimation.Start.Position;
        FlyTo = self.Briefing[_PlayerID].CurrentAnimation.End;
        x, y, z = self:ConvertPosition(Position);
        if FlyTo then
            local lX, lY, lZ = self:ConvertPosition(FlyTo.Position);
            if lX and lY and lZ then
                x = x + (lX - x) * self:GetInterpolationFactor(_PlayerID);
                y = y + (lY - y) * self:GetInterpolationFactor(_PlayerID);
                z = z + (lZ - z) * self:GetInterpolationFactor(_PlayerID);
            end
        end
    end
    return x, y, z;
end

function Lib.BriefingSystem.Local:GetPageLookAt(_PlayerID)
    local LookAt, FlyTo;
    if self.Briefing[_PlayerID].CurrentAnimation then
        LookAt = self.Briefing[_PlayerID].CurrentAnimation.Start.LookAt;
        FlyTo = self.Briefing[_PlayerID].CurrentAnimation.End;
    end

    local x, y, z = self:ConvertPosition(LookAt);
    if FlyTo and x then
        local lX, lY, lZ = self:ConvertPosition(FlyTo.LookAt);
        if lX and lY and lZ then
            x = x + (lX - x) * self:GetInterpolationFactor(_PlayerID);
            y = y + (lY - y) * self:GetInterpolationFactor(_PlayerID);
            z = z + (lZ - z) * self:GetInterpolationFactor(_PlayerID);
        end
    end
    return x, y, z;
end

function Lib.BriefingSystem.Local:ConvertPosition(_Table)
    local x, y, z;
    if _Table and type(_Table) == "table" then
        if _Table.X then
            x = _Table.X;
            y = _Table.Y;
            z = _Table.Z;
        elseif _Table[3] then
            x = _Table[1];
            y = _Table[2];
            z = _Table[3];
        else
            x, y, z = Logic.EntityGetPos(GetID(_Table[1]));
            z = z + (_Table[2] or 0);
        end
    end
    return x, y, z;
end

function Lib.BriefingSystem.Local:GetInterpolationFactor(_PlayerID, _Modulate)
    if self.Briefing[_PlayerID].CurrentAnimation then
        local CurrentTime = XGUIEng.GetSystemTime();
        local Data = self.Briefing[_PlayerID].CurrentAnimation;
        local Factor = 1;
        if Data.Interpolation then
            Factor = Data:Interpolation(CurrentTime);
        else
            Factor = math.lerp(
                self.Briefing[_PlayerID].CurrentAnimation.Started,
                CurrentTime,
                self.Briefing[_PlayerID].CurrentAnimation.Duration
            );
        end
        if type(Data.Modulation) == "function" then
            Factor = Data:Modulation(CurrentTime, Factor);
        elseif _Modulate then
            Factor = self:ModulateInterpolationFactor(Factor);
        end
        return math.min(math.max(Factor, 0), 1);
    end
    return 1;
end

function Lib.BriefingSystem.Local:ModulateInterpolationFactor(_Factor)
    return (1 / (0.97 + math.exp(-8 * (_Factor - 0.5)))) - 0.01;
end

function Lib.BriefingSystem.Local:BernsteinPolynome(n, i, t)
    return (math.factorial(n) / (math.factorial(i) * math.factorial(n - i))) * (t ^ i) * ((1 - t) ^ (n - i));
end

function Lib.BriefingSystem.Local:BezierCurve(_Factor, ...)
    _Factor = math.max(0, math.min(1, _Factor));
    local Points = {...};
    local n = #Points;
    local PX, PY, PZ, LX, LY, LZ = 0, 0, 0, 0, 0, 0;
    for i = 1, n do
        local f = self:BernsteinPolynome(n - 1, i - 1, _Factor);
        PX = PX + Points[i][1] * f;
        PY = PY + Points[i][2] * f;
        PZ = PZ + Points[i][3] * f;
        LX = LX + Points[i][4] * f;
        LY = LY + Points[i][5] * f;
        LZ = LZ + Points[i][6] * f;
    end
    return PX, PY, PZ, LX, LY, LZ;
end

function Lib.BriefingSystem.Local:BezierCurveParallax(_Factor, ...)
    _Factor = math.max(0, math.min(1, _Factor));
    local Points = {...};
    local n = #Points;
    local U0, V0, U1, V1, A = 0, 0, 0, 0, 0;
    for i = 1, n do
        local f = self:BernsteinPolynome(n - 1, i - 1, _Factor);
        U0 = U0 + Points[i][1] * f;
        V0 = V0 + Points[i][2] * f;
        U1 = U1 + Points[i][3] * f;
        V1 = V1 + Points[i][4] * f;
        A  = A  + Points[i][5] * f;
    end
    return U0, V0, U1, V1, A;
end

function Lib.BriefingSystem.Local:GetCameraProperties(_PlayerID, _FOV)
    local CurrPage, FlyTo;
    if self.Briefing[_PlayerID].CurrentAnimation then
        CurrPage = self.Briefing[_PlayerID].CurrentAnimation.Start;
        FlyTo = self.Briefing[_PlayerID].CurrentAnimation.End;
    end

    local startPosition = CurrPage.Position;
    local endPosition = (FlyTo and FlyTo.Position) or CurrPage.Position;
    local startRotation = CurrPage.Rotation;
    local endRotation = (FlyTo and FlyTo.Rotation) or CurrPage.Rotation;
    local startZoomAngle = CurrPage.Angle;
    local endZoomAngle = (FlyTo and FlyTo.Angle) or CurrPage.Angle;
    local startZoomDistance = CurrPage.Zoom;
    local endZoomDistance = (FlyTo and FlyTo.Zoom) or CurrPage.Zoom;

    local factor = self:GetInterpolationFactor(_PlayerID);

    local lPLX, lPLY, lPLZ = self:ConvertPosition(startPosition);
    local cPLX, cPLY, cPLZ = self:ConvertPosition(endPosition);
    local lookAtX = lPLX + (cPLX - lPLX) * factor;
    local lookAtY = lPLY + (cPLY - lPLY) * factor;
    local lookAtZ = lPLZ + (cPLZ - lPLZ) * factor;

    local zoomDistance = startZoomDistance + (endZoomDistance - startZoomDistance) * factor;
    local zoomAngle = startZoomAngle + (endZoomAngle - startZoomAngle) * factor;
    local rotation = startRotation + (endRotation - startRotation) * factor;
    local line = zoomDistance * math.cos(math.rad(zoomAngle));
    local positionX = lookAtX + math.cos(math.rad(rotation - 90)) * line;
    local positionY = lookAtY + math.sin(math.rad(rotation - 90)) * line;
    local positionZ = lookAtZ + (zoomDistance) * math.sin(math.rad(zoomAngle));

    return lookAtX, lookAtY, lookAtZ, positionX, positionY, positionZ, _FOV;
end

function Lib.BriefingSystem.Local:SkipButtonPressed(_PlayerID, _Page)
    if not self.Briefing[_PlayerID] then
        return;
    end
    if (self.Briefing[_PlayerID].LastSkipButtonPressed + 500) < Logic.GetTimeMs() then
        self.Briefing[_PlayerID].LastSkipButtonPressed = Logic.GetTimeMs();
    end
end

function Lib.BriefingSystem.Local:GetCurrentBriefing(_PlayerID)
    return self.Briefing[_PlayerID];
end

function Lib.BriefingSystem.Local:GetCurrentBriefingPage(_PlayerID)
    if self.Briefing[_PlayerID] then
        local PageID = self.Briefing[_PlayerID].CurrentPage;
        return self.Briefing[_PlayerID][PageID];
    end
end

function Lib.BriefingSystem.Local:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Briefing[_PlayerID] ~= nil then
            for i= 1, #self.Briefing[_PlayerID], 1 do
                if type(self.Briefing[_PlayerID][i]) == "table" and self.Briefing[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function Lib.BriefingSystem.Local:OverrideThroneRoomFunctions()
    self.Orig_GameCallback_Camera_ThroneRoomLeftClick = GameCallback_Camera_ThroneRoomLeftClick;
    GameCallback_Camera_ThroneRoomLeftClick = function(_PlayerID)
        Lib.BriefingSystem.Local.Orig_GameCallback_Camera_ThroneRoomLeftClick(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            -- Must trigger in global script for all players.
            SendReportToGlobal(Report.BriefingLeftClick, _PlayerID);
            SendReport(Report.BriefingLeftClick, _PlayerID);
        end
    end

    self.Orig_GameCallback_Camera_SkipButtonPressed = GameCallback_Camera_SkipButtonPressed;
    GameCallback_Camera_SkipButtonPressed = function(_PlayerID)
        Lib.BriefingSystem.Local.Orig_GameCallback_Camera_SkipButtonPressed(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            -- Must trigger in global script for all players.
            SendReportToGlobal(Report.BriefingSkipButtonPressed, _PlayerID);
            SendReport(Report.BriefingSkipButtonPressed, _PlayerID);
        end
    end

    self.Orig_GameCallback_Camera_ThroneroomCameraControl = GameCallback_Camera_ThroneroomCameraControl;
    GameCallback_Camera_ThroneroomCameraControl = function(_PlayerID)
        Lib.BriefingSystem.Local.Orig_GameCallback_Camera_ThroneroomCameraControl(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            local Briefing = Lib.BriefingSystem.Local:GetCurrentBriefing(_PlayerID);
            if Briefing ~= nil then
                Lib.BriefingSystem.Local:ThroneRoomCameraControl(
                    _PlayerID,
                    Lib.BriefingSystem.Local:GetCurrentBriefingPage(_PlayerID)
                );
            end
        end
    end

    self.Orig_GameCallback_Escape = GameCallback_Escape;
    GameCallback_Escape = function()
        if Lib.BriefingSystem.Local.Briefing[GUI.GetPlayerID()] then
            return;
        end
        Lib.BriefingSystem.Local.Orig_GameCallback_Escape();
    end
end

function Lib.BriefingSystem.Local:ActivateCinematicMode(_PlayerID)
    if self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end

    if not self.LoadscreenClosed then
        XGUIEng.PopPage();
    end
    local ScreenX, ScreenY = GUI.GetScreenSize();

    local ConsoleWasVisible = IsScriptConsoleShown();
    if ConsoleWasVisible then
        HideScriptConsole();
    end

    -- Parallax
    function EndScreen_ExitGame() end
    function MissionFadeInEndScreen() end
    for i= 1, #self.ParallaxWidgets do
        XGUIEng.ShowWidget(self.ParallaxWidgets[i][2], 1);
        if not self.ParallaxWidgets.Pushed[self.ParallaxWidgets[i][2]] then
            self.ParallaxWidgets.Pushed[self.ParallaxWidgets[i][2]] = true;
            XGUIEng.PushPage(self.ParallaxWidgets[i][2], false);
        end
        XGUIEng.ShowWidget(self.ParallaxWidgets[i][1], 1);

        XGUIEng.SetMaterialTexture(self.ParallaxWidgets[i][1], 0, "");
        XGUIEng.SetMaterialColor(self.ParallaxWidgets[i][1], 0, 255, 255, 255, 0);
        XGUIEng.SetMaterialUV(self.ParallaxWidgets[i][1], 0, 0, 0, 1, 1);
    end
    XGUIEng.ShowWidget("/EndScreen/EndScreen/BG", 0);
    XGUIEng.ShowWidget("/InGame/Root/PresentationLoadingScreen/Logo", 0);

    -- Throneroom Main
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);
    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/KnightInfo/LeftFrame", false);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Title", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/updater", 1);

    -- Text
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    -- Title and back button
    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");
    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65 * (ScreenY/1080));
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Objectives", 2, 0, 2000, 20);

    -- Briefing messages
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/KnightInfo", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/BG", 0);
    XGUIEng.SetText("/InGame/ThroneRoom/KnightInfo/Text", " ");
    XGUIEng.SetWidgetPositionAndSize("/InGame/ThroneRoom/KnightInfo/Text", 200, 300, 1000, 10);

    self.SelectionBackup = {GUI.GetSelectedEntities()};
    GUI.ClearSelection();
    GUI.ClearNotes();
    GUI.ForbidContextSensitiveCommandsInSelectionState();
    GUI.ActivateCutSceneState();
    GUI.SetFeedbackSoundOutputState(0);
    GUI.EnableBattleSignals(false);
    Input.CutsceneMode();
    if not self.Briefing[_PlayerID].EnableFoW then
        Display.SetRenderFogOfWar(0);
    end
    if self.Briefing[_PlayerID].EnableSky then
        Display.SetRenderSky(1);
    end
    if not self.Briefing[_PlayerID].EnableBorderPins then
        Display.SetRenderBorderPins(0);
    end
    if self:IsChangingGraphicsPermited() then
        Display.SetUserOptionOcclusionEffect(0);
    end
    Camera.SwitchCameraBehaviour(5);

    InitializeFader();
    -- FIX: Push text widgets over the fader
    XGUIEng.PushPage("/InGame/ThroneRoom/Main/MissionBriefing", false);
    g_Fade.To = 0;
    SetFaderAlpha(0);

    if ConsoleWasVisible then
        ShowScriptConsole();
    end
    if not self.LoadscreenClosed then
        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);
    end
    if self.Briefing[_PlayerID].PreloadAssets then
        DeactivateColoredScreen(_PlayerID);
    end
    self.CinematicActive = true;
end

function Lib.BriefingSystem.Local:DeactivateCinematicMode(_PlayerID)
    if not self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end

    local ConsoleWasVisible = IsScriptConsoleShown();
    if ConsoleWasVisible then
        HideScriptConsole();
    end

    g_Fade.To = 0;
    SetFaderAlpha(0);
    XGUIEng.PopPage();
    Camera.SwitchCameraBehaviour(0);
    Display.UseStandardSettings();
    Input.GameMode();
    GUI.EnableBattleSignals(true);
    GUI.SetFeedbackSoundOutputState(1);
    GUI.ActivateSelectionState();
    GUI.PermitContextSensitiveCommandsInSelectionState();
    for k, v in pairs(self.SelectionBackup) do
        GUI.SelectEntity(v);
    end
    Display.SetRenderSky(0);
    Display.SetRenderBorderPins(1);
    Display.SetRenderFogOfWar(1);
    if  Options.GetIntValue("Display", "Occlusion", 0) > 0 then
        Display.SetUserOptionOcclusionEffect(1);
    end

    XGUIEng.ShowWidget("/EndScreen/EndScreen/BG", 1);
    XGUIEng.ShowWidget("/InGame/Root/PresentationLoadingScreen/Logo", 1);
    self.ParallaxWidgets.Pushed = {};
    for i= 1, #self.ParallaxWidgets do
        XGUIEng.ShowWidget(self.ParallaxWidgets[i][1], 0);
        XGUIEng.ShowWidget(self.ParallaxWidgets[i][2], 0);
        XGUIEng.PopPage();
    end
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);

    ResetRenderDistance();
    self:SetQualityMode();

    if ConsoleWasVisible then
        ShowScriptConsole();
    end
    self.CinematicActive = false;
end

-- -------------------------------------------------------------------------- --

function Lib.BriefingSystem.Local:IsChangingGraphicsPermited()
    return self.Config.DoAlternateGraphics == true;
end

function Lib.BriefingSystem.Local:RequestAlternateGraphics()
    if IsMultiplayer() then
        return;
    end
    DialogRequestBox(
        GUI.GetPlayerID(),
        Lib.BriefingSystem.Text.Request.Title,
        Lib.BriefingSystem.Text.Request.Text,
        function(_Yes)
            Lib.BriefingSystem.Local.Config.DoAlternateGraphics = _Yes == true;
        end,
        false
    );
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.BriefingSystem.Name);

Lib.Register("module/information/CutsceneSystem_Behavior");

function Reprisal_Cutscene(_Name, _Cutscene)
    return B_Reprisal_Cutscene:new(_Name, _Cutscene);
end

B_Reprisal_Cutscene = {
    Name = "Reprisal_Cutscene",
    Description = {
        en = "Reprisal: Calls a function to start an new Cutscene.",
        de = "Vergeltung: Ruft die Funktion auf und startet die enthaltene Cutscene.",
        fr = "Rétribution : Appelle la fonction et démarre la cutscene contenue.",
    },
    Parameter = {
        { ParameterType.Default, en = "Cutscene name",     de = "Name der Cutscene",     fr = "Nom de la cutscene", },
        { ParameterType.Default, en = "Cutscene function", de = "Funktion mit Cutscene", fr = "Fonction avec cutscene", },
    },
}

function B_Reprisal_Cutscene:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} }
end

function B_Reprisal_Cutscene:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.CutsceneName = _Parameter;
    elseif (_Index == 1) then
        self.Function = _Parameter;
    end
end

function B_Reprisal_Cutscene:CustomFunction(_Quest)
    _G[self.Function](self.CutsceneName, _Quest.ReceivingPlayer);
end

function B_Reprisal_Cutscene:Debug(_Quest)
    if self.CutsceneName == nil or self.CutsceneName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    if not type(_G[self.Function]) == "function" then
        debug(false, _Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_Cutscene);

-- -------------------------------------------------------------------------- --

function Reward_Cutscene(_Name, _Cutscene)
    return B_Reward_Cutscene:new(_Name, _Cutscene);
end

B_Reward_Cutscene = CopyTable(B_Reprisal_Cutscene);
B_Reward_Cutscene.Name = "Reward_Cutscene";
B_Reward_Cutscene.Description.en = "Reward: Calls a function to start an new Cutscene.";
B_Reward_Cutscene.Description.de = "Lohn: Ruft die Funktion auf und startet die enthaltene Cutscene.";
B_Reward_Cutscene.Description.fr = "Récompense: Appelle la fonction et démarre la cutscene contenue.";
B_Reward_Cutscene.GetReprisalTable = nil;

B_Reward_Cutscene.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_Cutscene);

-- -------------------------------------------------------------------------- --

function Trigger_Cutscene(_Name, _PlayerID, _Waittime)
    return B_Trigger_Cutscene:new(_Name, _PlayerID, _Waittime);
end

B_Trigger_Cutscene = {
    Name = "Trigger_Cutscene",
    Description = {
        en = "Trigger: Checks if an Cutscene has concluded and starts the quest if so.",
        de = "Auslöser: Prüft, ob eine Cutscene beendet ist und startet dann den Quest.",
        fr = "Déclencheur: Vérifie si une cutscene est terminée et démarre ensuite la quête.",
    },
    Parameter = {
        { ParameterType.Default,  en = "Cutscene name", de = "Name der Cutscene", fr  ="Nom de la cutscene" },
        { ParameterType.PlayerID, en = "Player ID",     de = "Player ID",         fr  ="Player ID" },
        { ParameterType.Number,   en = "Wait time",     de = "Wartezeit",         fr  ="Temps d'attente" },
    },
}

function B_Trigger_Cutscene:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_Cutscene:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.CutsceneName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function B_Trigger_Cutscene:CustomFunction(_Quest)
    if GetCinematicEvent(self.CutsceneName, self.PlayerID) == CinematicEventState.Concluded then
        if self.WaitTime and self.WaitTime > 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function B_Trigger_Cutscene:Debug(_Quest)
    if self.WaitTime < 0 then
        debug(false, string.format("%s: %s: Wait time must be 0 or greater!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, string.format("%s: %s: Player-ID must be between 1 and 8!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.CutsceneName == nil or self.CutsceneName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_Cutscene);

-- -------------------------------------------------------------------------- --

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/information/CutsceneSystem_API");

function StartCutscene(_Cutscene, _Name, _PlayerID)
    if GUI then
        return;
    end
    local PlayerID = _PlayerID;
    if not PlayerID and not Framework.IsNetworkGame() then
        PlayerID = 1; -- Human Player
    end
    assert(_Name ~= nil);
    assert(_PlayerID ~= nil);
    assert(type(_Cutscene) == "table", "Cutscene must be a table!");
    assert(#_Cutscene > 0, "Cutscene does not contain pages!");
    for i=1, #_Cutscene do
        assert(
            type(_Cutscene[i]) ~= "table" or _Cutscene[i].__Legit,
            "A page is not initialized!"
        );
    end
    if _Cutscene.EnableSky == nil then
        _Cutscene.EnableSky = true;
    end
    if _Cutscene.EnableFoW == nil then
        _Cutscene.EnableFoW = false;
    end
    if _Cutscene.EnableGlobalImmortality == nil then
        _Cutscene.EnableGlobalImmortality = true;
    end
    if _Cutscene.EnableBorderPins == nil then
        _Cutscene.EnableBorderPins = false;
    end
    Lib.CutsceneSystem.Global:StartCutscene(_Name, PlayerID, _Cutscene);
end
API.StartCutscene = StartCutscene;

function RequestCutsceneAlternateGraphics()
    if not GUI then
        ExecuteLocal("RequestCutsceneAlternateGraphics()");
        return;
    end
    Lib.BriefingSystem.Local:RequestAlternateGraphics();
end
API.RequestCutsceneAlternateGraphics = RequestCutsceneAlternateGraphics;

function IsCutsceneActive(_PlayerID)
    if not IsLocalScript() then
        return Lib.CutsceneSystem.Global:GetCurrentCutscene(_PlayerID) ~= nil;
    end
    return Lib.CutsceneSystem.Local:GetCurrentCutscene(_PlayerID) ~= nil;
end
API.IsCutsceneActive = IsCutsceneActive;

function AddCutscenePages(_Cutscene)
    Lib.CutsceneSystem.Global:CreateCutsceneGetPage(_Cutscene);
    Lib.CutsceneSystem.Global:CreateCutsceneAddPage(_Cutscene);

    local AP = function(_Page)
        return _Cutscene:AddPage(_Page);
    end
    return AP;
end
API.AddCutscenePages = AddCutscenePages;

function AP(_Data)
    assert(false);
end

Lib.Register("module/information/CutsceneSystem_Text");

Lib.CutsceneSystem.Text = {
    FastForwardActivate   = {de = "Beschleunigen",      en = "Fast Forward", fr = "Accélérer"},
    FastForwardDeactivate = {de = "Zurücksetzen",       en = "Normal Speed", fr = "Réinitialiser"},
    FastFormardMessage    = {de = "SCHNELLER VORLAUF",  en = "FAST FORWARD", fr = "AVANCÉ RAPIDE"},

    Request = {
        Title = {
            de = "Grafik ändern",
            en = "Alternate Graphics",
            fr = "Graphiques alternatifs",
        },
        Text  = {
            de = "Während des Spiels können die Grafikeinstellungen durch das Mapscript vorübergehend geändert werden. Willst du das zulassen?",
            en = "During gameplay the graphic settings might be changed temporarily by the mapscript. Do you want to allow that?",
            fr = "Pendant le jeu, les paramètres graphiques peuvent être modifiés temporairement par le mapscript. Voulez-vous autoriser cela?",
        },
    },
};

Lib.CutsceneSystem = Lib.CutsceneSystem or {};
Lib.CutsceneSystem.Name = "CutsceneSystem";
Lib.CutsceneSystem.Global = {
    Cutscene = {},
    CutsceneQueue = {},
    CutsceneCounter = 0;
};
Lib.CutsceneSystem.Local = {
    Config = {
        DoAlternateGraphics = true,
    },
    Cutscene = {},
};

Lib.Require("comfort/IsMultiplayer");
Lib.Require("core/Core");
Lib.Require("module/ui/UIEffects");
Lib.Require("module/ui/UITools");
Lib.Require("module/settings/Sound");
Lib.Require("module/information/Requester");
Lib.Require("module/information/CutsceneSystem_Text");
Lib.Require("module/information/CutsceneSystem_API");
Lib.Require("module/information/CutsceneSystem_Behavior");
Lib.Register("module/information/CutsceneSystem");

CinematicEventTypes.Cutscene = 3;

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.CutsceneSystem.Global:Initialize()
    if not self.IsInstalled then
        Report.CutsceneStarted = CreateReport("Event_CutsceneStarted");
        Report.CutsceneEnded = CreateReport("Event_CutsceneEnded");
        Report.CutscenePageShown = CreateReport("Event_CutscenePageShown");
        Report.CutsceneSkipButtonPressed = CreateReport("Event_CutsceneSkipButtonPressed");
        Report.CutsceneFlightStarted = CreateReport("Event_CutsceneFlightStarted");
        Report.CutsceneFlightEnded = CreateReport("Event_CutsceneFlightEnded");

        for i= 1, 8 do
            self.CutsceneQueue[i] = {};
        end
        RequestHiResJob(function()
            Lib.CutsceneSystem.Global:UpdateQueue();
        end);

        -- Garbage collection
        Lib.CutsceneSystem.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.CutsceneSystem.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.CutsceneSystem.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.EscapePressed then
        -- Nothing to do?
    elseif _ID == Report.CutsceneStarted then
        -- Nothing to do?
    elseif _ID == Report.CutsceneEnded then
        self:EndCutscene(arg[1]);
    elseif _ID == Report.CutsceneFlightStarted then
        self:StartCutsceneFlight(arg[1], arg[2], arg[3]);
    elseif _ID == Report.CutsceneFlightEnded then
        self:EndCutsceneFlight(arg[1], arg[2]);
    elseif _ID == Report.CutsceneSkipButtonPressed then
        SendReportToLocal(Report.CutsceneSkipButtonPressed, arg[1]);
    elseif _ID == Report.CutscenePageShown then
        self:DisplayPage(arg[1], arg[2], arg[3]);
    end
end

function Lib.CutsceneSystem.Global:UpdateQueue()
    for i= 1, 8 do
        if self:CanStartCutscene(i) then
            local Next = Lib.UIEffects.Global:LookUpCinematicInQueue(i);
            if Next and Next[1] == CinematicEventTypes.Cutscene then
                self:NextCutscene(i);
            end
        end
    end
end

function Lib.CutsceneSystem.Global:CreateCutsceneGetPage(_Cutscene)
    _Cutscene.GetPage = function(self, _PlayerID, _NameOrID)
        local ID = Lib.CutsceneSystem.Global:GetPageIDByName(_PlayerID, _NameOrID);
        return Lib.CutsceneSystem.Global.Cutscene[_PlayerID][ID];
    end
end

function Lib.CutsceneSystem.Global:CreateCutsceneAddPage(_Cutscene)
    _Cutscene.AddPage = function(self, _Page)
        if type(_Page) == "table" then
            -- Make page legit
            _Page.__Legit = true;

            -- Translate text
            _Page.Title = Localize(_Page.Title);
            if _Page.Text then
                _Page.Text = Localize(_Page.Text);
            end
            -- Translate text lines
            if _Page.Lines then
                _Page.Lines = Localize(_Page.Lines);
            end
            if not _Page.Lines and not _Page.Text then
                assert(false, "Missing Lines or Text attribute!");
                return;
            end

            -- Set bar default
            if _Page.BigBars == nil then
                _Page.BigBars = false;
            end
        end
        table.insert(_Cutscene, _Page);
        return _Page;
    end
end

function Lib.CutsceneSystem.Global:StartCutscene(_Name, _PlayerID, _Data)
    self.CutsceneQueue[_PlayerID] = self.CutsceneQueue[_PlayerID] or {};
    Lib.UIEffects.Global:PushCinematicEventToQueue(
        _PlayerID,
        CinematicEventTypes.Cutscene,
        _Name,
        _Data
    );
end

function Lib.CutsceneSystem.Global:EndCutscene(_PlayerID)
    Logic.SetGlobalInvulnerability(0);
    SendReportToLocal(Report.CutsceneEnded, _PlayerID);
    if self.Cutscene[_PlayerID].Finished then
        self.Cutscene[_PlayerID]:Finished();
    end
    FinishCinematicEvent(self.Cutscene[_PlayerID].Name, _PlayerID);
    self.Cutscene[_PlayerID] = nil;
end

function Lib.CutsceneSystem.Global:NextCutscene(_PlayerID)
    if self:CanStartCutscene(_PlayerID) then
        local CutsceneData = Lib.UIEffects.Global:PopCinematicEventFromQueue(_PlayerID);
        assert(CutsceneData[1] == CinematicEventTypes.Cutscene);
        StartCinematicEvent(CutsceneData[2], _PlayerID);

        local Cutscene = CutsceneData[3];
        Cutscene.Name = CutsceneData[2];
        Cutscene.PlayerID = _PlayerID;
        Cutscene.BarOpacity = Cutscene.BarOpacity or 1;
        Cutscene.CurrentPage = 0;
        self.Cutscene[_PlayerID] = Cutscene;

        if Cutscene.EnableGlobalImmortality then
            Logic.SetGlobalInvulnerability(1);
        end
        if self.Cutscene[_PlayerID].Starting then
            self.Cutscene[_PlayerID]:Starting();
        end

        SendReportToLocal(Report.CutsceneStarted, _PlayerID, Cutscene.Name, Cutscene);
        SendReport(Report.CutsceneStarted, _PlayerID, Cutscene.Name);
    end
end

function Lib.CutsceneSystem.Global:StartCutsceneFlight(_PlayerID, _PageID, _Duration)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    self.Cutscene[_PlayerID][_PageID].Duration = _Duration;
    if self.Cutscene[_PlayerID][_PageID].Action then
        self.Cutscene[_PlayerID][_PageID]:Action();
    end

    SendReportToLocal(Report.CutsceneFlightStarted, _PlayerID, _PageID, _Duration);
end

function Lib.CutsceneSystem.Global:EndCutsceneFlight(_PlayerID, _PageID)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    SendReportToLocal(Report.CutsceneFlightEnded, _PlayerID, _PageID);
end

function Lib.CutsceneSystem.Global:DisplayPage(_PlayerID, _PageID, _Duration)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    SendReportToGlobal(Report.CutscenePageShown, _PlayerID, _PageID, _Duration);
    -- Nothing to do in global script
end

function Lib.CutsceneSystem.Global:GetCurrentCutscene(_PlayerID)
    return self.Cutscene[_PlayerID];
end

function Lib.CutsceneSystem.Global:GetCurrentCutscenePage(_PlayerID)
    if self.Cutscene[_PlayerID] then
        local PageID = self.Cutscene[_PlayerID].CurrentPage;
        return self.Cutscene[_PlayerID][PageID];
    end
end

function Lib.CutsceneSystem.Global:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Cutscene[_PlayerID] ~= nil then
            for i= 1, #self.Cutscene[_PlayerID], 1 do
                if type(self.Cutscene[_PlayerID][i]) == "table" and self.Cutscene[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function Lib.CutsceneSystem.Global:CanStartCutscene(_PlayerID)
    return  self.Cutscene[_PlayerID] == nil and
            not IsCinematicEventActive(_PlayerID) and
            self.LoadscreenClosed;
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.CutsceneSystem.Local:Initialize()
    if not self.IsInstalled then
        Report.CutsceneStarted = CreateReport("Event_CutsceneStarted");
        Report.CutsceneEnded = CreateReport("Event_CutsceneEnded");
        Report.CutscenePageShown = CreateReport("Event_CutscenePageShown");
        Report.CutsceneSkipButtonPressed = CreateReport("Event_CutsceneSkipButtonPressed");
        Report.CutsceneFlightStarted = CreateReport("Event_CutsceneFlightStarted");
        Report.CutsceneFlightEnded = CreateReport("Event_CutsceneFlightEnded");

        self:OverrideThroneRoomFunctions();

        -- Garbage collection
        Lib.CutsceneSystem.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.CutsceneSystem.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.CutsceneSystem.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.EscapePressed then
        -- Nothing to do?
    elseif _ID == Report.CutsceneStarted then
        self:StartCutscene(arg[1], arg[2], arg[3]);
    elseif _ID == Report.CutsceneEnded then
        self:EndCutscene(arg[1]);
    elseif _ID == Report.CutsceneFlightStarted then
        self:StartCutsceneFlight(arg[1], arg[2], arg[3]);
    elseif _ID == Report.CutsceneFlightEnded then
        self:EndCutsceneFlight(arg[1], arg[2]);
    elseif _ID == Report.CutsceneSkipButtonPressed then
        self:SkipButtonPressed(arg[1]);
    elseif _ID == Report.CutscenePageShown then
        -- Nothing to do?
    end
end

function Lib.CutsceneSystem.Local:StartCutscene(_PlayerID, _CutsceneName, _Cutscene)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Cutscene[_PlayerID] = _Cutscene;
    self.Cutscene[_PlayerID].LastSkipButtonPressed = 0;
    self.Cutscene[_PlayerID].CurrentPage = 0;

    DeactivateNormalInterface(_PlayerID);
    DeactivateBorderScroll(_PlayerID);

    if not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, 1);
    end
    self:ActivateCinematicMode(_PlayerID);
    self:NextFlight(_PlayerID);
end

function Lib.CutsceneSystem.Local:EndCutscene(_PlayerID)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end

    if not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, 1);
    end
    StopVoice("CutsceneSpeech");
    self:DeactivateCinematicMode(_PlayerID);
    ActivateNormalInterface(_PlayerID);
    ActivateBorderScroll(_PlayerID);
    Lib.UITools.Widget:UpdateHiddenWidgets();

    self.Cutscene[_PlayerID] = nil;
end

function Lib.CutsceneSystem.Local:NextFlight(_PlayerID)
    if self.Cutscene[_PlayerID] then
        self.Cutscene[_PlayerID].CurrentPage = self.Cutscene[_PlayerID].CurrentPage +1;
        local PageID = self.Cutscene[_PlayerID].CurrentPage;

        if self.Cutscene[_PlayerID][PageID] then
            local Flight = self.Cutscene[_PlayerID][PageID].Flight;
            if Camera.IsValidCutscene(Flight) then
                if GUI.GetPlayerID() == _PlayerID then
                    Camera.StartCutscene(Flight);
                end
            else
                -- This shouldn't happen!
                error("Lib.CutsceneSystem.Local:NextFlight: %s is an invalid flight!", tostring(Flight));
                self:PropagateCutsceneEnded(_PlayerID);
            end
        else
            self:PropagateCutsceneEnded(_PlayerID);
        end
    end
end

function Lib.CutsceneSystem.Local:PropagateCutsceneEnded(_PlayerID)
    if not self.Cutscene[_PlayerID] then
        return;
    end
    SendReportToGlobal(Report.CutsceneEnded, _PlayerID);
end

function Lib.CutsceneSystem.Local:FlightStarted(_Duration)
    local PlayerID = GUI.GetPlayerID();
    if self.Cutscene[PlayerID] then
        local PageID = self.Cutscene[PlayerID].CurrentPage;

        -- Far Clip Plane
        -- The clipping is changed by every camera event. To reset it to the
        -- desired value, we must update it here.
        local Page = self.Cutscene[PlayerID][PageID];
        if Page.FarClipPlane then
            SetRenderDistance(Page.FarClipPlane);
        end

        SendReportToGlobal(Report.CutsceneFlightStarted, PlayerID, PageID, _Duration);
    end
end
CutsceneFlightStarted = function(_Duration)
    Lib.CutsceneSystem.Local:FlightStarted(_Duration);
end

function Lib.CutsceneSystem.Local:StartCutsceneFlight(_PlayerID, _PageID, _Duration)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    self:DisplayPage(_PlayerID, _PageID, _Duration);
end

function Lib.CutsceneSystem.Local:FlightFinished()
    local PlayerID = GUI.GetPlayerID();
    if self.Cutscene[PlayerID] then
        local PageID = self.Cutscene[PlayerID].CurrentPage;
        SendReportToGlobal(Report.CutsceneFlightEnded, PlayerID, PageID);
    end
end
CutsceneFlightFinished = function()
    Lib.CutsceneSystem.Local:FlightFinished();
end

function Lib.CutsceneSystem.Local:EndCutsceneFlight(_PlayerID, _PageID)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    self:NextFlight(_PlayerID);
end

function Lib.CutsceneSystem.Local:DisplayPage(_PlayerID, _PageID, _Duration)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Cutscene[_PlayerID].AnimationQueue = self.Cutscene[_PlayerID].AnimationQueue or {};
    self.Cutscene[_PlayerID].CurrentPage = _PageID;
    if type(self.Cutscene[_PlayerID][_PageID]) == "table" then
        self.Cutscene[_PlayerID][_PageID].Started = Logic.GetTime();
        self.Cutscene[_PlayerID][_PageID].Duration = _Duration;
        ResetRenderDistance();
        self:DisplayPageBars(_PlayerID, _PageID);
        self:DisplayPageTitle(_PlayerID, _PageID);
        self:DisplayPageText(_PlayerID, _PageID);
        self:DisplayPageControls(_PlayerID, _PageID);
        self:DisplayPageFader(_PlayerID, _PageID);
        SendReportToGlobal(Report.CutscenePageShown, _PlayerID, _PageID, _Duration);
    end
end

function Lib.CutsceneSystem.Local:DisplayPageBars(_PlayerID, _PageID)
    local Page = self.Cutscene[_PlayerID][_PageID];
    local Opacity = (Page.Opacity ~= nil and Page.Opacity) or 1;
    local OpacityBig = (255 * Opacity);
    local OpacitySmall = (255 * Opacity);

    local BigVisibility = (Page.BigBars and 1) or 0;
    local SmallVisibility = (Page.BigBars and 0) or 1;
    if Opacity == 0 then
        BigVisibility = 0;
        SmallVisibility = 0;
    end

    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", BigVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", SmallVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", BigVisibility);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", SmallVisibility);

    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarBottom", 1, OpacityBig);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars/BarTop", 1, OpacityBig);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarBottom", 1, OpacitySmall);
    XGUIEng.SetMaterialAlpha("/InGame/ThroneRoomBars_2/BarTop", 1, OpacitySmall);
end

function Lib.CutsceneSystem.Local:DisplayPageTitle(_PlayerID, _PageID)
    local Page = self.Cutscene[_PlayerID][_PageID];
    local TitleWidget = "/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight";
    XGUIEng.SetText(TitleWidget, "");
    if Page.Title then
        local Title = ConvertPlaceholders(Localize(Page.Title));
        if Title:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
            Title = XGUIEng.GetStringTableText(Title);
        end
        if Title:sub(1, 1) ~= "{" then
            Title = "{@color:255,250,0,255}{center}" ..Title;
        end
        XGUIEng.SetText(TitleWidget, Title);
    end
end

function Lib.CutsceneSystem.Local:DisplayPageText(_PlayerID, _PageID)
    local Page = self.Cutscene[_PlayerID][_PageID];
    local TextWidget = "/InGame/ThroneRoom/Main/MissionBriefing/Text";
    XGUIEng.SetText(TextWidget, "");
    if Page.Text then
        local Text = ConvertPlaceholders(Localize(Page.Text));
        if Text:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
            Text = XGUIEng.GetStringTableText(Text);
        end
        if Text:sub(1, 1) ~= "{" then
            Text = "{center}" ..Text;
        end
        if not Page.BigBars then
            Text = "{cr}{cr}{cr}" .. Text;
        end
        XGUIEng.SetText(TextWidget, Text);
    end
    StopVoice("CutsceneSpeech");
    if Page.Speech then
        PlayVoice(Page.Speech, "CutsceneSpeech");
    end
end

function Lib.CutsceneSystem.Local:DisplayPageControls(_PlayerID, _PageID)
    local Page = self.Cutscene[_PlayerID][_PageID];
    local SkipFlag = 1;
    if Page.DisableSkipping == true then
        self.Cutscene[_PlayerID].FastForward = false;
        Game.GameTimeSetFactor(_PlayerID, 1);
        SkipFlag = 0;
    end
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", SkipFlag);
end

function Lib.CutsceneSystem.Local:DisplayPageFader(_PlayerID, _PageID)
    local Page = self.Cutscene[_PlayerID][_PageID];
    g_Fade.To = Page.FaderAlpha or 0;

    local PageFadeIn = Page.FadeIn;
    if PageFadeIn then
        FadeIn(PageFadeIn);
    end

    local PageFadeOut = Page.FadeOut;
    if PageFadeOut then
        -- FIXME: This would create jobs that are only be paused at the end!
        self.Cutscene[_PlayerID].FaderJob = RequestHiResJob(function(_Time, _FadeOut)
            if Logic.GetTimeMs() > _Time - (_FadeOut * 1000) then
                FadeOut(_FadeOut);
                return true;
            end
        end, (Page.Started * 1000) + (Page.Duration * 100), PageFadeOut);
    end
end

function Lib.CutsceneSystem.Local:ThroneRoomCameraControl(_PlayerID, _Page)
    if _Page then
        if _Page.DisableSkipping then
            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");
            -- XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 0);
            return;
        end
        -- XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);

        -- Button text
        local SkipText = Localize(Lib.CutsceneSystem.Text.FastForwardActivate);
        if self.Cutscene[_PlayerID].FastForward then
            SkipText = Localize(Lib.CutsceneSystem.Text.FastForwardDeactivate);
        end
        XGUIEng.SetText("/InGame/ThroneRoom/Main/Skip", "{center}" ..SkipText);

        -- Fast forward message
        if self.Cutscene[_PlayerID].FastForward then
            local RealTime = GetSecondsRealTime();
            if not self.Cutscene[_PlayerID].FastForwardRealTime then
                self.Cutscene[_PlayerID].FastForwardRealTime = RealTime;
            end
            if self.Cutscene[_PlayerID].FastForwardRealTime < RealTime then
                self.Cutscene[_PlayerID].FastForwardIndent = (self.Cutscene[_PlayerID].FastForwardIndent or 0) +1;
                if self.Cutscene[_PlayerID].FastForwardIndent > 4 then
                    self.Cutscene[_PlayerID].FastForwardIndent = 1;
                end
                self.Cutscene[_PlayerID].FastForwardRealTime = RealTime;
            end
            local Text = "{cr}{cr}" ..Localize(Lib.CutsceneSystem.Text.FastFormardMessage);
            local Indent = string.rep("  ", (self.Cutscene[_PlayerID].FastForwardIndent or 0));
            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", Text..Indent.. ". . .");
        else
            XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");
        end
    end
end

function Lib.CutsceneSystem.Local:SkipButtonPressed(_PlayerID)
    if self.Cutscene[_PlayerID] == nil then
        return;
    end
    if (self.Cutscene[_PlayerID].LastSkipButtonPressed + 500) < Logic.GetTimeMs() then
        self.Cutscene[_PlayerID].LastSkipButtonPressed = Logic.GetTimeMs();

        -- Change speed of cutscene is only possible in singleplayer!
        if not Framework.IsNetworkGame() then
            if self.Cutscene[_PlayerID].FastForward then
                self.Cutscene[_PlayerID].FastForward = false;
                Game.GameTimeSetFactor(_PlayerID, 1);
            else
                self.Cutscene[_PlayerID].FastForward = true;
                Game.GameTimeSetFactor(_PlayerID, 10);
            end
        end
    end
end

function Lib.CutsceneSystem.Local:GetCurrentCutscene(_PlayerID)
    return self.Cutscene[_PlayerID];
end

function Lib.CutsceneSystem.Local:GetCurrentCutscenePage(_PlayerID)
    if self.Cutscene[_PlayerID] then
        local PageID = self.Cutscene[_PlayerID].CurrentPage;
        return self.Cutscene[_PlayerID][PageID];
    end
end

function Lib.CutsceneSystem.Local:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Cutscene[_PlayerID] ~= nil then
            for i= 1, #self.Cutscene[_PlayerID], 1 do
                if type(self.Cutscene[_PlayerID][i]) == "table" and self.Cutscene[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function Lib.CutsceneSystem.Local:OverrideThroneRoomFunctions()
    self.Orig_GameCallback_Camera_SkipButtonPressed = GameCallback_Camera_SkipButtonPressed;
    GameCallback_Camera_SkipButtonPressed = function(_PlayerID)
        Lib.CutsceneSystem.Local.Orig_GameCallback_Camera_SkipButtonPressed(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            SendReportToGlobal(Report.CutsceneSkipButtonPressed, _PlayerID);
        end
    end

    self.Orig_GameCallback_Camera_ThroneroomCameraControl = GameCallback_Camera_ThroneroomCameraControl;
    GameCallback_Camera_ThroneroomCameraControl = function(_PlayerID)
        Lib.CutsceneSystem.Local.Orig_GameCallback_Camera_ThroneroomCameraControl(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            local Cutscene = Lib.CutsceneSystem.Local:GetCurrentCutscene(_PlayerID);
            if Cutscene ~= nil then
                Lib.CutsceneSystem.Local:ThroneRoomCameraControl(
                    _PlayerID,
                    Lib.CutsceneSystem.Local:GetCurrentCutscenePage(_PlayerID)
                );
            end
        end
    end

    self.Orig_GameCallback_Escape = GameCallback_Escape;
    GameCallback_Escape = function()
        if Lib.CutsceneSystem.Local.Cutscene[GUI.GetPlayerID()] then
            return;
        end
        Lib.CutsceneSystem.Local.Orig_GameCallback_Escape();
    end
end

function Lib.CutsceneSystem.Local:ActivateCinematicMode(_PlayerID)
    if self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.CinematicActive = true;

    if not self.LoadscreenClosed then
        XGUIEng.PopPage();
    end

    local ConsoleWasVisible = IsScriptConsoleShown();
    if ConsoleWasVisible then
        HideScriptConsole();
    end

    local ScreenX, ScreenY = GUI.GetScreenSize();

    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);
    XGUIEng.PushPage("/InGame/ThroneRoomBars", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2", false);
    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_Dodge", false);
    XGUIEng.PushPage("/InGame/ThroneRoomBars_2_Dodge", false);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Skip", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/StartButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/Frame", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/DialogBG", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogTopChooseKnight/FrameEdges", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/DialogBottomRight3pcs", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/KnightInfoButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Briefing", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/BackButton", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/Cutscene", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/TitleContainer", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Text", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Title", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", 1);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/BG", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo/LeftFrame", 0);

    -- Text
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Text", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Title", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    -- Title and back button position
    local x,y = XGUIEng.GetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight");
    XGUIEng.SetWidgetScreenPosition("/InGame/ThroneRoom/Main/DialogTopChooseKnight/ChooseYourKnight", x, 65 * (ScreenY/1080));

    self.SelectionBackup = {GUI.GetSelectedEntities()};
    GUI.ClearSelection();
    GUI.ClearNotes();
    GUI.ForbidContextSensitiveCommandsInSelectionState();
    GUI.ActivateCutSceneState();
    GUI.SetFeedbackSoundOutputState(0);
    GUI.EnableBattleSignals(false);
    Input.CutsceneMode();
    if not self.Cutscene[_PlayerID].EnableFoW then
        Display.SetRenderFogOfWar(0);
    end
    if self.Cutscene[_PlayerID].EnableSky then
        Display.SetRenderSky(1);
    end
    if not self.Cutscene[_PlayerID].EnableBorderPins then
        Display.SetRenderBorderPins(0);
    end
    if self:IsChangingGraphicsPermited() then
        Display.SetUserOptionOcclusionEffect(0);
    end
    Camera.SwitchCameraBehaviour(5);

    InitializeFader();
    g_Fade.To = 1;
    SetFaderAlpha(1);

    if ConsoleWasVisible then
        ShowScriptConsole();
    end
    if not self.LoadscreenClosed then
        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);
    end
end

function Lib.CutsceneSystem.Local:DeactivateCinematicMode(_PlayerID)
    if not self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.CinematicActive = false;

    local ConsoleWasVisible = IsScriptConsoleShown();
    if ConsoleWasVisible then
        HideScriptConsole();
    end

    g_Fade.To = 0;
    SetFaderAlpha(0);
    XGUIEng.PopPage();
    Camera.SwitchCameraBehaviour(0);
    Display.UseStandardSettings();
    Input.GameMode();
    GUI.EnableBattleSignals(true);
    GUI.SetFeedbackSoundOutputState(1);
    GUI.ActivateSelectionState();
    GUI.PermitContextSensitiveCommandsInSelectionState();
    for k, v in pairs(self.SelectionBackup) do
        GUI.SelectEntity(v);
    end
    Display.SetRenderSky(0);
    Display.SetRenderBorderPins(1);
    Display.SetRenderFogOfWar(1);
    if Options.GetIntValue("Display", "Occlusion", 0) > 0 then
        Display.SetUserOptionOcclusionEffect(1);
    end

    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.PopPage();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionBriefing/Objectives", " ");

    ResetRenderDistance();

    if ConsoleWasVisible then
        ShowScriptConsole();
    end
end

-- -------------------------------------------------------------------------- --

function Lib.CutsceneSystem.Local:IsChangingGraphicsPermited()
    if Lib.BriefingSystem then
        return Lib.BriefingSystem.Local:IsChangingGraphicsPermited();
    end
    if Lib.DialogSystem then
        return Lib.DialogSystem.Local:IsChangingGraphicsPermited();
    end
    return self.Config.DoAlternateGraphics == true;
end

function Lib.CutsceneSystem.Local:RequestAlternateGraphics()
    if Lib.BriefingSystem then
        return Lib.BriefingSystem.Local:RequestAlternateGraphics();
    end
    if Lib.DialogSystem then
        return Lib.DialogSystem.Local:RequestAlternateGraphics();
    end
    if IsMultiplayer() then
        return;
    end

    DialogRequestBox(
        GUI.GetPlayerID(),
        Lib.CutsceneSystem.Text.Request.Title,
        Lib.CutsceneSystem.Text.Request.Text,
        function(_Yes)
            Lib.BriefingSystem.Local.Config.DoAlternateGraphics = _Yes == true;
        end,
        false
    );
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.CutsceneSystem.Name);

Lib.Register("module/information/DialogSystem_Behavior");

function Reprisal_Dialog(_Name, _Dialog)
    return B_Reprisal_Dialog:new(_Name, _Dialog);
end

B_Reprisal_Dialog = {
    Name = "Reprisal_Dialog",
    Description = {
        en = "Reprisal: Calls a function to start an new dialog.",
        de = "Vergeltung: Ruft die Funktion auf und startet das enthaltene Dialog.",
        fr = "Rétribution: Appelle la fonction et démarre le dialogue contenu.",
    },
    Parameter = {
        { ParameterType.Default, en = "Dialog name",     de = "Name des Dialog",     fr = "Nom du dialogue" },
        { ParameterType.Default, en = "Dialog function", de = "Funktion mit Dialog", fr = "Fonction du dialogue" },
    },
}

function B_Reprisal_Dialog:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_Dialog:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.DialogName = _Parameter;
    elseif (_Index == 1) then
        self.Function = _Parameter;
    end
end

function B_Reprisal_Dialog:CustomFunction(_Quest)
    _G[self.Function](self.DialogName, _Quest.ReceivingPlayer);
end

function B_Reprisal_Dialog:Debug(_Quest)
    if self.DialogName == nil or self.DialogName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    if not type(_G[self.Function]) == "function" then
        debug(false, _Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_Dialog);

-- -------------------------------------------------------------------------- --

function Reward_Dialog(_Name, _Dialog)
    return B_Reward_Dialog:new(_Name, _Dialog);
end

B_Reward_Dialog = CopyTable(B_Reprisal_Dialog);
B_Reward_Dialog.Name = "Reward_Dialog";
B_Reward_Dialog.Description.en = "Reward: Calls a function to start an new dialog.";
B_Reward_Dialog.Description.de = "Lohn: Ruft die Funktion auf und startet das enthaltene Dialog.";
B_Reward_Dialog.Description.fr = "Récompense: Appelle la fonction et lance le dialogue qu'elle contient.";
B_Reward_Dialog.GetReprisalTable = nil;

B_Reward_Dialog.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_Dialog);

-- -------------------------------------------------------------------------- --

function Trigger_Dialog(_Name, _PlayerID, _Waittime)
    return B_Trigger_Dialog:new(_Name, _PlayerID, _Waittime);
end

B_Trigger_Dialog = {
    Name = "Trigger_Dialog",
    Description = {
        en = "Trigger: Checks if an dialog has concluded and starts the quest if so.",
        de = "Auslöser: Prüft, ob ein Dialog beendet ist und startet dann den Quest.",
        fr = "Déclencheur: Vérifie si un dialogue est terminé et démarre alors la quête.",
    },
    Parameter = {
        { ParameterType.Default,  en = "Dialog name", de = "Name des Dialog", fr = "Nom du dialogue" },
        { ParameterType.PlayerID, en = "Player ID",   de = "Player ID",       fr = "Player ID" },
        { ParameterType.Number,   en = "Wait time",   de = "Wartezeit",       fr = "Temps d'attente" },
    },
}

function B_Trigger_Dialog:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_Dialog:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.DialogName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function B_Trigger_Dialog:CustomFunction(_Quest)
    if GetCinematicEvent(self.DialogName, self.PlayerID) == CinematicEventState.Concluded then
        if self.WaitTime and self.WaitTime > 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function B_Trigger_Dialog:Debug(_Quest)
    if self.WaitTime < 0 then
        debug(false, string.format("%s: %s: Wait time must be 0 or greater!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, string.format("%s: %s: Player-ID must be between 1 and 8!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.DialogName == nil or self.DialogName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_Dialog);

-- -------------------------------------------------------------------------- --

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/information/DialogSystem_API");

function StartDialog(_Dialog, _Name, _PlayerID)
    if GUI then
        return;
    end
    local PlayerID = _PlayerID;
    if not PlayerID and not Framework.IsNetworkGame() then
        PlayerID = 1; -- Human player?
    end
    assert(_Name ~= nil);
    assert(_PlayerID ~= nil);
    assert(type(_Dialog) == "table", "Dialog must be a table!");
    assert(#_Dialog > 0, "Dialog does not contain pages!");
    for i=1, #_Dialog do
        assert(
            type(_Dialog[i]) ~= "table" or _Dialog[i].__Legit,
            "Page is not initialized!"
        );
    end
    if _Dialog.EnableSky == nil then
        _Dialog.EnableSky = true;
    end
    if _Dialog.EnableFoW == nil then
        _Dialog.EnableFoW = false;
    end
    if _Dialog.EnableGlobalImmortality == nil then
        _Dialog.EnableGlobalImmortality = true;
    end
    if _Dialog.EnableBorderPins == nil then
        _Dialog.EnableBorderPins = false;
    end
    if _Dialog.RestoreGameSpeed == nil then
        _Dialog.RestoreGameSpeed = true;
    end
    if _Dialog.RestoreCamera == nil then
        _Dialog.RestoreCamera = true;
    end
    Lib.DialogSystem.Global:StartDialog(_Name, PlayerID, _Dialog);
end
API.StartDialog = StartDialog;

function RequestDialogAlternateGraphics()
    if not GUI then
        ExecuteLocal("RequestDialogAlternateGraphics()");
        return;
    end
    Lib.DialogSystem.Local:RequestAlternateGraphics();
end
API.RequestDialogAlternateGraphics = RequestDialogAlternateGraphics;

function IsDialogActive(_PlayerID)
    if not IsLocalScript() then
        return Lib.DialogSystem.Global:GetCurrentDialog(_PlayerID) ~= nil;
    end
    return Lib.DialogSystem.Local:GetCurrentDialog(_PlayerID) ~= nil;
end
API.IsDialogActive = IsDialogActive;

function AddDialogPages(_Dialog)
    Lib.DialogSystem.Global:CreateDialogGetPage(_Dialog);
    Lib.DialogSystem.Global:CreateDialogAddPage(_Dialog);
    Lib.DialogSystem.Global:CreateDialogAddMCPage(_Dialog);
    Lib.DialogSystem.Global:CreateDialogAddRedirect(_Dialog);

    local AP = function(_Page)
        local Page;
        if type(_Page) == "table" then
            if _Page.MC then
                Page = _Dialog:AddMCPage(_Page);
            else
                Page = _Dialog:AddPage(_Page);
            end
        else
            Page = _Dialog:AddRedirect(_Page);
        end
        return Page;
    end

    local ASP = function(...)
        if type(arg[1]) ~= "number" then
            Name = table.remove(arg, 1);
        end
        local Sender   = table.remove(arg, 1);
        local Position = table.remove(arg, 1);
        local Title    = table.remove(arg, 1);
        local Text     = table.remove(arg, 1);
        local Dialog   = table.remove(arg, 1);
        local Action;
        if type(arg[1]) == "function" then
            Action = table.remove(arg, 1);
        end
        return _Dialog:AddPage{
            Name         = Name,
            Title        = Title,
            Text         = Text,
            Actor        = Sender,
            Target       = Position,
            DialogCamera = Dialog == true,
            Action       = Action,
        };
    end
    return AP, ASP;
end
API.AddDialogPages = AddDialogPages;

function AP(_Data)
    assert(false);
end

function ASP(...)
    assert(false);
end

Lib.Register("module/information/DialogSystem_Text");

Lib.DialogSystem.Text = {
    Continue = {
        de = "{cr}{cr}{azure}Weiter mit ESC",
        en = "{cr}{cr}{azure}Continue with ESC",
        fr = "{cr}{cr}{azure}Continuer avec ESC",
    },

    Request = {
        Title = {
            de = "Grafik ändern",
            en = "Alternate Graphics",
            fr = "Graphiques alternatifs",
        },
        Text  = {
            de = "Während des Spiels können die Grafikeinstellungen durch das Mapscript vorübergehend geändert werden. Willst du das zulassen?",
            en = "During gameplay the graphic settings might be changed temporarily by the mapscript. Do you want to allow that?",
            fr = "Pendant le jeu, les paramètres graphiques peuvent être modifiés temporairement par le mapscript. Voulez-vous autoriser cela?",
        },
    },
};

Lib.DialogSystem = Lib.DialogSystem or {};
Lib.DialogSystem.Name = "DialogSystem";
Lib.DialogSystem.Global = {
    Dialog = {},
    DialogQueue = {},
    DialogCounter = 0,
};
Lib.DialogSystem.Local = {
    Config = {
        DoAlternateGraphics = true,
    },
    Dialog = {},
};

CONST_DIALOG = {
    TIMER_PER_CHAR = 0.175,
    CAMERA_ANGLEDEFAULT = 43,
    CAMERA_ROTATIONDEFAULT = -45,
    CAMERA_ZOOMDEFAULT = 6500,
    CAMERA_FOVDEFAULT = 42,
    DLGCAMERA_ANGLEDEFAULT = 27,
    DLGCAMERA_ROTATIONDEFAULT = -45,
    DLGCAMERA_ZOOMDEFAULT = 1750,
    DLGCAMERA_FOVDEFAULT = 25,
}

Lib.Require("comfort/IsMultiplayer");
Lib.Require("core/Core");
Lib.Require("module/ui/UIEffects");
Lib.Require("module/ui/UITools");
Lib.Require("module/settings/Sound");
Lib.Require("module/information/Requester");
Lib.Require("module/information/DialogSystem_Text");
Lib.Require("module/information/DialogSystem_API");
Lib.Require("module/information/DialogSystem_Behavior");
Lib.Register("module/information/DialogSystem");

CinematicEventTypes.Dialog = 5;

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.DialogSystem.Global:Initialize()
    if not self.IsInstalled then
        Report.DialogStarted = CreateReport("Event_DialogStarted");
        Report.DialogEnded = CreateReport("Event_DialogEnded");
        Report.DialogPageShown = CreateReport("Event_DialogPageShown");
        Report.DialogOptionSelected = CreateReport("Event_DialogOptionSelected");

        for i= 1, 8 do
            self.DialogQueue[i] = {};
        end
        RequestHiResJob(function()
            Lib.DialogSystem.Global:UpdateQueue();
            Lib.DialogSystem.Global:DialogExecutionController();
        end);

        -- Garbage collection
        Lib.DialogSystem.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.DialogSystem.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.DialogSystem.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.EscapePressed then
        self:SkipButtonPressed(arg[1]);
    elseif _ID == Report.DialogStarted then
        self:NextPage(arg[1]);
    elseif _ID == Report.DialogEnded then
        -- Nothing to do?
    elseif _ID == Report.DialogPageShown then
        -- Nothing to do?
    elseif _ID == Report.DialogOptionSelected then
        self:OnOptionSelected(arg[1], arg[2]);
    end
end

-- Manages the actual activation of dialogues.
function Lib.DialogSystem.Global:UpdateQueue()
    for i= 1, 8 do
        if self:CanStartDialog(i) then
            local Next = Lib.UIEffects.Global:LookUpCinematicInQueue(i);
            if Next and Next[1] == CinematicEventTypes.Dialog then
                self:NextDialog(i);
            end
        end
    end
end

-- Manages auto skipping of pages.
function Lib.DialogSystem.Global:DialogExecutionController()
    for i= 1, 8 do
        if self.Dialog[i] then
            local PageID = self.Dialog[i].CurrentPage;
            local Page = self.Dialog[i][PageID];
            if Page and not Page.MC and Page.Duration > 0 and Page.AutoSkip then
                if (Page.Started + Page.Duration) < Logic.GetTime() then
                    self:NextPage(i);
                end
            end
        end
    end
end

function Lib.DialogSystem.Global:CreateDialogGetPage(_Dialog)
    _Dialog.GetPage = function(self, _NameOrID)
        local ID = Lib.DialogSystem.Global:GetPageIDByName(_Dialog.PlayerID, _NameOrID);
        return Lib.DialogSystem.Global.Dialog[_Dialog.PlayerID][ID];
    end
end

function Lib.DialogSystem.Global:CreateDialogAddPage(_Dialog)
    _Dialog.AddPage = function(self, _Page)
        -- Dialog length
        self.Length = (self.Length or 0) +1;

        -- Set page name
        local Identifier = "Page" ..(#self +1);
        if _Page.Name then
            Identifier = _Page.Name;
        else
            _Page.Name = Identifier;
        end

        -- Make page legit
        _Page.__Legit = true;
        -- Language
        _Page.Text = Localize(_Page.Text or "");

        -- Skip page
        _Page.AutoSkip = false;
        if _Page.Duration then
            if _Page.Duration == -1 then
                _Page.Duration = string.len(_Page.Text or "") * CONST_DIALOG.TIMER_PER_CHAR;
                _Page.Duration = (_Page.Duration < 6 and 6) or _Page.Duration < 6;
            end
            _Page.AutoSkip = _Page.Duration > 0;
        end

        -- Default camera rotation
        if not _Page.Rotation then
            _Page.Rotation = CONST_DIALOG.CAMERA_ROTATIONDEFAULT;
            if _Page.DialogCamera then
                _Page.Rotation = CONST_DIALOG.DLGCAMERA_ROTATIONDEFAULT;
            end
            if _Page.Position and type(_Page.Position) ~= "table" then
                local ID = GetID(_Page.Position);
                local Orientation = Logic.GetEntityOrientation(ID) +90;
                _Page.Rotation = Orientation;
            elseif _Page.Target then
                local ID = GetID(_Page.Target);
                local Orientation = Logic.GetEntityOrientation(ID) +90;
                _Page.Rotation = Orientation;
            end
        end
        -- Default camera distance
        if not _Page.Distance then
            _Page.Distance = CONST_DIALOG.CAMERA_ZOOMDEFAULT;
            if _Page.DialogCamera then
                _Page.Distance = CONST_DIALOG.DLGCAMERA_ZOOMDEFAULT;
            end
        end
        -- Default camera angle
        if not _Page.Angle then
            _Page.Angle = CONST_DIALOG.CAMERA_ANGLEDEFAULT;
            if _Page.DialogCamera then
                _Page.Angle = CONST_DIALOG.DLGCAMERA_ANGLEDEFAULT;
            end
        end

        -- Multiple choice selection
        _Page.GetSelected = function(self)
            return 0;
        end
        -- Return page
        table.insert(self, _Page);
        return _Page;
    end
end

function Lib.DialogSystem.Global:CreateDialogAddMCPage(_Dialog)
    _Dialog.AddMCPage = function(self, _Page)
        -- Create base page
        local Page = self:AddPage(_Page);

        -- Multiple Choice options
        if Page.MC then
            for i= 1, #Page.MC do
                Page.MC[i][1] = Localize(Page.MC[i][1]);
                Page.MC[i].ID = Page.MC[i].ID or i;
            end
            Page.AutoSkip = false;
            Page.Duration = -1;
        end

        -- Multiple choice selection
        Page.GetSelected = function(self)
            if self.MC then
                return self.MC.Selected;
            end
            return 0;
        end
        -- Return page
        return Page;
    end
end

function Lib.DialogSystem.Global:CreateDialogAddRedirect(_Dialog)
    _Dialog.AddRedirect = function(self, _Target)
        -- Dialog length
        self.Length = (self.Length or 0) +1;
        -- Return page
        local Page = (_Target == nil and -1) or _Target;
        table.insert(self, Page);
        return Page;
    end
end

-- Does not really start the dialog. It is pushed inside the global queue for
-- all informational stuff and executed later by a job.
function Lib.DialogSystem.Global:StartDialog(_Name, _PlayerID, _Data)
    self.DialogQueue[_PlayerID] = self.DialogQueue[_PlayerID] or {};
    Lib.UIEffects.Global:PushCinematicEventToQueue(
        _PlayerID,
        CinematicEventTypes.Dialog,
        _Name,
        _Data
    );
end

function Lib.DialogSystem.Global:EndDialog(_PlayerID)
    Logic.SetGlobalInvulnerability(0);
    ExecuteLocal(
        [[Lib.DialogSystem.Local:ResetTimerButtons(%d);
          Camera.RTS_FollowEntity(0);]],
        _PlayerID
    );
    SendReport(
        Report.DialogEnded,
        _PlayerID,
        self.Dialog[_PlayerID].Name
    );
    SendReportToLocal(
        Report.DialogEnded,
        _PlayerID,
        self.Dialog[_PlayerID].Name,
        self.Dialog[_PlayerID]
    );

    if self.Dialog[_PlayerID].Finished then
        self.Dialog[_PlayerID]:Finished();
    end
    FinishCinematicEvent(self.Dialog[_PlayerID].Name, _PlayerID);
    self.Dialog[_PlayerID] = nil;
end

function Lib.DialogSystem.Global:NextDialog(_PlayerID)
    if self:CanStartDialog(_PlayerID) then
        local DialogData = Lib.UIEffects.Global:PopCinematicEventFromQueue(_PlayerID);
        assert(DialogData[1] == CinematicEventTypes.Dialog);
        StartCinematicEvent(DialogData[2], _PlayerID);

        local Dialog = DialogData[3];
        Dialog.Name = DialogData[2];
        Dialog.PlayerID = _PlayerID;
        Dialog.LastSkipButtonPressed = 0;
        Dialog.CurrentPage = 0;
        self.Dialog[_PlayerID] = Dialog;

        if Dialog.EnableGlobalImmortality then
            Logic.SetGlobalInvulnerability(1);
        end
        if self.Dialog[_PlayerID].Starting then
            self.Dialog[_PlayerID]:Starting();
        end

        SendReportToLocal(
            Report.DialogStarted,
            _PlayerID,
            self.Dialog[_PlayerID].Name,
            self.Dialog[_PlayerID]
        );
        SendReport(
            Report.DialogStarted,
            _PlayerID,
            self.Dialog[_PlayerID].Name
        );
    end
end

function Lib.DialogSystem.Global:NextPage(_PlayerID)
    if self.Dialog[_PlayerID] == nil then
        return;
    end

    self.Dialog[_PlayerID].CurrentPage = self.Dialog[_PlayerID].CurrentPage +1;
    local PageID = self.Dialog[_PlayerID].CurrentPage;
    if PageID == -1 or PageID == 0 then
        self:EndDialog(_PlayerID);
        return;
    end

    local Page = self.Dialog[_PlayerID][PageID];
    if type(Page) == "table" then
        if PageID <= #self.Dialog[_PlayerID] then
            self.Dialog[_PlayerID][PageID].Started = Logic.GetTime();
            self.Dialog[_PlayerID][PageID].Duration = Page.Duration or -1;
            if self.Dialog[_PlayerID][PageID].Action then
                self.Dialog[_PlayerID][PageID]:Action();
            end
            self:DisplayPage(_PlayerID, PageID);
        else
            self:EndDialog(_PlayerID);
        end
    elseif type(Page) == "number" or type(Page) == "string" then
        local Target = self:GetPageIDByName(_PlayerID, self.Dialog[_PlayerID][PageID]);
        self.Dialog[_PlayerID].CurrentPage = Target -1;
        self:NextPage(_PlayerID);
    else
        self:EndDialog(_PlayerID);
    end
end

function Lib.DialogSystem.Global:DisplayPage(_PlayerID, _PageID)
    if self.Dialog[_PlayerID] == nil then
        return;
    end

    local Page = self.Dialog[_PlayerID][_PageID];
    if type(Page) == "table" then
        local PageID = self.Dialog[_PlayerID].CurrentPage;
        if Page.MC then
            for i= 1, #Page.MC, 1 do
                if type(Page.MC[i][3]) == "function" then
                    self.Dialog[_PlayerID][PageID].MC[i].Visible = Page.MC[i][3](_PlayerID, PageID, i);
                end
            end
        end
    end

    SendReport(Report.DialogPageShown, _PlayerID, _PageID);
    SendReportToLocal(Report.DialogPageShown, _PlayerID, _PageID, Page);
end

-- There is no skip button but I want to keep the original names to make
-- comparisons easier for other authors who might want to implement yet
-- another information system.
function Lib.DialogSystem.Global:SkipButtonPressed(_PlayerID, _PageID)
    if not self.Dialog[_PlayerID] then
        return;
    end
    if (self.Dialog[_PlayerID].LastSkipButtonPressed + 500) > Logic.GetTimeMs() then
        return;
    end
    local PageID = self.Dialog[_PlayerID].CurrentPage;
    if self.Dialog[_PlayerID][PageID].AutoSkip
    or self.Dialog[_PlayerID][PageID].MC then
        return;
    end
    if self.Dialog[_PlayerID][PageID].OnForward then
        self.Dialog[_PlayerID][PageID]:OnForward();
    end
    self.Dialog[_PlayerID].LastSkipButtonPressed = Logic.GetTimeMs();
    self:NextPage(_PlayerID);
end

function Lib.DialogSystem.Global:OnOptionSelected(_PlayerID, _OptionID)
    if self.Dialog[_PlayerID] == nil then
        return;
    end
    local PageID = self.Dialog[_PlayerID].CurrentPage;
    if type(self.Dialog[_PlayerID][PageID]) ~= "table" then
        return;
    end
    local Page = self.Dialog[_PlayerID][PageID];
    if Page.MC then
        local Option;
        for i= 1, #Page.MC, 1 do
            if Page.MC[i].ID == _OptionID then
                Option = Page.MC[i];
            end
        end
        if Option ~= nil then
            local Target = Option[2];
            if type(Option[2]) == "function" then
                Target = Option[2](_PlayerID, PageID, _OptionID);
            end
            self.Dialog[_PlayerID][PageID].MC.Selected = Option.ID;
            self.Dialog[_PlayerID].CurrentPage = self:GetPageIDByName(_PlayerID, Target) -1;
            self:NextPage(_PlayerID);
        end
    end
end

function Lib.DialogSystem.Global:GetCurrentDialog(_PlayerID)
    return self.Dialog[_PlayerID];
end

function Lib.DialogSystem.Global:GetCurrentDialogPage(_PlayerID)
    if self.Dialog[_PlayerID] then
        local PageID = self.Dialog[_PlayerID].CurrentPage;
        return self.Dialog[_PlayerID][PageID];
    end
end

function Lib.DialogSystem.Global:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Dialog[_PlayerID] ~= nil then
            for i= 1, #self.Dialog[_PlayerID], 1 do
                if type(self.Dialog[_PlayerID][i]) == "table" and self.Dialog[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function Lib.DialogSystem.Global:CanStartDialog(_PlayerID)
    return self.Dialog[_PlayerID] == nil
           and not IsCinematicEventActive(_PlayerID)
           and self.LoadscreenClosed;
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.DialogSystem.Local:Initialize()
    if not self.IsInstalled then
        Report.DialogStarted = CreateReport("Event_DialogStarted");
        Report.DialogEnded = CreateReport("Event_DialogEnded");
        Report.DialogPageShown = CreateReport("Event_DialogPageShown");
        Report.DialogOptionSelected = CreateReport("Event_DialogOptionSelected");

        self:OverrideThroneRoomFunctions();

        -- Garbage collection
        Lib.DialogSystem.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.DialogSystem.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.DialogSystem.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.EscapePressed then
        -- Nothing to do?
    elseif _ID == Report.DialogStarted then
        self:StartDialog(arg[1], arg[2], arg[3]);
    elseif _ID == Report.DialogEnded then
        self:EndDialog(arg[1], arg[2], arg[3]);
    elseif _ID == Report.DialogPageShown then
        self:DisplayPage(arg[1], arg[2], arg[3]);
    end
end

function Lib.DialogSystem.Local:StartDialog(_PlayerID, _DialogName, _Dialog)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Dialog[_PlayerID] = _Dialog;
    self.Dialog[_PlayerID].CurrentPage = 0;
    local PosX, PosY = Camera.RTS_GetLookAtPosition();
    local Rotation = Camera.RTS_GetRotationAngle();
    local ZoomFactor = Camera.RTS_GetZoomFactor();
    local SpeedFactor = Game.GameTimeGetFactor(_PlayerID);
    local SubX, SubY = XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/AlignBottomLeft/SubTitles");
    self.Dialog[_PlayerID].Backup = {
        SubTitles = {SubX, SubY},
        Camera    = {PosX, PosY, Rotation, ZoomFactor},
        Speed     = SpeedFactor,
    };

    DeactivateNormalInterface(_PlayerID);
    DeactivateBorderScroll(_PlayerID);

    if not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, 1);
    end
    self:ActivateCinematicMode(_PlayerID);
end

function Lib.DialogSystem.Local:EndDialog(_PlayerID, _DialogName, _Dialog)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end

    if self.Dialog[_PlayerID].RestoreGameSpeed and not Framework.IsNetworkGame() then
        Game.GameTimeSetFactor(_PlayerID, self.Dialog[_PlayerID].Backup.Speed);
    end
    if self.Dialog[_PlayerID].RestoreCamera then
        Camera.RTS_SetLookAtPosition(self.Dialog[_PlayerID].Backup.Camera[1], self.Dialog[_PlayerID].Backup.Camera[2]);
        Camera.RTS_SetRotationAngle(self.Dialog[_PlayerID].Backup.Camera[3]);
        Camera.RTS_SetZoomFactor(self.Dialog[_PlayerID].Backup.Camera[4]);
    end
    StopVoice("DialogSpeech");

    self:DeactivateCinematicMode(_PlayerID);
    ActivateNormalInterface(_PlayerID);
    ActivateBorderScroll(_PlayerID);
    Lib.UITools.Widget:UpdateHiddenWidgets();

    self.Dialog[_PlayerID] = nil;
    Display.SetRenderFogOfWar(1);
    Display.SetRenderBorderPins(1);
    Display.SetRenderSky(0);
end

function Lib.DialogSystem.Local:DisplayPage(_PlayerID, _PageID, _PageData)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.Dialog[_PlayerID][_PageID] = _PageData;
    self.Dialog[_PlayerID].CurrentPage = _PageID;

    if type(self.Dialog[_PlayerID][_PageID]) == "table" then
        self.Dialog[_PlayerID][_PageID].Started = Logic.GetTime();
        self:DisplayPageFader(_PlayerID, _PageID);
        self:DisplayPagePosition(_PlayerID, _PageID);
        self:DisplayPageActor(_PlayerID, _PageID);
        self:DisplayPageTitle(_PlayerID, _PageID);
        self:DisplayPageText(_PlayerID, _PageID);
        if self.Dialog[_PlayerID][_PageID].MC then
            self:DisplayPageOptionsDialog(_PlayerID, _PageID);
        end
    end
end

function Lib.DialogSystem.Local:DisplayPagePosition(_PlayerID, _PageID)
    local Page = self.Dialog[_PlayerID][_PageID];
    -- Camera
    Camera.RTS_FollowEntity(0);
    if Page.Position then
        local Position = Page.Position;
        if type(Position) ~= "table" then
            Position = GetPosition(Page.Position);
        end
        Camera.RTS_SetLookAtPosition(Position.X, Position.Y);
    elseif Page.Target then
        Camera.RTS_FollowEntity(GetID(Page.Target));
    else
        assert(false);
    end
    Camera.RTS_SetRotationAngle(Page.Rotation);
    Camera.RTS_SetZoomFactor(Page.Distance / 18000);
    -- FIXME: This does not work?
    Camera.RTS_SetZoomAngle(Page.Angle);
end

function Lib.DialogSystem.Local:DisplayPageFader(_PlayerID, _PageID)
    local Page = self.Dialog[_PlayerID][_PageID];
    g_Fade.To = Page.FaderAlpha or 0;

    local PageFadeIn = Page.FadeIn;
    if PageFadeIn then
        FadeIn(PageFadeIn);
    end

    local PageFadeOut = Page.FadeOut;
    if PageFadeOut then
        -- FIXME: This would create jobs that are only be paused at the end!
        self.Dialog[_PlayerID].FaderJob = RequestHiResJob(function(_Time, _FadeOut)
            if Logic.GetTimeMs() > _Time - (_FadeOut * 1000) then
                FadeOut(_FadeOut);
                return true;
            end
        end, Logic.GetTimeMs() + ((Page.Duration or 0) * 1000), PageFadeOut);
    end
end

function Lib.DialogSystem.Local:DisplayPageActor(_PlayerID, _PageID)
    local PortraitWidget = "/InGame/Root/Normal/AlignBottomLeft/Message";
    XGUIEng.ShowWidget(PortraitWidget, 1);
    XGUIEng.ShowAllSubWidgets(PortraitWidget, 1);
    XGUIEng.ShowWidget(PortraitWidget.. "/QuestLog", 0);
    XGUIEng.ShowWidget(PortraitWidget.. "/Update", 0);
    local Page = self.Dialog[_PlayerID][_PageID];
    if not Page.Actor or Page.Actor == -1 then
        XGUIEng.ShowWidget(PortraitWidget, 0);
        return;
    end
    local Actor = self:GetPageActor(_PlayerID, _PageID);
    self:DisplayActorPortrait(_PlayerID, Actor);
end

function Lib.DialogSystem.Local:GetPageActor(_PlayerID, _PageID)
    local Actor = g_PlayerPortrait[_PlayerID];
    local Page = self.Dialog[_PlayerID][_PageID];
    if type(Page.Actor) == "string" then
        Actor = Page.Actor;
    elseif type(Page.Actor) == "number" then
        Actor = g_PlayerPortrait[Page.Actor];
    end
    -- If someone doesn't read the fucking manual...
    if not Models["Heads_" .. tostring(Actor)] then
        Actor = "H_NPC_Generic_Trader";
    end
    return Actor;
end

function Lib.DialogSystem.Local:DisplayPageTitle(_PlayerID, _PageID)
    local PortraitWidget = "/InGame/Root/Normal/AlignBottomLeft/Message";
    local Page = self.Dialog[_PlayerID][_PageID];
    if Page.Title then
        local Title = ConvertPlaceholders(Localize(Page.Title));
        if Title:find("^[A-Za-z0-9_]+/[A-Za-z0-9_]+$") then
            Title = XGUIEng.GetStringTableText(Title);
        end
        if Title:sub(1, 1) ~= "{" then
            Title = "{center}" ..Title;
        end
        XGUIEng.SetText(PortraitWidget.. "/MessagePortrait/PlayerName", Title);
        XGUIEng.ShowWidget(PortraitWidget.. "/MessagePortrait/PlayerName", 1);
    else
        XGUIEng.ShowWidget(PortraitWidget.. "/MessagePortrait/PlayerName", 0);
    end
end

function Lib.DialogSystem.Local:DisplayPageText(_PlayerID, _PageID)
    self:ResetSubtitlesPosition(_PlayerID);
    local Page = self.Dialog[_PlayerID][_PageID];
    local SubtitlesWidget = "/InGame/Root/Normal/AlignBottomLeft/SubTitles";
    if not Page or not Page.Text or Page.Text == "" then
        XGUIEng.SetText(SubtitlesWidget.. "/VoiceText1", " ");
        XGUIEng.ShowWidget(SubtitlesWidget, 0);
        return;
    end
    XGUIEng.ShowWidget(SubtitlesWidget, 1);
    XGUIEng.ShowWidget(SubtitlesWidget.. "/Update", 0);
    XGUIEng.ShowWidget(SubtitlesWidget.. "/VoiceText1", 1);
    XGUIEng.ShowWidget(SubtitlesWidget.. "/BG", 1);

    local Text = ConvertPlaceholders(Localize(Page.Text));
    local Extension = "";
    if not Page.AutoSkip and not Page.MC then
        Extension = ConvertPlaceholders(Localize(Lib.DialogSystem.Text.Continue));
    end
    XGUIEng.SetText(SubtitlesWidget.. "/VoiceText1", Text .. Extension);
    self:SetSubtitlesPosition(_PlayerID, _PageID);

    StopVoice("DialogSpeech");
    if Page and Page.Speech then
        PlayVoice(Page.Speech, "DialogSpeech");
    end
end

function Lib.DialogSystem.Local:SetSubtitlesPosition(_PlayerID, _PageID)
    local Page = self.Dialog[_PlayerID][_PageID];
    local MotherWidget = "/InGame/Root/Normal/AlignBottomLeft/SubTitles";
    local Height = XGUIEng.GetTextHeight(MotherWidget.. "/VoiceText1", true);
    local W, H = XGUIEng.GetWidgetSize(MotherWidget.. "/VoiceText1");
    local X,Y = XGUIEng.GetWidgetLocalPosition(MotherWidget);
    if Page.Actor then
        XGUIEng.SetWidgetSize(MotherWidget.. "/BG", W + 10, Height + 120);
        Y = 675 - Height;
        XGUIEng.SetWidgetLocalPosition(MotherWidget, X, Y);
    else
        XGUIEng.SetWidgetSize(MotherWidget.. "/BG", W + 10, Height + 35);
        Y = 1115 - Height;
        XGUIEng.SetWidgetLocalPosition(MotherWidget, 46, Y);
    end
end

function Lib.DialogSystem.Local:ResetSubtitlesPosition(_PlayerID)
    local Position = self.Dialog[_PlayerID].Backup.SubTitles;
    local SubtitleWidget = "/InGame/Root/Normal/AlignBottomLeft/SubTitles";
    XGUIEng.SetWidgetLocalPosition(SubtitleWidget, Position[1], Position[2]);
end

-- This is needed to reset the timer buttons after the portrait widget has been
-- abused to show the actor in the dialog.
function Lib.DialogSystem.Local:ResetTimerButtons(_PlayerID)
    if GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    if not g_Interaction.TimerQuests then
        return;
    end
    local MainWidget = "/InGame/Root/Normal/AlignTopLeft/QuestTimers/";
    for i= 1,6 do
        local ButtonWidget = MainWidget ..i.. "/TimerButton";
        local QuestIndex = g_Interaction.TimerQuests[i];
        if QuestIndex ~= nil then
            local Quest = Quests[QuestIndex];
            if g_Interaction.CurrentMessageQuestIndex == QuestIndex and not QuestLog.IsQuestLogShown() then
                g_Interaction.CurrentMessageQuestIndex = nil;
                g_VoiceMessageIsRunning = false;
                g_VoiceMessageEndTime = nil;
                XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait", 0);
                XGUIEng.ShowWidget(QuestLog.Widget.Main, 0);
                XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles", 0);
                XGUIEng.ShowAllSubWidgets("/InGame/Root/Normal/AlignBottomLeft/Message/QuestObjectives", 0);
                XGUIEng.HighLightButton(ButtonWidget, 0);
            end
            if Quest then
                self:DisplayActorPortrait(Quest.SendingPlayer);
            end
        end
    end
end

function Lib.DialogSystem.Local:DisplayActorPortrait(_PlayerID, _HeadModel)
    local PortraitWidget = "/InGame/Root/Normal/AlignBottomLeft/Message";
    local Actor = g_PlayerPortrait[_PlayerID];
    if _HeadModel then
        -- Just because I am paranoid... Should never happen.
        if not Models["Heads_" .. tostring(_HeadModel)] then
            _HeadModel = "H_NPC_Generic_Trader";
        end
        Actor = _HeadModel;
    end
    XGUIEng.ShowWidget(PortraitWidget.. "/MessagePortrait", 1);
    XGUIEng.ShowWidget(PortraitWidget.. "/QuestObjectives", 0);
    -- FIXME
    SetPortraitWithCameraSettings(PortraitWidget.. "/MessagePortrait/3DPortraitFaceFX", Actor);
    GUI.PortraitWidgetSetRegister(PortraitWidget.. "/MessagePortrait/3DPortraitFaceFX", "Mood_Friendly", 1,2,0);
    GUI.PortraitWidgetSetRegister(PortraitWidget.. "/MessagePortrait/3DPortraitFaceFX", "Mood_Angry", 1,2,0);
end

function Lib.DialogSystem.Local:DisplayPageOptionsDialog(_PlayerID, _PageID)
    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
    local Screen = {GUI.GetScreenSize()};
    local Page = self.Dialog[_PlayerID][_PageID];
    local Listbox = XGUIEng.GetWidgetID(Widget .. "/ListBox");

    -- Save original coordinates of sound provider selection
    self.Dialog[_PlayerID].MCSelectionBoxPosition = {
        XGUIEng.GetWidgetScreenPosition(Widget)
    };

    -- Fill sound provider selection with options
    XGUIEng.ListBoxPopAll(Listbox);
    self.Dialog[_PlayerID].MCSelectionOptionsMap = {};
    for i=1, #Page.MC, 1 do
        if Page.MC[i].Visible ~= false then
            XGUIEng.ListBoxPushItem(Listbox, Page.MC[i][1]);
            table.insert(self.Dialog[_PlayerID].MCSelectionOptionsMap, Page.MC[i].ID);
        end
    end
    XGUIEng.ListBoxSetSelectedIndex(Listbox, 0);

    -- Set choice position
    local ChoiceSize = {XGUIEng.GetWidgetScreenSize(Widget)};
    local CX = math.ceil((Screen[1] * 0.05) + (ChoiceSize[1] /2));
    local CY = math.ceil(Screen[2] - (ChoiceSize[2] + 60 * (Screen[2]/540)));
    if not Page.Actor then
        CX = 15 * (Screen[1]/960);
        CY = math.ceil(Screen[2] - (ChoiceSize[2] + 0 * (Screen[2]/540)));
    end
    XGUIEng.SetWidgetScreenPosition(Widget, CX, CY);
    XGUIEng.PushPage(Widget, false);
    XGUIEng.ShowWidget(Widget, 1);

    -- Set text position
    if not Page.Actor then
        local TextWidget = "/InGame/Root/Normal/AlignBottomLeft/SubTitles";
        local DX,DY = XGUIEng.GetWidgetLocalPosition(TextWidget);
        XGUIEng.SetWidgetLocalPosition(TextWidget, DX, DY-220);
    end

    self.Dialog[_PlayerID].MCSelectionIsShown = true;
end

function Lib.DialogSystem.Local:OnOptionSelected(_PlayerID)
    local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
    local Position = self.Dialog[_PlayerID].MCSelectionBoxPosition;
    XGUIEng.SetWidgetScreenPosition(Widget, Position[1], Position[2]);
    XGUIEng.ShowWidget(Widget, 0);
    XGUIEng.PopPage();

    local Selected = XGUIEng.ListBoxGetSelectedIndex(Widget .. "/ListBox")+1;
    local AnswerID = self.Dialog[_PlayerID].MCSelectionOptionsMap[Selected];

    SendReport(Report.DialogOptionSelected, _PlayerID, AnswerID);
    SendReportToGlobal(Report.DialogOptionSelected, _PlayerID, AnswerID);
end

function Lib.DialogSystem.Local:ThroneRoomCameraControl(_PlayerID, _Page)
    if _Page then
        if self.Dialog[_PlayerID].MCSelectionIsShown then
            local Widget = "/InGame/SoundOptionsMain/RightContainer/SoundProviderComboBoxContainer";
            if XGUIEng.IsWidgetShown(Widget) == 0 then
                self.Dialog[_PlayerID].MCSelectionIsShown = false;
                self:OnOptionSelected(_PlayerID);
            end
        end
    end
end

function Lib.DialogSystem.Local:ConvertPosition(_Table)
    local Position = _Table;
    if type(Position) ~= "table" then
        Position = GetPosition(_Table);
    end
    return Position.X, Position.Y, Position.Z;
end

function Lib.DialogSystem.Local:GetCurrentDialog(_PlayerID)
    return self.Dialog[_PlayerID];
end

function Lib.DialogSystem.Local:GetCurrentDialogPage(_PlayerID)
    if self.Dialog[_PlayerID] then
        local PageID = self.Dialog[_PlayerID].CurrentPage;
        return self.Dialog[_PlayerID][PageID];
    end
end

function Lib.DialogSystem.Local:GetPageIDByName(_PlayerID, _Name)
    if type(_Name) == "string" then
        if self.Dialog[_PlayerID] ~= nil then
            for i= 1, #self.Dialog[_PlayerID], 1 do
                if type(self.Dialog[_PlayerID][i]) == "table" and self.Dialog[_PlayerID][i].Name == _Name then
                    return i;
                end
            end
        end
        return 0;
    end
    return _Name;
end

function Lib.DialogSystem.Local:IsAnyCinematicEventActive(_PlayerID)
    for k, v in pairs(Lib.UIEffects.Local.CinematicEventStatus[_PlayerID]) do
        if v == 1 then
            return true;
        end
    end
    return false;
end

function Lib.DialogSystem.Local:OverrideThroneRoomFunctions()
    -- We only need this to update the sound provider list box for the multiple
    -- choice options. We do not even use the throneroom camera.
    self.Orig_GameCallback_Camera_ThroneroomCameraControl = GameCallback_Camera_ThroneroomCameraControl;
    GameCallback_Camera_ThroneroomCameraControl = function(_PlayerID)
        Lib.DialogSystem.Local.Orig_GameCallback_Camera_ThroneroomCameraControl(_PlayerID);
        if _PlayerID == GUI.GetPlayerID() then
            local Dialog = Lib.DialogSystem.Local:GetCurrentDialog(_PlayerID);
            if Dialog ~= nil then
                Lib.DialogSystem.Local:ThroneRoomCameraControl(
                    _PlayerID,
                    Lib.DialogSystem.Local:GetCurrentDialogPage(_PlayerID)
                );
            end
        end
    end
end

function Lib.DialogSystem.Local:ActivateCinematicMode(_PlayerID)
    -- Check for cinematic mode running and UI player
    if self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.CinematicActive = true;

    -- Pop loadscreen if visible
    if not self.LoadscreenClosed then
        XGUIEng.PopPage();
    end

    local ConsoleWasVisible = IsScriptConsoleShown();
    if ConsoleWasVisible then
        HideScriptConsole();
    end

    -- Show throneroom updater
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 1);
    XGUIEng.PushPage("/InGame/ThroneRoom/Main", false);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoomBars_2_Dodge", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/KnightInfo", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main", 1);
    XGUIEng.ShowAllSubWidgets("/InGame/ThroneRoom/Main", 0);
    XGUIEng.ShowWidget("/InGame/ThroneRoom/Main/updater", 1);

    -- Show message stuff
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechStartAgainOrStop", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechButtons/SpeechStartAgainOrStop", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/Update", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles/Update", 0);
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionDialog/Text", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionDialog/Title", " ");
    XGUIEng.SetText("/InGame/ThroneRoom/Main/MissionDialog/Objectives", " ");

    -- Change ui state for cinematic
    self.SelectionBackup = {GUI.GetSelectedEntities()};
    GUI.ClearSelection();
    GUI.ClearNotes();
    GUI.ForbidContextSensitiveCommandsInSelectionState();
    GUI.ActivateCutSceneState();
    GUI.SetFeedbackSoundOutputState(0);
    GUI.EnableBattleSignals(false);
    Input.CutsceneMode();
    if not self.Dialog[_PlayerID].EnableFoW then
        Display.SetRenderFogOfWar(0);
    end
    if self.Dialog[_PlayerID].EnableSky then
        Display.SetRenderSky(1);
    end
    if not self.Dialog[_PlayerID].EnableBorderPins then
        Display.SetRenderBorderPins(0);
    end
    if self:IsChangingGraphicsPermited() then
        Display.SetUserOptionOcclusionEffect(0);
    end
    Camera.SwitchCameraBehaviour(0);

    -- Prepare the fader
    InitializeFader();
    g_Fade.To = 0;
    SetFaderAlpha(0);

    if ConsoleWasVisible then
        ShowScriptConsole();
    end
    if not self.LoadscreenClosed then
        XGUIEng.PushPage("/LoadScreen/LoadScreen", false);
    end
end

function Lib.DialogSystem.Local:DeactivateCinematicMode(_PlayerID)
    -- Check for cinematic mode running and UI player
    if not self.CinematicActive or GUI.GetPlayerID() ~= _PlayerID then
        return;
    end
    self.CinematicActive = false;

    local ConsoleWasVisible = IsScriptConsoleShown();
    if ConsoleWasVisible then
        HideScriptConsole();
    end

    -- Reset ui state
    g_Fade.To = 0;
    SetFaderAlpha(0);
    XGUIEng.PopPage();
    Camera.SwitchCameraBehaviour(0);
    Display.UseStandardSettings();
    Input.GameMode();
    GUI.EnableBattleSignals(true);
    GUI.SetFeedbackSoundOutputState(1);
    GUI.ActivateSelectionState();
    GUI.PermitContextSensitiveCommandsInSelectionState();
    for k, v in pairs(self.SelectionBackup) do
        GUI.SelectEntity(v);
    end
    Display.SetRenderSky(0);
    Display.SetRenderBorderPins(1);
    Display.SetRenderFogOfWar(1);
    if  Options.GetIntValue("Display", "Occlusion", 0) > 0 then
        Display.SetUserOptionOcclusionEffect(1);
    end

    -- Hide the message stuff
    XGUIEng.SetText("/InGame/Root/Normal/AlignBottomLeft/SubTitles/VoiceText1", " ");
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechButtons/SpeechStartAgainOrStop", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait/SpeechStartAgainOrStop", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/Update", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles/Update", 1);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/Message/MessagePortrait", 0);
    XGUIEng.ShowWidget("/InGame/Root/Normal/AlignBottomLeft/SubTitles", 0);

    -- Reset the throneroom
    XGUIEng.PopPage();
    XGUIEng.ShowWidget("/InGame/ThroneRoom", 0);

    ResetRenderDistance();
    self:ResetSubtitlesPosition(_PlayerID);

    if ConsoleWasVisible then
        ShowScriptConsole();
    end
end

-- -------------------------------------------------------------------------- --

function Lib.DialogSystem.Local:IsChangingGraphicsPermited()
    if Lib.BriefingSystem then
        return Lib.BriefingSystem.Local:IsChangingGraphicsPermited();
    end
    return self.Config.DoAlternateGraphics == true;
end

function Lib.DialogSystem.Local:RequestAlternateGraphics()
    if Lib.BriefingSystem then
        return Lib.BriefingSystem.Local:RequestAlternateGraphics();
    end
    if IsMultiplayer() then
        return;
    end

    DialogRequestBox(
        GUI.GetPlayerID(),
        Lib.DialogSystem.Text.Request.Title,
        Lib.DialogSystem.Text.Request.Text,
        function(_Yes)
            Lib.BriefingSystem.Local.Config.DoAlternateGraphics = _Yes == true;
        end,
        false
    );
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.DialogSystem.Name);

Lib.Register("module/city/LifestockSystem_Text");

Lib.LifestockSystem = Lib.LifestockSystem or {};
Lib.LifestockSystem.Text = {
    CattleStarved = {
        de = "Eure Kühe sind verhungert!",
        en = "Your cows have starved to death!",
        fr = "Tes vaches sont mortes de faim !",
    },
    SheepStarved = {
        de = "Eure Schafe sind verhungert!",
        en = "Your sheep have starved to death!",
        fr = "Vos moutons sont morts de faim!",
    },
};

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/city/LifestockSystem_API");

function SetCattleBreedingParameters(_Data)
    assert(not IsLocalScript(), "Can not be used in local script!");
    assert(type(_Data) == "table", "Malformed data passed!");

    local CattleBasePrice = _Data.BasePrice or 300;
    local CattleGrainCost = _Data.GrainCost or 10;
    local CattleGrainUpkeep = _Data.GrainUpkeep or 1;
    local CattleFeedingTimer = _Data.FeedingTimer or 0;
    local CattleStarveChance = _Data.StarveChance or 35;

    ExecuteLocal([[Lib.LifestockSystem.Global.CattleBasePrice = %d]], CattleBasePrice);
    Lib.LifestockSystem.Global.CattleBasePrice = CattleBasePrice;
    ExecuteLocal([[MerchantSystem.BasePrices[Goods.G_Cow] = %d]], CattleGrainCost);
    MerchantSystem.BasePrices[Goods.G_Cow] = CattleBasePrice;
    ExecuteLocal([[Lib.LifestockSystem.Global.CattleGrainCost = %d]], CattleGrainCost);
    Lib.LifestockSystem.Global.CattleGrainCost = CattleGrainCost;
    ExecuteLocal([[Lib.LifestockSystem.Global.CattleGrainUpkeep = %d]], CattleGrainUpkeep);
    Lib.LifestockSystem.Global.CattleGrainUpkeep = CattleGrainUpkeep;
    ExecuteLocal([[Lib.LifestockSystem.Global.CattleFeedingTimer = %d]], CattleFeedingTimer);
    Lib.LifestockSystem.Global.CattleFeedingTimer = CattleFeedingTimer;
    ExecuteLocal([[Lib.LifestockSystem.Global.CattleStarveChance = %d]], CattleStarveChance);
    Lib.LifestockSystem.Global.CattleStarveChance = CattleStarveChance;
end
API.SetCattleBreedingParameters = SetCattleBreedingParameters;

function SetSheepBreedingParameters(_Data)
    assert(not IsLocalScript(), "Can not be used in local script!");
    assert(type(_Data) == "table", "Malformed data passed!");

    local SheepBasePrice = _Data.SheepBasePrice or 300;
    local SheepGrainCost = _Data.SheepGrainCost or 10;
    local SheepGrainUpkeep = _Data.SheepGrainUpkeep or 1;
    local SheepFeedingTimer = _Data.SheepFeedingTimer or 0;
    local SheepStarveChance = _Data.SheepStarveChance or 35;

    ExecuteLocal([[Lib.LifestockSystem.Global.SheepBasePrice = %d]], SheepBasePrice);
    Lib.LifestockSystem.Global.SheepBasePrice = SheepBasePrice;
    ExecuteLocal([[MerchantSystem.BasePrices[Goods.G_Sheep] = %d]], SheepBasePrice);
    MerchantSystem.BasePrices[Goods.G_Sheep] = SheepBasePrice;
    ExecuteLocal([[Lib.LifestockSystem.Global.SheepGrainCost = %d]], SheepGrainCost);
    Lib.LifestockSystem.Global.SheepGrainCost = SheepGrainCost;
    ExecuteLocal([[Lib.LifestockSystem.Global.SheepGrainUpkeep = %d]], SheepGrainUpkeep);
    Lib.LifestockSystem.Global.SheepGrainUpkeep = SheepGrainUpkeep;
    ExecuteLocal([[Lib.LifestockSystem.Global.SheepFeedingTimer = %d]], SheepFeedingTimer);
    Lib.LifestockSystem.Global.SheepFeedingTimer = SheepFeedingTimer;
    ExecuteLocal([[Lib.LifestockSystem.Global.SheepStarveChance = %d]], SheepStarveChance);
    Lib.LifestockSystem.Global.SheepStarveChance = SheepStarveChance;
end
API.SetSheepBreedingParameters = SetSheepBreedingParameters;

function RequireTitleToBreedCattle(_Title)
    assert(not IsLocalScript(), "Can not be used in local script!");
    ExecuteLocal([[
        table.insert(NeedsAndRightsByKnightTitle[%d][4], 1, Technologies.R_Cattle)
        CreateTechnologyKnightTitleTable()
    ]], _Title);
    table.insert(NeedsAndRightsByKnightTitle[_Title][4], 1, Technologies.R_Cattle);
    CreateTechnologyKnightTitleTable()
    for i= 1, 8 do
        Logic.TechnologySetState(i, Technologies.R_Cattle, 0);
    end
end
API.RequireTitleToBreedCattle = RequireTitleToBreedCattle;

function RequireTitleToBreedSheep(_Title)
    assert(not IsLocalScript(), "Can not be used in local script!");
    ExecuteLocal([[
        table.insert(NeedsAndRightsByKnightTitle[%d][4], 1, Technologies.R_Cattle)
        CreateTechnologyKnightTitleTable()
    ]], _Title);
    table.insert(NeedsAndRightsByKnightTitle[_Title][4], 1, Technologies.R_Sheep);
    CreateTechnologyKnightTitleTable()
    for i= 1, 8 do
        Logic.TechnologySetState(i, Technologies.R_Sheep, 0);
    end
end
API.RequireTitleToBreedSheep = RequireTitleToBreedSheep;

Lib.LifestockSystem = Lib.LifestockSystem or {};
Lib.LifestockSystem.Name = "LifestockSystem";
Lib.LifestockSystem.Global = {
    CattleBasePrice = 300,
    CattleGrainCost = 10,
    CattleGrainUpkeep = 1,
    CattleFeedingTimer = 0,
    CattleStarveChance = 35,
    SheepBasePrice = 300,
    SheepGrainCost = 10,
    SheepGrainUpkeep = 1,
    SheepFeedingTimer = 0,
    SheepStarveChance = 35,

    Text = {
        CattleStaved = "",
        SheepStarved = "",
    }
};
Lib.LifestockSystem.Local  = {
    BuyLock = false,
    CattleBasePrice = 300,
    CattleGrainCost = 10,
    CattleGrainUpkeep = 1,
    CattleFeedingTimer = 0,
    CattleStarveChance = 35,
    SheepBasePrice = 300,
    SheepGrainCost = 10,
    SheepGrainUpkeep = 1,
    SheepFeedingTimer = 0,
    SheepStarveChance = 35,

    Text = {
        CattleTitle = "",
        CattleDescription = "",
        CattleDisabled = "",
        SheepTitle = "",
        SheepDescription = "",
        SheepDisabled = "",
    }
};
Lib.LifestockSystem.Shared = {
    TechnologyConfig = {
        -- Tech name, Description, Icon, Extra Number
        {"R_Cattle", {de = "Kühe züchten",   en = "Breeding Cows",   fr = "Vaches reproductrices"}, {3, 16, 0}, 0},
        {"R_Sheep",  {de = "Schafe züchten", en = "Breeding Sheeps", fr = "Moutons reproducteurs"}, {4,  1, 0}, 0},
    },
};

Lib.Require("comfort/SetHealth");
Lib.Require("core/Core");
Lib.Require("module/ui/UIEffects");
Lib.Require("module/ui/UITools");
Lib.Require("module/ui/UIBuilding");
Lib.Require("module/faker/Technology");
Lib.Require("module/city/Promotion");
Lib.Require("module/city/LifestockSystem_API");
Lib.Require("module/city/LifestockSystem_Text");
Lib.Register("module/city/LifestockSystem");

-- -------------------------------------------------------------------------- --
-- Global

-- Global initalizer method
function Lib.LifestockSystem.Global:Initialize()
    if not self.IsInstalled then
        --- The player has clicked the buy animal button
        --- 
        --- #### Parameters
        --- * `Index   `   - "Cattle" or "Sheep"
        --- * `PlayerID`   - ID of player
        --- * `EntityID`   - ID of pasture
        Report.BreedAnimalClicked = CreateReport("Event_BreedAnimalClicked");

        --- The player has bought a cow.
        --- 
        --- #### Parameters
        --- * `PlayerID`   - ID of player
        --- * `EntityID`   - ID of created cow
        --- * `BuildingID` - ID of pasture
        Report.CattleBought = CreateReport("Event_CattleBought");

        --- The player has bought a sheep.
        --- 
        --- #### Parameters
        --- * `PlayerID`   - ID of player
        --- * `EntityID`   - ID of created sheep
        --- * `BuildingID` - ID of pasture
        Report.SheepBought = CreateReport("Event_SheepBought");

        --- A cow has starved.
        --- 
        --- #### Parameters
        --- * `PlayerID`   - ID of player
        --- * `EntityID`   - ID of created cow
        Report.CattleStarved = CreateReport("Event_CattleStarved");

        --- A sheep has starved.
        --- 
        --- #### Parameters
        --- * `PlayerID`   - ID of player
        --- * `EntityID`   - ID of created cow
        Report.SheepStarved = CreateReport("Event_SheepStarved");

        -- Get texts
        self.Text.CattleStarved = Localize(Lib.LifestockSystem.Text.CattleStarved);
        self.Text.SheepStarved = Localize(Lib.LifestockSystem.Text.SheepStarved);

        -- Change base prices
        MerchantSystem.BasePricesOrigModuleLifestockBreeding                = {};
        MerchantSystem.BasePricesOrigModuleLifestockBreeding[Goods.G_Sheep] = MerchantSystem.BasePrices[Goods.G_Sheep];
        MerchantSystem.BasePricesOrigModuleLifestockBreeding[Goods.G_Cow]   = MerchantSystem.BasePrices[Goods.G_Cow];

        MerchantSystem.BasePrices[Goods.G_Sheep] = self.SheepBasePrice;
        MerchantSystem.BasePrices[Goods.G_Cow]   = self.CattleBasePrice;

        -- Breeding
        Lib.LifestockSystem.Shared:CreateTechnologies();
        RequestJob(function()
            Lib.LifestockSystem.Global:ControlFeeding();
            Lib.LifestockSystem.Global:ControlDecay();
        end);

        -- Garbage collection
        Lib.LifestockSystem.Local = nil;
    end
    self.IsInstalled = true;
end

-- Global load game
function Lib.LifestockSystem.Global:OnSaveGameLoaded()
end

-- Global report listener
function Lib.LifestockSystem.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.LanguageChanged then
        self.Text.CattleStarved = Localize(Lib.LifestockSystem.Text.CattleStarved);
        self.Text.SheepStarved = Localize(Lib.LifestockSystem.Text.SheepStarved);
    elseif _ID == Report.BreedAnimalClicked then
        --- @diagnostic disable-next-line: param-type-mismatch
        Lib.LifestockSystem.Global:BuyAnimal(arg[1], arg[2], arg[3]);
    end
end

function Lib.LifestockSystem.Global:BuyAnimal(_Index, _PlayerID, _BuildingID)
    local AnimalType = (_Index == "Cattle" and Entities.A_X_Cow01) or Entities.A_X_Sheep01;
    local GrainCost = self[_Index.. "GrainCost"];
    if GetPlayerResources(Goods.G_Grain, _PlayerID) < GrainCost then
        return;
    end
    local x,y = Logic.GetBuildingApproachPosition(_BuildingID);
    local EntityID = Logic.CreateEntity(AnimalType, x, y, 0, _PlayerID);
    AddGood(Goods.G_Grain, (-1) * GrainCost, _PlayerID);
    SendReport(Report[_Index.. "Bought"], _PlayerID, EntityID, _BuildingID);
    SendReportToLocal(Report[_Index.. "Bought"], _PlayerID, EntityID, _BuildingID);
end

function Lib.LifestockSystem.Global:ControlFeeding()
    for PlayerID = 1, 8 do
        if Logic.PlayerGetIsHumanFlag(PlayerID) then
            -- Cattle
            local CattleTimer = self.CattleFeedingTimer;
            local CattleList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.CattlePasture)};
            if CattleTimer > 0 then
                local FeedingTime = math.max(CattleTimer * (1 - (0.03 * #CattleList)), 15);
                if #CattleList > 0 and Logic.GetTime() % math.floor(FeedingTime) == 0 then
                    local Upkeep = self.CattleGrainUpkeep;
                    local GrainAmount = GetPlayerResources(Goods.G_Grain, PlayerID);
                    if GrainAmount < Upkeep then
                        -- Make animals starve
                        local AnimalStarved = false;
                        for k,v in pairs(CattleList) do
                            local x,y,z = Logic.EntityGetPos(v);
                            local _,PastureID = Logic.GetEntitiesInArea(Entities.B_CattlePasture, x, y, 750, 1);
                            if IsExisting(PastureID) and math.random(1, 100) <= self.CattleStarveChance then
                                if Logic.GetEntityHealth(v) > 0 then
                                    SetHealth(v, 0);
                                end
                                SendReportToLocal(Report.CattleStarved, PlayerID, v);
                                SendReport(Report.CattleStarved, PlayerID, v);
                                AnimalStarved = true;
                            end
                        end
                        -- Show message if animals have starved
                        if AnimalStarved then
                            local Text = Localize(self.Text.CattleStarved);
                            AddMessage(Text);
                        end
                    else
                        AddGood(Goods.G_Grain, (-1) * Upkeep, PlayerID);
                    end
                end
            end
            -- Sheep
            local SheepTimer = self.SheepFeedingTimer;
            local SheepList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories.SheepPasture)};
            if SheepTimer > 0 then
                local FeedingTime = math.max(SheepTimer * (1 - (0.03 * #SheepList)), 15);
                if #SheepList > 0 and Logic.GetTime() % math.floor(FeedingTime) == 0 then
                    local Upkeep = self.SheepGrainUpkeep;
                    local GrainAmount = GetPlayerResources(Goods.G_Grain, PlayerID);
                    if GrainAmount < Upkeep then
                        -- Make animals starve
                        local AnimalStarved = false;
                        for k,v in pairs(SheepList) do
                            local x,y,z = Logic.EntityGetPos(v);
                            local _,PastureID = Logic.GetEntitiesInArea(Entities.B_CattlePasture, x, y, 750, 1);
                            if IsExisting(PastureID) and math.random(1, 100) <= self.SheepStarveChance then
                                if Logic.GetEntityHealth(v) > 0 then
                                    SetHealth(v, 0);
                                end
                                SendReportToLocal(Report.SheepStarved, PlayerID, v);
                                SendReport(Report.SheepStarved, PlayerID, v);
                            end
                        end
                        -- Show message if animals have starved
                        if AnimalStarved then
                            local Text = Localize(self.Text.SheepStarved);
                            AddMessage(Text);
                        end
                    else
                        AddGood(Goods.G_Grain, (-1) * Upkeep, PlayerID);
                    end
                end
            end
        end
    end
end

function Lib.LifestockSystem.Global:ControlDecay()
    if Logic.GetTime() % 10 == 0 then
        -- Cattle
        local CattleCorpses = Logic.GetEntitiesOfType(Entities.R_DeadCow);
        for k,v in pairs(CattleCorpses) do
            local x,y,z = Logic.EntityGetPos(v);
            local _,PastureID = Logic.GetEntitiesInArea(Entities.B_CattlePasture, x, y, 900, 1);
            if IsExisting(PastureID) then
                local GoodAmount = Logic.GetResourceDoodadGoodAmount(v);
                Logic.SetResourceDoodadGoodAmount(v, GoodAmount -1);
            end
        end
        -- Sheep
        local SheepCorpses = Logic.GetEntitiesOfType(Entities.R_DeadSheep);
        for k,v in pairs(SheepCorpses) do
            local x,y,z = Logic.EntityGetPos(v);
            local _,PastureID = Logic.GetEntitiesInArea(Entities.B_SheepPasture, x, y, 900, 1);
            if IsExisting(PastureID) then
                local GoodAmount = Logic.GetResourceDoodadGoodAmount(v);
                Logic.SetResourceDoodadGoodAmount(v, GoodAmount -1);
            end
        end
    end
end

-- -------------------------------------------------------------------------- --
-- Local

-- Local initalizer method
function Lib.LifestockSystem.Local:Initialize()
    if not self.IsInstalled then
        Report.BreedAnimalClicked = CreateReport("Event_BreedAnimalClicked");
        Report.CattleBought = CreateReport("Event_CattleBought");
        Report.SheepBought = CreateReport("Event_SheepBought");
        Report.CattleStarved = CreateReport("Event_CattleStarved");
        Report.SheepStarved = CreateReport("Event_SheepStarved");

        -- Get texts
        self.Text.CattleTitle = XGUIEng.GetStringTableText("Names/A_X_Cow01");
        self.Text.CattleDescription = XGUIEng.GetStringTableText("UI_ObjectDescription/G_Cow");
        self.Text.CattleDisabled = XGUIEng.GetStringTableText("UI_ButtonDisabled/PromoteKnight");
        self.Text.SheepTitle = XGUIEng.GetStringTableText("Names/A_X_Sheep01");
        self.Text.SheepDescription = XGUIEng.GetStringTableText("UI_ObjectDescription/G_Sheep");
        self.Text.SheepDisabled = XGUIEng.GetStringTableText("UI_ButtonDisabled/PromoteKnight");

        -- Change base prices
        MerchantSystem.BasePricesOrigModuleLifestockBreeding                = {};
        MerchantSystem.BasePricesOrigModuleLifestockBreeding[Goods.G_Sheep] = MerchantSystem.BasePrices[Goods.G_Sheep];
        MerchantSystem.BasePricesOrigModuleLifestockBreeding[Goods.G_Cow]   = MerchantSystem.BasePrices[Goods.G_Cow];

        MerchantSystem.BasePrices[Goods.G_Sheep] = self.SheepBasePrice;
        MerchantSystem.BasePrices[Goods.G_Cow]   = self.CattleBasePrice;

        -- Breeding
        Lib.LifestockSystem.Shared:CreateTechnologies();
        self:InitBuyCowButton();
        self:InitBuySheepButton();

        -- Garbage collection
        Lib.LifestockSystem.Global = nil;
    end
    self.IsInstalled = true;
end

-- Local load game
function Lib.LifestockSystem.Local:OnSaveGameLoaded()
end

-- Local report listener
function Lib.LifestockSystem.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadingFinished then
        self.LoadscreenClosed = true;
    elseif _ID == Report.CattleBought then
        if arg[1] == GUI.GetPlayerID() then
            self.BuyLock = false;
        end
    elseif _ID == Report.SheepBought then
        if arg[1] == GUI.GetPlayerID() then
            self.BuyLock = false;
        end
    end
end

function Lib.LifestockSystem.Local:BuyAnimalAction(_Index, _WidgetID, _EntityID)
    local GrainCost = self[_Index.. "GrainCost"];
    local PlayerID = Logic.EntityGetPlayer(_EntityID);
    if GetPlayerResources(Goods.G_Grain, PlayerID) < GrainCost then
        local Text = XGUIEng.GetStringTableText("Feedback_TextLines/TextLine_NotEnough_Resources");
        Message(Text);
        return;
    end
    -- Prevent click spam
    self.BuyLock = true;
    -- Send reports
    SendReportToGlobal(Report.BreedAnimalClicked, _Index, PlayerID, _EntityID);
    SendReport(Report.BreedAnimalClicked, _Index, PlayerID, _EntityID);
end

function Lib.LifestockSystem.Local:BuyAnimalTooltip(_Index, _WidgetID, _EntityID)
    local Title = self.Text[_Index.. "Title"];
    local Text  = self.Text[_Index.. "Description"];
    local Disabled = "";

    local GrainCost = self[_Index.. "GrainCost"];
    local PlayerID = Logic.EntityGetPlayer(_EntityID);
    local TechType = (_Index == "Cattle" and Technologies.R_Cattle) or Technologies.R_Sheep;
    if Logic.TechnologyGetState(PlayerID, TechType) == 0 then
        local Key = GUI_Tooltip.GetDisabledKeyForTechnologyType(TechType);
        Disabled = GetStringText("UI_ButtonDisabled/" ..Key);
    elseif XGUIEng.IsButtonDisabled(_WidgetID) == 1 then
        Disabled = self.Text[_Index.. "Disabled"];
    end
    SetTooltipCosts(Title, Text, Disabled, {Goods.G_Grain, GrainCost}, true);
end

function Lib.LifestockSystem.Local:BuyAnimalUpdate(_Index, _WidgetID, _EntityID)
    local PlayerID = Logic.EntityGetPlayer(_EntityID);
    local TechType = (_Index == "Cattle" and Technologies.R_Cattle) or Technologies.R_Sheep;
    local PastureType = Logic.GetEntityType(_EntityID);
    local TechState = Logic.TechnologyGetState(PlayerID, TechType);
    local Icon = (_Index == "Cattle" and {3, 16}) or {4, 1};
    local DisabledFlag = 0;

    local PastureList = GetPlayerEntities(PlayerID, PastureType);
    local AnimalList = {Logic.GetPlayerEntitiesInCategory(PlayerID, EntityCategories[_Index.. "Pasture"])};

    if (TechState ~= TechnologyStates.Unlocked and TechState ~= TechnologyStates.Researched)
    or self.BuyLock or (#PastureList * 5) <= #AnimalList then
        Icon = (_Index == "Cattle" and {4, 2}) or {4, 3};
        DisabledFlag = 1;
    end
    XGUIEng.DisableButton(_WidgetID, DisabledFlag);
    SetIcon(_WidgetID, Icon);
end

function Lib.LifestockSystem.Local:InitBuyCowButton()
    local Position = {XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart")};
    AddBuildingButtonByTypeAtPosition(
        Entities.B_CattlePasture,
        Position[1], Position[2],
        function(_WidgetID, _EntityID)
            Lib.LifestockSystem.Local:BuyAnimalAction("Cattle", _WidgetID, _EntityID);
        end,
        function(_WidgetID, _EntityID)
            Lib.LifestockSystem.Local:BuyAnimalTooltip("Cattle", _WidgetID, _EntityID);
        end,
        function(_WidgetID, _EntityID)
            Lib.LifestockSystem.Local:BuyAnimalUpdate("Cattle", _WidgetID, _EntityID);
        end
    )
end

function Lib.LifestockSystem.Local:InitBuySheepButton()
    local Position = {XGUIEng.GetWidgetLocalPosition("/InGame/Root/Normal/BuildingButtons/BuyCatapultCart")};
    AddBuildingButtonByTypeAtPosition(
        Entities.B_SheepPasture,
        Position[1], Position[2],
        function(_WidgetID, _EntityID)
            Lib.LifestockSystem.Local:BuyAnimalAction("Sheep", _WidgetID, _EntityID);
        end,
        function(_WidgetID, _EntityID)
            Lib.LifestockSystem.Local:BuyAnimalTooltip("Sheep", _WidgetID, _EntityID);
        end,
        function(_WidgetID, _EntityID)
            Lib.LifestockSystem.Local:BuyAnimalUpdate("Sheep", _WidgetID, _EntityID);
        end
    )
end

-- -------------------------------------------------------------------------- --
-- Shared

function Lib.LifestockSystem.Shared:CreateTechnologies()
    for i= 1, #self.TechnologyConfig do
        if g_GameExtraNo >= self.TechnologyConfig[i][4] then
            if not Technologies[self.TechnologyConfig[i][1]] then
                AddCustomTechnology(self.TechnologyConfig[i][1], self.TechnologyConfig[i][2], self.TechnologyConfig[i][3]);
                if not IsLocalScript() then
                    for j= 1, 8 do
                        Logic.TechnologySetState(j, Technologies[self.TechnologyConfig[i][1]], 3);
                    end
                end
            end
        end
    end
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.LifestockSystem.Name);

Lib.Require("comfort/IsLocalScript");
Lib.Register("module/entity/EntitySearch_API");

function SearchEntities(_PlayerID, _WithoutDefeatResistant)
    return Lib.EntitySearch.Shared:SearchEntities(_PlayerID, _WithoutDefeatResistant);
end
API.SearchEntities = SearchEntities;

function SearchEntitiesOfTypeInArea(_Area, _Position, _Type, _PlayerID)
    return Lib.EntitySearch.Shared:SearchEntitiesInArea(_Area, _Position, _PlayerID, _Type, nil);
end
API.SearchEntitiesOfTypeInArea = SearchEntitiesOfTypeInArea;

function SearchEntitiesOfCategoryInArea(_Area, _Position, _Category, _PlayerID)
    return Lib.EntitySearch.Shared:SearchEntitiesInArea(_Area, _Position, _PlayerID, nil, _Category);
end
API.SearchEntitiesOfCategoryInArea = SearchEntitiesOfCategoryInArea;

function SearchEntitiesOfTypeInTerritory(_Territory, _Type, _PlayerID)
    return Lib.EntitySearch.Shared:SearchEntitiesInTerritory(_Territory, _PlayerID, _Type, nil);
end
API.SearchEntitiesOfTypeInTerritory = SearchEntitiesOfTypeInTerritory;

function SearchEntitiesOfCategoryInTerritory(_Territory, _Category, _PlayerID)
    return Lib.EntitySearch.Shared:SearchEntitiesInTerritory(_Territory, _PlayerID, nil, _Category);
end
API.SearchEntitiesOfCategoryInTerritory = SearchEntitiesOfCategoryInTerritory;
API.GetEntitiesOfCategoryInTerritory = SearchEntitiesOfCategoryInTerritory;

function SearchEntitiesByScriptname(_Pattern)
    return Lib.EntitySearch.Shared:SearchEntitiesByScriptname(_Pattern);
end
API.SearchEntitiesByScriptname = SearchEntitiesByScriptname;

function CreateSearchFilter(_Identifier, _Function)
    Lib.EntitySearch.Shared:CreateFilter(_Identifier, _Function);
end
API.CreateSearchFilter = CreateSearchFilter;

function DropSearchFilter(_Identifier)
    Lib.EntitySearch.Shared:DropFilter(_Identifier);
end
API.DropSearchFilter = DropSearchFilter;

function CommenceEntitySearch(_Filter)
    return Lib.EntitySearch.Shared:IterateOverEntities(_Filter);
end
API.CommenceEntitySearch = CommenceEntitySearch;

-- Compatibility option
function GetEntitiesOfCategoriesInTerritories(_PlayerID, _Category, _Territory)
    local p = (type(_PlayerID) == "table" and _PlayerID) or {_PlayerID};
    local c = (type(_Category) == "table" and _Category) or {_Category};
    local t = (type(_Territory) == "table" and _Territory) or {_Territory};
    local PlayerEntities = {};
    for i=1, #p, 1 do
        for j=1, #c, 1 do
            for k=1, #t, 1 do
                local Units = SearchEntitiesOfCategoryInTerritory(t[k], c[j], p[i]);
                PlayerEntities = Array_Append(PlayerEntities, Units);
            end
        end
    end
    return PlayerEntities;
end
API.GetEntitiesOfCategoriesInTerritories = GetEntitiesOfCategoriesInTerritories;

Lib.EntitySearch = Lib.EntitySearch or {};
Lib.EntitySearch.Name = "EntitySearch";
Lib.EntitySearch.Global = {};
Lib.EntitySearch.Local  = {};
Lib.EntitySearch.Shared  = {
    Filters = {
        ["__Default"] = function(_ID) return true; end,
    },
    Caches = {
        Entity = {},
        Filter = {},
    },
};

Lib.Require("comfort/GetDistance");
Lib.Require("core/Core");
Lib.Require("module/entity/EntitySearch_API");
Lib.Register("module/entity/EntitySearch");

-- Global ------------------------------------------------------------------- --

function Lib.EntitySearch.Global:Initialize()
end

function Lib.EntitySearch.Global:OnReportReceived(_ID, ...)
    if _ID == Report.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- Local -------------------------------------------------------------------- --

function Lib.EntitySearch.Local:Initialize()
end

function Lib.EntitySearch.Local:OnReportReceived(_ID, ...)
    if _ID == Report.LoadscreenClosed then
        self.LoadscreenClosed = true;
    end
end

-- Shared ------------------------------------------------------------------- --

function Lib.EntitySearch.Shared:CreateFilter(_Identifier, _Function)
    self.Filters[_Identifier] = _Function;
end

function Lib.EntitySearch.Shared:DropFilter(_Identifier)
    self.Filters[_Identifier] = nil;
end

function Lib.EntitySearch.Shared:IterateOverEntities(_Filter)
    local FilterName = (self.Filters[_Filter] and _Filter) or "__Default";
    local Time = math.floor(Logic.GetTime());
    local ResultList = {};
    local AllEntities;

    -- Invoke filter cache if not too old and return cache
    if self.Caches.Filter[FilterName] and self.Caches.Filter[FilterName][1] then
        -- Clear to old result...
        if self.Caches.Filter[FilterName][1] +3 <= Time then
            self.Caches.Filter[FilterName] = nil;
        -- ...or use cache
        elseif FilterName ~= "__Default" and self.Caches.Filter[FilterName][1] +1 <= Time then
            return self.Caches.Filter[FilterName][2];
        end
    end

    -- Invoke entity cache if not to old or scan all entities
    if self.Caches.Entity[1] and self.Caches.Entity[1] +1 > Time then
        AllEntities = self.Caches.Entity[2];
    else
        AllEntities = {};
        for _, v in pairs(Entities) do
            for _, ID in pairs(Logic.GetEntitiesOfType(v)) do
                AllEntities[#AllEntities +1] = ID;
            end
        end
        self.Caches.Entity = {Time, AllEntities};
    end

    -- Do actual search and save results in cache
    local Filter = self.Filters[_Filter] or self.Filters["__Default"];
    for i= 1, #AllEntities do
        if Filter(AllEntities[i]) then
            ResultList[#ResultList +1] = AllEntities[i];
        end
    end
    self.Caches.Filter[FilterName] = {Time, ResultList};
    return ResultList;
end

function Lib.EntitySearch.Shared:SearchEntities(_PlayerID, _WithoutDefeatResistant)
    if _WithoutDefeatResistant == nil then
        _WithoutDefeatResistant = false;
    end

    local Time = math.floor(Logic.GetTime());
    local Key = "hupl_".._PlayerID.."_"..tostring(_WithoutDefeatResistant);

    local Function = function(_ID)
        if _PlayerID and Logic.EntityGetPlayer(_ID) ~= _PlayerID then
            return false;
        end
        if _WithoutDefeatResistant then
            if (Logic.IsBuilding(_ID) or Logic.IsWall(_ID)) and Logic.IsConstructionComplete(_ID) == 0 then
                return false;
            end
            local Type = Logic.GetEntityType(_ID);
            local TypeName = Logic.GetEntityType(Type);
            if TypeName and (string.find(TypeName, "^S_") or string.find(TypeName, "^XD_")) then
                return false;
            end
        end
        return true;
    end

    if not self.Filters[Key] then
        self:CreateFilter(Key, Function);
    end
    if  self.Caches.Filter[Key]
    and self.Caches.Filter[Key][2]
    and self.Caches.Filter[Key][1] +1 > Time then
        return self.Caches.Entity[Key][2];
    end
    return CommenceEntitySearch(Key);
end

function Lib.EntitySearch.Shared:SearchEntitiesByScriptname(_Pattern)
    local Time = math.floor(Logic.GetTime());

    local Key = "name_".._Pattern;

    local Function = function(_ID)
        local ScriptName = Logic.GetEntityName(_ID);
        if not string.find(ScriptName, _Pattern) then
            return false;
        end
        return true;
    end

    if not self.Filters[Key] then
        self:CreateFilter(Key, Function);
    end
    if  self.Caches.Filter[Key]
    and self.Caches.Filter[Key][2]
    and self.Caches.Filter[Key][1] +1 > Time then
        return self.Caches.Entity[Key][2];
    end
    return CommenceEntitySearch(Key);
end

function Lib.EntitySearch.Shared:SearchEntitiesInArea(_Area, _Position, _PlayerID, _Type, _Category)
    local Time = math.floor(Logic.GetTime());
    local Position = _Position;
    if type(Position) ~= "table" then
        Position = GetPosition(Position);
    end

    local a = _Area;
    local x,y = Position.X, Position.Y;
    local p = _PlayerID;
    local t = _Type;
    local c = _Category;

    local Key = "area_"..a.."_"..x.."_"..y.."_"..p.."_"..t.."_"..c;

    local Function = function(_ID)
        if _PlayerID and Logic.EntityGetPlayer(_ID) ~= _PlayerID then
            return false;
        end
        if _Type and Logic.GetEntityType(_ID) ~= _Type then
            return false;
        end
        if _Category and Logic.IsEntityInCategory(_ID, _Category) == 0 then
            return false;
        end
        if GetDistance(_ID, Position) > _Area then
            return false;
        end
        return true;
    end

    if not self.Filters[Key] then
        self:CreateFilter(Key, Function);
    end
    if  self.Caches.Filter[Key]
    and self.Caches.Filter[Key][2]
    and self.Caches.Filter[Key][1] +1 > Time then
        return self.Caches.Entity[Key][2];
    end
    return CommenceEntitySearch(Key);
end

function Lib.EntitySearch.Shared:SearchEntitiesInTerritory(_Territory, _PlayerID, _Type, _Category)
    local Time = math.floor(Logic.GetTime());

    local a = _Territory;
    local p = _PlayerID;
    local t = _Type;
    local c = _Category;

    local Key = "teri_"..a.."_"..p.."_"..t.."_"..c;

    local Function = function(_ID)
        if _PlayerID and Logic.EntityGetPlayer(_ID) ~= _PlayerID then
            return false;
        end
        if _Type and Logic.GetEntityType(_ID) ~= _Type then
            return false;
        end
        if _Category and Logic.IsEntityInCategory(_ID, _Category) == 0 then
            return false;
        end
        if _Territory and GetTerritoryUnderEntity(_ID) ~= _Territory then
            return false;
        end
        return true;
    end

    if not self.Filters[Key] then
        self:CreateFilter(Key, Function);
    end
    if  self.Caches.Filter[Key]
    and self.Caches.Filter[Key][2]
    and self.Caches.Filter[Key][1] +1 > Time then
        return self.Caches.Entity[Key][2];
    end
    return CommenceEntitySearch(Key);
end

-- -------------------------------------------------------------------------- --

RegisterModule(Lib.EntitySearch.Name);

Lib.Register("core/QSB");

--- @diagnostic disable: cast-local-type
--- @diagnostic disable: duplicate-set-field
--- @diagnostic disable: missing-return-value

ParameterType = ParameterType or {};
Report = Report or {};

g_QuestBehaviorVersion = 1;
g_QuestBehaviorTypes = {};

g_GameExtraNo = 0;
if Framework then
    g_GameExtraNo = Framework.GetGameExtraNo();
elseif MapEditor then
    g_GameExtraNo = MapEditor.GetGameExtraNo();
end

function LoadBehaviors()
    for i= 1, #g_QuestBehaviorTypes, 1 do
        local Behavior = g_QuestBehaviorTypes[i];

        if not _G["B_" .. Behavior.Name].new then
            _G["B_" .. Behavior.Name].new = function(self, ...)
                local parameter = {...};
                local behavior = table.copy(self);
                -- Raw parameters
                behavior.i47ya_6aghw_frxil = {};
                -- Overhead parameters
                behavior.v12ya_gg56h_al125 = {};
                for j= 1, #parameter, 1 do
                    table.insert(behavior.v12ya_gg56h_al125, parameter[j]);
                    if self.Parameter and self.Parameter[j] ~= nil then
                        behavior:AddParameter(j-1, parameter[j]);
                    else
                        table.insert(behavior.i47ya_6aghw_frxil, parameter[j]);
                    end
                end
                return behavior;
            end
        end
    end
end

function RegisterBehavior(_Behavior)
    if GUI ~= nil then
        return;
    end
    if type(_Behavior) ~= "table" or _Behavior.Name == nil then
        assert(false, "Behavior is invalid!");
        return;
    end
    if _Behavior.RequiresExtraNo and _Behavior.RequiresExtraNo > g_GameExtraNo then
        return;
    end
    if not _G["B_" .. _Behavior.Name] then
        error(string.format("Behavior %s does not exist!", _Behavior.Name));
        return;
    end

    for i= 1, #g_QuestBehaviorTypes, 1 do
        if g_QuestBehaviorTypes[i].Name == _Behavior.Name then
            return;
        end
    end
    table.insert(g_QuestBehaviorTypes, _Behavior);
end

if not MapEditor and GUI then
    return;
end

Lib.Register("core/Core_Behavior");

function Reward_DEBUG(_Assertions, _CheckAtRun, _DevelopingCheats, _DevelopingShell, _TraceQuests)
    return B_Reward_DEBUG:new(_Assertions, _CheckAtRun, _DevelopingCheats, _DevelopingShell, _TraceQuests);
end

B_Reward_DEBUG = {
    Name = "Reward_DEBUG",
    Description = {
        en = "Reward: Start the debug mode. See documentation for more information.",
        de = "Lohn: Startet den Debug-Modus. Für mehr Informationen siehe Dokumentation.",
        fr = "Récompense: Démarre le mode de débug. Pour plus d'informations, voir la documentation.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Activate script errors",     de = "Skriptfeleranzeige nutzen",  fr = "Afficher les erreurs de script" },
        { ParameterType.Custom, en = "Check quest while runtime",  de = "Quests zur Laufzeit prüfen", fr = "Vérifier les quêtes au cours de l'exécution" },
        { ParameterType.Custom, en = "Activate developing cheats", de = "Cheats aktivieren",          fr = "Activer les cheats" },
        { ParameterType.Custom, en = "Activate developing shell",  de = "Eingabe aktivieren",         fr = "Activer la saisie" },
        { ParameterType.Custom, en = "Use quest trace",            de = "Questverfolgung",            fr = "Suivi de quête" },
    },
}

function B_Reward_DEBUG:GetRewardTable(_Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

function B_Reward_DEBUG:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.DisplayScriptErrors = ToBoolean(_Parameter);
    elseif (_Index == 1) then
        self.CheckWhileRuntime = ToBoolean(_Parameter);
    elseif (_Index == 2) then
        self.DevelopingCheats = ToBoolean(_Parameter);
    elseif (_Index == 3) then
        self.DevelopingShell = ToBoolean(_Parameter);
    elseif (_Index == 4) then
        self.UseQuestTrace = ToBoolean(_Parameter);
    end
end

function B_Reward_DEBUG:CustomFunction(_Quest)
    ActivateDebugMode(self.DisplayScriptErrors, self.CheckWhileRuntime, self.DevelopingCheats, self.DevelopingShell, self.UseQuestTrace );
end

function B_Reward_DEBUG:GetCustomData(_Index)
    return {"true","false"};
end

RegisterBehavior(B_Reward_DEBUG);

-- -------------------------------------------------------------------------- --

function Goal_ActivateObject(...)
    return B_Goal_ActivateObject:new(...);
end

B_Goal_ActivateObject = {
    Name = "Goal_ActivateObject",
    Description = {
        en = "Goal: Activate an interactive object",
        de = "Ziel: Aktiviere ein interaktives Objekt",
        fr = "Objectif: activer un objet interactif",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Object name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_ActivateObject:GetGoalTable()
    return {Objective.Object, { self.ScriptName } }
end

function B_Goal_ActivateObject:AddParameter(_Index, _Parameter)
   if _Index == 0 then
        self.ScriptName = _Parameter
   end
end

function B_Goal_ActivateObject:GetMsgKey()
    return "Quest_Object_Activate"
end

RegisterBehavior(B_Goal_ActivateObject);

-- -------------------------------------------------------------------------- --

function Goal_Deliver(...)
    return B_Goal_Deliver:new(...)
end

B_Goal_Deliver = {
    Name = "Goal_Deliver",
    Description = {
        en = "Goal: Deliver goods to quest giver or to another player.",
        de = "Ziel: Liefere Waren zum Auftraggeber oder zu einem anderen Spieler.",
        fr = "Objectif: livrer des marchandises au mandant ou à un autre joueur.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type of good", de = "Ressourcentyp", fr = "Type de ressources" },
        { ParameterType.Number, en = "Amount of good", de = "Ressourcenmenge", fr = "Quantité de ressources" },
        { ParameterType.Custom, en = "To different player", de = "Anderer Empfänger", fr = "Autre bénéficiaire" },
        { ParameterType.Custom, en = "Ignore capture", de = "Abfangen ignorieren", fr = "Ignorer une interception" },
    },
}

function B_Goal_Deliver:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Deliver, GoodType, self.GoodAmount, self.OverrideTarget, self.IgnoreCapture }
end

function B_Goal_Deliver:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    elseif (_Index == 2) then
        self.OverrideTarget = tonumber(_Parameter)
    elseif (_Index == 3) then
        self.IgnoreCapture = ToBoolean(_Parameter)
    end
end

function B_Goal_Deliver:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        table.insert( Data, "-" )
        for i = 1, 8 do
            table.insert( Data, i )
        end
    elseif _Index == 3 then
        table.insert( Data, "true" )
        table.insert( Data, "false" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_Deliver:GetMsgKey()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    local GC = Logic.GetGoodCategoryForGoodType( GoodType )

    local tMapping = {
        [GoodCategories.GC_Clothes] = "Quest_Deliver_GC_Clothes",
        [GoodCategories.GC_Entertainment] = "Quest_Deliver_GC_Entertainment",
        [GoodCategories.GC_Food] = "Quest_Deliver_GC_Food",
        [GoodCategories.GC_Gold] = "Quest_Deliver_GC_Gold",
        [GoodCategories.GC_Hygiene] = "Quest_Deliver_GC_Hygiene",
        [GoodCategories.GC_Medicine] = "Quest_Deliver_GC_Medicine",
        [GoodCategories.GC_Water] = "Quest_Deliver_GC_Water",
        [GoodCategories.GC_Weapon] = "Quest_Deliver_GC_Weapon",
        [GoodCategories.GC_Resource] = "Quest_Deliver_Resources",
    }

    if GC then
        local Key = tMapping[GC]
        if Key then
            return Key
        end
    end
    return "Quest_Deliver_Goods"
end

RegisterBehavior(B_Goal_Deliver);

-- -------------------------------------------------------------------------- --

function Goal_Diplomacy(...)
    return B_Goal_Diplomacy:new(...);
end

B_Goal_Diplomacy = {
    Name = "Goal_Diplomacy",
    Description = {
        en = "Goal: A diplomatic state must b reached. Can be lower than current state or higher.",
        de = "Ziel: Die Beziehungen zu einem Spieler müssen entweder verbessert oder verschlechtert werden.",
        fr = "Objectif: les relations avec un joueur doivent être soit améliorées, soit détériorées.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Party", de = "Partei", fr = "Faction" },
        { ParameterType.Custom,   en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Custom,   en = "Diplomacy state", de = "Diplomatische Beziehung", fr = "Relations diplomatiques" },
    },
    TextPattern = {
        de = "DIPLOMATIESTATUS ERREICHEN {cr}{cr}Status: %s{cr}Zur Partei: %s",
        en = "DIPLOMATIC STATE {cr}{cr}State: %s{cr}To player: %s",
        fr = "ATTEINDRE LE STATUT DE DIPLOMATIQUE {cr}{cr}Statut : %s{cr}Avec la faction : %s",
    },
}

function B_Goal_Diplomacy:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_Diplomacy:GetDiplomacyMapping()
    return {
        [DiplomacyStates.Allied]             = {de = "Verbündeter",    en = "Allied",               fr = "Allié"},
        [DiplomacyStates.TradeContact]       = {de = "Handelspartner", en = "Trade Contact",        fr = "Partenaire commercial"},
        [DiplomacyStates.EstablishedContact] = {de = "Bekannt",        en = "Established Contact",  fr = "Contact établi"},
        [DiplomacyStates.Undecided]          = {de = "Unbekannt",      en = "Undecided",            fr = "Inconnu"},
        [DiplomacyStates.Enemy]              = {de = "Feind",          en = "Enemy",                fr = "Ennemi"},
    };
end

function B_Goal_Diplomacy:ChangeCaption(_Quest)
    local DiplomacyMap = self:GetDiplomacyMapping();
    local PlayerName = GetPlayerName(self.PlayerID) or "";
    local Text = string.format(
        Localize(self.TextPattern),
        Localize(DiplomacyMap[self.DiplState]),
        PlayerName
    );
    Lib.Core.Quest:ChangeCustomQuestCaptionText(Text, _Quest);
end

function B_Goal_Diplomacy:CustomFunction(_Quest)
    self:ChangeCaption(_Quest);
    if self.Relation == "<=" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) <= self.DiplState then
            return true;
        end
    elseif self.Relation == ">=" then
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) >= self.DiplState then
            return true;
        end
    else
        if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) == self.DiplState then
            return true;
        end
    end
end

function B_Goal_Diplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Relation = _Parameter;
    elseif (_Index == 2) then
        self.DiplState = DiplomacyStates[_Parameter];
    end
end

function B_Goal_Diplomacy:GetIcon()
    return {6, 3};
end

function B_Goal_Diplomacy:GetCustomData(_Index)
    if _Index == 1 then
        return {">=", "<=", "=="};
    elseif _Index == 2 then
        return {"Allied", "TradeContact", "EstablishedContact", "Undecided", "Enemy"};
    end
end

RegisterBehavior(B_Goal_Diplomacy);

-- -------------------------------------------------------------------------- --

function Goal_DiscoverPlayer(...)
    return B_Goal_DiscoverPlayer:new(...);
end

B_Goal_DiscoverPlayer = {
    Name = "Goal_DiscoverPlayer",
    Description = {
        en = "Goal: Discover the home territory of another player.",
        de = "Ziel: Entdecke das Heimatterritorium eines Spielers.",
        fr = "Objectif: Découvrir le territoire d'origine d'un joueur.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DiscoverPlayer:GetGoalTable()
    return {Objective.Discover, 2, { self.PlayerID } }
end

function B_Goal_DiscoverPlayer:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DiscoverPlayer:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_Discover",
        [PlayerCategories.City] = "Quest_Discover_City",
        [PlayerCategories.Cloister] = "Quest_Discover_Cloister",
        [PlayerCategories.Harbour] = "Quest_Discover",
        [PlayerCategories.Village] = "Quest_Discover_Village",
    }
    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_Discover"
end

RegisterBehavior(B_Goal_DiscoverPlayer);

-- -------------------------------------------------------------------------- --

function Goal_DiscoverTerritory(...)
    return B_Goal_DiscoverTerritory:new(...);
end

B_Goal_DiscoverTerritory = {
    Name = "Goal_DiscoverTerritory",
    Description = {
        en = "Goal: Discover a territory",
        de = "Ziel: Entdecke ein Territorium",
        fr = "Objectif : Découvrir un territoire",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", fr = "Territoire" },
    },
}

function B_Goal_DiscoverTerritory:GetGoalTable()
    return { Objective.Discover, 1, { self.TerritoryID  } }
end

function B_Goal_DiscoverTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
        assert( self.TerritoryID > 0 )
    end
end

function B_Goal_DiscoverTerritory:GetMsgKey()
    return "Quest_Discover_Territory"
end

RegisterBehavior(B_Goal_DiscoverTerritory);

-- -------------------------------------------------------------------------- --

function Goal_DestroyPlayer(...)
    return B_Goal_DestroyPlayer:new(...);
end

B_Goal_DestroyPlayer = {
    Name = "Goal_DestroyPlayer",
    Description = {
        en = "Goal: Destroy a player (destroy a main building)",
        de = "Ziel: Zerstöre einen Spieler (ein Hauptgebäude muss zerstört werden).",
        fr = "Objectif : Détruire un joueur (un bâtiment principal doit être détruit).",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DestroyPlayer:GetGoalTable()
    assert( self.PlayerID <= 8 and self.PlayerID >= 1, "Error in " .. self.Name .. ": GetGoalTable: PlayerID is invalid")
    return { Objective.DestroyPlayers, self.PlayerID }
end

function B_Goal_DestroyPlayer:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DestroyPlayer:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",
        [PlayerCategories.City] = "Quest_DestroyPlayers_City",
        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",
        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",
        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",
    }

    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_DestroyEntities_Building"
end

RegisterBehavior(B_Goal_DestroyPlayer)

-- -------------------------------------------------------------------------- --

function Goal_StealInformation(...)
    return B_Goal_StealInformation:new(...);
end

B_Goal_StealInformation = {
    Name = "Goal_StealInformation",
    Description = {
        en = "Goal: Steal information from another players castle",
        de = "Ziel: Stehle Informationen aus der Burg eines Spielers",
        fr = "Objectif : voler des informations du château d'un joueur",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_StealInformation:GetGoalTable()

    local Target = Logic.GetHeadquarters(self.PlayerID)
    if not Target or Target == 0 then
        Target = Logic.GetStoreHouse(self.PlayerID)
    end
    assert( Target and Target ~= 0 )
    return {Objective.Steal, 1, { Target } }

end

function B_Goal_StealInformation:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end

end

function B_Goal_StealInformation:GetMsgKey()
    return "Quest_Steal_Info"

end

RegisterBehavior(B_Goal_StealInformation);

-- -------------------------------------------------------------------------- --

function Goal_DestroyAllPlayerUnits(...)
    return B_Goal_DestroyAllPlayerUnits:new(...);
end

B_Goal_DestroyAllPlayerUnits = {
    Name = "Goal_DestroyAllPlayerUnits",
    Description = {
        en = "Goal: Destroy all units owned by player (be careful with script entities)",
        de = "Ziel: Zerstöre alle Einheiten eines Spielers (vorsicht mit Script-Entities)",
        fr = "Objectif: Détruire toutes les unités d'un joueur (attention aux entités de script)",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DestroyAllPlayerUnits:GetGoalTable()
    return { Objective.DestroyAllPlayerUnits, self.PlayerID }
end

function B_Goal_DestroyAllPlayerUnits:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DestroyAllPlayerUnits:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_DestroyPlayers_Bandits",
        [PlayerCategories.City] = "Quest_DestroyPlayers_City",
        [PlayerCategories.Cloister] = "Quest_DestroyPlayers_Cloister",
        [PlayerCategories.Harbour] = "Quest_DestroyEntities_Building",
        [PlayerCategories.Village] = "Quest_DestroyPlayers_Village",
    }

    local PlayerCategory = GetPlayerCategoryType(self.PlayerID)
    if PlayerCategory then
        local Key = tMapping[PlayerCategory]
        if Key then
            return Key
        end
    end
    return "Quest_DestroyEntities"
end

RegisterBehavior(B_Goal_DestroyAllPlayerUnits);

-- -------------------------------------------------------------------------- --

function Goal_DestroyScriptEntity(...)
    return B_Goal_DestroyScriptEntity:new(...);
end

B_Goal_DestroyScriptEntity = {
    Name = "Goal_DestroyScriptEntity",
    Description = {
        en = "Goal: Destroy an entity",
        de = "Ziel: Zerstöre eine Entität",
        fr = "Objectif : Détruire une entité",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_DestroyScriptEntity:GetGoalTable()
    return {Objective.DestroyEntities, 1, { self.ScriptName } }
end

function B_Goal_DestroyScriptEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Goal_DestroyScriptEntity:GetMsgKey()
    if Logic.IsEntityAlive(self.ScriptName) then
        local ID = GetID(self.ScriptName)
        if ID and ID ~= 0 then
            ID = Logic.GetEntityType( ID )
            if ID and ID ~= 0 then
                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
                    return "Quest_DestroyEntities_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then
                    return "Quest_DestroyEntities_Predators"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
                    return "Quest_Destroy_Leader"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1
                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1
                    or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then

                    return "Quest_DestroyEntities_Unit"
                end
            end
        end
    end
    return "Quest_DestroyEntities"
end

RegisterBehavior(B_Goal_DestroyScriptEntity);

-- -------------------------------------------------------------------------- --

function Goal_DestroyType(...)
    return B_Goal_DestroyType:new(...);
end

B_Goal_DestroyType = {
    Name = "Goal_DestroyType",
    Description = {
        en = "Goal: Destroy entity types",
        de = "Ziel: Zerstöre Entitätstypen",
        fr = "Objectif: Détruire les types d'entités",
    },
    Parameter = {
        { ParameterType.Custom, en = "Type name", de = "Typbezeichnung", fr = "Désignation du type" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.Custom, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_DestroyType:GetGoalTable()
    return {Objective.DestroyEntities, 2, Entities[self.EntityName], self.Amount, self.PlayerID }
end

function B_Goal_DestroyType:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
        self.DestroyTypeAmount = self.Amount
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_DestroyType:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Entities ) do
            if string.find( k, "^[ABU]_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        for i = 0, 8 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function B_Goal_DestroyType:GetMsgKey()
    local ID = self.EntityName
    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
        return "Quest_DestroyEntities_Building"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableAnimal ) == 1 then
        return "Quest_DestroyEntities_Predators"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
        return "Quest_Destroy_Leader"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Military ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableSettler ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1  then

        return "Quest_DestroyEntities_Unit"
    end
    return "Quest_DestroyEntities"
end

RegisterBehavior(B_Goal_DestroyType);

-- -------------------------------------------------------------------------- --

function Goal_EntityDistance(...)
    return B_Goal_EntityDistance:new(...);
end

B_Goal_EntityDistance = {
    Name = "Goal_EntityDistance",
    Description = {
        en = "Goal: Distance between two entities",
        de = "Ziel: Zwei Entities sollen zueinander eine Entfernung über- oder unterschreiten.",
        fr = "Objectif: deux entités doivent se trouver à une distance supérieure ou inférieure l'une de l'autre.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1", fr = "Entité 1" },
        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2", fr = "Entité 2" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number, en = "Distance", de = "Entfernung", fr = "Distance" },
    },
}

function B_Goal_EntityDistance:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_EntityDistance:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity1 = _Parameter
    elseif (_Index == 1) then
        self.Entity2 = _Parameter
    elseif (_Index == 2) then
        self.bRelSmallerThan = _Parameter == "<"
    elseif (_Index == 3) then
        self.Distance = _Parameter * 1
    end
end

function B_Goal_EntityDistance:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.Entity1 ) or Logic.IsEntityDestroyed( self.Entity2 ) then
        return false
    end
    local ID1 = GetID( self.Entity1 )
    local ID2 = GetID( self.Entity2 )
    local InRange = Logic.CheckEntitiesDistance( ID1, ID2, self.Distance )
    if ( self.bRelSmallerThan and InRange ) or ( not self.bRelSmallerThan and not InRange ) then
        return true
    end
end

function B_Goal_EntityDistance:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        table.insert( Data, ">" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_EntityDistance:Debug(_Quest)
    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": At least 1 of the entities for distance check don't exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_EntityDistance);

-- -------------------------------------------------------------------------- --

function Goal_KnightDistance(...)
    return B_Goal_KnightDistance:new(...);
end

B_Goal_KnightDistance = {
    Name = "Goal_KnightDistance",
    Description = {
        en = "Goal: Bring the knight close to a given entity. If the distance is left at 0 it will automatically set to 2500.",
        de = "Ziel: Bringe den Ritter nah an eine bestimmte Entität. Wird die Entfernung 0 gelassen, ist sie automatisch 2500.",
        fr = "Objectif : Rapproche le chevalier d'une entité donnée. Si la distance est laissée à 0, elle est automatiquement de 2500.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target", de = "Ziel", fr = "Cible" },
        { ParameterType.Number, en = "Distance", de = "Entfernung", fr = "Distance" },
    },
}

function B_Goal_KnightDistance:GetGoalTable()
    return {Objective.Distance, -65566, self.Target, self.Distance, true}
end

function B_Goal_KnightDistance:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Target = _Parameter;
    elseif (_Index == 1) then
        if _Parameter == nil or _Parameter == "" then
            _Parameter = 0;
        end
        self.Distance = _Parameter * 1;
        if self.Distance == 0 then
            self.Distance = 2500;
        end
    end
end

RegisterBehavior(B_Goal_KnightDistance);

-- -------------------------------------------------------------------------- --

function Goal_UnitsOnTerritory(...)
    return B_Goal_UnitsOnTerritory:new(...);
end

B_Goal_UnitsOnTerritory = {
    Name = "Goal_UnitsOnTerritory",
    Description = {
        en = "Goal: Place a certain amount of units on a territory",
        de = "Ziel: Platziere eine bestimmte Anzahl Einheiten auf einem Gebiet",
        fr = "Objectif: placer un certain nombre d'unités sur un territoire",
    },
    Parameter = {
        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium", fr = "Territoire" },
        { ParameterType.Custom,  en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Custom,  en = "Category", de = "Kategorie", fr = "Catégorie" },
        { ParameterType.Custom,  en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number,  en = "Number of units", de = "Anzahl Einheiten", fr = "Quantité d'unitées" },
    },
}

function B_Goal_UnitsOnTerritory:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_UnitsOnTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if self.TerritoryID == nil then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    elseif (_Index == 1) then
        self.PlayerID = tonumber(_Parameter) * 1
    elseif (_Index == 2) then
        self.Category = _Parameter
    elseif (_Index == 3) then
        self.bRelSmallerThan = (tostring(_Parameter) == "true" or tostring(_Parameter) == "<")
    elseif (_Index == 4) then
        self.NumberOfUnits = _Parameter * 1
    end
end

function B_Goal_UnitsOnTerritory:CustomFunction(_Quest)
    local PlayerEntities = self:GetEntities(self.TerritoryID, self.PlayerID, EntityCategories[self.Category]);
    if self.bRelSmallerThan == false and #PlayerEntities >= self.NumberOfUnits then
        return true;
    elseif self.bRelSmallerThan == true and #PlayerEntities < self.NumberOfUnits then
        return true;
    end
end

function B_Goal_UnitsOnTerritory:GetEntities(_TerritoryID, _PlayerID, _Category)
    local PlayerEntities = {};
    local Units = {};
    if (_PlayerID == -1) then
        for i=0,8 do
            local NumLast = 0;
            repeat
                Units = {Logic.GetEntitiesOfCategoryInTerritory(_TerritoryID, i, _PlayerID, NumLast)};
                PlayerEntities = Array_Append(PlayerEntities, Units);
                NumLast = NumLast + #Units;
            until #Units == 0;
        end
    else
        local NumLast = 0;
        repeat
            Units = { Logic.GetEntitiesOfCategoryInTerritory(_TerritoryID, _PlayerID, _Category, NumLast)};
            PlayerEntities = Array_Append(PlayerEntities, Units);
            NumLast = NumLast + #Units;
        until #Units == 0;
    end
    return PlayerEntities;
end

function B_Goal_UnitsOnTerritory:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, -1 )
        for i = 1, 8 do
            table.insert( Data, i )
        end
    elseif _Index == 2 then
        for k, v in pairs( EntityCategories ) do
            if not string.find( k, "^G_" ) and k ~= "SheepPasture" then
                table.insert( Data, k )
            end
        end
        table.sort( Data );
    elseif _Index == 3 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_UnitsOnTerritory:Debug(_Quest)
    local territories = {Logic.GetTerritories()}
    if tonumber(self.TerritoryID) == nil or self.TerritoryID < 0 or not table.contains(territories, self.TerritoryID) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid territoryID!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 0 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    elseif not EntityCategories[self.Category] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid entity category!");
        return true;
    elseif tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": amount is negative or nil!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_UnitsOnTerritory);

-- -------------------------------------------------------------------------- --

function Goal_ActivateBuff(...)
    return B_Goal_ActivateBuff:new(...);
end

B_Goal_ActivateBuff = {
    Name = "Goal_ActivateBuff",
    Description = {
        en = "Goal: Activate a buff",
        de = "Ziel: Aktiviere einen Buff",
        fr = "Objectif: Activer un bonus",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Custom, en = "Buff", de = "Buff", fr = "Bonus" },
    },
}

function B_Goal_ActivateBuff:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_ActivateBuff:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.BuffName = _Parameter
        self.Buff = Buffs[_Parameter]
    end
end

function B_Goal_ActivateBuff:CustomFunction(_Quest)
   if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local tMapping = CopyTable(Lib.Core.Quest.Text.ActivateBuff.BuffsVanilla);
        if g_GameExtraNo >= 1 then
            tMapping = CopyTable(Lib.Core.Quest.Text.ActivateBuff.BuffsEx1, tMapping);
        end
        Lib.Core.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Localize(Lib.Core.Quest.Text.ActivateBuff.Pattern),
                Localize(tMapping[self.BuffName])
            ),
            _Quest
        );
    end

    local Buff = Logic.GetBuff( self.PlayerID, self.Buff )
    if Buff and Buff ~= 0 then
        return true
    end
end

function B_Goal_ActivateBuff:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        Data = {
            "Buff_Spice",
            "Buff_Colour",
            "Buff_Entertainers",
            "Buff_FoodDiversity",
            "Buff_ClothesDiversity",
            "Buff_HygieneDiversity",
            "Buff_EntertainmentDiversity",
            "Buff_Sermon",
            "Buff_Festival",
            "Buff_ExtraPayment",
            "Buff_HighTaxes",
            "Buff_NoPayment",
            "Buff_NoTaxes"
        }

        if g_GameExtraNo >= 1 then
            table.insert(Data, "Buff_Gems")
            table.insert(Data, "Buff_MusicalInstrument")
            table.insert(Data, "Buff_Olibanum")
        end

        table.sort( Data )
    else
        assert( false )
    end
    return Data
end

function B_Goal_ActivateBuff:GetIcon()
    local tMapping = {
        [Buffs.Buff_Spice]                  = "Goods.G_Salt",
        [Buffs.Buff_Colour]                 = "Goods.G_Dye",
        [Buffs.Buff_Entertainers]           = "Entities.U_Entertainer_NA_FireEater", --{5, 12},
        [Buffs.Buff_FoodDiversity]          = "Needs.Nutrition", --{1, 1},
        [Buffs.Buff_ClothesDiversity]       = "Needs.Clothes", --{1, 2},
        [Buffs.Buff_HygieneDiversity]       = "Needs.Hygiene", --{16, 1},
        [Buffs.Buff_EntertainmentDiversity] = "Needs.Entertainment", --{1, 4},
        [Buffs.Buff_Sermon]                 = "Technologies.R_Sermon", --{4, 14},
        [Buffs.Buff_Festival]               = "Technologies.R_Festival", --{4, 15},
        [Buffs.Buff_ExtraPayment]           = {1,8},
        [Buffs.Buff_HighTaxes]              = {1,6},
        [Buffs.Buff_NoPayment]              = {1,8},
        [Buffs.Buff_NoTaxes]                = {1,6},
    }
    if g_GameExtraNo and g_GameExtraNo >= 1 then
        tMapping[Buffs.Buff_Gems] = "Goods.G_Gems"
        tMapping[Buffs.Buff_MusicalInstrument] = "Goods.G_MusicalInstrument"
        tMapping[Buffs.Buff_Olibanum] = "Goods.G_Olibanum"
    end
    return tMapping[self.Buff]
end

function B_Goal_ActivateBuff:Debug(_Quest)
    if not self.Buff then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": buff '" ..self.BuffName.. "' does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_ActivateBuff);

-- -------------------------------------------------------------------------- --

function Goal_BuildRoad(...)
    return B_Goal_BuildRoad:new(...)
end

B_Goal_BuildRoad = {
    Name = "Goal_BuildRoad",
    Description = {
        en = "Goal: Connect two points with a street or a road",
        de = "Ziel: Verbinde zwei Punkte mit einer Strasse oder einem Weg.",
        fr = "Objectif: Relier deux points par une route ou un chemin.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity 1",       de = "Entity 1",     fr = "Entité 1" },
        { ParameterType.ScriptName, en = "Entity 2",       de = "Entity 2",     fr = "Entité 2" },
        { ParameterType.Custom,     en = "Only roads",     de = "Nur Strassen", fr = "Que des Routes" },
    },
}

function B_Goal_BuildRoad:GetGoalTable()
    -- {BehaviorType, {EntityID1, EntityID2, BeSmalerThan, Length, RoadsOnly}}
    -- -> Length wird nicht mehr benutzt. Sorgte für Promleme im Spiel
    return { Objective.BuildRoad, { GetID( self.Entity1 ), GetID( self.Entity2 ), false, 0, self.bRoadsOnly } }
end

function B_Goal_BuildRoad:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity1 = _Parameter
    elseif (_Index == 1) then
        self.Entity2 = _Parameter
    elseif (_Index == 2) then
        self.bRoadsOnly = ToBoolean(_Parameter)
    end
end

function B_Goal_BuildRoad:GetCustomData( _Index )
    local Data
    if _Index == 2 then
        Data = {"true","false"}
    end
    return Data
end

function B_Goal_BuildRoad:Debug(_Quest)
    if not IsExisting(self.Entity1) or not IsExisting(self.Entity2) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": first or second entity does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_BuildRoad);

-- -------------------------------------------------------------------------- --

function Goal_BuildWall(...)
    return B_Goal_BuildWall:new(...)
end

B_Goal_BuildWall = {
    Name = "Goal_BuildWall",
    Description = {
        en = "Goal: Build a wall between 2 positions bo stop the movement of an (hostile) player.",
        de = "Ziel: Baue eine Mauer zwischen 2 Punkten, die die Bewegung eines (feindlichen) Spielers zwischen den Punkten verhindert.",
        fr = "Objectif: Construire un mur entre 2 points qui empêche le déplacement d'un joueur (ennemi) entre les points.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Enemy", de = "Feind", fr = "Ennemi" },
        { ParameterType.ScriptName, en = "Entity 1", de = "Entity 1", fr = "Entité 1" },
        { ParameterType.ScriptName, en = "Entity 2", de = "Entity 2", fr = "Entité 2" },
    },
}

function B_Goal_BuildWall:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_BuildWall:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.EntityName1 = _Parameter
    elseif (_Index == 2) then
        self.EntityName2 = _Parameter
    end
end

function B_Goal_BuildWall:CustomFunction(_Quest)
    local eID1 = GetID(self.EntityName1)
    local eID2 = GetID(self.EntityName2)

    if not IsExisting(eID1) then
        return false
    end
    if not IsExisting(eID2) then
        return false
    end
    local x,y,z = Logic.EntityGetPos(eID1)
    if Logic.IsBuilding(eID1) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID1)
    end
    local Sector1 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)
    local x,y,z = Logic.EntityGetPos(eID2)
    if Logic.IsBuilding(eID2) == 1 then
        x,y = Logic.GetBuildingApproachPosition(eID2)
    end
    local Sector2 = Logic.GetPlayerSectorAtPosition(self.PlayerID, x, y)
    if Sector1 ~= Sector2 then
        return true
    end
    return nil
end

function B_Goal_BuildWall:GetMsgKey()
    return "Quest_Create_Wall"
end

function B_Goal_BuildWall:GetIcon()
    return {3,9}
end

function B_Goal_BuildWall:Debug(_Quest)
    if not IsExisting(self.EntityName1) or not IsExisting(self.EntityName2) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": first or second entity does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end

    if GetDiplomacyState(_Quest.ReceivingPlayer, self.PlayerID) > -1 and not self.WarningPrinted then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": player %d is neighter enemy or unknown to quest receiver!");
        self.WarningPrinted = true;
    end
    return false;
end

RegisterBehavior(B_Goal_BuildWall);

-- -------------------------------------------------------------------------- --

function Goal_Claim(...)
    return B_Goal_Claim:new(...)
end

B_Goal_Claim = {
    Name = "Goal_Claim",
    Description = {
        en = "Goal: Claim a territory",
        de = "Ziel: Erobere ein Territorium",
        fr = "Objectif: Conquérir un territoire",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", fr = "Territoire" },
    },
}

function B_Goal_Claim:GetGoalTable()
    return { Objective.Claim, 1, self.TerritoryID }
end

function B_Goal_Claim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    end
end

function B_Goal_Claim:GetMsgKey()
    return "Quest_Claim_Territory"
end

RegisterBehavior(B_Goal_Claim);

-- -------------------------------------------------------------------------- --

function Goal_ClaimXTerritories(...)
    return B_Goal_ClaimXTerritories:new(...)
end

B_Goal_ClaimXTerritories = {
    Name = "Goal_ClaimXTerritories",
    Description = {
        en = "Goal: Claim the given number of territories, all player territories are counted",
        de = "Ziel: Erobere die angegebene Anzahl Territorien, alle spielereigenen Territorien werden gezählt",
        fr = "Objectif: conquérir le nombre de territoires indiqué, tous les territoires des joueurs sont comptabilisés.",
    },
    Parameter = {
        { ParameterType.Number, en = "Territories" , de = "Territorien", fr = "Territoire" }
    },
}

function B_Goal_ClaimXTerritories:GetGoalTable()
    return { Objective.Claim, 2, self.TerritoriesToClaim }
end

function B_Goal_ClaimXTerritories:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.TerritoriesToClaim = _Parameter * 1
    end
end

function B_Goal_ClaimXTerritories:GetMsgKey()
    return "Quest_Claim_Territory"
end

RegisterBehavior(B_Goal_ClaimXTerritories);

-- -------------------------------------------------------------------------- --

function Goal_Create(...)
    return B_Goal_Create:new(...);
end

B_Goal_Create = {
    Name = "Goal_Create",
    Description = {
        en = "Goal: Create Buildings/Units on a specified territory",
        de = "Ziel: Erstelle Einheiten/Gebäude auf einem bestimmten Territorium.",
        fr = "Objectif: créer des unités/bâtiments sur un territoire donné.",
    },
    Parameter = {
        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung", fr = "Désignation du type" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.TerritoryNameWithUnknown, en = "Territory", de = "Territorium", fr = "Territoire" },
    },
}

function B_Goal_Create:GetGoalTable()
    return { Objective.Create, assert( Entities[self.EntityName] ), self.Amount, self.TerritoryID }
end

function B_Goal_Create:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    elseif (_Index == 2) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    end
end

function B_Goal_Create:GetMsgKey()
    return Logic.IsEntityTypeInCategory( Entities[self.EntityName], EntityCategories.AttackableBuilding ) == 1 and "Quest_Create_Building" or "Quest_Create_Unit"
end

RegisterBehavior(B_Goal_Create);

-- -------------------------------------------------------------------------- --

function Goal_Produce(...)
    return B_Goal_Produce:new(...);
end

B_Goal_Produce = {
    Name = "Goal_Produce",
    Description = {
        en = "Goal: Produce an amount of goods",
        de = "Ziel: Produziere eine Anzahl einer bestimmten Ware.",
        fr = "Objectif: produire un certain nombre d'une marchandise donnée."
    },
    Parameter = {
        { ParameterType.RawGoods, en = "Type of good", de = "Ressourcentyp", fr = "Type de ressources" },
        { ParameterType.Number, en = "Amount of good", de = "Anzahl der Ressource", fr = "Quantité de ressources" },
    },
}

function B_Goal_Produce:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Produce, GoodType, self.GoodAmount }
end

function B_Goal_Produce:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    end
end

function B_Goal_Produce:GetMsgKey()
    return "Quest_Produce"
end

RegisterBehavior(B_Goal_Produce);

-- -------------------------------------------------------------------------- --

function Goal_GoodAmount(...)
    return B_Goal_GoodAmount:new(...);
end

B_Goal_GoodAmount = {
    Name = "Goal_GoodAmount",
    Description = {
        en = "Goal: Obtain an amount of goods - either by trading or producing them",
        de = "Ziel: Beschaffe eine Anzahl Waren - entweder durch Handel oder durch eigene Produktion.",
        fr = "Objectif: Se procurer un certain nombre de marchandises - soit par le commerce, soit par sa propre production."
    },
    Parameter = {
        { ParameterType.Custom, en = "Type of good", de = "Warentyp", fr = "TYpe de marchandises" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
    },
}

function B_Goal_GoodAmount:GetGoalTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Objective.Produce, GoodType, self.GoodAmount, self.bRelSmallerThan }
end

function B_Goal_GoodAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    elseif  (_Index == 2) then
        self.bRelSmallerThan = _Parameter == "<" or tostring(_Parameter) == "true"
    end
end

function B_Goal_GoodAmount:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

RegisterBehavior(B_Goal_GoodAmount);

-- -------------------------------------------------------------------------- --

function Goal_SatisfyNeed(...)
    return B_Goal_SatisfyNeed:new(...);
end

B_Goal_SatisfyNeed = {
    Name = "Goal_SatisfyNeed",
    Description = {
        en = "Goal: Satisfy a need",
        de = "Ziel: Erfuelle ein Beduerfnis",
        fr = "Objectif: Répondre à un besoin",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Need, en = "Need", de = "Beduerfnis", fr = "Besoin" },
    },
}

function B_Goal_SatisfyNeed:GetGoalTable()
    return { Objective.SatisfyNeed, Needs[self.Need], self.PlayerID }

end

function B_Goal_SatisfyNeed:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Need = _Parameter
    end

end

function B_Goal_SatisfyNeed:GetMsgKey()
    local tMapping = {
        [Needs.Clothes] = "Quest_SatisfyNeed_Clothes",
        [Needs.Entertainment] = "Quest_SatisfyNeed_Entertainment",
        [Needs.Nutrition] = "Quest_SatisfyNeed_Food",
        [Needs.Hygiene] = "Quest_SatisfyNeed_Hygiene",
        [Needs.Medicine] = "Quest_SatisfyNeed_Medicine",
    }

    local Key = tMapping[Needs[self.Need]]
    if Key then
        return Key
    end

    -- No default message
end

RegisterBehavior(B_Goal_SatisfyNeed);

-- -------------------------------------------------------------------------- --

function Goal_SettlersNumber(...)
    return B_Goal_SettlersNumber:new(...);
end

B_Goal_SettlersNumber = {
    Name = "Goal_SettlersNumber",
    Description = {
        en = "Goal: Get a given amount of settlers",
        de = "Ziel: Erreiche eine bestimmte Anzahl Siedler.",
        fr = "Objectif: atteindre un certain nombre de Settlers.",
    },
    Parameter = {
        { ParameterType.Number,   en = "Amount", de = "Anzahl", fr = "Quantité" },
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Goal_SettlersNumber:GetGoalTable()
    return {Objective.SettlersNumber, self.PlayerID or 1, self.SettlersAmount };
end

function B_Goal_SettlersNumber:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SettlersAmount = _Parameter * 1;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    end
end

function B_Goal_SettlersNumber:GetMsgKey()
    return "Quest_NumberSettlers";
end

RegisterBehavior(B_Goal_SettlersNumber);

-- -------------------------------------------------------------------------- --

function Goal_Spouses(...)
    return B_Goal_Spouses:new(...);
end

B_Goal_Spouses = {
    Name = "Goal_Spouses",
    Description = {
        en = "Goal: Get a given amount of spouses",
        de = "Ziel: Erreiche eine bestimmte Ehefrauenanzahl",
        fr = "Objectif: Atteindre un certain nombre d'épouses",
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr = "Quantité" },
    },
}

function B_Goal_Spouses:GetGoalTable()
    return {Objective.Spouses, self.SpousesAmount }
end

function B_Goal_Spouses:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SpousesAmount = _Parameter * 1
    end
end

function B_Goal_Spouses:GetMsgKey()
    return "Quest_NumberSpouses"
end

RegisterBehavior(B_Goal_Spouses);

-- -------------------------------------------------------------------------- --

function Goal_SoldierCount(...)
    return B_Goal_SoldierCount:new(...);
end

B_Goal_SoldierCount = {
    Name = "Goal_SoldierCount",
    Description = {
        en = "Goal: Create a specified number of soldiers",
        de = "Ziel: Erreiche eine Anzahl grösser oder kleiner der angegebenen Menge Soldaten.",
        fr = "Objectif: Atteindre un nombre de soldats supérieur ou inférieur à la quantité indiquée.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number, en = "Number of soldiers", de = "Anzahl Soldaten", fr = "Nombre de soldats" },
    },
}

function B_Goal_SoldierCount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_SoldierCount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.bRelSmallerThan = tostring(_Parameter) == "true" or tostring(_Parameter) == "<"
    elseif (_Index == 2) then
        self.NumberOfUnits = _Parameter * 1
    end
end

function B_Goal_SoldierCount:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local Relation = tostring(self.bRelSmallerThan);
        local PlayerName = GetPlayerName(self.PlayerID) or "";
        Lib.Core.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Localize(Lib.Core.Quest.Text.SoldierCount.Pattern),
                PlayerName,
                Localize(Lib.Core.Quest.Text.SoldierCount.Relation[Relation]),
                self.NumberOfUnits
            ),
            _Quest
        );
    end

    local NumSoldiers = Logic.GetCurrentSoldierCount( self.PlayerID )
    if ( self.bRelSmallerThan and NumSoldiers < self.NumberOfUnits ) then
        return true
    elseif ( not self.bRelSmallerThan and NumSoldiers >= self.NumberOfUnits ) then
        return true
    end
    return nil
end

function B_Goal_SoldierCount:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then

        table.insert( Data, ">=" )
        table.insert( Data, "<" )

    else
        assert( false )
    end
    return Data
end

function B_Goal_SoldierCount:GetIcon()
    return {7,11}
end

function B_Goal_SoldierCount:GetMsgKey()
    return "Quest_Create_Unit"
end

function B_Goal_SoldierCount:Debug(_Quest)
    if tonumber(self.NumberOfUnits) == nil or self.NumberOfUnits < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": amount can not be below 0!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_SoldierCount);

-- -------------------------------------------------------------------------- --

function Goal_KnightTitle(...)
    return B_Goal_KnightTitle:new(...);
end

B_Goal_KnightTitle = {
    Name = "Goal_KnightTitle",
    Description = {
        en = "Goal: Reach a specified knight title",
        de = "Ziel: Erreiche einen vorgegebenen Titel",
        fr = "Objectif: atteindre un titre donné",
    },
    Parameter = {
        { ParameterType.Custom, en = "Knight title", de = "Titel", fr = "Titre" },
    },
}

function B_Goal_KnightTitle:GetGoalTable()
    return {Objective.KnightTitle, assert( KnightTitles[self.KnightTitle] ) }
end

function B_Goal_KnightTitle:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.KnightTitle = _Parameter
    end
end

function B_Goal_KnightTitle:GetMsgKey()
    return "Quest_KnightTitle"
end

function B_Goal_KnightTitle:GetCustomData( _Index )
    return {"Knight", "Mayor", "Baron", "Earl", "Marquees", "Duke", "Archduke"}
end

RegisterBehavior(B_Goal_KnightTitle);

-- -------------------------------------------------------------------------- --

function Goal_Festivals(...)
    return B_Goal_Festivals:new(...);
end

B_Goal_Festivals = {
    Name = "Goal_Festivals",
    Description = {
        en = "Goal: The player has to start the given number of festivals.",
        de = "Ziel: Der Spieler muss eine gewisse Anzahl Feste gestartet haben.",
        fr = "Objectif: Le joueur doit avoir lancé un certain nombre de festivités."
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
        { ParameterType.Number, en = "Number of festivals", de = "Anzahl Feste", fr = "Nombre de festivités" }
    }
};

function B_Goal_Festivals:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_Festivals:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.PlayerID = tonumber(_Parameter);
    else
        assert(_Index == 1, "Error in " .. self.Name .. ": AddParameter: Index is invalid.");
        self.NeededFestivals = tonumber(_Parameter);
    end
end

function B_Goal_Festivals:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local PlayerName = GetPlayerName(self.PlayerID) or "";
        Lib.Core.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Localize(Lib.Core.Quest.Text.Festivals.Pattern),
                PlayerName, self.NeededFestivals
            ), 
            _Quest
        );
    end

    if Logic.GetStoreHouse( self.PlayerID ) == 0  then
        return false
    end
    local tablesOnFestival = {Logic.GetPlayerEntities(self.PlayerID, Entities.B_TableBeer, 5,0)}
    local amount = 0
    for k=2, #tablesOnFestival do
        local tableID = tablesOnFestival[k]
        if Logic.GetIndexOnOutStockByGoodType(tableID, Goods.G_Beer) ~= -1 then
            local goodAmountOnMarketplace = Logic.GetAmountOnOutStockByGoodType(tableID, Goods.G_Beer)
            amount = amount + goodAmountOnMarketplace
        end
    end
    if not self.FestivalStarted and amount > 0 then
        self.FestivalStarted = true
        self.FestivalCounter = (self.FestivalCounter and self.FestivalCounter + 1) or 1
        if self.FestivalCounter >= self.NeededFestivals then
            self.FestivalCounter = nil
            return true
        end
    elseif amount == 0 then
        self.FestivalStarted = false
    end
end

function B_Goal_Festivals:Debug(_Quest)
    if Logic.GetStoreHouse( self.PlayerID ) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead :-(")
        return true
    elseif GetPlayerCategoryType(self.PlayerID) ~= PlayerCategories.City then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ":  Player "..  self.PlayerID .. " is no city")
        return true
    elseif self.NeededFestivals < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Festivals is negative")
        return true
    end
    return false
end

function B_Goal_Festivals:Reset()
    self.FestivalCounter = nil
    self.FestivalStarted = nil
end

function B_Goal_Festivals:GetIcon()
    return {4,15}
end

RegisterBehavior(B_Goal_Festivals)

-- -------------------------------------------------------------------------- --

function Goal_Capture(...)
    return B_Goal_Capture:new(...)
end

B_Goal_Capture = {
    Name = "Goal_Capture",
    Description = {
        en = "Goal: Capture a cart.",
        de = "Ziel: Ein Karren muss erobert werden.",
        fr = "Objectif: un chariot doit être conquis.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_Capture:GetGoalTable()
    return { Objective.Capture, 1, { self.ScriptName } }
end

function B_Goal_Capture:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Goal_Capture:GetMsgKey()
   local ID = GetID(self.ScriptName)
   if Logic.IsEntityAlive(ID) then
        ID = Logic.GetEntityType( ID )
        if ID and ID ~= 0 then
            if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
                return "Quest_Capture_Cart"

            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then
                return "Quest_Capture_SiegeEngine"

            elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1
                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1
                or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then

                return "Quest_Capture_VIPOfPlayer"

            end
        end
    end
end

RegisterBehavior(B_Goal_Capture);

-- -------------------------------------------------------------------------- --

function Goal_CaptureType(...)
    return B_Goal_CaptureType:new(...)
end

B_Goal_CaptureType = {
    Name = "Goal_CaptureType",
    Description = {
        en = "Goal: Capture specified entity types",
        de = "Ziel: Nimm bestimmte Entitätstypen gefangen",
        fr = "Objectif: capturer certains types d'entités",
    },
    Parameter = {
        { ParameterType.Custom,     en = "Type name",   de = "Typbezeichnung",  fr = "Désignation du type" },
        { ParameterType.Number,     en = "Amount",      de = "Anzahl",          fr = "Quantité" },
        { ParameterType.PlayerID,   en = "Player",      de = "Spieler",         fr = "Joueur" },
    },
}

function B_Goal_CaptureType:GetGoalTable()
    return { Objective.Capture, 2, Entities[self.EntityName], self.Amount, self.PlayerID }
end

function B_Goal_CaptureType:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    end
end

function B_Goal_CaptureType:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for k, v in pairs( Entities ) do
            if string.find( k, "^U_.+Cart" ) or Logic.IsEntityTypeInCategory( v, EntityCategories.AttackableMerchant ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        for i = 0, 8 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function B_Goal_CaptureType:GetMsgKey()

    local ID = self.EntityName
    if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
        return "Quest_Capture_Cart"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SiegeEngine ) == 1 then
        return "Quest_Capture_SiegeEngine"

    elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Worker ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Spouse ) == 1
        or Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then

        return "Quest_Capture_VIPOfPlayer"
    end
end

RegisterBehavior(B_Goal_CaptureType);

-- -------------------------------------------------------------------------- --

function Goal_Protect(...)
    return B_Goal_Protect:new(...)
end

B_Goal_Protect = {
    Name = "Goal_Protect",
    Description = {
        en = "Goal: Protect an entity (entity needs a script name",
        de = "Ziel: Beschütze eine Entität (Entität benötigt einen Skriptnamen)",
        fr = "Objectif : Protéger une entité (l'entité nécessite un nom de script)"
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Goal_Protect:GetGoalTable()
    return {Objective.Protect, { self.ScriptName }}
end

function B_Goal_Protect:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Goal_Protect:GetMsgKey()
    if Logic.IsEntityAlive(self.ScriptName) then
        local ID = GetID(self.ScriptName)
        if ID and ID ~= 0 then
            ID = Logic.GetEntityType( ID )
            if ID and ID ~= 0 then
                if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
                    return "Quest_Protect_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.SpecialBuilding ) == 1 then
                    local tMapping = {
                        [PlayerCategories.City]        = "Quest_Protect_City",
                        [PlayerCategories.Cloister]    = "Quest_Protect_Cloister",
                        [PlayerCategories.Village]    = "Quest_Protect_Village",
                    }
                    local PlayerCategory = GetPlayerCategoryType( Logic.EntityGetPlayer(GetID(self.ScriptName)) )
                    if PlayerCategory then
                        local Key = tMapping[PlayerCategory]
                        if Key then
                            return Key
                        end
                    end
                    return "Quest_Protect_Building"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.Hero ) == 1 then
                    return "Quest_Protect_Knight"

                elseif Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableMerchant ) == 1 then
                    return "Quest_Protect_Cart"
                end
            end
        end
    end
    return "Quest_Protect"
end

RegisterBehavior(B_Goal_Protect);

-- -------------------------------------------------------------------------- --

function Goal_Refill(...)
    return B_Goal_Refill:new(...)
end

B_Goal_Refill = {
    Name = "Goal_Refill",
    Description = {
        en = "Goal: Refill an object using a geologist",
        de = "Ziel: Eine Mine soll durch einen Geologen wieder aufgefuellt werden.",
        fr = "Objectif: Une mine doit être réalimentée par un géologue.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
   RequiresExtraNo = 1,
}

function B_Goal_Refill:GetGoalTable()
    return { Objective.Refill, { GetID(self.ScriptName) } }
end

function B_Goal_Refill:GetIcon()
    return {8,1,1}
end

function B_Goal_Refill:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

if g_GameExtraNo > 0 then
    RegisterBehavior(B_Goal_Refill);
end

-- -------------------------------------------------------------------------- --

function Goal_ResourceAmount(...)
    return B_Goal_ResourceAmount:new(...)
end

B_Goal_ResourceAmount = {
    Name = "Goal_ResourceAmount",
    Description = {
        en = "Goal: Reach a specified amount of resources in a doodad",
        de = "Ziel: In einer Mine soll weniger oder mehr als eine angegebene Anzahl an Rohstoffen sein.",
        fr = "Objectif: Dans une mine, il doit y avoir moins ou plus de matières premières qu'un nombre indiqué.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
        { ParameterType.Custom, en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité" },
    },
}

function B_Goal_ResourceAmount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_ResourceAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.bRelSmallerThan = _Parameter == "<"
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1
    end
end

function B_Goal_ResourceAmount:CustomFunction(_Quest)
    local ID = GetID(self.ScriptName)
    if ID and ID ~= 0 and Logic.GetResourceDoodadGoodType(ID) ~= 0 then
        local HaveAmount = Logic.GetResourceDoodadGoodAmount(ID)
        if ( self.bRelSmallerThan and HaveAmount < self.Amount ) or ( not self.bRelSmallerThan and HaveAmount >= self.Amount ) then
            return true
        end
    end
    return nil
end

function B_Goal_ResourceAmount:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, ">=" )
        table.insert( Data, "<" )
    else
        assert( false )
    end
    return Data
end

function B_Goal_ResourceAmount:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": entity '" ..self.ScriptName.. "' does not exist!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": error at amount! (nil or below 0)");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_ResourceAmount);

-- -------------------------------------------------------------------------- --

function Goal_InstantFailure()
    return B_Goal_InstantFailure:new()
end

B_Goal_InstantFailure = {
    Name = "Goal_InstantFailure",
    Description = {
        en = "Goal: Instant failure, the goal returns false.",
        de = "Ziel: Direkter Misserfolg, das Goal sendet false.",
        fr = "Objectif: échec direct, le goal envoie false.",
    },
}

function B_Goal_InstantFailure:GetGoalTable()
    return {Objective.DummyFail};
end

RegisterBehavior(B_Goal_InstantFailure);

-- -------------------------------------------------------------------------- --

function Goal_InstantSuccess()
    return B_Goal_InstantSuccess:new()
end

B_Goal_InstantSuccess = {
    Name = "Goal_InstantSuccess",
    Description = {
        en = "Goal: Instant success, the goal returns true.",
        de = "Ziel: Direkter Erfolg, das Goal sendet true.",
        fr = "Objectif: succès direct, le goal envoie false."
    },
}

function B_Goal_InstantSuccess:GetGoalTable()
    return {Objective.Dummy};
end

RegisterBehavior(B_Goal_InstantSuccess);

-- -------------------------------------------------------------------------- --

function Goal_NoChange()
    return B_Goal_NoChange:new()
end

B_Goal_NoChange = {
    Name = "Goal_NoChange",
    Description = {
        en = "Goal: The quest state doesn't change. Use reward functions of other quests to change the state of this quest.",
        de = "Ziel: Der Questzustand wird nicht verändert. Ein Reward einer anderen Quest sollte den Zustand dieser Quest verändern.",
        fr = "Objectif: L'état de la quête n'est pas modifié. Une récompense d'une autre quête doit modifier l'état de cette quête.",
    },
}

function B_Goal_NoChange:GetGoalTable()
    return { Objective.NoChange }
end

RegisterBehavior(B_Goal_NoChange);

-- -------------------------------------------------------------------------- --

function Goal_MapScriptFunction(...)
    return B_Goal_MapScriptFunction:new(...);
end

B_Goal_MapScriptFunction = {
    Name = "Goal_MapScriptFunction",
    Description = {
        en = "Goal: Calls a function within the global map script. Return 'true' means success, 'false' means failure and 'nil' doesn't change anything.",
        de = "Ziel: Ruft eine Funktion im globalen Skript auf, die einen Wahrheitswert zurueckgibt. Rueckgabe 'true' gilt als erfuellt, 'false' als gescheitert und 'nil' ändert nichts.",
        fr = "Objectif: Appelle une fonction dans le script global qui renvoie une valeur de vérité. Le retour 'true' est considéré comme rempli, 'false' comme échoué et 'nil' ne change rien.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname", fr = "Nom de la fonction" },
    },
}

function B_Goal_MapScriptFunction:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_MapScriptFunction:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.FuncName = _Parameter
    end
end

function B_Goal_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        return self.FuncName(unpack(self.i47ya_6aghw_frxil));
    end
    return _G[self.FuncName](self, _Quest);
end

function B_Goal_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_MapScriptFunction);

-- -------------------------------------------------------------------------- --

function Goal_CustomVariables(...)
    return B_Goal_CustomVariables:new(...);
end

B_Goal_CustomVariables = {
    Name = "Goal_CustomVariables",
    Description = {
        en = "Goal: A customised variable has to assume a certain value.",
        de = "Ziel: Eine benutzerdefinierte Variable muss einen bestimmten Wert annehmen.",
        fr = "Objectif: une variable définie par l'utilisateur doit prendre une certaine valeur.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of Variable", de = "Variablenname", fr = "Nom de la variable" },
        { ParameterType.Custom,  en = "Relation", de = "Relation", fr = "Relation" },
        { ParameterType.Default, en = "Value or variable", de = "Wert oder Variable", fr = "Valeur ou variable" }
    }
};

function B_Goal_CustomVariables:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Relation = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        self.Value = (value == nil and tostring(_Parameter)) or value;
    end
end

function B_Goal_CustomVariables:CustomFunction()
    local Value1 = ObtainCustomVariable("BehaviorVariable_" ..self.VariableName, 0);
    local Value2 = self.Value;
    if type(self.Value) == "string" then
        Value2 = ObtainCustomVariable("BehaviorVariable_" ..self.Value, 0);
    end

    if self.Relation == "==" then
        if Value1 == Value2 then
            return true;
        end
    elseif self.Relation == "~=" then
        if Value1 == Value2 then
            return true;
        end
    elseif self.Relation == "<" then
        if Value1 < Value2 then
            return true;
        end
    elseif self.Relation == "<=" then
        if Value1 <= Value2 then
            return true;
        end
    elseif self.Relation == ">=" then
        if Value1 >= Value2 then
            return true;
        end
    else
        if Value1 > Value2 then
            return true;
        end
    end
    return nil;
end

function B_Goal_CustomVariables:GetCustomData( _Index )
    return {"==", "~=", "<=", "<", ">", ">="};
end

function B_Goal_CustomVariables:Debug(_Quest)
    local relations = {"==", "~=", "<=", "<", ">", ">="}
    local results    = {true, false, nil}

    if not ObtainCustomVariable("BehaviorVariable_" ..self.VariableName) then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": variable '"..self.VariableName.."' do not exist!");
    end
    if not table.contains(relations, self.Relation) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.Relation.."' is an invalid relation!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_CustomVariables)

-- -------------------------------------------------------------------------- --

function Goal_TributeDiplomacy(...)
    return B_Goal_TributeDiplomacy:new(...);
end

B_Goal_TributeDiplomacy = {
    Name = "Goal_TributeDiplomacy",
    Description = {
        en = "Goal: AI requests periodical tribute for better Diplomacy",
        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer bessere Diplomatie. Der Questgeber ist der fordernde Spieler.",
        fr = "Objectif: L'IA demande un tribut régulier pour une meilleure diplomatie. Le donneur de quête est le joueur qui exige."
    },
    Parameter = {
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité", },
        { ParameterType.Number, en = "Time till next peyment in seconds", de = "Zeit bis zur Forderung in Sekunden", fr = "Temps jusqu'à la demande en secondes", },
        { ParameterType.Number, en = "Time to pay tribute in seconds", de = "Zeit bis zur Zahlung in Sekunden", fr = "Délai avant paiement en secondes", },
        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", fr = "Message de début de quête de tribut", },
        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", fr = "Message de réussite de la quête de tribut", },
        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", fr = "Message de défaite de la quête de tribut", },
        { ParameterType.Custom, en = "Restart if failed to pay", de = "Nicht-bezahlen beendet die Quest", fr = "Ne pas payer met fin à la quête", },
    },
}

function B_Goal_TributeDiplomacy:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_TributeDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 1) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 2) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 3) then
        self.StartMsg = _Parameter;
    elseif (_Index == 4) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 5) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 6) then
        self.RestartAtFailure = ToBoolean(_Parameter);
    end
end

function B_Goal_TributeDiplomacy:GetTributeQuest(_Quest)
    if not self.InternTributeQuest then
        local Language = CONST_LANGUAGE;
        local StartMsg = self.StartMsg;
        if type(StartMsg) == "table" then
            StartMsg = StartMsg[Language];
        end
        local SuccessMsg = self.SuccessMsg;
        if type(SuccessMsg) == "table" then
            SuccessMsg = SuccessMsg[Language];
        end
        local FailureMsg = self.FailureMsg;
        if type(FailureMsg) == "table" then
            FailureMsg = FailureMsg[Language];
        end

        Lib.Core.Quest.QuestCounter = Lib.Core.Quest.QuestCounter+1;

        local QuestID, Quest = QuestTemplate:New (
            _Quest.Identifier.."_TributeDiplomacyQuest_" ..Lib.Core.Quest.QuestCounter,
            _Quest.SendingPlayer,
            _Quest.ReceivingPlayer,
            {{ Objective.Deliver, {Goods.G_Gold, self.Amount}}},
            {{ Triggers.Time, 0 }},
            self.TributTime, nil, nil, nil, nil, true, true, nil,
            StartMsg,
            SuccessMsg,
            FailureMsg
        );
        self.InternTributeQuest = Quest;
    end
end

function B_Goal_TributeDiplomacy:CheckTributeQuest(_Quest)
    if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Over and not self.RestartQuest then
        if self.InternTributeQuest.Result ~= QuestResult.Success then
            SetDiplomacyState( _Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.Enemy);
            if not self.RestartAtFailure then
                return false;
            end
        else
            SetDiplomacyState(_Quest.ReceivingPlayer, _Quest.SendingPlayer, DiplomacyStates.TradeContact);
        end
        self.RestartQuest = true;
        self.Time = Logic.GetTime();
    end
end

function B_Goal_TributeDiplomacy:CheckTributePlayer(_Quest)
    local storeHouse = Logic.GetStoreHouse(_Quest.SendingPlayer);
    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then
        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        return true;
    end
end

function B_Goal_TributeDiplomacy:TributQuestRestarter(_Quest)
    if self.InternTributeQuest and self.Time and self.RestartQuest and ((Logic.GetTime() - self.Time) >= self.PeriodLength) then
        self.InternTributeQuest.Objectives[1].Completed = nil;
        self.InternTributeQuest.Objectives[1].Data[3] = nil;
        self.InternTributeQuest.Objectives[1].Data[4] = nil;
        self.InternTributeQuest.Objectives[1].Data[5] = nil;
        self.InternTributeQuest.Result = nil;
        self.InternTributeQuest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");
        StartSimpleJobEx(_G[QuestTemplate.Loop], self.InternTributeQuest.QueueID);
        self.RestartQuest = nil;
    end
end

function B_Goal_TributeDiplomacy:CustomFunction(_Quest)
    -- Tribut Quest erzeugen
    self:GetTributeQuest(_Quest);
    -- Status des Tributes prüfen.
    if self:CheckTributeQuest(_Quest) == false then
        return false;
    end
    -- Status des fordernden Spielers prüfen.
    if self:CheckTributePlayer(_Quest) == true then
        return true;
    end
    -- Quest neu starten, falls nötig.
    self:TributQuestRestarter(_Quest);
end

function B_Goal_TributeDiplomacy:Debug(_Quest)
    if self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Amount is negative!");
        return true;
    end
    if self.PeriodLength < self.TributTime then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": TributTime too long!");
        return true;
    end
end

function B_Goal_TributeDiplomacy:Reset(_Quest)
    self.Time = nil;
    self.InternTributeQuest = nil;
    self.RestartQuest = nil;
end

function B_Goal_TributeDiplomacy:Interrupt(_Quest)
    if self.InternTributeQuest ~= nil then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
    end
end

function B_Goal_TributeDiplomacy:GetCustomData(_Index)
    if (_Index == 6) then
        return {"true", "false"};
    end
end

RegisterBehavior(B_Goal_TributeDiplomacy);

-- -------------------------------------------------------------------------- --

function Goal_TributeClaim(...)
    return B_Goal_TributeClaim:new(...);
end

B_Goal_TributeClaim = {
    Name = "Goal_TributeClaim",
    Description = {
        en = "Goal: AI requests periodical tribute for a specified territory. The quest sender is the demanding player.",
        de = "Ziel: Die KI fordert einen regelmässigen Tribut fuer ein Territorium. Der Questgeber ist der fordernde Spieler.",
        fr = "Objectif: L'IA demande un tribut régulier pour un territoire. Le donneur de quête est le joueur qui exige.",
    },
    Parameter = {
        { ParameterType.TerritoryName, en = "Territory", de = "Territorium", fr = "Territoire", },
        { ParameterType.PlayerID, en = "PlayerID", de = "PlayerID", fr = "PlayerID", },
        { ParameterType.Custom, en = "Good Type", de = "Warentyp", fr = "Type de biens", },
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité", },
        { ParameterType.Number, en = "Length of Period in seconds", de = "Sekunden bis zur nächsten Forderung", fr = "secondes jusqu'à la prochaine demande", },
        { ParameterType.Number, en = "Time to pay Tribut in seconds", de = "Zeit bis zur Zahlung in Sekunden", fr = "Délai avant paiement en secondes", },
        { ParameterType.Default, en = "Start Message for TributQuest", de = "Startnachricht der Tributquest", fr = "Message de début de quête de tribut", },
        { ParameterType.Default, en = "Success Message for TributQuest", de = "Erfolgsnachricht der Tributquest", fr = "Message de réussite de la quête de tribut", },
        { ParameterType.Default, en = "Failure Message for TributQuest", de = "Niederlagenachricht der Tributquest", fr = "Message de défaite de la quête de tribut", },
        { ParameterType.Number, en = "How often to pay (0 = forerver)", de = "Anzahl der Tributquests (0 = unendlich)", fr = "Nombre de quêtes de tribut (0 = infini)", },
        { ParameterType.Custom, en = "Other Owner cancels the Quest", de = "Anderer Spieler kann Quest beenden", fr = "Un autre joueur peut terminer une quête", },
        { ParameterType.Custom, en = "About if a rate is not payed", de = "Nicht-bezahlen beendet die Quest", fr = "Ne pas payer met fin à la quête", },
    },
}

function B_Goal_TributeClaim:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} };
end

function B_Goal_TributeClaim:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        if type(_Parameter) == "string" then
            _Parameter = GetTerritoryIDByName(_Parameter);
        end
        self.TerritoryID = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        self.GoodType = Goods[_Parameter or "G_Gold"];
    elseif (_Index == 3) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 4) then
        self.PeriodLength = _Parameter * 1;
    elseif (_Index == 5) then
        self.TributTime = _Parameter * 1;
    elseif (_Index == 6) then
        self.StartMsg = _Parameter;
    elseif (_Index == 7) then
        self.SuccessMsg = _Parameter;
    elseif (_Index == 8) then
        self.FailureMsg = _Parameter;
    elseif (_Index == 9) then
        self.HowOften = _Parameter * 1;
    elseif (_Index == 10) then
        self.OtherOwnerCancels = ToBoolean(_Parameter);
    elseif (_Index == 11) then
        self.DontPayCancels = ToBoolean(_Parameter);
    end
end

function B_Goal_TributeClaim:CureOutpost(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if IsExisting(Outpost) and GetHealth(Outpost) < 25 and Logic.IsBuildingBeingKnockedDown(Outpost) == false then
        while (Logic.GetEntityHealth(Outpost) < Logic.GetEntityMaxHealth(Outpost) * 0.6) do
            Logic.HealEntity(Outpost, 1);
        end
    end
end

function B_Goal_TributeClaim:RestartTributeQuest(_Quest)
    if self.InternTributeQuest then
        self.InternTributeQuest.Objectives[1].Completed = nil;
        self.InternTributeQuest.Objectives[1].Data[3] = nil;
        self.InternTributeQuest.Objectives[1].Data[4] = nil;
        self.InternTributeQuest.Objectives[1].Data[5] = nil;
        self.InternTributeQuest.Result = nil;
        self.InternTributeQuest.State = QuestState.NotTriggered;
        Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")");
        StartSimpleJobEx(_G[QuestTemplate.Loop], self.InternTributeQuest.QueueID);
    end
end

function B_Goal_TributeClaim:CreateTributeQuest(_Quest)
    if not self.InternTributeQuest then
        local Language = CONST_LANGUAGE;
        local StartMsg = self.StartMsg;
        if type(StartMsg) == "table" then
            StartMsg = StartMsg[Language];
        end
        local SuccessMsg = self.SuccessMsg;
        if type(SuccessMsg) == "table" then
            SuccessMsg = SuccessMsg[Language];
        end
        local FailureMsg = self.FailureMsg;
        if type(FailureMsg) == "table" then
            FailureMsg = FailureMsg[Language];
        end

        Lib.Core.Quest.QuestCounter = Lib.Core.Quest.QuestCounter+1;

        local OnFinished = function()
            self.Time = Logic.GetTime();
        end
        local QuestID, Quest = QuestTemplate:New(
            _Quest.Identifier.."_TributeClaimQuest" ..Lib.Core.Quest.QuestCounter,
            self.PlayerID,
            _Quest.ReceivingPlayer,
            {{ Objective.Deliver, {self.GoodType, self.Amount}}},
            {{ Triggers.Time, 0 }},
            self.TributTime, nil, nil, OnFinished, nil, true, true, nil,
            StartMsg,
            SuccessMsg,
            FailureMsg
        );
        self.InternTributeQuest = Quest;
    end
end

function B_Goal_TributeClaim:OnTributeFailed(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if IsExisting(Outpost) then
        Logic.ChangeEntityPlayerID(Outpost, self.PlayerID);
    end
    Logic.SetTerritoryPlayerID(self.TerritoryID, self.PlayerID);
    self.InternTributeQuest.State = false;
    self.Time = nil;

    if self.DontPayCancels then
        _Quest:Interrupt();
    end
end

function B_Goal_TributeClaim:OnTributePaid(_Quest)
    local Outpost = Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID);
    if self.InternTributeQuest.Result == QuestResult.Success then
        if Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then
            if IsExisting(Outpost) then
                Logic.ChangeEntityPlayerID(Outpost, _Quest.ReceivingPlayer);
            end
            Logic.SetTerritoryPlayerID(self.TerritoryID, _Quest.ReceivingPlayer);
        end
    end
    if self.Time and Logic.GetTime() >= self.Time + self.PeriodLength then
        if self.HowOften and self.HowOften ~= 0 then
            self.TributeCounter = (self.TributeCounter or 0) +1;
            if self.TributeCounter >= self.HowOften then
                return false;
            end
        end
        self:RestartTributeQuest();
        self.Time = nil;
    end
end

function B_Goal_TributeClaim:CustomFunction(_Quest)
    self:CreateTributeQuest(_Quest);
    self:CureOutpost(_Quest);

    if Logic.GetTerritoryPlayerID(self.TerritoryID) == _Quest.ReceivingPlayer
    or Logic.GetTerritoryPlayerID(self.TerritoryID) == self.PlayerID then
        if self.OtherOwner then
            self:RestartTributeQuest();
            self.OtherOwner = nil;
        end

        -- Quest abgeschlossen
        if self.InternTributeQuest.State == QuestState.Over then
            if self.InternTributeQuest.Result == QuestResult.Failure then
                self:OnTributeFailed(_Quest);
            else
                self:OnTributePaid(_Quest);
            end

        elseif self.InternTributeQuest.State == false then
            if self.Time and Logic.GetTime() >= self.Time + self.PeriodLength then
                self:RestartTributeQuest(_Quest);
            end
        end

    -- Keiner besitzt das Territorium -> Abbruch
    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) == 0 and self.InternTributeQuest then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end

    -- Anderer Besitzer -> Abbruch
    elseif Logic.GetTerritoryPlayerID(self.TerritoryID) ~= self.PlayerID then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        if self.OtherOwnerCancels then
            _Quest:Interrupt();
        end
        self.OtherOwner = true;
    end

    --Fordernder Spieler existiert nicht -> Abbruch
    local storeHouse = Logic.GetStoreHouse(self.PlayerID);
    if (storeHouse == 0 or Logic.IsEntityDestroyed(storeHouse)) then
        if self.InternTributeQuest and self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
        return true;
    end
end

function B_Goal_TributeClaim:Debug(_Quest)
    if self.TerritoryID == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Unknown Territory");
        return true;
    end
    if not self.Quest and Logic.GetStoreHouse(self.PlayerID) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(");
        return true;
    end
    if self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Amount is negative");
        return true;
    end
    if self.PeriodLength < self.TributTime or self.PeriodLength < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Period Length is wrong");
        return true;
    end
    if self.HowOften < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": HowOften is negative");
        return true;
    end
end

function B_Goal_TributeClaim:Reset(_Quest)
    self.InternTributeQuest = nil;
    self.Time = nil;
    self.OtherOwner = nil;
end

function B_Goal_TributeClaim:Interrupt(_Quest)
    if type(self.InternTributeQuest) == "table" then
        if self.InternTributeQuest.State == QuestState.Active then
            self.InternTributeQuest:Interrupt();
        end
    end
end

function B_Goal_TributeClaim:GetCustomData(_Index)
    if _Index == 2 then
        local Data = {};
        for k, v in pairs(Goods) do
            if string.find(k, "^G_") then
                table.insert(Data, k);
            end
        end
        table.sort(Data);
        return Data;
    elseif (_Index == 10) or (_Index == 11) then
        return {"false", "true"};
    end
end

RegisterBehavior(B_Goal_TributeClaim);

-- -------------------------------------------------------------------------- --

function Reprisal_ObjectDeactivate(...)
    return B_Reprisal_InteractiveObjectDeactivate:new(...);
end

B_Reprisal_InteractiveObjectDeactivate = {
    Name = "Reprisal_InteractiveObjectDeactivate",
    Description = {
        en = "Reprisal: Deactivates an interactive object",
        de = "Vergeltung: Deaktiviert ein interaktives Objekt",
        fr = "Rétribution: désactive un objet interactif",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object", de = "Interaktives Objekt", fr = "Object interactif" },
    },
}

function B_Reprisal_InteractiveObjectDeactivate:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_InteractiveObjectDeactivate:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.ScriptName = _Parameter
    end

end

function B_Reprisal_InteractiveObjectDeactivate:CustomFunction(_Quest)
    InteractiveObjectDeactivate(self.ScriptName);
end

function B_Reprisal_InteractiveObjectDeactivate:Debug(_Quest)
    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");
        self.WarningPrinted = true;
    end
    local eID = GetID(self.ScriptName);
    if CONST_INITIALIZED_OBJECTS[eID] and CONST_INITIALIZED_OBJECTS[eID] == _Quest.Identifier then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": you can not deactivate in the same quest the object is initalized!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_InteractiveObjectDeactivate);

-- -------------------------------------------------------------------------- --

function Reprisal_ObjectActivate(...)
    return B_Reprisal_InteractiveObjectActivate:new(...);
end

B_Reprisal_InteractiveObjectActivate = {
    Name = "Reprisal_InteractiveObjectActivate",
    Description = {
        en = "Reprisal: Activates an interactive object",
        de = "Vergeltung: Aktiviert ein interaktives Objekt",
        fr = "Retribution : active un objet interactif",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object",  de = "Interaktives Objekt", fr = "Object interactif" },
        { ParameterType.Custom,     en = "Availability",        de = "Nutzbarkeit",         fr = "Utilisabilité" },
    },
}

function B_Reprisal_InteractiveObjectActivate:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_InteractiveObjectActivate:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        local parameter = 0
        if _Parameter == "Always" or 1 then
            parameter = 1
        end
        self.UsingState = parameter * 1
    end
end

function B_Reprisal_InteractiveObjectActivate:CustomFunction(_Quest)
    InteractiveObjectActivate(self.ScriptName, self.UsingState);
end

function B_Reprisal_InteractiveObjectActivate:GetCustomData( _Index )
    if _Index == 1 then
        return {"Knight only", "Always"}
    end
end

function B_Reprisal_InteractiveObjectActivate:Debug(_Quest)
    if not Logic.IsInteractiveObject(GetID(self.ScriptName)) then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' is not a interactive object!");
        self.WarningPrinted = true;
    end
    local eID = GetID(self.ScriptName);
    if CONST_INITIALIZED_OBJECTS[eID] and CONST_INITIALIZED_OBJECTS[eID] == _Quest.Identifier then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": you can not activate in the same quest the object is initalized!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_InteractiveObjectActivate);

-- -------------------------------------------------------------------------- --

function Reprisal_DiplomacyDecrease()
    return B_Reprisal_SlightlyDiplomacyDecrease:new();
end

B_Reprisal_SlightlyDiplomacyDecrease = {
    Name = "Reprisal_SlightlyDiplomacyDecrease",
    Description = {
        en = "Reprisal: Diplomacy decreases slightly to another player.",
        de = "Vergeltung: Der Diplomatiestatus zum Auftraggeber wird um eine Stufe verringert.",
        fr = "Rétribution: le statut diplomatique avec le mandant est réduit d'un niveau.",
    },
}

function B_Reprisal_SlightlyDiplomacyDecrease:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_SlightlyDiplomacyDecrease:CustomFunction(_Quest)
    local Sender = _Quest.SendingPlayer;
    local Receiver = _Quest.ReceivingPlayer;
    local State = GetDiplomacyState(Receiver, Sender);
    if State > -2 then
        SetDiplomacyState(Receiver, Sender, State-1);
    end
end

function B_Reprisal_SlightlyDiplomacyDecrease:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

RegisterBehavior(B_Reprisal_SlightlyDiplomacyDecrease);

-- -------------------------------------------------------------------------- --

function Reprisal_Diplomacy(...)
    return B_Reprisal_Diplomacy:new(...);
end

B_Reprisal_Diplomacy = {
    Name = "Reprisal_Diplomacy",
    Description = {
        en = "Reprisal: Sets Diplomacy state of two Players to a stated value.",
        de = "Vergeltung: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.",
        fr = "Rétribution: Définit le statut diplomatique de deux joueurs sur la valeur indiquée.",
    },
    Parameter = {
        { ParameterType.PlayerID,         en = "PlayerID 1", de = "Spieler 1", fr = "Joueur 1" },
        { ParameterType.PlayerID,         en = "PlayerID 2", de = "Spieler 2", fr = "Joueur 2" },
        { ParameterType.DiplomacyState,   en = "Relation",   de = "Beziehung", fr = "Relation diplomatique" },
    },
}

function B_Reprisal_Diplomacy:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_Diplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID1 = _Parameter * 1
    elseif (_Index == 1) then
        self.PlayerID2 = _Parameter * 1
    elseif (_Index == 2) then
        self.Relation = DiplomacyStates[_Parameter]
    end
end

function B_Reprisal_Diplomacy:CustomFunction(_Quest)
    SetDiplomacyState(self.PlayerID1, self.PlayerID2, self.Relation);
end

function B_Reprisal_Diplomacy:Debug(_Quest)
    if not tonumber(self.PlayerID1) or self.PlayerID1 < 1 or self.PlayerID1 > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": PlayerID 1 is invalid!");
        return true;
    elseif not tonumber(self.PlayerID2) or self.PlayerID2 < 1 or self.PlayerID2 > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": PlayerID 2 is invalid!");
        return true;
    elseif not tonumber(self.Relation) or self.Relation < -2 or self.Relation > 2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": '"..self.Relation.."' is a invalid diplomacy state!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_Diplomacy);

-- -------------------------------------------------------------------------- --

function Reprisal_DestroyEntity(...)
    return B_Reprisal_DestroyEntity:new(...);
end

B_Reprisal_DestroyEntity = {
    Name = "Reprisal_DestroyEntity",
    Description = {
        en = "Reprisal: Replaces an entity with an invisible script entity, which retains the entities name.",
        de = "Vergeltung: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.",
        fr = "Rétribution: remplace une entité par une entité de script invisible qui prend son nom.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity", de = "Entity", fr = "Entité" },
    },
}

function B_Reprisal_DestroyEntity:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_DestroyEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Reprisal_DestroyEntity:CustomFunction(_Quest)
    ReplaceEntity(self.ScriptName, Entities.XD_ScriptEntity);
end

function B_Reprisal_DestroyEntity:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        warn(false, _Quest.Identifier .. ": " ..self.Name..": '" ..self.ScriptName.. "' is already destroyed!");
        self.WarningPrinted = true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_DestroyEntity);

-- -------------------------------------------------------------------------- --

function Reprisal_DestroyEffect(...)
    return B_Reprisal_DestroyEffect:new(...);
end

B_Reprisal_DestroyEffect = {
    Name = "Reprisal_DestroyEffect",
    Description = {
        en = "Reprisal: Destroys an effect",
        de = "Vergeltung: Zerstört einen Effekt",
        fr = "Rétribution: détruit un effet",
    },
    Parameter = {
        { ParameterType.Default, en = "Effect name", de = "Effektname", fr = "Nom de l'effet" },
    }
}

function B_Reprisal_DestroyEffect:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.EffectName = _Parameter;
    end
end

function B_Reprisal_DestroyEffect:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } };
end

function B_Reprisal_DestroyEffect:CustomFunction(_Quest)
    if not CONST_EFFECT_NAME_TO_ID[self.EffectName] or not Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName]) then
        return;
    end
    Logic.DestroyEffect(CONST_EFFECT_NAME_TO_ID[self.EffectName]);
end

function B_Reprisal_DestroyEffect:Debug(_Quest)
    if not CONST_EFFECT_NAME_TO_ID[self.EffectName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Effect " .. self.EffectName .. " never created")
    end
    return false;
end

RegisterBehavior(B_Reprisal_DestroyEffect);

-- -------------------------------------------------------------------------- --

function Reprisal_Defeat()
    return B_Reprisal_Defeat:new()
end

B_Reprisal_Defeat = {
    Name = "Reprisal_Defeat",
    Description = {
        en = "Reprisal: The player loses the game.",
        de = "Vergeltung: Der Spieler verliert das Spiel.",
        fr = "Rétribution: le joueur perd la partie.",
    },
}

function B_Reprisal_Defeat:GetReprisalTable()
    return {Reprisal.Defeat};
end

RegisterBehavior(B_Reprisal_Defeat);

-- -------------------------------------------------------------------------- --

function Reprisal_FakeDefeat()
    return B_Reprisal_FakeDefeat:new();
end

B_Reprisal_FakeDefeat = {
    Name = "Reprisal_FakeDefeat",
    Description = {
        en = "Reprisal: Displays a defeat icon for a quest",
        de = "Vergeltung: Zeigt ein Niederlage Icon fuer eine Quest an",
        fr = "Rétribution: affiche une icône de défaite pour une quête",
    },
}

function B_Reprisal_FakeDefeat:GetReprisalTable()
    return { Reprisal.FakeDefeat }
end

RegisterBehavior(B_Reprisal_FakeDefeat);

-- -------------------------------------------------------------------------- --

function Reprisal_ReplaceEntity(...)
    return B_Reprisal_ReplaceEntity:new(...);
end

B_Reprisal_ReplaceEntity = {
    Name = "Reprisal_ReplaceEntity",
    Description = {
        en = "Reprisal: Replaces an entity with a new one of a different type. The playerID can be changed too.",
        de = "Vergeltung: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.",
        fr = "Rétribution: remplace une entité par une nouvelle entité d'un autre type. Il est également possible de changer l'appartenance d'un joueur.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target", de = "Ziel", fr = "Cible" },
        { ParameterType.Custom, en = "New Type", de = "Neuer Typ", fr = "Nouveau type" },
        { ParameterType.Custom, en = "New playerID", de = "Neue Spieler ID", fr = "Nouvelle ID de joueur" },
    },
}

function B_Reprisal_ReplaceEntity:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_ReplaceEntity:AddParameter(_Index, _Parameter)
   if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.NewType = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = tonumber(_Parameter);
    end
end

function B_Reprisal_ReplaceEntity:CustomFunction(_Quest)
    local eID = GetID(self.ScriptName);
    local pID = self.PlayerID;
    if pID == Logic.EntityGetPlayer(eID) then
        pID = nil;
    end
    ReplaceEntity(self.ScriptName, Entities[self.NewType], pID);
end

function B_Reprisal_ReplaceEntity:GetCustomData(_Index)
    local Data = {}
    if _Index == 1 then
        for k, v in pairs( Entities ) do
            local name = {"^M_","^XS_","^X_","^XT_","^Z_", "^XB_"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )
    elseif _Index == 2 then
        Data = {"-","0","1","2","3","4","5","6","7","8",}
    end
    return Data
end

function B_Reprisal_ReplaceEntity:Debug(_Quest)
    if not Entities[self.NewType] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid entity type!");
        return true;
    elseif self.PlayerID ~= nil and (self.PlayerID < 1 or self.PlayerID > 8) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end

    if not IsExisting(self.ScriptName) then
        self.WarningPrinted = true;
        warn(false, _Quest.Identifier.. ": " ..self.Name..": '" ..self.ScriptName.. "' does not exist!");
    end
    return false;
end

RegisterBehavior(B_Reprisal_ReplaceEntity);

-- -------------------------------------------------------------------------- --

function Reprisal_QuestRestart(...)
    return B_Reprisal_QuestRestart:new(...)
end

B_Reprisal_QuestRestart = {
    Name = "Reprisal_QuestRestart",
    Description = {
        en = "Reprisal: Restarts a (completed) quest so it can be triggered and completed again",
        de = "Vergeltung: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann",
        fr = "Rétribution : relance une quête (terminée) pour qu'elle puisse être redéclenchée et terminée à nouveau",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestRestart:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestRestart:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestRestart:CustomFunction(_Quest)
    RestartQuest(self.QuestName, true);
end

function B_Reprisal_QuestRestart:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestRestart);

-- -------------------------------------------------------------------------- --

function Reprisal_QuestFailure(...)
    return B_Reprisal_QuestFailure:new(...)
end

B_Reprisal_QuestFailure = {
    Name = "Reprisal_QuestFailure",
    Description = {
        en = "Reprisal: Lets another active quest fail",
        de = "Vergeltung: Lässt eine andere aktive Quest fehlschlagen",
        fr = "Rétribution: fait échouer une autre quête active",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestFailure:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestFailure:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestFailure:CustomFunction(_Quest)
    FailQuest(self.QuestName, true);
end

function B_Reprisal_QuestFailure:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid quest!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestFailure);

-- -------------------------------------------------------------------------- --

function Reprisal_QuestSuccess(...)
    return B_Reprisal_QuestSuccess:new(...)
end

B_Reprisal_QuestSuccess = {
    Name = "Reprisal_QuestSuccess",
    Description = {
        en = "Reprisal: Completes another active quest successfully",
        de = "Vergeltung: Beendet eine andere aktive Quest erfolgreich",
        fr = "Rétribution: Réussir une autre quête active",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestSuccess:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestSuccess:CustomFunction(_Quest)
    WinQuest(self.QuestName, true);
end

function B_Reprisal_QuestSuccess:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestSuccess);

-- -------------------------------------------------------------------------- --

function Reprisal_QuestActivate(...)
    return B_Reprisal_QuestActivate:new(...)
end

B_Reprisal_QuestActivate = {
    Name = "Reprisal_QuestActivate",
    Description = {
        en = "Reprisal: Activates another quest that is not triggered yet.",
        de = "Vergeltung: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.",
        fr = "Rétribution: Active une autre quête qui n'a pas encore été déclenchée.",
    },
    Parameter = {
        {ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête", },
    },
}

function B_Reprisal_QuestActivate:GetReprisalTable()
    return {Reprisal.Custom, {self, self.CustomFunction} }
end

function B_Reprisal_QuestActivate:AddParameter(_Index, _Parameter)
    if (_Index==0) then
        self.QuestName = _Parameter
    else
        assert(false, "Error in " .. self.Name .. ": AddParameter: Index is invalid")
    end
end

function B_Reprisal_QuestActivate:CustomFunction(_Quest)
    StartQuest(self.QuestName, true);
end

function B_Reprisal_QuestActivate:Debug(_Quest)
    if not IsValidQuest(self.QuestName) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Quest: "..  self.QuestName .. " does not exist");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestActivate)

-- -------------------------------------------------------------------------- --

function Reprisal_QuestInterrupt(...)
    return B_Reprisal_QuestInterrupt:new(...)
end

B_Reprisal_QuestInterrupt = {
    Name = "Reprisal_QuestInterrupt",
    Description = {
        en = "Reprisal: Interrupts another active quest without success or failure",
        de = "Vergeltung: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg",
        fr = "Rétribution : termine une autre quête active sans succès ni échec",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
    },
}

function B_Reprisal_QuestInterrupt:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_QuestInterrupt:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Reprisal_QuestInterrupt:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then

        local QuestID = GetQuestID(self.QuestName)
        local Quest = Quests[QuestID]
        if Quest.State == QuestState.Active then
            StopQuest(self.QuestName, true);
        end
    end
end

function B_Reprisal_QuestInterrupt:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestInterrupt);

-- -------------------------------------------------------------------------- --

function Reprisal_QuestForceInterrupt(...)
    return B_Reprisal_QuestForceInterrupt:new(...)
end

B_Reprisal_QuestForceInterrupt = {
    Name = "Reprisal_QuestForceInterrupt",
    Description = {
        en = "Reprisal: Interrupts another quest (even when it isn't active yet) without success or failure",
        de = "Vergeltung: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg",
        fr = "Rétribution: Termine une autre quête, même si elle n'est pas encore active, sans succès ni échec.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la Quête" },
        { ParameterType.Custom, en = "Ended quests", de = "Beendete Quests", fr = "Quêtes terminées" },
    },
}

function B_Reprisal_QuestForceInterrupt:GetReprisalTable()

    return { Reprisal.Custom,{self, self.CustomFunction} }

end

function B_Reprisal_QuestForceInterrupt:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.InterruptEnded = ToBoolean(_Parameter)
    end

end

function B_Reprisal_QuestForceInterrupt:GetCustomData( _Index )
    local Data = {}
    if _Index == 1 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reprisal_QuestForceInterrupt:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then

        local QuestID = GetQuestID(self.QuestName)
        local Quest = Quests[QuestID]
        if self.InterruptEnded or Quest.State ~= QuestState.Over then
            Quest:Interrupt();
        end
    end
end

function B_Reprisal_QuestForceInterrupt:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": quest "..  self.QuestName .. " does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_QuestForceInterrupt);

-- -------------------------------------------------------------------------- --

function Reprisal_CustomVariables(...)
    return B_Reprisal_CustomVariables:new(...);
end

B_Reprisal_CustomVariables = {
    Name = "Reprisal_CustomVariables",
    Description = {
        en = "Reprisal: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.",
        de = "Vergeltung: Führt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.",
        fr = "Rétribution: effectue une opération mathématique sur la variable. L'autre opérateur peut être un nombre ou une variable personnalisée.",
    },
    Parameter = {
        { ParameterType.Default, en = "Name of variable", de = "Variablenname", fr = "Nom de la variable" },
        { ParameterType.Custom,  en = "Operator", de = "Operator", fr = "Operateur" },
        { ParameterType.Default,  en = "Value or variable", de = "Wert oder Variable", fr = "Valeur ou variable" }
    }
};

function B_Reprisal_CustomVariables:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} };
end

function B_Reprisal_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Operator = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        self.Value = (value == nil and tostring(_Parameter)) or value;
    end
end

function B_Reprisal_CustomVariables:CustomFunction()
    local Value1 = ObtainCustomVariable("BehaviorVariable_" ..self.VariableName, 0);
    local Value2 = self.Value;
    if type(self.Value) == "string" then
        Value2 = ObtainCustomVariable("BehaviorVariable_" ..self.Value, 0);
    end

    if self.Operator == "=" then
        Value1 = Value2;
    elseif self.Operator == "+" then
        Value1 = Value1 + Value2;
    elseif self.Operator == "-" then
        Value1 = Value1 - Value2;
    elseif self.Operator == "*" then
        Value1 = Value1 * Value2;
    elseif self.Operator == "/" then
        Value1 = Value1 / Value2;
    elseif self.Operator == "^" then
        Value1 = Value1 % Value2;
    end
    SaveCustomVariable("BehaviorVariable_"..self.VariableName, Value1);
end

function B_Reprisal_CustomVariables:GetCustomData( _Index )
    return {"=", "+", "-", "*", "/", "^"};
end

function B_Reprisal_CustomVariables:Debug(_Quest)
    local operators = {"=", "+", "-", "*", "/", "^"};
    if not table.contains(operators, self.Operator) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid operator!");
        return true;
    elseif self.VariableName == "" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": missing name for variable!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_CustomVariables)

-- -------------------------------------------------------------------------- --

function Reprisal_MapScriptFunction(...)
    return B_Reprisal_MapScriptFunction:new(...);
end

B_Reprisal_MapScriptFunction = {
    Name = "Reprisal_MapScriptFunction",
    Description = {
        en = "Reprisal: Calls a function within the global map script if the quest has failed.",
        de = "Vergeltung: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.",
        fr = "Rétribution: lance une fonction dans le script global de la carte en cas d'échec de la quête.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname", fr = "Nom de la fonction" },
    },
}

function B_Reprisal_MapScriptFunction:GetReprisalTable()
    return {Reprisal.Custom, {self, self.CustomFunction}};
end

function B_Reprisal_MapScriptFunction:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.FuncName = _Parameter;
    end
end

function B_Reprisal_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        self.FuncName(unpack(self.i47ya_6aghw_frxil));
        return;
    end
    _G[self.FuncName](self, _Quest);
end

function B_Reprisal_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_MapScriptFunction);

-- -------------------------------------------------------------------------- --

function Reprisal_Technology(...)
    return B_Reprisal_Technology:new(...);
end

B_Reprisal_Technology = {
    Name = "Reprisal_Technology",
    Description = {
        en = "Reprisal: Locks or unlocks a technology for the given player",
        de = "Vergeltung: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player",
        fr = "Rétribution: bloque ou autorise une technologie pour le joueur spécifié",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "PlayerID", de = "SpielerID", fr = "PlayerID" },
        { ParameterType.Custom,   en = "Un / Lock", de = "Sperren/Erlauben", fr = "Bloquer/Autoriser" },
        { ParameterType.Custom,   en = "Technology", de = "Technologie"; fr = "Technologie" },
    },
}

function B_Reprisal_Technology:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} }
end

function B_Reprisal_Technology:AddParameter(_Index, _Parameter)
    if (_Index ==0) then
        self.PlayerID = _Parameter*1
    elseif (_Index == 1) then
        self.LockType = _Parameter == "Lock"
    elseif (_Index == 2) then
        self.Technology = _Parameter
    end
end

function B_Reprisal_Technology:CustomFunction(_Quest)
    if self.PlayerID
    and Logic.GetStoreHouse(self.PlayerID) ~= 0
    and Technologies[self.Technology]
    then
        if self.LockType  then
            LockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        else
            UnLockFeaturesForPlayer(self.PlayerID, Technologies[self.Technology])
        end
    else
        return false
    end
end

function B_Reprisal_Technology:GetCustomData(_Index)
    local Data = {}
    if (_Index == 1) then
        Data[1] = "Lock"
        Data[2] = "UnLock"
    elseif (_Index == 2) then
        for k, v in pairs( Technologies ) do
            table.insert( Data, k )
        end
    end
    return Data
end

function B_Reprisal_Technology:Debug(_Quest)
    if not Technologies[self.Technology] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid technology type!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": got an invalid playerID!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_Technology);

-- -------------------------------------------------------------------------- --

function Reward_ObjectDeactivate(...)
    return B_Reward_InteractiveObjectDeactivate:new(...);
end

B_Reward_InteractiveObjectDeactivate = CopyTable(B_Reprisal_InteractiveObjectDeactivate);
B_Reward_InteractiveObjectDeactivate.Name             = "Reward_InteractiveObjectDeactivate";
B_Reward_InteractiveObjectDeactivate.Description.en   = "Reward: Deactivates an interactive object";
B_Reward_InteractiveObjectDeactivate.Description.de   = "Lohn: Deaktiviert ein interaktives Objekt";
B_Reward_InteractiveObjectDeactivate.Description.fr   = "Récompense: Désactive un objet interactif";
B_Reward_InteractiveObjectDeactivate.GetReprisalTable = nil;

B_Reward_InteractiveObjectDeactivate.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_InteractiveObjectDeactivate);

-- -------------------------------------------------------------------------- --

function Reward_ObjectActivate(...)
    return B_Reward_InteractiveObjectActivate:new(...);
end

B_Reward_InteractiveObjectActivate = CopyTable(B_Reprisal_InteractiveObjectActivate);
B_Reward_InteractiveObjectActivate.Name             = "Reward_InteractiveObjectActivate";
B_Reward_InteractiveObjectActivate.Description.en   = "Reward: Activates an interactive object";
B_Reward_InteractiveObjectActivate.Description.de   = "Lohn: Aktiviert ein interaktives Objekt";
B_Reward_InteractiveObjectActivate.Description.fr   = "Récompense: Active un objet interactif";
B_Reward_InteractiveObjectActivate.GetReprisalTable = nil;

B_Reward_InteractiveObjectActivate.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} };
end

RegisterBehavior(B_Reward_InteractiveObjectActivate);

-- -------------------------------------------------------------------------- --

function Reward_ObjectInit(...)
    return B_Reward_ObjectInit:new(...);
end

B_Reward_ObjectInit = {
    Name = "Reward_ObjectInit",
    Description = {
        en = "Reward: Setup an interactive object with costs and rewards.",
        de = "Lohn: Initialisiert ein interaktives Objekt mit seinen Kosten und Schätzen.",
        fr = "Récompense: Initialise un objet interactif avec ses coûts et ses trésors.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Interactive object", de = "Interaktives Objekt",  fr = "Obejct interactif" },
        { ParameterType.Number,     en = "Distance to use",    de = "Nutzungsentfernung",   fr = "Distance d'utilisation" },
        { ParameterType.Number,     en = "Waittime",           de = "Wartezeit",            fr = "Temps d'attente" },
        { ParameterType.Custom,     en = "Reward good",        de = "Belohnungsware",       fr = "Produits de récompense" },
        { ParameterType.Number,     en = "Reward amount",      de = "Anzahl",               fr = "Quantité" },
        { ParameterType.Custom,     en = "Cost good 1",        de = "Kostenware 1",         fr = "Marchandise de coût 1" },
        { ParameterType.Number,     en = "Cost amount 1",      de = "Anzahl 1",             fr = "Quantité 1" },
        { ParameterType.Custom,     en = "Cost good 2",        de = "Kostenware 2",         fr = "Marchandise de coût 2" },
        { ParameterType.Number,     en = "Cost amount 2",      de = "Anzahl 2",             fr = "Quantité 2" },
        { ParameterType.Custom,     en = "Availability",       de = "Verfügbarkeit",        fr = "Disponibilité" },
    },
}

function B_Reward_ObjectInit:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_ObjectInit:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.Distance = _Parameter * 1
    elseif (_Index == 2) then
        self.Waittime = _Parameter * 1
    elseif (_Index == 3) then
        self.RewardType = _Parameter
    elseif (_Index == 4) then
        self.RewardAmount = _Parameter * 1
    elseif (_Index == 5) then
        self.FirstCostType = _Parameter
    elseif (_Index == 6) then
        self.FirstCostAmount = _Parameter * 1
    elseif (_Index == 7) then
        self.SecondCostType = _Parameter
    elseif (_Index == 8) then
        self.SecondCostAmount = _Parameter * 1
    elseif (_Index == 9) then
        local parameter = nil
        if _Parameter == "Always" or _Parameter == 1 then
            parameter = 1
        elseif _Parameter == "Never" or _Parameter == 2 then
            parameter = 2
        elseif _Parameter == "Knight only" or _Parameter == 0 then
            parameter = 0
        end
        self.UsingState = parameter
    end
end

function B_Reward_ObjectInit:CustomFunction(_Quest)
    local eID = GetID(self.ScriptName);
    if eID == 0 then
        return;
    end
    CONST_INITIALIZED_OBJECTS[eID] = _Quest.Identifier;

    Logic.InteractiveObjectClearCosts(eID);
    Logic.InteractiveObjectClearRewards(eID);

    Logic.InteractiveObjectSetInteractionDistance(eID, self.Distance);
    Logic.InteractiveObjectSetTimeToOpen(eID, self.Waittime);

    if self.RewardType and self.RewardType ~= "-" then
        Logic.InteractiveObjectAddRewards(eID, Goods[self.RewardType], self.RewardAmount);
    end
    if self.FirstCostType and self.FirstCostType ~= "-" then
        Logic.InteractiveObjectAddCosts(eID, Goods[self.FirstCostType], self.FirstCostAmount);
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        Logic.InteractiveObjectAddCosts(eID, Goods[self.SecondCostType], self.SecondCostAmount);
    end

    Logic.InteractiveObjectSetAvailability(eID,true);
    if self.UsingState then
        for i=1, 8 do
            Logic.InteractiveObjectSetPlayerState(eID,i, self.UsingState);
        end
    end

    Logic.InteractiveObjectSetRewardResourceCartType(eID,Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetRewardGoldCartType(eID,Entities.U_GoldCart);
    Logic.InteractiveObjectSetCostResourceCartType(eID,Entities.U_ResourceMerchant);
    Logic.InteractiveObjectSetCostGoldCartType(eID, Entities.U_GoldCart);
    RemoveInteractiveObjectFromOpenedList(eID);
    table.insert(HiddenTreasures,eID);
end

function B_Reward_ObjectInit:GetCustomData( _Index )
    if _Index == 3 or _Index == 5 or _Index == 7 then
        local Data = {
            "-",
            "G_Beer",
            "G_Bread",
            "G_Broom",
            "G_Carcass",
            "G_Cheese",
            "G_Clothes",
            "G_Dye",
            "G_Gold",
            "G_Grain",
            "G_Herb",
            "G_Honeycomb",
            "G_Iron",
            "G_Leather",
            "G_Medicine",
            "G_Milk",
            "G_RawFish",
            "G_Salt",
            "G_Sausage",
            "G_SmokedFish",
            "G_Soap",
            "G_Stone",
            "G_Water",
            "G_Wood",
            "G_Wool",
        }

        if g_GameExtraNo >= 1 then
            Data[#Data+1] = "G_Gems"
            Data[#Data+1] = "G_MusicalInstrument"
            Data[#Data+1] = "G_Olibanum"
        end
        return Data
    elseif _Index == 9 then
        return {"-", "Knight only", "Always", "Never",}
    end
end

function B_Reward_ObjectInit:Debug(_Quest)
    if Logic.IsInteractiveObject(GetID(self.ScriptName)) == false then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.ScriptName.."' is not a interactive object!");
        return true;
    end
    if self.UsingState ~= 1 and self.Distance < 50 then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": distance is maybe too short!");
    end
    if self.Waittime < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waittime must be equal or greater than 0!");
        return true;
    end
    if self.RewardType and self.RewardType ~= "-" then
        if not Goods[self.RewardType] then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.RewardType.."' is invalid good type!");
            return true;
        elseif self.RewardAmount < 1 then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    if self.FirstCostType and self.FirstCostType ~= "-" then
        if not Goods[self.FirstCostType] then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.FirstCostType.."' is invalid good type!");
            return true;
        elseif self.FirstCostAmount < 1 then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        if not Goods[self.SecondCostType] then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.SecondCostType.."' is invalid good type!");
            return true;
        elseif self.SecondCostAmount < 1 then
            debug(false, _Quest.Identifier.. ": " ..self.Name..": amount can not be 0 or negative!");
            return true;
        end
    end
    return false;
end

RegisterBehavior(B_Reward_ObjectInit);

-- -------------------------------------------------------------------------- --

function Reward_Diplomacy(...)
    return B_Reward_Diplomacy:new(...);
end

B_Reward_Diplomacy = CopyTable(B_Reprisal_Diplomacy);
B_Reward_Diplomacy.Name             = "Reward_Diplomacy";
B_Reward_Diplomacy.Description.en   = "Reward: Sets Diplomacy state of two Players to a stated value.";
B_Reward_Diplomacy.Description.de   = "Lohn: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.";
B_Reward_Diplomacy.Description.fr   = "Récompense: Définit le statut diplomatique de deux joueurs sur la valeur indiquée.";
B_Reward_Diplomacy.GetReprisalTable = nil;

B_Reward_Diplomacy.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_Diplomacy);

-- -------------------------------------------------------------------------- --

function Reward_DiplomacyIncrease()
    return B_Reward_SlightlyDiplomacyIncrease:new();
end

B_Reward_SlightlyDiplomacyIncrease = {
    Name = "Reward_SlightlyDiplomacyIncrease",
    Description = {
        en = "Reward: Diplomacy increases slightly to another player",
        de = "Lohn: Verbesserung des Diplomatiestatus zu einem anderen Spieler",
        fr = "Récompense: Amélioration du statut diplomatique avec un autre joueur",
    },
}

function B_Reward_SlightlyDiplomacyIncrease:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_SlightlyDiplomacyIncrease:CustomFunction(_Quest)
    local Sender = _Quest.SendingPlayer;
    local Receiver = _Quest.ReceivingPlayer;
    local State = GetDiplomacyState(Receiver, Sender);
    if State < 2 then
        SetDiplomacyState(Receiver, Sender, State+1);
    end
end

function B_Reward_SlightlyDiplomacyIncrease:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    end
end

RegisterBehavior(B_Reward_SlightlyDiplomacyIncrease);

-- -------------------------------------------------------------------------- --

function Reward_TradePost(...)
    return B_Reward_TradePost:new(...);
end

B_Reward_TradePost= {
    Name = "B_Reward_TradePost",
    Description = {
        en = "Sets options for a Tradepost and deactivates it.",
        de = "Stellt einen Handelsposten ein und deaktiviert ihn.",
        fr = "",
    },
    Parameter = {
        {ParameterType.ScriptName, en = "ScriptName", de = "ScriptName" },
        {ParameterType.PlayerID, en = "PlayerID", de = "PlayerID" },
        {ParameterType.Custom, en = "Type of good to pay 1", de = "Resourcentyp Bezahlung 1", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to get 1", de = "Resourcentyp Angebot 1", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource" },
        {ParameterType.Custom, en = "Type of good to pay 2", de = "Resourcentyp Bezahlung 2", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to get 2", de = "Resourcentyp Angebot 2", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to pay 3", de = "Resourcentyp Bezahlung 3", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to get 3", de = "Resourcentyp Angebot 3", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to pay 4", de = "Resourcentyp Bezahlung 4", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
        {ParameterType.Custom, en = "Type of good to get 4", de = "Resourcentyp Angebot 4", fr = ""},
        {ParameterType.Number, en = "Amount of good", de = "Anzahl der Resource", fr = ""},
    },
}

function B_Reward_TradePost:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction}};
end
function B_Reward_TradePost:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 3) then
        self.PayType1 = _Parameter;
    elseif (_Index == 4) then
        self.PayAmount1 = _Parameter * 1;
    elseif (_Index == 5) then
        self.OfferType1 = _Parameter;
    elseif (_Index == 6) then
        self.OfferAmount1 = _Parameter * 1;
    elseif (_Index == 7) then
        self.PayType2 = _Parameter;
    elseif (_Index == 8) then
        self.PayAmount2 = _Parameter * 1;
    elseif (_Index == 9) then
        self.OfferType2 = _Parameter;
    elseif (_Index == 10) then
        self.OfferAmount2 = _Parameter * 1;
    elseif (_Index == 11) then
        self.PayType3 = _Parameter;
    elseif (_Index == 12) then
        self.PayAmount3 = _Parameter * 1;
    elseif (_Index == 13) then
        self.OfferType3 = _Parameter;
    elseif (_Index == 14) then
        self.OfferAmount3 = _Parameter * 1;
    elseif (_Index == 15) then
        self.PayType4 = _Parameter;
    elseif (_Index == 16) then
        self.PayAmount4 = _Parameter * 1;
    elseif (_Index == 17) then
        self.OfferType4 = _Parameter;
    elseif (_Index == 18) then
        self.OfferAmount4 = _Parameter * 1;
    end
end

function B_Reward_TradePost:CustomFunction(_Quest)
    local OfferCount = 0;
    for i = 1, 4 do
        if self["PayAmount"..i] and self["PayAmount"..i] > 0 and self["OfferAmount"..i] and self["OfferAmount"..i] > 0 then
            OfferCount = i;
        else
            break;
        end
    end
    debug(IsExisting(self.ScriptName), _Quest.Identifier .. ": Error in " .. self.Name .. ": CustomFunction: Tradepost is missing");
    local TradepostID = GetID(self.ScriptName);
    if OfferCount > 0 then
        Logic.TradePost_SetTradePartnerGenerateGoodsFlag(TradepostID, true);
        Logic.TradePost_SetTradePartnerPlayerID(TradepostID, self.PlayerID);
        for i = 1, OfferCount do
            for j = 1, OfferCount do
                Logic.TradePost_SetTradeDefinition(
                    TradepostID,
                    (j-1),
                    Goods[self["PayType"..j]],
                    self["PayAmount"..j],
                    Goods[self["OfferType"..j]],
                    self["OfferAmount"..j]
                );
            end
        end
        Logic.TradePost_SetActiveTradeSlot(TradepostID, 0);
        Logic.InteractiveObjectSetAvailability(TradepostID, false);
        for PlayerID = 1, 8 do
            Logic.InteractiveObjectSetPlayerState(TradepostID, PlayerID, 2);
        end
    end
end

function B_Reward_TradePost:DEBUG(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        debug(false, _Quest.Identifier .. ":  Error in " .. self.Name ..": Player " .. self.PlayerID .. " is dead :-(");
        return true;
    elseif not IsExisting(self.ScriptName) then
        debug(false, _Quest.Identifier .. ":  Error in " .. self.Name ..": No TradePost found");
        return true;
    end
    for i = 1, 4 do
        if  self["PayAmount"..i]
        and self["OfferAmount"..i]
        and self["PayAmount"..i] > 0
        and self["OfferAmount"..i] > 0
        and (not Goods[self["PayType"..i]] or
             not Goods[self["OfferType"..i]])
        then
            debug(false, _Quest.Identifier .. ":  Error in " .. self.Name ..": Offer type or pay type in Slot " .. i .. " is wrong")
            return true
        end
    end
end

function B_Reward_TradePost:GetCustomData(_index)
    if _index >= 2 and _index <= 16 and _index % 2 == 0 then
        return {
            "G_Carcass",
            "G_Grain",
            "G_Herb",
            "G_Honeycomb",
            "G_Iron",
            "G_Milk",
            "G_RawFish",
            "G_Stone",
            "G_Wood",
            "G_Wool",
            "G_Salt",
            "G_Dye",
            "G_Olibanum",
            "G_Gems",
            "G_MusicalInstrument",
        };
    end
end

if g_GameExtraNo and g_GameExtraNo >= 1 then
    RegisterBehavior(B_Reward_TradePost);
end

-- -------------------------------------------------------------------------- --

function Reward_TradeOffers(...)
    return B_Reward_Merchant:new(...);
end

B_Reward_Merchant = {
    Name = "Reward_Merchant",
    Description = {
        en = "Reward: Deletes all existing offers for a merchant and sets new offers, if given",
        de = "Lohn: Löscht alle Angebote eines Händlers und setzt neue, wenn angegeben",
        fr = "Récompense: Supprime toutes les offres d'un commerçant et en place de nouvelles si elles sont indiquées.",
    },
    Parameter = {
        { ParameterType.Custom, en = "PlayerID", de = "PlayerID",  fr = "PlayerID" },
        { ParameterType.Custom, en = "Amount 1", de = "Menge 1",   fr = "Quantité 1" },
        { ParameterType.Custom, en = "Offer 1",  de = "Angebot 1", fr = "Offre 1" },
        { ParameterType.Custom, en = "Amount 2", de = "Menge 2",   fr = "Quantité 2" },
        { ParameterType.Custom, en = "Offer 2",  de = "Angebot 2", fr = "Offre 2" },
        { ParameterType.Custom, en = "Amount 3", de = "Menge 3",   fr = "Quantité 3" },
        { ParameterType.Custom, en = "Offer 3",  de = "Angebot 3", fr = "Offr 3e" },
        { ParameterType.Custom, en = "Amount 4", de = "Menge 4",   fr = "Quantité 4" },
        { ParameterType.Custom, en = "Offer 4",  de = "Angebot 4", fr = "Offre 4" },
    },
}

function B_Reward_Merchant:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_Merchant:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 1) then
        _Parameter = _Parameter or 0;
        self.AmountOffer1 = _Parameter * 1;
    elseif (_Index == 2) then
        self.Offer1 = _Parameter
    elseif (_Index == 3) then
        _Parameter = _Parameter or 0;
        self.AmountOffer2 = _Parameter * 1;
    elseif (_Index == 4) then
        self.Offer2 = _Parameter
    elseif (_Index == 5) then
        _Parameter = _Parameter or 0;
        self.AmountOffer3 = _Parameter * 1;
    elseif (_Index == 6) then
        self.Offer3 = _Parameter
    elseif (_Index == 7) then
        _Parameter = _Parameter or 0;
        self.AmountOffer4 = _Parameter * 1;
    elseif (_Index == 8) then
        self.Offer4 = _Parameter
    end
end

function B_Reward_Merchant:CustomFunction()
    if (self.PlayerID > 1) and (self.PlayerID < 9) then
        local Storehouse = Logic.GetStoreHouse(self.PlayerID)
        Logic.RemoveAllOffers(Storehouse)
        for i =  1,4 do
            if self["Offer"..i] and self["Offer"..i] ~= "-" then
                if Goods[self["Offer"..i]] then
                    AddOffer(Storehouse, self["AmountOffer"..i], Goods[self["Offer"..i]])
                elseif Logic.IsEntityTypeInCategory(Entities[self["Offer"..i]], EntityCategories.Military) == 1 then
                    AddMercenaryOffer(Storehouse, self["AmountOffer"..i], Entities[self["Offer"..i]])
                else
                    AddEntertainerOffer (Storehouse , Entities[self["Offer"..i]])
                end
            end
        end
    end
end

function B_Reward_Merchant:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID ) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.PlayerID .. " is dead. :-(")
        return true
    end
end

function B_Reward_Merchant:GetCustomData(_Index)
    local Players = { 1,2,3,4,5,6,7,8 }
    local Amount = { "1", "2", "3", "4", "5", "6", "7", "8", "9" }
    local Offers = {"-",
                    "G_Beer",
                    "G_Bow",
                    "G_Bread",
                    "G_Broom",
                    "G_Candle",
                    "G_Carcass",
                    "G_Cheese",
                    "G_Clothes",
                    "G_Cow",
                    "G_Grain",
                    "G_Herb",
                    "G_Honeycomb",
                    "G_Iron",
                    "G_Leather",
                    "G_Medicine",
                    "G_Milk",
                    "G_RawFish",
                    "G_Sausage",
                    "G_Sheep",
                    "G_SmokedFish",
                    "G_Soap",
                    "G_Stone",
                    "G_Sword",
                    "G_Wood",
                    "G_Wool",
                    "G_Salt",
                    "G_Dye",
                    "U_AmmunitionCart",
                    "U_BatteringRamCart",
                    "U_CatapultCart",
                    "U_SiegeTowerCart",
                    "U_MilitaryBandit_Melee_ME",
                    "U_MilitaryBandit_Melee_SE",
                    "U_MilitaryBandit_Melee_NA",
                    "U_MilitaryBandit_Melee_NE",
                    "U_MilitaryBandit_Ranged_ME",
                    "U_MilitaryBandit_Ranged_NA",
                    "U_MilitaryBandit_Ranged_NE",
                    "U_MilitaryBandit_Ranged_SE",
                    "U_MilitaryBow_RedPrince",
                    "U_MilitaryBow",
                    "U_MilitarySword_RedPrince",
                    "U_MilitarySword",
                    "U_Entertainer_NA_FireEater",
                    "U_Entertainer_NA_StiltWalker",
                    "U_Entertainer_NE_StrongestMan_Barrel",
                    "U_Entertainer_NE_StrongestMan_Stone",
                    }
    if g_GameExtraNo and g_GameExtraNo >= 1 then
        table.insert(Offers, "G_Gems")
        table.insert(Offers, "G_Olibanum")
        table.insert(Offers, "G_MusicalInstrument")
        table.insert(Offers, "G_MilitaryBandit_Ranged_AS")
        table.insert(Offers, "G_MilitaryBandit_Melee_AS")
        table.insert(Offers, "U_MilitarySword_Khana")
        table.insert(Offers, "U_MilitaryBow_Khana")
    end
    if (_Index == 0) then
        return Players
    elseif (_Index == 1) or (_Index == 3) or (_Index == 5) or (_Index == 7) then
        return Amount
    elseif (_Index == 2) or (_Index == 4) or (_Index == 6) or (_Index == 8) then
        return Offers
    end
end

RegisterBehavior(B_Reward_Merchant)

-- -------------------------------------------------------------------------- --

function Reward_DestroyEntity(...)
    return B_Reward_DestroyEntity:new(...);
end

B_Reward_DestroyEntity = CopyTable(B_Reprisal_DestroyEntity);
B_Reward_DestroyEntity.Name = "Reward_DestroyEntity";
B_Reward_DestroyEntity.Description.en = "Reward: Replaces an entity with an invisible script entity, which retains the entities name.";
B_Reward_DestroyEntity.Description.de = "Lohn: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.";
B_Reward_DestroyEntity.Description.fr = "Récompense: Remplace une entité par une entité de script invisible qui prend le nom.";
B_Reward_DestroyEntity.GetReprisalTable = nil;

B_Reward_DestroyEntity.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_DestroyEntity);

-- -------------------------------------------------------------------------- --

function Reward_DestroyEffect(...)
    return B_Reward_DestroyEffect:new(...);
end

B_Reward_DestroyEffect = CopyTable(B_Reprisal_DestroyEffect);
B_Reward_DestroyEffect.Name = "Reward_DestroyEffect";
B_Reward_DestroyEffect.Description.en = "Reward: Destroys an effect.";
B_Reward_DestroyEffect.Description.de = "Lohn: Zerstört einen Effekt.";
B_Reward_DestroyEffect.Description.fr = "Récompense: Détruit un effet.";
B_Reward_DestroyEffect.GetReprisalTable = nil;

B_Reward_DestroyEffect.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

RegisterBehavior(B_Reward_DestroyEffect);

-- -------------------------------------------------------------------------- --

function Reward_CreateBattalion(...)
    return B_Reward_CreateBattalion:new(...);
end

B_Reward_CreateBattalion = {
    Name = "Reward_CreateBattalion",
    Description = {
        en = "Reward: Replaces a script entity with a battalion, which retains the entities name",
        de = "Lohn: Ersetzt eine Script-Entity durch ein Bataillon, welches den Namen der Script-Entity übernimmt",
        fr = "Récompense: Remplace une entité de script par un bataillon qui prend le nom de l'entité de script.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Entité de script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Désignation du type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Number,     en = "Number of soldiers",          de = "Anzahl Soldaten",         fr = "Nombre de Soldats" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'IA" },
    },
}

function B_Reward_CreateBattalion:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateBattalion:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 4) then
        self.SoldierCount = _Parameter * 1
    elseif (_Index == 5) then
        self.HideFromAI = ToBoolean(_Parameter)
    end
end

function B_Reward_CreateBattalion:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, self.SoldierCount )
    local posID = GetID(self.ScriptNameEntity)
    if Logic.IsBuilding(posID) == 0 then
        DestroyEntity(self.ScriptNameEntity)
        Logic.SetEntityName( NewID, self.ScriptNameEntity )
    end
    if self.HideFromAI then
        AICore.HideEntityFromAI( self.PlayerID, NewID, true )
    end
end

function B_Reward_CreateBattalion:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        for k, v in pairs( Entities ) do
            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 5 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_CreateBattalion:Debug(_Quest)
    if not Entities[self.UnitKey] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": playerID is wrong!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": you can not create a empty batallion!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_CreateBattalion);

-- -------------------------------------------------------------------------- --

function Reward_CreateSeveralBattalions(...)
    return B_Reward_CreateSeveralBattalions:new(...);
end

B_Reward_CreateSeveralBattalions = {
    Name = "Reward_CreateSeveralBattalions",
    Description = {
        en = "Reward: Creates a given amount of battalions",
        de = "Lohn: Erstellt eine gegebene Anzahl Bataillone",
        fr = "Récompense: Crée un nombre donné de bataillons",
    },
    Parameter = {
        { ParameterType.Number,     en = "Amount",                      de = "Anzahl",                  fr = "Quantité" },
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Quentité de Script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Désignation de type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Number,     en = "Number of soldiers",          de = "Anzahl Soldaten",         fr = "Nombre de soldats" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'AI" },
    },
}

function B_Reward_CreateSeveralBattalions:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateSeveralBattalions:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1
    elseif (_Index == 1) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 3) then
        self.UnitKey = _Parameter
    elseif (_Index == 4) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 5) then
        self.SoldierCount = _Parameter * 1
    elseif (_Index == 6) then
        self.HideFromAI = ToBoolean(_Parameter)
    end
end

function B_Reward_CreateSeveralBattalions:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local tID = GetID(self.ScriptNameEntity)
    local x,y,z = Logic.EntityGetPos(tID);
    if Logic.IsBuilding(tID) == 1 then
        x,y = Logic.GetBuildingApproachPosition(tID)
    end

    for i=1, self.Amount do
        local NewID = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], x, y, self.Orientation, self.PlayerID, self.SoldierCount )
        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )
        if self.HideFromAI then
            AICore.HideEntityFromAI( self.PlayerID, NewID, true )
        end
    end
end

function B_Reward_CreateSeveralBattalions:GetCustomData( _Index )
    local Data = {}
    if _Index == 3 then
        for k, v in pairs( Entities ) do
            if Logic.IsEntityTypeInCategory( v, EntityCategories.Soldier ) == 1 then
                table.insert( Data, k )
            end
        end
        table.sort( Data )
    elseif _Index == 6 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_CreateSeveralBattalions:Debug(_Quest)
    if not Entities[self.UnitKey] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": playerDI is wrong!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.SoldierCount) == nil or self.SoldierCount < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": you can not create a empty batallion!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_CreateSeveralBattalions);

-- -------------------------------------------------------------------------- --

function Reward_CreateEffect(...)
    return B_Reward_CreateEffect:new(...);
end

B_Reward_CreateEffect = {
    Name = "Reward_CreateEffect",
    Description = {
        en = "Reward: Creates an effect at a specified position",
        de = "Lohn: Erstellt einen Effekt an der angegebenen Position",
        fr = "Récompense: Crée un effet à la position indiquée",
    },
    Parameter = {
        { ParameterType.Default,    en = "Effect name", de = "Effektname",      fr = "Nom de l'effet" },
        { ParameterType.Custom,     en = "Type name",   de = "Typbezeichnung",  fr = "Designation de type" },
        { ParameterType.PlayerID,   en = "Player",      de = "Spieler",         fr = "Joueur" },
        { ParameterType.ScriptName, en = "Location",    de = "Ort",             fr = "Lieu" },
        { ParameterType.Number,     en = "Orientation (in degrees)(-1: from locating entity)", de = "Ausrichtung (in Grad)(-1: von Positionseinheit)", fr = "Orientation (en degrés)(-1 : de l'unité de position)" },
    }
}

function B_Reward_CreateEffect:AddParameter(_Index, _Parameter)

    if _Index == 0 then
        self.EffectName = _Parameter;
    elseif _Index == 1 then
        self.Type = EGL_Effects[_Parameter];
    elseif _Index == 2 then
        self.PlayerID = _Parameter * 1;
    elseif _Index == 3 then
        self.Location = _Parameter;
    elseif _Index == 4 then
        self.Orientation = _Parameter * 1;
    end

end

function B_Reward_CreateEffect:GetRewardTable()
    return { Reward.Custom, { self, self.CustomFunction } };
end

function B_Reward_CreateEffect:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed(self.Location) then
        return;
    end
    local entity = assert(GetID(self.Location), _Quest.Identifier .. "Error in " .. self.Name .. ": CustomFunction: Entity is invalid");
    if CONST_EFFECT_NAME_TO_ID[self.EffectName] and Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName]) then
        return;
    end

    local posX, posY = Logic.GetEntityPosition(entity);
    local orientation = tonumber(self.Orientation);
    local effect = Logic.CreateEffectWithOrientation(self.Type, posX, posY, orientation, self.PlayerID);
    if self.EffectName ~= "" then
        CONST_EFFECT_NAME_TO_ID[self.EffectName] = effect;
    end
end

function B_Reward_CreateEffect:Debug(_Quest)
    if CONST_EFFECT_NAME_TO_ID[self.EffectName] and Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName]) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": effect already exists!");
        return true;
    elseif not IsExisting(self.Location) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": location '" ..self.Location.. "' is missing!");
        return true;
    elseif self.PlayerID and (self.PlayerID < 0 or self.PlayerID > 8) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid playerID!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid orientation!");
        return true;
    end
end

function B_Reward_CreateEffect:GetCustomData(_Index)
    assert(_Index == 1, "Error in " .. self.Name .. ": GetCustomData: Index is invalid.");
    local types = {};
    for k, v in pairs(EGL_Effects) do
        table.insert(types, k);
    end
    table.sort(types);
    return types;
end

RegisterBehavior(B_Reward_CreateEffect);

-- -------------------------------------------------------------------------- --

function Reward_CreateEntity(...)
    return B_Reward_CreateEntity:new(...);
end

B_Reward_CreateEntity = {
    Name = "Reward_CreateEntity",
    Description = {
        en = "Reward: Replaces an entity by a new one of a given type",
        de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs",
        fr = "Récompense: Remplace une entité par une nouvelle entité de type donné",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Entité de script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Désignation de type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'AI" },
    },
}

function B_Reward_CreateEntity:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateEntity:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 4) then
        self.HideFromAI = ToBoolean(_Parameter)
    end
end

function B_Reward_CreateEntity:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID;
    if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then
        NewID     = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )
        local l,s = Logic.GetSoldiersAttachedToLeader(NewID)
        Logic.SetOrientation(s, math.floor(self.Orientation + 0.5))
    else
        NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )
    end
    local posID = GetID(self.ScriptNameEntity)
    if Logic.IsBuilding(posID) == 0 then
        DestroyEntity(self.ScriptNameEntity)
        Logic.SetEntityName( NewID, self.ScriptNameEntity )
    end
    if self.HideFromAI then
        AICore.HideEntityFromAI( self.PlayerID, NewID, true )
    end
end

function B_Reward_CreateEntity:GetCustomData( _Index )
    local Data = {}
    if _Index == 2 then
        for k, v in pairs( Entities ) do
            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )

    elseif _Index == 4 or _Index == 5 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_CreateEntity:Debug(_Quest)
    if not Entities[self.UnitKey] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 0 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": playerID is not valid!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_CreateEntity);

-- -------------------------------------------------------------------------- --

-- Kompatibelität
B_Reward_CreateSettler = CopyTable(B_Reward_CreateEntity);
B_Reward_CreateSettler.Name = "Reward_CreateSettler";
B_Reward_CreateSettler.Description.en = "Reward: Replaces an entity by a new one of a given type";
B_Reward_CreateSettler.Description.de = "Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs";
B_Reward_CreateSettler.Description.fr = "Récompense: Remplace une entité par une nouvelle entité de type donné";
RegisterBehavior(B_Reward_CreateSettler);

-- -------------------------------------------------------------------------- --

function Reward_CreateSeveralEntities(...)
    return B_Reward_CreateSeveralEntities:new(...);
end

B_Reward_CreateSeveralEntities = {
    Name = "Reward_CreateSeveralEntities",
    Description = {
        en = "Reward: Creating serveral battalions at the position of a entity. They retains the entities name and a _[index] suffix",
        de = "Lohn: Erzeugt mehrere Entities an der Position der Entity. Sie übernimmt den Namen der Script Entity und den Suffix _[index]",
        fr = "Récompense: Crée plusieurs Entities à la position de l'Entity. Elle reprend le nom de l'entité script et le suffixe _[index].",
    },
    Parameter = {
        { ParameterType.Number,     en = "Amount",                      de = "Anzahl",                  fr = "Quantité" },
        { ParameterType.ScriptName, en = "Script entity",               de = "Script Entity",           fr = "Entité de script" },
        { ParameterType.PlayerID,   en = "Player",                      de = "Spieler",                 fr = "Joueur" },
        { ParameterType.Custom,     en = "Type name",                   de = "Typbezeichnung",          fr = "Designation de type" },
        { ParameterType.Number,     en = "Orientation (in degrees)",    de = "Ausrichtung (in Grad)",   fr = "Orientation (en degrés)" },
        { ParameterType.Custom,     en = "Hide from AI",                de = "Vor KI verstecken",       fr = "Cacher de l'AI" },
    },
}

function B_Reward_CreateSeveralEntities:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_CreateSeveralEntities:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1
    elseif (_Index == 1) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 2) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 3) then
        self.UnitKey = _Parameter
    elseif (_Index == 4) then
        self.Orientation = _Parameter * 1
    elseif (_Index == 5) then
        self.HideFromAI = ToBoolean(_Parameter)
    end
end

function B_Reward_CreateSeveralEntities:CustomFunction(_Quest)
    if not IsExisting( self.ScriptNameEntity ) then
        return false
    end
    local pos = GetPosition(self.ScriptNameEntity)
    local NewID;
    for i=1, self.Amount do
        if Logic.IsEntityTypeInCategory( self.UnitKey, EntityCategories.Soldier ) == 1 then
            NewID     = Logic.CreateBattalionOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID, 1 )
            local l,s = Logic.GetSoldiersAttachedToLeader(NewID)
            Logic.SetOrientation(s, math.floor(self.Orientation + 0.5))
        else
            NewID = Logic.CreateEntityOnUnblockedLand( Entities[self.UnitKey], pos.X, pos.Y, self.Orientation, self.PlayerID )
        end
        Logic.SetEntityName( NewID, self.ScriptNameEntity .. "_" .. i )
        if self.HideFromAI then
            AICore.HideEntityFromAI( self.PlayerID, NewID, true )
        end
    end
end

function B_Reward_CreateSeveralEntities:GetCustomData( _Index )
    local Data = {}
    if _Index == 3 then
        for k, v in pairs( Entities ) do
            local name = {"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}
            local found = false;
            for i=1,#name do
                if k:find(name[i]) then
                    found = true;
                    break;
                end
            end
            if not found then
                table.insert( Data, k );
            end
        end
        table.sort( Data )

    elseif _Index == 5 or _Index == 6 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data

end

function B_Reward_CreateSeveralEntities:Debug(_Quest)
    if not Entities[self.UnitKey] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": got an invalid entity type!");
        return true;
    elseif not IsExisting(self.ScriptNameEntity) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.PlayerID) == nil or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif tonumber(self.Orientation) == nil then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": orientation must be a number!");
        return true;
    elseif tonumber(self.Amount) == nil or self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_CreateSeveralEntities);

-- -------------------------------------------------------------------------- --

function Reward_MoveSettler(...)
    return B_Reward_MoveSettler:new(...);
end

B_Reward_MoveSettler = {
    Name = "Reward_MoveSettler",
    Description = {
        en = "Reward: Moves a (NPC) settler to a destination. Must not be AI controlled, or it won't move",
        de = "Lohn: Bewegt einen (NPC) Siedler zu einem Zielort. Darf keinem KI Spieler gehören, ansonsten wird sich der Siedler nicht bewegen",
        fr = "Récompense: Déplace un settler (NPC) vers une destination. Ne doit pas appartenir à un joueur IA, sinon le settler ne se déplacera pas.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Settler", de = "Siedler", fr = "Settler" },
        { ParameterType.ScriptName, en = "Destination", de = "Ziel", fr = "Destination" },
    },
}

function B_Reward_MoveSettler:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_MoveSettler:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameUnit = _Parameter
    elseif (_Index == 1) then
        self.ScriptNameDest = _Parameter
    end
end

function B_Reward_MoveSettler:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.ScriptNameUnit ) or Logic.IsEntityDestroyed( self.ScriptNameDest ) then
        return false
    end
    local DestID = GetID( self.ScriptNameDest )
    local DestX, DestY = Logic.GetEntityPosition( DestID )
    if Logic.IsBuilding( DestID ) == 1 then
        DestX, DestY = Logic.GetBuildingApproachPosition( DestID )
    end
    Logic.MoveSettler( GetID( self.ScriptNameUnit ), DestX, DestY )
end

function B_Reward_MoveSettler:Debug(_Quest)
    if not IsExisting(self.ScriptNameUnit) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": mover entity does not exist!");
        return true;
    elseif not IsExisting(self.ScriptNameDest) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": destination does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_MoveSettler);

-- -------------------------------------------------------------------------- --

function Reward_Victory()
    return B_Reward_Victory:new()
end

B_Reward_Victory = {
    Name = "Reward_Victory",
    Description = {
        en = "Reward: The player wins the game.",
        de = "Lohn: Der Spieler gewinnt das Spiel.",
        fr = "Récompense: Le Joueur gagne la partie.",
    },
}

function B_Reward_Victory:GetRewardTable()
    return {Reward.Victory};
end

RegisterBehavior(B_Reward_Victory);

-- -------------------------------------------------------------------------- --

function Reward_Defeat()
    return B_Reward_Defeat:new()
end

B_Reward_Defeat = {
    Name = "Reward_Defeat",
    Description = {
        en = "Reward: The player loses the game.",
        de = "Lohn: Der Spieler verliert das Spiel.",
        fr = "Récompense: le Joueur perd la partie.",
    },
}

function B_Reward_Defeat:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function B_Reward_Defeat:CustomFunction(_Quest)
    _Quest:TerminateEventsAndStuff()
    Logic.ExecuteInLuaLocalState("GUI_Window.MissionEndScreenSetVictoryReasonText(".. g_VictoryAndDefeatType.DefeatMissionFailed ..")")
    Defeated(_Quest.ReceivingPlayer)
end

RegisterBehavior(B_Reward_Defeat);

-- -------------------------------------------------------------------------- --

function Reward_FakeVictory()
    return B_Reward_FakeVictory:new();
end

B_Reward_FakeVictory = {
    Name = "Reward_FakeVictory",
    Description = {
        en = "Reward: Display a victory icon for a quest",
        de = "Lohn: Zeigt ein Siegesicon fuer diese Quest",
        fr = "Récompense: Affiche une icône de victoire pour cette quête",
    },
}

function B_Reward_FakeVictory:GetRewardTable()
    return { Reward.FakeVictory }
end

RegisterBehavior(B_Reward_FakeVictory);

-- -------------------------------------------------------------------------- --

function Reward_AI_SpawnAndAttackTerritory(...)
    return B_Reward_AI_SpawnAndAttackTerritory:new(...);
end

B_Reward_AI_SpawnAndAttackTerritory = {
    Name = "Reward_AI_SpawnAndAttackTerritory",
    Description = {
        en = "Reward: Spawns AI troops and attacks a territory (Hint: Use for hidden quests as a surprise)",
        de = "Lohn: Erstellt KI Truppen und greift ein Territorium an (Tipp: Fuer eine versteckte Quest als Ueberraschung verwenden)",
        fr = "Récompense: Créez des troupes d'IA et attaquez un territoire (astuce : utilisez une surprise pour une quête cachée).",
    },
    Parameter = {
        { ParameterType.PlayerID,       en = "AI Player",       de = "KI Spieler",                  fr = "Joueur AI" },
        { ParameterType.ScriptName,     en = "Spawn point",     de = "Erstellungsort",              fr = "Lieu de création" },
        { ParameterType.TerritoryName,  en = "Territory",       de = "Territorium",                 fr = "Territoire" },
        { ParameterType.Number,         en = "Sword",           de = "Schwert",                     fr = "Épéiste" },
        { ParameterType.Number,         en = "Bow",             de = "Bogen",                       fr = "Archer" },
        { ParameterType.Number,         en = "Catapults",       de = "Katapulte",                   fr = "Catapultes" },
        { ParameterType.Number,         en = "Siege towers",    de = "Belagerungstuerme",           fr = "Tours de siège" },
        { ParameterType.Number,         en = "Rams",            de = "Rammen",                      fr = "Bélier" },
        { ParameterType.Number,         en = "Ammo carts",      de = "Munitionswagen",              fr = "Chariot à munitions" },
        { ParameterType.Custom,         en = "Soldier type",    de = "Soldatentyp",                 fr = "Type de soldat" },
        { ParameterType.Custom,         en = "Reuse troops",    de = "Verwende bestehende Truppen", fr = "Utiliser les troupes existantes" },
    },
}

function B_Reward_AI_SpawnAndAttackTerritory:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SpawnAndAttackTerritory:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TerritoryID = tonumber(_Parameter)
        if not self.TerritoryID then
            self.TerritoryID = GetTerritoryIDByName(_Parameter)
        end
    elseif (_Index == 3) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 4) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 5) then
        self.NumCatapults = _Parameter * 1
    elseif (_Index == 6) then
        self.NumSiegeTowers = _Parameter * 1
    elseif (_Index == 7) then
        self.NumRams = _Parameter * 1
    elseif (_Index == 8) then
        self.NumAmmoCarts = _Parameter * 1
    elseif (_Index == 9) then
        if _Parameter == "Normal" or _Parameter == false then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == true then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 10) then
        self.ReuseTroops = ToBoolean(_Parameter)
    end
end

function B_Reward_AI_SpawnAndAttackTerritory:GetCustomData( _Index )
    local Data = {}
    if _Index == 9 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end
    elseif _Index == 10 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_AI_SpawnAndAttackTerritory:CustomFunction(_Quest)
    local TargetID = Logic.GetTerritoryAcquiringBuildingID( self.TerritoryID )
    if TargetID ~= 0 then
        AIScript_SpawnAndAttackCity(
            self.AIPlayerID,
            TargetID,
            self.Spawnpoint,
            self.NumSword,
            self.NumBow,
            self.NumCatapults,
            self.NumSiegeTowers,
            self.NumRams,
            self.NumAmmoCarts,
            self.TroopType,
            self.ReuseTroops
        )
    end
end

function B_Reward_AI_SpawnAndAttackTerritory:Debug(_Quest)
    if self.AIPlayerID < 2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif self.TerritoryID == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Territory unknown")
        return true
    elseif self.NumSword < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    elseif self.NumCatapults < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Catapults is negative")
        return true
    elseif self.NumSiegeTowers < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": SiegeTowers is negative")
        return true
    elseif self.NumRams < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Rams is negative")
        return true
    elseif self.NumAmmoCarts < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": AmmoCarts is negative")
        return true
    end
    return false;
end

RegisterBehavior(B_Reward_AI_SpawnAndAttackTerritory);

-- -------------------------------------------------------------------------- --

function Reward_AI_SpawnAndAttackArea(...)
    return B_Reward_AI_SpawnAndAttackArea:new(...);
end

B_Reward_AI_SpawnAndAttackArea = {
    Name = "Reward_AI_SpawnAndAttackArea",
    Description = {
        en = "Reward: Spawns AI troops and attacks everything within the specified area, except the players main buildings",
        de = "Lohn: Erstellt KI Truppen und greift ein angegebenes Gebiet an, aber nicht die Hauptgebauede eines Spielers",
        fr = "Récompense: Crée des troupes IA et attaque une zone spécifiée, mais pas les bâtiments principaux d'un joueur.",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "AI Player",       de = "KI Spieler",                  fr = "Joueur AI" },
        { ParameterType.ScriptName, en = "Spawn point",     de = "Erstellungsort",              fr = "Lieu de création" },
        { ParameterType.ScriptName, en = "Target",          de = "Ziel",                        fr = "Cible" },
        { ParameterType.Number,     en = "Radius",          de = "Radius",                      fr = "Rayon" },
        { ParameterType.Number,     en = "Sword",           de = "Schwert",                     fr = "Épéiste" },
        { ParameterType.Number,     en = "Bow",             de = "Bogen",                       fr = "Archer" },
        { ParameterType.Custom,     en = "Soldier type",    de = "Soldatentyp",                 fr = "Type de soldats" },
        { ParameterType.Custom,     en = "Reuse troops",    de = "Verwende bestehende Truppen", fr = "Utiliser des troupes existantes" },
    },
}

function B_Reward_AI_SpawnAndAttackArea:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SpawnAndAttackArea:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TargetName = _Parameter
    elseif (_Index == 3) then
        self.Radius = _Parameter * 1
    elseif (_Index == 4) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 5) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 6) then
        if _Parameter == "Normal" or _Parameter == false then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == true then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 7) then
        self.ReuseTroops = ToBoolean(_Parameter)
    end
end

function B_Reward_AI_SpawnAndAttackArea:GetCustomData( _Index )
    local Data = {}
    if _Index == 6 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end
    elseif _Index == 7 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    else
        assert( false )
    end
    return Data
end

function B_Reward_AI_SpawnAndAttackArea:CustomFunction(_Quest)
    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then
        local TargetID = GetID( self.TargetName )
        AIScript_SpawnAndRaidSettlement(
            self.AIPlayerID,
            TargetID,
            self.Spawnpoint,
            self.Radius,
            self.NumSword,
            self.NumBow,
            self.TroopType,
            self.ReuseTroops
        )
    end
end

function B_Reward_AI_SpawnAndAttackArea:Debug(_Quest)
    if self.AIPlayerID < 2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif Logic.IsEntityDestroyed(self.TargetName) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.TargetName .. " is missing")
        return true
    elseif self.Radius < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Radius is to small or negative")
        return true
    elseif self.NumSword < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    end
    return false;
end

RegisterBehavior(B_Reward_AI_SpawnAndAttackArea);

-- -------------------------------------------------------------------------- --

function Reward_AI_SpawnAndProtectArea(...)
    return B_Reward_AI_SpawnAndProtectArea:new(...);
end

B_Reward_AI_SpawnAndProtectArea = {
    Name = "Reward_AI_SpawnAndProtectArea",
    Description = {
        en = "Reward: Spawns AI troops and defends a specified area",
        de = "Lohn: Erstellt KI Truppen und verteidigt ein angegebenes Gebiet",
        fr = "Récompense: Crée des troupes d'IA et défend un territoire donné",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "AI Player",               de = "KI Spieler",                  fr = "Joueur AI" },
        { ParameterType.ScriptName, en = "Spawn point",             de = "Erstellungsort",              fr = "Lieu de création" },
        { ParameterType.ScriptName, en = "Target",                  de = "Ziel",                        fr = "Cible" },
        { ParameterType.Number,     en = "Radius",                  de = "Radius",                      fr = "Rayon" },
        { ParameterType.Number,     en = "Time (-1 for infinite)",  de = "Zeit (-1 fuer unendlich)",    fr = "Temps (-1 pour infini)" },
        { ParameterType.Number,     en = "Sword",                   de = "Schwert",                     fr = "Épéiste" },
        { ParameterType.Number,     en = "Bow",                     de = "Bogen",                       fr = "Archer" },
        { ParameterType.Custom,     en = "Capture tradecarts",      de = "Handelskarren angreifen",     fr = "Attaquer les chariots de commerce" },
        { ParameterType.Custom,     en = "Soldier type",            de = "Soldatentyp",                 fr = "Type de soldat" },
        { ParameterType.Custom,     en = "Reuse troops",            de = "Verwende bestehende Truppen", fr = "Utiliser les troupes existantes" },
    },
}

function B_Reward_AI_SpawnAndProtectArea:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SpawnAndProtectArea:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Spawnpoint = _Parameter
    elseif (_Index == 2) then
        self.TargetName = _Parameter
    elseif (_Index == 3) then
        self.Radius = _Parameter * 1
    elseif (_Index == 4) then
        self.Time = _Parameter * 1
    elseif (_Index == 5) then
        self.NumSword = _Parameter * 1
    elseif (_Index == 6) then
        self.NumBow = _Parameter * 1
    elseif (_Index == 7) then
        self.CaptureTradeCarts = ToBoolean(_Parameter)
    elseif (_Index == 8) then
        if _Parameter == "Normal" or _Parameter == true then
            self.TroopType = false
        elseif _Parameter == "RedPrince" or _Parameter == false then
            self.TroopType = true
        elseif _Parameter == "Bandit" or _Parameter == 2 then
            self.TroopType = 2
        elseif _Parameter == "Cultist" or _Parameter == 3 then
            self.TroopType = 3
        else
            assert(false)
        end
    elseif (_Index == 9) then
        self.ReuseTroops = ToBoolean(_Parameter)
    end

end

function B_Reward_AI_SpawnAndProtectArea:GetCustomData( _Index )

    local Data = {}
    if _Index == 7 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )
    elseif _Index == 8 then
        table.insert( Data, "Normal" )
        table.insert( Data, "RedPrince" )
        table.insert( Data, "Bandit" )
        if g_GameExtraNo >= 1 then
            table.insert( Data, "Cultist" )
        end

    elseif _Index == 9 then
        table.insert( Data, "false" )
        table.insert( Data, "true" )

    else
        assert( false )
    end

    return Data

end

function B_Reward_AI_SpawnAndProtectArea:CustomFunction(_Quest)
    if Logic.IsEntityAlive( self.TargetName ) and Logic.IsEntityAlive( self.Spawnpoint ) then
        local TargetID = GetID( self.TargetName )
        AIScript_SpawnAndProtectArea(
            self.AIPlayerID,
            TargetID,
            self.Spawnpoint,
            self.Radius,
            self.NumSword,
            self.NumBow,
            self.Time,
            self.TroopType,
            self.ReuseTroops,
            self.CaptureTradeCarts
        )
    end
end

function B_Reward_AI_SpawnAndProtectArea:Debug(_Quest)
    if self.AIPlayerID < 2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong")
        return true
    elseif Logic.IsEntityDestroyed(self.Spawnpoint) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.SpawnPoint .. " is missing")
        return true
    elseif Logic.IsEntityDestroyed(self.TargetName) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Entity " .. self.TargetName .. " is missing")
        return true
    elseif self.Radius < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Radius is to small or negative")
        return true
    elseif self.Time < -1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Time is smaller than -1")
        return true
    elseif self.NumSword < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Swords is negative")
        return true
    elseif self.NumBow < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Number of Bows is negative")
        return true
    elseif self.NumBow + self.NumSword < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": No Soldiers?")
        return true
    end
    return false;
end

RegisterBehavior(B_Reward_AI_SpawnAndProtectArea);

-- -------------------------------------------------------------------------- --

function Reward_AI_SetNumericalFact(...)
    return B_Reward_AI_SetNumericalFact:new(...);
end

B_Reward_AI_SetNumericalFact = {
    Name = "Reward_AI_SetNumericalFact",
    Description = {
        en = "Reward: Sets a numerical fact for the AI player",
        de = "Lohn: Setzt eine Verhaltensregel fuer den KI-Spieler. ",
        fr = "Récompense: Définit une règle de comportement pour le joueur IA.",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "AI Player",      de = "KI Spieler",         fr = "Joueur AI" },
        { ParameterType.Custom,   en = "Numerical Fact", de = "Verhaltensregel",    fr = "Règle de conduite" },
        { ParameterType.Number,   en = "Value",          de = "Wert",               fr = "Valeur" },
    },
}

function B_Reward_AI_SetNumericalFact:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_SetNumericalFact:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AIPlayerID = _Parameter * 1
    elseif (_Index == 1) then
        -- mapping of numerical facts
        local fact = {
            ["Courage"]               = "FEAR",
            ["Reconstruction"]        = "BARB",
            ["Build Order"]           = "BPMX",
            ["Conquer Outposts"]      = "FCOP",
            ["Mount Outposts"]        = "FMOP",
            ["max. Bowmen"]           = "FMBM",
            ["max. Swordmen"]         = "FMSM",
            ["max. Rams"]             = "FMRA",
            ["max. Catapults"]        = "FMCA",
            ["max. Ammunition Carts"] = "FMAC",
            ["max. Siege Towers"]     = "FMST",
            ["max. Wall Catapults"]   = "FMBA",
            ["FEAR"]                  = "FEAR", -- > 0
            ["BARB"]                  = "BARB", -- 1 or 0
            ["BPMX"]                  = "BPMX", -- >= 0
            ["FCOP"]                  = "FCOP", -- 1 or 0
            ["FMOP"]                  = "FMOP", -- 1 or 0
            ["FMBM"]                  = "FMBM", -- >= 0
            ["FMSM"]                  = "FMSM", -- >= 0
            ["FMRA"]                  = "FMRA", -- >= 0
            ["FMCA"]                  = "FMCA", -- >= 0
            ["FMAC"]                  = "FMAC", -- >= 0
            ["FMST"]                  = "FMST", -- >= 0
            ["FMBA"]                  = "FMBA", -- >= 0
        }
        self.NumericalFact = fact[_Parameter]
    elseif (_Index == 2) then
        self.Value = _Parameter * 1
    end
end

function B_Reward_AI_SetNumericalFact:CustomFunction(_Quest)
    if self.NumericalFact ~= nil then
        AICore.SetNumericalFact(self.AIPlayerID, self.NumericalFact, self.Value)
    end
end

function B_Reward_AI_SetNumericalFact:GetCustomData(_Index)
    if (_Index == 1) then
        return {
            "Courage",
            "Reconstruction",
            "Build Order",
            "Conquer Outposts",
            "Mount Outposts",
            "max. Bowmen",
            "max. Swordmen",
            "max. Rams",
            "max. Catapults",
            "max. Ammunition Carts",
            "max. Siege Towers",
            "max. Wall Catapults",
        };
    end
end

function B_Reward_AI_SetNumericalFact:Debug(_Quest)
    if Logic.GetStoreHouse(self.AIPlayerID) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayerID .. " is wrong or dead!");
        return true;
    elseif not self.NumericalFact then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": invalid numerical fact choosen!");
        return true;
    else
        if self.NumericalFact == "BARB" or self.NumericalFact == "FCOP" or self.NumericalFact == "FMOP" then
            if self.Value ~= 0 and self.Value ~= 1 then
                debug(false, _Quest.Identifier.. ": " ..self.Name .. ": BARB, FCOP, FMOP: value must be 1 or 0!");
                return true;
            end
        elseif self.NumericalFact == "FEAR" then
            if self.Value <= 0 then
                debug(false, _Quest.Identifier.. ": " ..self.Name .. ": FEAR: value must greater than 0!");
                return true;
            end
        else
            if self.Value < 0 then
                debug(false, _Quest.Identifier.. ": " ..self.Name .. ": value must always greater than or equal 0!");
                return true;
            end
        end
    end
    return false
end

RegisterBehavior(B_Reward_AI_SetNumericalFact);

-- -------------------------------------------------------------------------- --

function Reward_AI_Aggressiveness(...)
    return B_Reward_AI_Aggressiveness:new(...);
end

B_Reward_AI_Aggressiveness = {
    Name = "Reward_AI_Aggressiveness",
    Description = {
        en = "Reward: Sets the AI player's aggressiveness.",
        de = "Lohn: Setzt die Aggressivität des KI-Spielers fest.",
        fr = "Récompense: Définit l'agressivité du joueur IA.",
    },
    Parameter =
    {
        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler", fr = "Joueur AI" },
        { ParameterType.Custom, en = "Aggressiveness (1-3)", de = "Aggressivität (1-3)", fr = "Agressivité (1-3)" }
    }
};

function B_Reward_AI_Aggressiveness:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction} };
end

function B_Reward_AI_Aggressiveness:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.AIPlayer = _Parameter * 1;
    elseif _Index == 1 then
        self.Aggressiveness = tonumber(_Parameter);
    end
end

function B_Reward_AI_Aggressiveness:CustomFunction()
    local player = (PlayerAIs[self.AIPlayer]
        or AIPlayerTable[self.AIPlayer]
        or AIPlayer:new(self.AIPlayer, AIPlayerProfile_City));
    assert(player ~= nil);
    PlayerAIs[self.AIPlayer] = player;
    if self.Aggressiveness >= 2 then
        player.ProfileLoop = AIProfile_Skirmish;
        player.Skirmish = player.Skirmish or {};
        player.Skirmish.Claim_MinTime = SkirmishDefault.Claim_MinTime + (self.Aggressiveness - 2) * 390;
        player.Skirmish.Claim_MaxTime = player.Skirmish.Claim_MinTime * 2;
    else
        player.ProfileLoop = AIPlayerProfile_City;
    end
end

function B_Reward_AI_Aggressiveness:Debug(_Quest)
    if self.AIPlayer < 1 or Logic.GetStoreHouse(self.AIPlayer) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayer .. " is wrong");
        return true;
    end
end

function B_Reward_AI_Aggressiveness:GetCustomData(_Index)
    return { "1", "2", "3" };
end

RegisterBehavior(B_Reward_AI_Aggressiveness)

-- -------------------------------------------------------------------------- --

function Reward_AI_SetEnemy(...)
    return B_Reward_AI_SetEnemy:new(...);
end

B_Reward_AI_SetEnemy = {
    Name = "Reward_AI_SetEnemy",
    Description = {
        en = "Reward:Sets the enemy of an AI player (the AI only handles one enemy properly).",
        de = "Lohn: Legt den Feind eines KI-Spielers fest (die KI behandelt nur einen Feind korrekt).",
        fr = "Récompense: Définit l'ennemi d'un joueur IA (l'IA ne traite correctement qu'un seul ennemi).",
    },
    Parameter =
    {
        { ParameterType.PlayerID, en = "AI player", de = "KI-Spieler", fr = "Joueur AI" },
        { ParameterType.PlayerID, en = "Enemy", de = "Feind", fr = "Ennemi" }
    }
};

function B_Reward_AI_SetEnemy:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction} };
end

function B_Reward_AI_SetEnemy:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.AIPlayer = _Parameter * 1;
    elseif _Index == 1 then
        self.Enemy = _Parameter * 1;
    end
end

function B_Reward_AI_SetEnemy:CustomFunction()
    local player = PlayerAIs[self.AIPlayer];
    if player and player.Skirmish then
        player.Skirmish.Enemy = self.Enemy;
    end
end

function B_Reward_AI_SetEnemy:Debug(_Quest)
    if self.AIPlayer < 1 or self.AIPlayer > 8 or Logic.PlayerGetIsHumanFlag(self.AIPlayer) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AIPlayer .. " is wrong");
        return true;
    end
    return false;
end
RegisterBehavior(B_Reward_AI_SetEnemy)

-- -------------------------------------------------------------------------- --

function Reward_ReplaceEntity(...)
    return B_Reward_ReplaceEntity:new(...);
end

B_Reward_ReplaceEntity = CopyTable(B_Reprisal_ReplaceEntity);
B_Reward_ReplaceEntity.Name = "Reward_ReplaceEntity";
B_Reward_ReplaceEntity.Description.en = "Reward: Replaces an entity with a new one of a different type. The playerID can be changed too.";
B_Reward_ReplaceEntity.Description.de = "Lohn: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.";
B_Reward_ReplaceEntity.Description.fr = "Récompense: Remplace une entité par une nouvelle entité d'un autre type. Il est également possible de changer l'appartenance d'un joueur.";
B_Reward_ReplaceEntity.GetReprisalTable = nil;

B_Reward_ReplaceEntity.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_ReplaceEntity);

-- -------------------------------------------------------------------------- --

function Reward_SetResourceAmount(...)
    return B_Reward_SetResourceAmount:new(...);
end

B_Reward_SetResourceAmount = {
    Name = "Reward_SetResourceAmount",
    Description = {
        en = "Reward: Set the current and maximum amount of a resource doodad (the amount can also set to 0)",
        de = "Lohn: Setzt die aktuellen sowie maximalen Resourcen in einem Doodad (auch 0 ist möglich)",
        fr = "Récompense: Définit les ressources actuelles ainsi que les ressources maximales dans un Doodad (0 est également possible)",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Ressource", de = "Resource", fr = "Ressources" },
        { ParameterType.Number, en = "Amount", de = "Menge", fr = "Quantité" },
    },
}

function B_Reward_SetResourceAmount:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_SetResourceAmount:AddParameter(_Index, _Parameter)

    if (_Index == 0) then
        self.ScriptName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    end

end

function B_Reward_SetResourceAmount:CustomFunction(_Quest)
    if Logic.IsEntityDestroyed( self.ScriptName ) then
        return false
    end
    local EntityID = GetID( self.ScriptName )
    if Logic.GetResourceDoodadGoodType( EntityID ) == 0 then
        return false
    end
    Logic.SetResourceDoodadGoodAmount( EntityID, self.Amount )
end

function B_Reward_SetResourceAmount:Debug(_Quest)
    if not IsExisting(self.ScriptName) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": resource entity does not exist!")
        return true
    elseif not type(self.Amount) == "number" or self.Amount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": resource amount can not be negative!")
        return true
    end
    return false;
end

RegisterBehavior(B_Reward_SetResourceAmount);

-- -------------------------------------------------------------------------- --

function Reward_Resources(...)
    return B_Reward_Resources:new(...);
end

B_Reward_Resources = {
    Name = "Reward_Resources",
    Description = {
        en = "Reward: The player receives a given amount of Goods in his store.",
        de = "Lohn: Legt der Partei die angegebenen Rohstoffe ins Lagerhaus.",
        fr = "Récompense: Placez les matières premières indiquées dans l'entrepôt de la faction.",
    },
    Parameter = {
        { ParameterType.RawGoods,   en = "Type of good",    de = "Resourcentyp",        fr = "Type de ressources" },
        { ParameterType.Number,     en = "Amount of good",  de = "Anzahl der Resource", fr = "Nombre de ressources" },
    },
}

function B_Reward_Resources:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 1) then
        self.GoodAmount = _Parameter * 1
    end
end

function B_Reward_Resources:GetRewardTable()
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    return { Reward.Resources, GoodType, self.GoodAmount }
end

RegisterBehavior(B_Reward_Resources);

-- -------------------------------------------------------------------------- --

function Reward_SendCart(...)
    return B_Reward_SendCart:new(...);
end

B_Reward_SendCart = {
    Name = "Reward_SendCart",
    Description = {
        en = "Reward: Sends a cart to a player. It spawns at a building or by replacing an entity. The cart can replace the entity if it's not a building.",
        de = "Lohn: Sendet einen Karren zu einem Spieler. Der Karren wird an einem Gebäude oder einer Entity erstellt. Er ersetzt die Entity, wenn diese kein Gebäude ist.",
        fr = "Récompense: Envoie un chariot à un joueur. Le chariot est créé sur un bâtiment ou une entité. Elle remplace l'entité si celle-ci n'est pas un bâtiment.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script entity",           de = "Script Entity",               fr = "Entité de Script" },
        { ParameterType.PlayerID,   en = "Owning player",           de = "Besitzer",                    fr = "Propriétaire" },
        { ParameterType.Custom,     en = "Type name",               de = "Typbezeichnung",              fr = "Désignation du type" },
        { ParameterType.Custom,     en = "Good type",               de = "Warentyp",                    fr = "Type de marchandise" },
        { ParameterType.Number,     en = "Amount",                  de = "Anzahl",                      fr = "Quantité" },
        { ParameterType.Custom,     en = "Override target player",  de = "Anderer Zielspieler",         fr = "Autre joueur destinataire" },
        { ParameterType.Custom,     en = "Ignore reservations",     de = "Ignoriere Reservierungen",    fr = "Ignorer les réservations" },
        { ParameterType.Custom,     en = "Replace entity",          de = "Entity ersetzen",             fr = "Remplacer une entité" },
    },
}

function B_Reward_SendCart:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_SendCart:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptNameEntity = _Parameter
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 2) then
        self.UnitKey = _Parameter
    elseif (_Index == 3) then
        self.GoodType = _Parameter
    elseif (_Index == 4) then
        self.GoodAmount = _Parameter * 1
    elseif (_Index == 5) then
        self.OverrideTargetPlayer = tonumber(_Parameter)
    elseif (_Index == 6) then
        self.IgnoreReservation = ToBoolean(_Parameter)
    elseif (_Index == 7) then
        self.ReplaceEntity = ToBoolean(_Parameter)
    end
end

function B_Reward_SendCart:CustomFunction(_Quest)

    if not IsExisting( self.ScriptNameEntity ) then
        return false;
    end

    local ID = SendCart(self.ScriptNameEntity, self.PlayerID, Goods[self.GoodType], self.GoodAmount, Entities[self.UnitKey], self.IgnoreReservation);

    if self.ReplaceEntity and Logic.IsBuilding(GetID(self.ScriptNameEntity)) == 0 then
        DestroyEntity(self.ScriptNameEntity);
        Logic.SetEntityName(ID, self.ScriptNameEntity);
    end
    if self.OverrideTargetPlayer then
        Logic.ResourceMerchant_OverrideTargetPlayerID(ID,self.OverrideTargetPlayer);
    end
end

function B_Reward_SendCart:GetCustomData( _Index )
    local Data = {};
    if _Index == 2 then
        Data = { "U_ResourceMerchant", "U_Medicus", "U_Marketer", "U_ThiefCart", "U_GoldCart", "U_Noblemen_Cart", "U_RegaliaCart" };
    elseif _Index == 3 then
        for k, v in pairs( Goods ) do
            if string.find( k, "^G_" ) then
                table.insert( Data, k );
            end
        end
        table.sort( Data );
    elseif _Index == 5 then
        table.insert( Data, "-" );
        for i = 1, 8 do
            table.insert( Data, i );
        end
    elseif _Index == 6 then
        table.insert( Data, "false" );
        table.insert( Data, "true" );
    elseif _Index == 7 then
        table.insert( Data, "false" );
        table.insert( Data, "true" );
    end
    return Data;
end

function B_Reward_SendCart:Debug(_Quest)
    if not IsExisting(self.ScriptNameEntity) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": spawnpoint does not exist!");
        return true;
    elseif not tonumber(self.PlayerID) or self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": got a invalid playerID!");
        return true;
    elseif not Entities[self.UnitKey] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": entity type '"..self.UnitKey.."' is invalid!");
        return true;
    elseif not Goods[self.GoodType] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": good type '"..self.GoodType.."' is invalid!");
        return true;
    elseif not tonumber(self.GoodAmount) or self.GoodAmount < 1 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": good amount can not be below 1!");
        return true;
    elseif tonumber(self.OverrideTargetPlayer) and (self.OverrideTargetPlayer < 1 or self.OverrideTargetPlayer > 8) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": overwrite target player with invalid playerID!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_SendCart);

-- -------------------------------------------------------------------------- --

function Reward_Units(...)
    return B_Reward_Units:new(...)
end

B_Reward_Units = {
    Name = "Reward_Units",
    Description = {
        en = "Reward: Creates units for the quest receiver.",
        de = "Lohn: Erzeugt einige Einheiten für den Auftragnehmer.",
        fr = "Récompense: Unités",
    },
    Parameter = {
        { ParameterType.Entity, en = "Type name", de = "Typbezeichnung", fr ="Désignation de type" },
        { ParameterType.Number, en = "Amount", de = "Anzahl", fr ="Quantité" },
    },
}

function B_Reward_Units:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.EntityName = _Parameter
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1
    end
end

function B_Reward_Units:GetRewardTable()
    return { Reward.Units, assert( Entities[self.EntityName] ), self.Amount }
end

RegisterBehavior(B_Reward_Units);

-- -------------------------------------------------------------------------- --

function Reward_QuestRestart(...)
    return B_Reward_QuestRestart:new(...)
end

B_Reward_QuestRestart = CopyTable(B_Reprisal_QuestRestart);
B_Reward_QuestRestart.Name = "Reward_QuestRestart";
B_Reward_QuestRestart.Description.en = "Reward: Restarts a (completed) quest so it can be triggered and completed again.";
B_Reward_QuestRestart.Description.de = "Lohn: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann.";
B_Reward_QuestRestart.Description.fr = "Récompense: Redémarre une quête (terminée) pour qu'elle puisse être redéclenchée et terminée.";
B_Reward_QuestRestart.GetReprisalTable = nil;

B_Reward_QuestRestart.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestRestart);

-- -------------------------------------------------------------------------- --

function Reward_QuestFailure(...)
    return B_Reward_QuestFailure:new(...)
end

B_Reward_QuestFailure = CopyTable(B_Reprisal_QuestFailure);
B_Reward_QuestFailure.Name = "Reward_QuestFailure";
B_Reward_QuestFailure.Description.en = "Reward: Lets another active quest fail.";
B_Reward_QuestFailure.Description.de = "Lohn: Lässt eine andere aktive Quest fehlschlagen.";
B_Reward_QuestFailure.Description.fr = "Récompense: Fait échouer une autre quête active.";
B_Reward_QuestFailure.GetReprisalTable = nil;

B_Reward_QuestFailure.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestFailure);

-- -------------------------------------------------------------------------- --

function Reward_QuestSuccess(...)
    return B_Reward_QuestSuccess:new(...)
end

B_Reward_QuestSuccess = CopyTable(B_Reprisal_QuestSuccess);
B_Reward_QuestSuccess.Name = "Reward_QuestSuccess";
B_Reward_QuestSuccess.Description.en = "Reward: Completes another active quest successfully.";
B_Reward_QuestSuccess.Description.de = "Lohn: Beendet eine andere aktive Quest erfolgreich.";
B_Reward_QuestSuccess.Description.fr = "Récompense: Termine avec succès une autre quête active.";
B_Reward_QuestSuccess.GetReprisalTable = nil;

B_Reward_QuestSuccess.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestSuccess);

-- -------------------------------------------------------------------------- --

function Reward_QuestActivate(...)
    return B_Reward_QuestActivate:new(...)
end

B_Reward_QuestActivate = CopyTable(B_Reprisal_QuestActivate);
B_Reward_QuestActivate.Name = "Reward_QuestActivate";
B_Reward_QuestActivate.Description.en = "Reward: Activates another quest that is not triggered yet.";
B_Reward_QuestActivate.Description.de = "Lohn: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.";
B_Reward_QuestActivate.Description.fr = "Récompense: Active une autre quête qui n'a pas encore été déclenchée.";
B_Reward_QuestActivate.GetReprisalTable = nil;

B_Reward_QuestActivate.GetRewardTable = function(self, _Quest)
    return {Reward.Custom, {self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestActivate)

-- -------------------------------------------------------------------------- --

function Reward_QuestInterrupt(...)
    return B_Reward_QuestInterrupt:new(...)
end

B_Reward_QuestInterrupt = CopyTable(B_Reprisal_QuestInterrupt);
B_Reward_QuestInterrupt.Name = "Reward_QuestInterrupt";
B_Reward_QuestInterrupt.Description.en = "Reward: Interrupts another active quest without success or failure.";
B_Reward_QuestInterrupt.Description.de = "Lohn: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg.";
B_Reward_QuestInterrupt.Description.fr = "Récompense: Termine une autre quête active sans succès ni échec.";
B_Reward_QuestInterrupt.GetReprisalTable = nil;

B_Reward_QuestInterrupt.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestInterrupt);

-- -------------------------------------------------------------------------- --

function Reward_QuestForceInterrupt(...)
    return B_Reward_QuestForceInterrupt:new(...)
end

B_Reward_QuestForceInterrupt = CopyTable(B_Reprisal_QuestForceInterrupt);
B_Reward_QuestForceInterrupt.Name = "Reward_QuestForceInterrupt";
B_Reward_QuestForceInterrupt.Description.en = "Reward: Interrupts another quest (even when it isn't active yet) without success or failure.";
B_Reward_QuestForceInterrupt.Description.de = "Lohn: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg.";
B_Reward_QuestForceInterrupt.Description.fr = "Récompense: Termine une autre quête, même si elle n'est pas encore active, sans succès ni échec.";
B_Reward_QuestForceInterrupt.GetReprisalTable = nil;

B_Reward_QuestForceInterrupt.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_QuestForceInterrupt);

-- -------------------------------------------------------------------------- --

function Reward_CustomVariables(...)
    return B_Reward_CustomVariables:new(...);
end

B_Reward_CustomVariables = CopyTable(B_Reprisal_CustomVariables);
B_Reward_CustomVariables.Name = "Reward_CustomVariables";
B_Reward_CustomVariables.Description.en = "Reward: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.";
B_Reward_CustomVariables.Description.de = "Lohn: Führt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.";
B_Reward_CustomVariables.Description.fr = "Récompense: Effectue une opération mathématique sur la variable. L'autre opérateur peut être un nombre ou une variable personnalisée.";
B_Reward_CustomVariables.GetReprisalTable = nil;

B_Reward_CustomVariables.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} };
end

RegisterBehavior(B_Reward_CustomVariables)

-- -------------------------------------------------------------------------- --

function Reward_MapScriptFunction(...)
    return B_Reward_MapScriptFunction:new(...);
end

B_Reward_MapScriptFunction = CopyTable(B_Reprisal_MapScriptFunction);
B_Reward_MapScriptFunction.Name = "Reward_MapScriptFunction";
B_Reward_MapScriptFunction.Description.en = "Reward: Calls a function within the global map script if the quest has failed.";
B_Reward_MapScriptFunction.Description.de = "Lohn: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.";
B_Reward_MapScriptFunction.Description.fr = "Récompense: Invoque une fonction dans le script global de la carte en cas d'échec de la quête.";
B_Reward_MapScriptFunction.GetReprisalTable = nil;

B_Reward_MapScriptFunction.GetRewardTable = function(self, _Quest)
    return {Reward.Custom, {self, self.CustomFunction}};
end

RegisterBehavior(B_Reward_MapScriptFunction);

-- -------------------------------------------------------------------------- --

function Reward_Technology(...)
    return B_Reward_Technology:new(...);
end

B_Reward_Technology = CopyTable(B_Reprisal_Technology);
B_Reward_Technology.Name = "Reward_Technology";
B_Reward_Technology.Description.en = "Reward: Locks or unlocks a technology for the given player.";
B_Reward_Technology.Description.de = "Lohn: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player.";
B_Reward_Technology.Description.fr = "Récompense: Bloque ou autorise une technologie pour le joueur spécifié.";
B_Reward_Technology.GetReprisalTable = nil;

B_Reward_Technology.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_Technology);

-- -------------------------------------------------------------------------- --

function Reward_PrestigePoints(...)
    return B_Reward_PrestigePoints:mew(...);
end

B_Reward_PrestigePoints  = {
    Name = "Reward_PrestigePoints",
    Description = {
        en = "Reward: Gives the quest receiver prestige.",
        de = "Lohn: Gibt dem Auftragnehmer Prestige.",
        fr = "Récompense: Prestige",
    },
    Parameter = {
        { ParameterType.Number, en = "Points", de = "Punkte", fr = "Points" },
    },
}

function B_Reward_PrestigePoints :AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Points = _Parameter
    end
end

function B_Reward_PrestigePoints :GetRewardTable()
    return { Reward.PrestigePoints, self.Points }
end

RegisterBehavior(B_Reward_PrestigePoints);

-- -------------------------------------------------------------------------- --

function Reward_AI_MountOutpost(...)
    return B_Reward_AI_MountOutpost:new(...);
end

B_Reward_AI_MountOutpost = {
    Name = "Reward_AI_MountOutpost",
    Description = {
        en = "Reward: Places a troop of soldiers on a named outpost.",
        de = "Lohn: Platziert einen Trupp Soldaten auf einem Aussenposten der KI.",
        fr = "Récompense: Place un groupe de soldats sur un avant-poste de l'IA.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name",   de = "Skriptname",  fr = "Nom de l'entité" },
        { ParameterType.Custom,     en = "Soldiers type", de = "Soldatentyp", fr = "Type de soldat" },
    },
}

function B_Reward_AI_MountOutpost:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_AI_MountOutpost:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Scriptname = _Parameter
    else
        self.SoldiersType = _Parameter
    end
end

function B_Reward_AI_MountOutpost:CustomFunction(_Quest)
    local outpostID = assert(
        not Logic.IsEntityDestroyed(self.Scriptname) and GetID(self.Scriptname),
       _Quest.Identifier .. ": Error in " .. self.Name .. ": CustomFunction: Outpost is invalid"
    )
    local AIPlayerID = Logic.EntityGetPlayer(outpostID)
    local ax, ay = Logic.GetBuildingApproachPosition(outpostID)
    local TroopID = Logic.CreateBattalionOnUnblockedLand(Entities[self.SoldiersType], ax, ay, 0, AIPlayerID, 0)
    AICore.HideEntityFromAI(AIPlayerID, TroopID, true)
    Logic.CommandEntityToMountBuilding(TroopID, outpostID)
end

function B_Reward_AI_MountOutpost:GetCustomData(_Index)
    if _Index == 1 then
        local Data = {}
        for k,v in pairs(Entities) do
            if string.find(k, "U_MilitaryBandit") or string.find(k, "U_MilitarySword") or string.find(k, "U_MilitaryBow") then
                Data[#Data+1] = k
            end
        end
        return Data
    end
end

function B_Reward_AI_MountOutpost:Debug(_Quest)
    if Logic.IsEntityDestroyed(self.Scriptname) then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Outpost " .. self.Scriptname .. " is missing")
        return true
    end
end

RegisterBehavior(B_Reward_AI_MountOutpost)

-- -------------------------------------------------------------------------- --

function Reward_QuestRestartForceActive(...)
    return B_Reward_QuestRestartForceActive:new(...);
end

B_Reward_QuestRestartForceActive = {
    Name = "Reward_QuestRestartForceActive",
    Description = {
        en = "Reward: Restarts a (completed) quest and triggers it immediately.",
        de = "Lohn: Startet eine (beendete) Quest neu und triggert sie sofort.",
        fr = "Récompense: Redémarre une quête (terminée) et la déclenche immédiatement.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name", de = "Questname", fr = "Nom de la quête" },
    },
}

function B_Reward_QuestRestartForceActive:GetRewardTable()
    return { Reward.Custom,{self, self.CustomFunction} }
end

function B_Reward_QuestRestartForceActive:AddParameter(_Index, _Parameter)
    self.QuestName = _Parameter
end

function B_Reward_QuestRestartForceActive:CustomFunction(_Quest)
    local QuestID, Quest = self:ResetQuest(_Quest);
    if QuestID then
        Quest:SetMsgKeyOverride();
        Quest:SetIconOverride();
        Quest:Trigger();
    end
end

B_Reward_QuestRestartForceActive.ResetQuest = B_Reward_QuestRestart.CustomFunction;
function B_Reward_QuestRestartForceActive:Debug(_Quest)
    if not Quests[GetQuestID(self.QuestName)] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Quest: "..  self.QuestName .. " does not exist");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_QuestRestartForceActive)

-- -------------------------------------------------------------------------- --

function Reward_UpgradeBuilding(...)
    return B_Reward_UpgradeBuilding:new(...);
end

B_Reward_UpgradeBuilding = {
    Name = "Reward_UpgradeBuilding",
    Description = {
        en = "Reward: Upgrades a building",
        de = "Lohn: Baut ein Gebäude aus",
        fr = "Récompense: Améliore un Bâtiment",
    },
    Parameter =    {
        { ParameterType.ScriptName, en = "Building", de = "Gebäude", fr = "Bâtiment" }
    }
};

function B_Reward_UpgradeBuilding:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction}};
end

function B_Reward_UpgradeBuilding:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Building = _Parameter;
    end
end

function B_Reward_UpgradeBuilding:CustomFunction(_Quest)
    local building = GetID(self.Building);
    if building ~= 0
    and Logic.IsBuilding(building) == 1
    and Logic.IsBuildingUpgradable(building, true)
    and Logic.IsBuildingUpgradable(building, false)
    then
        Logic.UpgradeBuilding(building);
    end
end

function B_Reward_UpgradeBuilding:Debug(_Quest)
    local building = GetID(self.Building);
    if not (building ~= 0
            and Logic.IsBuilding(building) == 1
            and Logic.IsBuildingUpgradable(building, true)
            and Logic.IsBuildingUpgradable(building, false) )
    then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Building is wrong")
        return true
    end
end

RegisterBehavior(B_Reward_UpgradeBuilding)

-- -------------------------------------------------------------------------- --

function Reward_SetBuildingUpgradeLevel(...)
    return B_Reward_SetBuildingUpgradeLevel:new(...);
end

B_Reward_SetBuildingUpgradeLevel = {
    Name = "Reward_SetBuildingUpgradeLevel",
    Description = {
        en = "Reward: Sets the upgrade level of the specified building.",
        de = "Lohn: Legt das Upgrade-Level eines Gebaeudes fest.",
        fr = "Récompense: Définit le niveau d'amélioration d'un bâtiment.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Building",        de = "Gebäude",         fr = "Bâtiment" },
        { ParameterType.Custom,     en = "Upgrade level",   de = "Upgrade-Level",   fr = "Niveau d'amélioration" },
    }
};

function B_Reward_SetBuildingUpgradeLevel:GetRewardTable()
    return {Reward.Custom, self, self.CustomFunction};
end

function B_Reward_SetBuildingUpgradeLevel:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.Building = _Parameter;
    elseif _Index == 1 then
        self.UpgradeLevel = tonumber(_Parameter);
    end
end

function B_Reward_SetBuildingUpgradeLevel:CustomFunction()
    local building = Logic.GetEntityIDByName(self.Building);
    local upgradeLevel = Logic.GetUpgradeLevel(building);
    local maxUpgradeLevel = Logic.GetMaxUpgradeLevel(building);
    if building ~= 0 
    and Logic.IsBuilding(building) == 1
    and (Logic.IsBuildingUpgradable(building, true)
    or (maxUpgradeLevel ~= 0 
    and maxUpgradeLevel == upgradeLevel))
    then
        Logic.SetUpgradableBuildingState(building, math.min(self.UpgradeLevel, maxUpgradeLevel), 0);
    end
end

function B_Reward_SetBuildingUpgradeLevel:Debug(_Quest)
    local building = Logic.GetEntityIDByName( self.Building )
    if not building or Logic.IsBuilding(building) == 0  then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Building " .. self.Building .. " is missing or no building.")
        return true
    elseif not self.UpgradeLevel or self.UpgradeLevel < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Upgrade level is wrong")
        return true
    end
end

function B_Reward_SetBuildingUpgradeLevel:GetCustomData(_Index)
    if _Index == 1 then
        return { "0", "1", "2", "3" };
    end
end

RegisterBehavior(B_Reward_SetBuildingUpgradeLevel);

-- -------------------------------------------------------------------------- --

function Trigger_PlayerDiscovered(...)
    return B_Trigger_PlayerDiscovered:new(...);
end

B_Trigger_PlayerDiscovered = {
    Name = "Trigger_PlayerDiscovered",
    Description = {
        en = "Trigger: if a given player has been discovered",
        de = "Auslöser: wenn ein angegebener Spieler entdeckt wurde",
        fr = "Déclencheur: lorsqu'un joueur spécifié est découvert",
    },
    Parameter = {
        { ParameterType.PlayerID, en = "Player", de = "Spieler", fr = "Joueur" },
    },
}

function B_Trigger_PlayerDiscovered:GetTriggerTable()
    return {Triggers.PlayerDiscovered, self.PlayerID}
end

function B_Trigger_PlayerDiscovered:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1;
    end
end

RegisterBehavior(B_Trigger_PlayerDiscovered);

-- -------------------------------------------------------------------------- --

function Trigger_OnDiplomacy(...)
    return B_Trigger_OnDiplomacy:new(...);
end

B_Trigger_OnDiplomacy = {
    Name = "Trigger_OnDiplomacy",
    Description = {
        en = "Trigger: if diplomatic relations have been established with a player",
        de = "Auslöser: wenn ein angegebener Diplomatie-Status mit einem Spieler erreicht wurde.",
        fr = "Déclencheur: lorsqu'un statut diplomatique spécifié a été atteint avec un joueur.",
    },
    Parameter = {
        { ParameterType.PlayerID,       en = "Player",      de = "Spieler",     fr = "Joueur" },
        { ParameterType.DiplomacyState, en = "Relation",    de = "Beziehung",   fr = "Relation diplomatique" },
    },
}

function B_Trigger_OnDiplomacy:GetTriggerTable()
    return {Triggers.Diplomacy, self.PlayerID, assert( DiplomacyStates[self.DiplState] ) }
end

function B_Trigger_OnDiplomacy:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.DiplState = _Parameter
    end
end

RegisterBehavior(B_Trigger_OnDiplomacy);

-- -------------------------------------------------------------------------- --

function Trigger_OnNeedUnsatisfied(...)
    return B_Trigger_OnNeedUnsatisfied:new(...);
end

B_Trigger_OnNeedUnsatisfied = {
    Name = "Trigger_OnNeedUnsatisfied",
    Description = {
        en = "Trigger: if a specified need is unsatisfied",
        de = "Auslöser: wenn ein bestimmtes Beduerfnis nicht befriedigt ist.",
        fr = "Déclencheur: lorsqu'un certain besoin n'est pas satisfait.",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "Player",              de = "Spieler",             fr = "Joueur" },
        { ParameterType.Need,       en = "Need",                de = "Beduerfnis",          fr = "Besoin" },
        { ParameterType.Number,     en = "Workers on strike",   de = "Streikende Arbeiter", fr = "Travailleurs en grève" },
    },
}

function B_Trigger_OnNeedUnsatisfied:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnNeedUnsatisfied:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.Need = _Parameter
    elseif (_Index == 2) then
        self.WorkersOnStrike = _Parameter * 1
    end
end

function B_Trigger_OnNeedUnsatisfied:CustomFunction(_Quest)
    return Logic.GetNumberOfStrikingWorkersPerNeed( self.PlayerID, Needs[self.Need] ) >= self.WorkersOnStrike
end

function B_Trigger_OnNeedUnsatisfied:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": " .. self.PlayerID .. " does not exist.")
        return true
    elseif not Needs[self.Need] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": " .. self.Need .. " does not exist.")
        return true
    elseif self.WorkersOnStrike < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": WorkersOnStrike value negative")
        return true
    end
    return false;
end

RegisterBehavior(B_Trigger_OnNeedUnsatisfied);

-- -------------------------------------------------------------------------- --

function Trigger_OnResourceDepleted(...)
    return B_Trigger_OnResourceDepleted:new(...);
end

B_Trigger_OnResourceDepleted = {
    Name = "Trigger_OnResourceDepleted",
    Description = {
        en = "Trigger: if a resource is (temporarily) depleted",
        de = "Auslöser: wenn eine Ressource (zeitweilig) verbraucht ist",
        fr = "Déclencheur: lorsqu'une ressource est (temporairement) consommée",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname", fr = "Nom de script" },
    },
}

function B_Trigger_OnResourceDepleted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnResourceDepleted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.ScriptName = _Parameter
    end
end

function B_Trigger_OnResourceDepleted:CustomFunction(_Quest)
    local ID = GetID(self.ScriptName)
    return not ID or ID == 0 or Logic.GetResourceDoodadGoodType(ID) == 0 or Logic.GetResourceDoodadGoodAmount(ID) == 0
end

RegisterBehavior(B_Trigger_OnResourceDepleted);

-- -------------------------------------------------------------------------- --

function Trigger_OnAmountOfGoods(...)
    return B_Trigger_OnAmountOfGoods:new(...);
end

B_Trigger_OnAmountOfGoods = {
    Name = "Trigger_OnAmountOfGoods",
    Description = {
        en = "Trigger: if the player has gathered a given amount of resources in his storehouse",
        de = "Auslöser: wenn der Spieler eine bestimmte Menge einer Ressource in seinem Lagerhaus hat",
        fr = "Déclencheur: lorsque le joueur a une certaine quantité d'une ressource dans son entrepôt",
    },
    Parameter = {
        { ParameterType.PlayerID,   en = "Player",          de = "Spieler",             fr = "Joueur" },
        { ParameterType.RawGoods,   en = "Type of good",    de = "Resourcentyp",        fr = "Type de ressources" },
        { ParameterType.Number,     en = "Amount of good",  de = "Anzahl der Resource", fr = "Quantité de ressources" },
    },
}

function B_Trigger_OnAmountOfGoods:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnAmountOfGoods:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.PlayerID = _Parameter * 1
    elseif (_Index == 1) then
        self.GoodTypeName = _Parameter
    elseif (_Index == 2) then
        self.GoodAmount = _Parameter * 1
    end
end

function B_Trigger_OnAmountOfGoods:CustomFunction(_Quest)
    local StoreHouseID = Logic.GetStoreHouse(self.PlayerID)
    if (StoreHouseID == 0) then
        return false
    end
    local GoodType = Logic.GetGoodTypeID(self.GoodTypeName)
    local GoodAmount = Logic.GetAmountOnOutStockByGoodType(StoreHouseID, GoodType)
    if (GoodAmount >= self.GoodAmount)then
        return true
    end
    return false
end

function B_Trigger_OnAmountOfGoods:Debug(_Quest)
    if Logic.GetStoreHouse(self.PlayerID) == 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": " .. self.PlayerID .. " does not exist.")
        return true
    elseif not Goods[self.GoodTypeName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Good type is wrong.")
        return true
    elseif self.GoodAmount < 0 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Good amount is negative.")
        return true
    end
    return false;
end

RegisterBehavior(B_Trigger_OnAmountOfGoods);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestActive(...)
    return B_Trigger_OnQuestActiveWait:new(...);
end
Trigger_OnQuestActiveWait = Trigger_OnQuestActive;

B_Trigger_OnQuestActiveWait = {
    Name = "Trigger_OnQuestActiveWait",
    Description = {
        en = "Trigger: if a given quest has been activated. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest aktiviert wurde. Optional mit Wartezeit",
        fr = "Déclencheur: lorsqu'une quête indiquée a été activée. En option avec délai d'attente",
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente" },
    },
}

function B_Trigger_OnQuestActiveWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestActiveWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestActiveWait:CustomFunction(_Quest)
    local QuestID = GetQuestID(self.QuestName)
    if QuestID ~= nil then
        assert(type(QuestID) == "number");

        if (Quests[QuestID].State == QuestState.Active) then
            self.WasActivated = self.WasActivated or true;
        end
        if self.WasActivated then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestActiveWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestActiveWait:Interrupt(_Quest)
    -- does this realy matter after interrupt?
    -- self.WaitTimeTimer = nil;
    -- self.WasActivated = nil;
end

function B_Trigger_OnQuestActiveWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
    self.WasActivated = nil;
end

RegisterBehavior(B_Trigger_OnQuestActiveWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestActive = CopyTable(B_Trigger_OnQuestActiveWait);
B_Trigger_OnQuestActive.Name = "Trigger_OnQuestActive";
B_Trigger_OnQuestActive.Description.en = "Trigger: Starts the quest after another has been activated.";
B_Trigger_OnQuestActive.Description.de = "Auslöser: Startet den Quest, wenn ein anderer aktiviert wird.";
B_Trigger_OnQuestActive.Description.fr = "Déclencheur: Démarre la quête lorsqu'une autre est activée.";
B_Trigger_OnQuestActive.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestActive:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

RegisterBehavior(B_Trigger_OnQuestActive);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestFailure(...)
    return B_Trigger_OnQuestFailureWait:new(...);
end
Trigger_OnQuestFailureWait = Trigger_OnQuestFailure;

B_Trigger_OnQuestFailureWait = {
    Name = "Trigger_OnQuestFailureWait",
    Description = {
        en = "Trigger: if a given quest has failed. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest fehlgeschlagen ist. Optional mit Wartezeit",
        fr = "Déclencheur: lorsqu'une quête indiquée a échoué. En option avec délai d'attente",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,    en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente" },
    },
}

function B_Trigger_OnQuestFailureWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestFailureWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestFailureWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].Result == QuestResult.Failure) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestFailureWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestFailureWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestFailureWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

RegisterBehavior(B_Trigger_OnQuestFailureWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestFailure = CopyTable(B_Trigger_OnQuestFailureWait);
B_Trigger_OnQuestFailure.Name = "Trigger_OnQuestFailure";
B_Trigger_OnQuestFailure.Description.en = "Trigger: Starts the quest after another has failed.";
B_Trigger_OnQuestFailure.Description.de = "Auslöser: Startet den Quest, wenn ein anderer fehlschlägt.";
B_Trigger_OnQuestFailure.Description.fr = "Déclencheur: Lance la quête lorsqu'une autre échoue.";
B_Trigger_OnQuestFailure.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestFailure:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

RegisterBehavior(B_Trigger_OnQuestFailure);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestNotTriggered(...)
    return B_Trigger_OnQuestNotTriggered:new(...);
end

B_Trigger_OnQuestNotTriggered = {
    Name = "Trigger_OnQuestNotTriggered",
    Description = {
        en = "Trigger: if a given quest is not yet active. Should be used in combination with other triggers.",
        de = "Auslöser: wenn eine angegebene Quest noch inaktiv ist. Sollte mit weiteren Triggern kombiniert werden.",
        fr = "Déclencheur: lorsqu'une quête indiquée est encore inactive. Doit être combiné avec d'autres déclencheurs."
    },
    Parameter = {
        { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
    },
}

function B_Trigger_OnQuestNotTriggered:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestNotTriggered:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    end
end

function B_Trigger_OnQuestNotTriggered:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.NotTriggered) then
            return true;
        end
    end
    return false;
end

function B_Trigger_OnQuestNotTriggered:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_OnQuestNotTriggered);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestInterrupted(...)
    return B_Trigger_OnQuestInterruptedWait:new(...);
end
Trigger_OnQuestInterruptedWait = Trigger_OnQuestInterrupted;

B_Trigger_OnQuestInterruptedWait = {
    Name = "Trigger_OnQuestInterruptedWait",
    Description = {
        en = "Trigger: if a given quest has been interrupted. Should be used in combination with other triggers.",
        de = "Auslöser: wenn eine angegebene Quest abgebrochen wurde. Sollte mit weiteren Triggern kombiniert werden.",
        fr = "Déclencheur: lorsqu'une quête indiquée a été interrompue. Doit être combiné avec d'autres déclencheurs."
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente"},
    },
}

function B_Trigger_OnQuestInterruptedWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestInterruptedWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestInterruptedWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result == QuestResult.Interrupted) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestInterruptedWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestInterruptedWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestInterruptedWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

RegisterBehavior(B_Trigger_OnQuestInterruptedWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestInterrupted = CopyTable(B_Trigger_OnQuestInterruptedWait);
B_Trigger_OnQuestInterrupted.Name = "Trigger_OnQuestInterrupted";
B_Trigger_OnQuestInterrupted.Description.en = "Trigger: Starts the quest after another is interrupted.";
B_Trigger_OnQuestInterrupted.Description.de = "Auslöser: Startet den Quest, wenn ein anderer abgebrochen wurde.";
B_Trigger_OnQuestInterrupted.Description.fr = "Déclencheur: Démarre la quête lorsqu'une autre a été annulée.";
B_Trigger_OnQuestInterrupted.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestInterrupted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

RegisterBehavior(B_Trigger_OnQuestInterrupted);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestOver(...)
    return B_Trigger_OnQuestOverWait:new(...);
end
Trigger_OnQuestOverWait = Trigger_OnQuestOver;

B_Trigger_OnQuestOverWait = {
    Name = "Trigger_OnQuestOverWait",
    Description = {
        en = "Trigger: if a given quest has been finished, regardless of its result. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest beendet wurde, unabhängig von deren Ergebnis. Wartezeit optional",
        fr = "Déclencheur: lorsqu'une quête indiquée est terminée, indépendamment de son résultat. Délai d'attente optionnel"
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente"},
    },
}

function B_Trigger_OnQuestOverWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestOverWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestOverWait:CustomFunction(_Quest)
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].State == QuestState.Over and Quests[QuestID].Result ~= QuestResult.Interrupted) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestOverWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waitTime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestOverWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestOverWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

RegisterBehavior(B_Trigger_OnQuestOverWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestOver = CopyTable(B_Trigger_OnQuestOverWait);
B_Trigger_OnQuestOver.Name = "Trigger_OnQuestOver";
B_Trigger_OnQuestOver.Description.en = "Trigger: Starts the quest after another finished.";
B_Trigger_OnQuestOver.Description.de = "Auslöser: Startet den Quest, wenn ein anderer abgeschlossen wurde.";
B_Trigger_OnQuestOver.Description.fr = "Déclencheur: Démarre la quête lorsqu'une autre est terminée.";
B_Trigger_OnQuestOver.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestOver:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

RegisterBehavior(B_Trigger_OnQuestOver);

-- -------------------------------------------------------------------------- --

function Trigger_OnQuestSuccess(...)
    return B_Trigger_OnQuestSuccessWait:new(...);
end
Trigger_OnQuestSuccessWait = Trigger_OnQuestSuccess;

B_Trigger_OnQuestSuccessWait = {
    Name = "Trigger_OnQuestSuccessWait",
    Description = {
        en = "Trigger: if a given quest has been finished successfully. Waiting time optional",
        de = "Auslöser: wenn eine angegebene Quest erfolgreich abgeschlossen wurde. Wartezeit optional",
        fr = "Déclencheur: lorsqu'une quête indiquée a été accomplie avec succès. Délai d'attente optionnel",
    },
    Parameter = {
        { ParameterType.QuestName,  en = "Quest name",   de = "Questname", fr = "Nom de la quête" },
        { ParameterType.Number,     en = "Waiting time", de = "Wartezeit", fr = "Temps d'attente" },
    },
}

function B_Trigger_OnQuestSuccessWait:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnQuestSuccessWait:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter
    elseif (_Index == 1) then
        self.WaitTime = (_Parameter ~= nil and tonumber(_Parameter)) or 0
    end
end

function B_Trigger_OnQuestSuccessWait:CustomFunction()
    if (GetQuestID(self.QuestName) ~= nil) then
        local QuestID = GetQuestID(self.QuestName)
        if (Quests[QuestID].Result == QuestResult.Success) then
            if self.WaitTime and self.WaitTime > 0 then
                self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
                if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                    return true;
                end
            else
                return true;
            end
        end
    end
    return false;
end

function B_Trigger_OnQuestSuccessWait:Debug(_Quest)
    if type(self.QuestName) ~= "string" then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": invalid quest name!");
        return true;
    elseif self.WaitTime and (type(self.WaitTime) ~= "number" or self.WaitTime < 0) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": waittime must be a number!");
        return true;
    end
    return false;
end

function B_Trigger_OnQuestSuccessWait:Interrupt(_Quest)
    self.WaitTimeTimer = nil;
end

function B_Trigger_OnQuestSuccessWait:Reset(_Quest)
    self.WaitTimeTimer = nil;
end

RegisterBehavior(B_Trigger_OnQuestSuccessWait);

-- -------------------------------------------------------------------------- --

-- Kompatibelitätsmodus
B_Trigger_OnQuestSuccess = CopyTable(B_Trigger_OnQuestSuccessWait);
B_Trigger_OnQuestSuccess.Name = "Trigger_OnQuestSuccess";
B_Trigger_OnQuestSuccess.Description.en = "Trigger: Starts the quest after another finished successfully.";
B_Trigger_OnQuestSuccess.Description.de = "Auslöser: Startet den Quest, wenn ein anderer erfolgreich abgeschlossen wurde.";
B_Trigger_OnQuestSuccess.Description.de = "Déclencheur: Démarre la quête lorsqu'une autre a été accomplie avec succès.";
B_Trigger_OnQuestSuccess.Parameter = {
    { ParameterType.QuestName,     en = "Quest name", de = "Questname", fr = "Nom de la quête" },
}

function B_Trigger_OnQuestSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.QuestName = _Parameter;
        self.WaitTime = 0;
    end
end

RegisterBehavior(B_Trigger_OnQuestSuccess);

-- -------------------------------------------------------------------------- --

function Trigger_CustomVariables(...)
    return B_Trigger_CustomVariables:new(...);
end

B_Trigger_CustomVariables = {
    Name = "Trigger_CustomVariables",
    Description = {
        en = "Trigger: if the variable has a certain value.",
        de = "Auslöser: wenn die Variable einen bestimmen Wert eingenommen hat.",
        fr = "Déclencheur: lorsque la variable a pris une valeur déterminée."
    },
    Parameter = {
        { ParameterType.Default, en = "Name of Variable",   de = "Variablennamen",  fr = "Noms de variables" },
        { ParameterType.Custom,  en = "Relation",           de = "Relation",        fr = "Relation" },
        { ParameterType.Default, en = "Value",              de = "Wert",            fr = "Valeur" }
    }
};

function B_Trigger_CustomVariables:GetTriggerTable()
    return { Triggers.Custom2, {self, self.CustomFunction} };
end

function B_Trigger_CustomVariables:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.VariableName = _Parameter
    elseif _Index == 1 then
        self.Relation = _Parameter
    elseif _Index == 2 then
        local value = tonumber(_Parameter);
        value = (value ~= nil and value) or _Parameter;
        self.Value = value
    end
end

function B_Trigger_CustomVariables:CustomFunction()
    local Value1 = ObtainCustomVariable("BehaviorVariable_" ..self.VariableName, 0);
    local Value2 = self.Value;
    if type(self.Value) == "string" then
        Value2 = ObtainCustomVariable("BehaviorVariable_" ..self.Value, 0);
    end

    if self.Relation == "==" then
        return Value1 == Value2;
    elseif self.Relation ~= "~=" then
        return Value1 ~= Value2;
    elseif self.Relation == ">" then
        return Value1 > Value2;
    elseif self.Relation == ">=" then
        return Value1 >= Value2;
    elseif self.Relation == "<=" then
        return Value1 <= Value2;
    else
        return Value1 < Value2;
    end
    return false;
end

function B_Trigger_CustomVariables:GetCustomData( _Index )
    if _Index == 1 then
        return {"==", "~=", "<=", "<", ">", ">="};
    end
end

function B_Trigger_CustomVariables:Debug(_Quest)
    local relations = {"==", "~=", "<=", "<", ">", ">="}
    local results    = {true, false, nil}

    if not ObtainCustomVariable("BehaviorVariable_" ..self.VariableName) then
        warn(false, _Quest.Identifier.. ": " ..self.Name..": variable '"..self.VariableName.."' do not exist!");
    end
    if not table.contains(relations, self.Relation) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": '"..self.Relation.."' is an invalid relation!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_CustomVariables)

-- -------------------------------------------------------------------------- --

function Trigger_AlwaysActive()
    return B_Trigger_AlwaysActive:new()
end

B_Trigger_AlwaysActive = {
    Name = "Trigger_AlwaysActive",
    Description = {
        en = "Trigger: the map has been started.",
        de = "Auslöser: Start der Karte.",
        fr = "Déclencheur: Démarrage de la carte.",
    },
}

function B_Trigger_AlwaysActive:GetTriggerTable()
    return {Triggers.Time, 0 }
end

RegisterBehavior(B_Trigger_AlwaysActive);

-- -------------------------------------------------------------------------- --

function Trigger_OnMonth(...)
    return B_Trigger_OnMonth:new(...);
end

B_Trigger_OnMonth = {
    Name = "Trigger_OnMonth",
    Description = {
        en = "Trigger: a specified month",
        de = "Auslöser: ein bestimmter Monat",
        fr = "Déclencheur: un mois donné"
    },
    Parameter = {
        { ParameterType.Custom, en = "Month", de = "Monat", fr = "Mois" },
    },
}

function B_Trigger_OnMonth:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnMonth:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Month = _Parameter * 1
    end
end

function B_Trigger_OnMonth:CustomFunction(_Quest)
    return self.Month == Logic.GetCurrentMonth()
end

function B_Trigger_OnMonth:GetCustomData( _Index )
    local Data = {}
    if _Index == 0 then
        for i = 1, 12 do
            table.insert( Data, i )
        end
    else
        assert( false )
    end
    return Data
end

function B_Trigger_OnMonth:Debug(_Quest)
    if self.Month < 1 or self.Month > 12 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Month has the wrong value")
        return true
    end
    return false;
end

RegisterBehavior(B_Trigger_OnMonth);

-- -------------------------------------------------------------------------- --

function Trigger_OnMonsoon()
    return B_Trigger_OnMonsoon:new();
end

B_Trigger_OnMonsoon = {
    Name = "Trigger_OnMonsoon",
    Description = {
        en = "Trigger: on monsoon.",
        de = "Auslöser: wenn der Monsun beginnt.",
        fr = "Déclencheur: lorsque la mousson commence.",
    },
    RequiresExtraNo = 1,
}

function B_Trigger_OnMonsoon:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnMonsoon:CustomFunction(_Quest)
    if Logic.GetWeatherDoesShallowWaterFlood(0) then
        return true
    end
end

RegisterBehavior(B_Trigger_OnMonsoon);

-- -------------------------------------------------------------------------- --

function Trigger_Time(...)
    return B_Trigger_Time:new(...);
end

B_Trigger_Time = {
    Name = "Trigger_Time",
    Description = {
        en = "Trigger: a given amount of time since map start",
        de = "Auslöser: eine gewisse Anzahl Sekunden nach Spielbeginn",
        fr = "Déclencheur: un certain nombre de secondes après le début du jeu",
    },
    Parameter = {
        { ParameterType.Number, en = "Time (sec.)", de = "Zeit (Sek.)", fr = "Temps (sec.)" },
    },
}

function B_Trigger_Time:GetTriggerTable()
    return {Triggers.Time, self.Time }
end

function B_Trigger_Time:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Time = _Parameter * 1
    end
end

RegisterBehavior(B_Trigger_Time);

-- -------------------------------------------------------------------------- --

function Trigger_OnWaterFreezes()
    return B_Trigger_OnWaterFreezes:new();
end

B_Trigger_OnWaterFreezes = {
    Name = "Trigger_OnWaterFreezes",
    Description = {
        en = "Trigger: if the water starts freezing",
        de = "Auslöser: wenn die Gewässer gefrieren",
        fr = "Déclencheur: lorsque les eaux gèlent",
    },
}

function B_Trigger_OnWaterFreezes:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnWaterFreezes:CustomFunction(_Quest)
    if Logic.GetWeatherDoesWaterFreeze(0) then
        return true
    end
end

RegisterBehavior(B_Trigger_OnWaterFreezes);

-- -------------------------------------------------------------------------- --

function Trigger_NeverTriggered()
    return B_Trigger_NeverTriggered:new();
end

B_Trigger_NeverTriggered = {
    Name = "Trigger_NeverTriggered",
    Description = {
        en = "Trigger: Never triggers a Quest. The quest may be set active by Reward_QuestActivate or Reward_QuestRestartForceActive",
        de = "Auslöser: Löst nie eine Quest aus. Die Quest kann von Reward_QuestActivate oder Reward_QuestRestartForceActive aktiviert werden.",
        fr = "Déclencheur: Ne déclenche jamais de quête. La quête peut être activée par Reward_QuestActivate ou Reward_QuestRestartForceActive.",
    },
}

function B_Trigger_NeverTriggered:GetTriggerTable()

    return {Triggers.Custom2, {self, function() end} }

end

RegisterBehavior(B_Trigger_NeverTriggered)

-- -------------------------------------------------------------------------- --

function Trigger_OnAtLeastOneQuestFailure(...)
    return B_Trigger_OnAtLeastOneQuestFailure:new(...);
end

B_Trigger_OnAtLeastOneQuestFailure = {
    Name = "Trigger_OnAtLeastOneQuestFailure",
    Description = {
        en = "Trigger: if one or both of the given quests have failed.",
        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge fehlgeschlagen sind.",
        fr = "Déclencheur: si l'une des quêtes indiquées ou les deux ont échoué.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2" },
    },
}

function B_Trigger_OnAtLeastOneQuestFailure:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnAtLeastOneQuestFailure:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnAtLeastOneQuestFailure:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure)
    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure) then
        return true;
    end
    return false;
end

function B_Trigger_OnAtLeastOneQuestFailure:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_OnAtLeastOneQuestFailure);

-- -------------------------------------------------------------------------- --

function Trigger_OnAtLeastOneQuestSuccess(...)
    return B_Trigger_OnAtLeastOneQuestSuccess:new(...);
end

B_Trigger_OnAtLeastOneQuestSuccess = {
    Name = "Trigger_OnAtLeastOneQuestSuccess",
    Description = {
        en = "Trigger: if one or both of the given quests are won.",
        de = "Auslöser: wenn einer oder beide der angegebenen Aufträge gewonnen wurden.",
        fr = "Déclencheur : si une ou les deux missions indiquées ont été gagnées.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2" },
    },
}

function B_Trigger_OnAtLeastOneQuestSuccess:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnAtLeastOneQuestSuccess:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnAtLeastOneQuestSuccess:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success)
    or (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success) then
        return true;
    end
    return false;
end

function B_Trigger_OnAtLeastOneQuestSuccess:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_OnAtLeastOneQuestSuccess);

-- -------------------------------------------------------------------------- --

function Trigger_MapScriptFunction(...)
    return B_Trigger_MapScriptFunction:new(...);
end

B_Trigger_MapScriptFunction = {
    Name = "Trigger_MapScriptFunction",
    Description = {
        en = "Trigger: Calls a function within the global map script. If the function returns true the quest will be started",
        de = "Auslöser: Ruft eine Funktion im globalen Skript auf. Wenn sie true sendet, wird die Quest gestartet.",
        fr = "Déclencheur: Appelle une fonction dans le script global. Si elle envoie true, la quête est lancée.",
    },
    Parameter = {
        { ParameterType.Default, en = "Function name", de = "Funktionsname", fr = "Nom de la fonction" },
    },
}

function B_Trigger_MapScriptFunction:GetTriggerTable(_Quest)
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_MapScriptFunction:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.FuncName = _Parameter
    end
end

function B_Trigger_MapScriptFunction:CustomFunction(_Quest)
    if type(self.FuncName) == "function" then
        return self.FuncName(unpack(self.i47ya_6aghw_frxil));
    end
    return _G[self.FuncName](self, _Quest);
end

function B_Trigger_MapScriptFunction:Debug(_Quest)
    if not self.FuncName then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function reference is invalid!");
        return true;
    end
    if type(self.FuncName) ~= "function" and not _G[self.FuncName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": function does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_MapScriptFunction);

-- -------------------------------------------------------------------------- --

function Trigger_OnEffectDestroyed(...)
    return B_Trigger_OnEffectDestroyed:new(...);
end

B_Trigger_OnEffectDestroyed = {
    Name = "Trigger_OnEffectDestroyed",
    Description = {
        en = "Trigger: Starts a quest after an effect was destroyed",
        de = "Auslöser: Startet eine Quest, nachdem ein Effekt zerstoert wurde",
        fr = "Déclencheur: Démarre une quête après la destruction d'un effet.",
    },
    Parameter = {
        { ParameterType.Default, en = "Effect name", de = "Effektname", fr = "Nom de l'effet" },
    },
}

function B_Trigger_OnEffectDestroyed:GetTriggerTable()
    return { Triggers.Custom2, {self, self.CustomFunction} }
end

function B_Trigger_OnEffectDestroyed:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        self.EffectName = _Parameter
    end
end

function B_Trigger_OnEffectDestroyed:CustomFunction()
    return not CONST_EFFECT_NAME_TO_ID[self.EffectName] or not Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName]);
end

function B_Trigger_OnEffectDestroyed:Debug(_Quest)
    if not CONST_EFFECT_NAME_TO_ID[self.EffectName] then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Effect has never existed")
        return true
    end
end
RegisterBehavior(B_Trigger_OnEffectDestroyed)

-- -------------------------------------------------------------------------- --

Lib.Register("module/entity/NPC_Behavior");

function Goal_NPC(_NpcName, _HeroName)
    return B_Goal_NPC:new(_NpcName, _HeroName);
end

B_Goal_NPC = {
    Name             = "Goal_NPC",
    Description     = {
        en = "Goal: The hero has to talk to a non-player character.",
        de = "Ziel: Der Held muss einen Nichtspielercharakter ansprechen.",
        fr = "Objectif: le héros doit interpeller un personnage non joueur.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "NPC",  de = "NPC",  fr = "NPC" },
        { ParameterType.ScriptName, en = "Hero", de = "Held", fr = "Héro" },
    },
}

function B_Goal_NPC:GetGoalTable()
    return {Objective.Distance, -65565, self.Hero, self.NPC, self}
end

function B_Goal_NPC:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.NPC = _Parameter
    elseif (_Index == 1) then
        self.Hero = _Parameter
        if self.Hero == "-" then
            self.Hero = nil
        end
   end
end

function B_Goal_NPC:GetIcon()
    return {14,10}
end

RegisterBehavior(B_Goal_NPC);

-- -------------------------------------------------------------------------- --

Lib.Register("module/io/IO_Behavior");

function Goal_ActivateSeveralObjects(...)
    return B_Goal_ActivateSeveralObjects:new(...);
end

B_Goal_ActivateSeveralObjects = {
    Name = "Goal_ActivateSeveralObjects",
    Description = {
        en = "Goal: Activate an interactive object",
        de = "Ziel: Aktiviere ein interaktives Objekt",
        fr = "Objectif: activer un objet interactif",
    },
    Parameter = {
        { ParameterType.Default, en = "Object name 1", de = "Skriptname 1", fr = "Nom de l'entité 1" },
        { ParameterType.Default, en = "Object name 2", de = "Skriptname 2", fr = "Nom de l'entité 2" },
        { ParameterType.Default, en = "Object name 3", de = "Skriptname 3", fr = "Nom de l'entité 3" },
        { ParameterType.Default, en = "Object name 4", de = "Skriptname 4", fr = "Nom de l'entité 4" },
    },
    ScriptNames = {};
}

function B_Goal_ActivateSeveralObjects:GetGoalTable()
    return {Objective.Object, { unpack(self.ScriptNames) } }
end

function B_Goal_ActivateSeveralObjects:AddParameter(_Index, _Parameter)
    if _Index == 0 then
        assert(_Parameter ~= nil and _Parameter ~= "", "Goal_ActivateSeveralObjects: At least one IO needed!");
    end
    if _Parameter ~= nil and _Parameter ~= "" then
        table.insert(self.ScriptNames, _Parameter);
    end
end

function B_Goal_ActivateSeveralObjects:GetMsgKey()
    return "Quest_Object_Activate"
end

RegisterBehavior(B_Goal_ActivateSeveralObjects);

-- -------------------------------------------------------------------------- --

--- @diagnostic disable-next-line: duplicate-set-field
B_Reward_ObjectInit.CustomFunction = function(self, _Quest)
    local EntityID = GetID(self.ScriptName);
    if EntityID == 0 then
        return;
    end
    CONST_INITIALIZED_OBJECTS[EntityID] = _Quest.Identifier;

    local GoodReward;
    if self.RewardType and self.RewardType ~= "-" then
        GoodReward = {Goods[self.RewardType], self.RewardAmount};
    end

    local GoodCosts;
    if self.FirstCostType and self.FirstCostType ~= "-" then
        GoodCosts = GoodReward or {};
        table.insert(GoodCosts, Goods[self.FirstCostType]);
        table.insert(GoodCosts, Goods[self.FirstCostAmount]);
    end
    if self.SecondCostType and self.SecondCostType ~= "-" then
        GoodCosts = GoodReward or {};
        table.insert(GoodCosts, Goods[self.SecondCostType]);
        table.insert(GoodCosts, Goods[self.SecondCostAmount]);
    end

    SetupObject {
        Name                   = self.ScriptName,
        Distance               = self.Distance,
        Waittime               = self.Waittime,
        Reward                 = GoodReward,
        Costs                  = GoodCosts,
    };
    InteractiveObjectActivate(self.ScriptName, self.UsingState);
end

-- -------------------------------------------------------------------------- --

Lib.Register("module/quest/Quest_Behavior");

function Goal_WinQuest(...)
    return B_Goal_WinQuest:new(...);
end

B_Goal_WinQuest = {
    Name = "Goal_WinQuest",
    Description = {
        en = "Goal: The player has to win a given quest.",
        de = "Ziel: Der Spieler muss eine angegebene Quest erfolgreich abschliessen.",
        fr = "Objectif: Le joueur doit réussir une quête indiquée.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name",  de = "Questname", fr = "Nom de la quête" },
    },
}

function B_Goal_WinQuest:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_WinQuest:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Quest = _Parameter;
    end
end

function B_Goal_WinQuest:CustomFunction(_Quest)
    local quest = Quests[GetQuestID(self.Quest)];
    if quest then
        if quest.Result == QuestResult.Failure then
            return false;
        end
        if quest.Result == QuestResult.Success then
            return true;
        end
    end
    return nil;
end

function B_Goal_WinQuest:Debug(_Quest)
    if Quests[GetQuestID(self.Quest)] == nil then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Quest '"..self.Quest.."' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_WinQuest);

-- -------------------------------------------------------------------------- --

function Goal_DiscoverPlayers(...)
    return B_Goal_DiscoverPlayers:new(...);
end

B_Goal_DiscoverPlayers = {
    Name = "Goal_DiscoverPlayers",
    Description = {
        en = "Goal: Discover the home territory of some other players.",
        de = "Ziel: Entdecke das Heimatterritorium einiger Spieler.",
        fr = "Objectif: Découvrir le territoire d'origine d'un joueur.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Player amount", de = "Spieleranzahl", fr = "Montant du Joueur" },
        { ParameterType.PlayerID, en = "Player 1", de = "Spieler 1", fr = "Joueur 1" },
        { ParameterType.PlayerID, en = "Player 2", de = "Spieler 2", fr = "Joueur 2" },
        { ParameterType.PlayerID, en = "Player 3", de = "Spieler 3", fr = "Joueur 3" },
        { ParameterType.PlayerID, en = "Player 4", de = "Spieler 4", fr = "Joueur 4" },
        { ParameterType.PlayerID, en = "Player 5", de = "Spieler 5", fr = "Joueur 5" },
    },
}

function B_Goal_DiscoverPlayers:GetGoalTable()
    return {Objective.Discover, 2, { unpack(self.PlayerList) } }
end

function B_Goal_DiscoverPlayers:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    end
    if (_Index > 0) then
        self.PlayerList = self.PlayerList or {};
        if _Index <= self.Amount then
            local PlayerID = _Parameter * 1;
            table.insert(self.PlayerList, PlayerID);
        end
    end
end

function B_Goal_DiscoverPlayers:GetMsgKey()
    local tMapping = {
        [PlayerCategories.BanditsCamp] = "Quest_Discover",
        [PlayerCategories.City] = "Quest_Discover_City",
        [PlayerCategories.Cloister] = "Quest_Discover_Cloister",
        [PlayerCategories.Harbour] = "Quest_Discover",
        [PlayerCategories.Village] = "Quest_Discover_Village",
    };
    local PlayerCategory = GetPlayerCategoryType(self.PlayerList[1] or 1);
    if PlayerCategory then
        local Key = tMapping[PlayerCategory];
        if Key then
            return Key;
        end
    end
    return "Quest_Discover";
end

RegisterBehavior(B_Goal_DiscoverPlayers);

-- -------------------------------------------------------------------------- --

function Goal_DiscoverTerritories(...)
    return B_Goal_DiscoverTerritories:new(...);
end

B_Goal_DiscoverTerritories = {
    Name = "Goal_DiscoverTerritories",
    Description = {
        en = "Goal: Discover multiple territories",
        de = "Ziel: Entdecke mehrere Territorien",
        fr = "Objectif : Découvrez plusieurs territoires",
    },
    Parameter = {
        { ParameterType.Custom, en = "Territory amount", de = "Territorienanzahl", fr = "Montant du territoire" },
        { ParameterType.TerritoryName, en = "Territory 1", de = "Territorium 1", fr = "Territoire 1" },
        { ParameterType.TerritoryName, en = "Territory 2", de = "Territorium 2", fr = "Territoire 2" },
        { ParameterType.TerritoryName, en = "Territory 3", de = "Territorium 3", fr = "Territoire 3" },
        { ParameterType.TerritoryName, en = "Territory 4", de = "Territorium 4", fr = "Territoire 4" },
        { ParameterType.TerritoryName, en = "Territory 5", de = "Territorium 5", fr = "Territoire 5" },
    },
}

function B_Goal_DiscoverTerritories:GetGoalTable()
    return { Objective.Discover, 1, { unpack(self.TerritoryList) } };
end

function B_Goal_DiscoverTerritories:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    end
    if (_Index > 0) then
        self.TerritoryList = self.TerritoryList or {};
        if _Index <= self.Amount then
            local TerritoryID = tonumber(_Parameter);
            if not TerritoryID then
                TerritoryID = GetTerritoryIDByName(_Parameter);
            end
            assert(TerritoryID > 0);
            table.insert(self.TerritoryList, TerritoryID);
        end
    end
end

function B_Goal_DiscoverTerritories:GetMsgKey()
    return "Quest_Discover_Territory";
end

RegisterBehavior(B_Goal_DiscoverTerritories);

-- -------------------------------------------------------------------------- --

function Trigger_OnAtLeastXOfYQuestsSuccess(...)
    return B_Trigger_OnAtLeastXOfYQuestsSuccess:new(...);
end

B_Trigger_OnAtLeastXOfYQuestsSuccess = {
    Name = "Trigger_OnAtLeastXOfYQuestsSuccess",
    Description = {
        en = "Trigger: if at least X of Y given quests has been finished successfully.",
        de = "Auslöser: wenn X von Y angegebener Quests erfolgreich abgeschlossen wurden.",
        fr = "Déclencheur: lorsque X des Y quêtes indiquées ont été accomplies avec succès.",
    },
    Parameter = {
        { ParameterType.Custom, en = "Least Amount", de = "Mindest Anzahl", fr = "Nombre minimum" },
        { ParameterType.Custom, en = "Quest Amount", de = "Quest Anzahl",   fr = "Nombre de quêtes" },
        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1", fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2", fr = "Nom de la quête 2" },
        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3", fr = "Nom de la quête 3" },
        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4", fr = "Nom de la quête 4" },
        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5", fr = "Nom de la quête 5" },
    },
}

function B_Trigger_OnAtLeastXOfYQuestsSuccess:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.LeastAmount = tonumber(_Parameter)
    elseif (_Index == 1) then
        self.QuestAmount = tonumber(_Parameter)
    elseif (_Index == 2) then
        self.QuestName1 = _Parameter
    elseif (_Index == 3) then
        self.QuestName2 = _Parameter
    elseif (_Index == 4) then
        self.QuestName3 = _Parameter
    elseif (_Index == 5) then
        self.QuestName4 = _Parameter
    elseif (_Index == 6) then
        self.QuestName5 = _Parameter
    end
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:CustomFunction()
    local least = 0
    for i = 1, self.QuestAmount do
        ---@diagnostic disable-next-line: param-type-mismatch
        local QuestID = GetQuestID(self["QuestName"..i]);
        if IsValidQuest(QuestID) then
            if (Quests[QuestID].Result == QuestResult.Success) then
                least = least + 1
                if least >= self.LeastAmount then
                    return true
                end
            end
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:Debug(_Quest)
    local leastAmount = self.LeastAmount
    local questAmount = self.QuestAmount
    if leastAmount <= 0 or leastAmount >5 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is wrong")
        return true
    elseif questAmount <= 0 or questAmount > 5 then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": QuestAmount is wrong")
        return true
    elseif leastAmount > questAmount then
        debug(false, _Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is greater than QuestAmount")
        return true
    end
    for i = 1, questAmount do
        if not IsValidQuest(self["QuestName"..i]) then
            debug(false, _Quest.Identifier.. ": " ..self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")
            return true
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsSuccess:GetCustomData(_Index)
    if (_Index == 0) or (_Index == 1) then
        return {"1", "2", "3", "4", "5"}
    end
end

RegisterBehavior(B_Trigger_OnAtLeastXOfYQuestsSuccess)

-- -------------------------------------------------------------------------- --

function Trigger_OnAtLeastXOfYQuestsFailed(...)
    return B_Trigger_OnAtLeastXOfYQuestsFailed:new(...);
end

B_Trigger_OnAtLeastXOfYQuestsFailed = {
    Name = "Trigger_OnAtLeastXOfYQuestsFailed",
    Description = {
        en = "Trigger: if at least X of Y given quests has been finished successfully.",
        de = "Auslöser: wenn X von Y angegebener Quests fehlgeschlagen sind.",
        fr = "Déclencheur: lorsque X des Y quêtes indiquées ont échoué.",
    },
    Parameter = {
        { ParameterType.Custom,    en = "Least Amount", de = "Mindest Anzahl",  fr = "Nombre minimum" },
        { ParameterType.Custom,    en = "Quest Amount", de = "Quest Anzahl",    fr = "Nombre de quêtes" },
        { ParameterType.QuestName, en = "Quest name 1", de = "Questname 1",     fr = "Nom de la quête 1" },
        { ParameterType.QuestName, en = "Quest name 2", de = "Questname 2",     fr = "Nom de la quête 2" },
        { ParameterType.QuestName, en = "Quest name 3", de = "Questname 3",     fr = "Nom de la quête 3" },
        { ParameterType.QuestName, en = "Quest name 4", de = "Questname 4",     fr = "Nom de la quête 4" },
        { ParameterType.QuestName, en = "Quest name 5", de = "Questname 5",     fr = "Nom de la quête 5" },
    },
}

function B_Trigger_OnAtLeastXOfYQuestsFailed:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.LeastAmount = tonumber(_Parameter)
    elseif (_Index == 1) then
        self.QuestAmount = tonumber(_Parameter)
    elseif (_Index == 2) then
        self.QuestName1 = _Parameter
    elseif (_Index == 3) then
        self.QuestName2 = _Parameter
    elseif (_Index == 4) then
        self.QuestName3 = _Parameter
    elseif (_Index == 5) then
        self.QuestName4 = _Parameter
    elseif (_Index == 6) then
        self.QuestName5 = _Parameter
    end
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:CustomFunction()
    local least = 0
    for i = 1, self.QuestAmount do
		local QuestID = GetQuestID(self["QuestName"..i]);
        if IsValidQuest(QuestID) then
			if (Quests[QuestID].Result == QuestResult.Failure) then
				least = least + 1
				if least >= self.LeastAmount then
					return true
				end
			end
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:Debug(_Quest)
    local leastAmount = self.LeastAmount
    local questAmount = self.QuestAmount
    if leastAmount <= 0 or leastAmount >5 then
        error(_Quest.Identifier .. ":" .. self.Name .. ": LeastAmount is wrong")
        return true
    elseif questAmount <= 0 or questAmount > 5 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": QuestAmount is wrong")
        return true
    elseif leastAmount > questAmount then
        error(_Quest.Identifier.. ": " ..self.Name .. ": LeastAmount is greater than QuestAmount")
        return true
    end
    for i = 1, questAmount do
        if not IsValidQuest(self["QuestName"..i]) then
            error(_Quest.Identifier.. ": " ..self.Name .. ": Quest ".. self["QuestName"..i] .. " not found")
            return true
        end
    end
    return false
end

function B_Trigger_OnAtLeastXOfYQuestsFailed:GetCustomData(_Index)
    if (_Index == 0) or (_Index == 1) then
        return {"1", "2", "3", "4", "5"}
    end
end

RegisterBehavior(B_Trigger_OnAtLeastXOfYQuestsFailed);

-- -------------------------------------------------------------------------- --

function Trigger_OnExactOneQuestIsWon(...)
    return B_Trigger_OnExactOneQuestIsWon:new(...);
end

B_Trigger_OnExactOneQuestIsWon = {
    Name = "Trigger_OnExactOneQuestIsWon",
    Description = {
        en = "Trigger: if one of two given quests has been finished successfully, but NOT both.",
        de = "Auslöser: wenn eine von zwei angegebenen Quests (aber NICHT beide) erfolgreich abgeschlossen wurde.",
        fr = "Déclencheur: lorsque l'une des deux quêtes indiquées (mais PAS les deux) a été accomplie avec succès.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1", },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2", },
    },
}

function B_Trigger_OnExactOneQuestIsWon:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnExactOneQuestIsWon:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnExactOneQuestIsWon:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if Quest2 and Quest1 then
        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Success);
        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Success);
        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then
            return true;
        end
    end
    return false;
end

function B_Trigger_OnExactOneQuestIsWon:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_OnExactOneQuestIsWon);

-- -------------------------------------------------------------------------- --

function Trigger_OnExactOneQuestIsLost(...)
    return B_Trigger_OnExactOneQuestIsLost:new(...);
end

B_Trigger_OnExactOneQuestIsLost = {
    Name = "Trigger_OnExactOneQuestIsLost",
    Description = {
        en = "Trigger: If one of two given quests has been lost, but NOT both.",
        de = "Auslöser: Wenn einer von zwei angegebenen Quests (aber NICHT beide) fehlschlägt.",
        fr = "Déclencheur: Si l'une des deux quêtes indiquées (mais PAS les deux) échoue.",
    },
    Parameter = {
        { ParameterType.QuestName, en = "Quest Name 1", de = "Questname 1", fr = "Nom de la quête 1", },
        { ParameterType.QuestName, en = "Quest Name 2", de = "Questname 2", fr = "Nom de la quête 2", },
    },
}

function B_Trigger_OnExactOneQuestIsLost:GetTriggerTable()
    return {Triggers.Custom2, {self, self.CustomFunction}};
end

function B_Trigger_OnExactOneQuestIsLost:AddParameter(_Index, _Parameter)
    self.QuestTable = {};

    if (_Index == 0) then
        self.Quest1 = _Parameter;
    elseif (_Index == 1) then
        self.Quest2 = _Parameter;
    end
end

function B_Trigger_OnExactOneQuestIsLost:CustomFunction(_Quest)
    local Quest1 = Quests[GetQuestID(self.Quest1)];
    local Quest2 = Quests[GetQuestID(self.Quest2)];
    if Quest2 and Quest1 then
        local Quest1Succeed = (Quest1.State == QuestState.Over and Quest1.Result == QuestResult.Failure);
        local Quest2Succeed = (Quest2.State == QuestState.Over and Quest2.Result == QuestResult.Failure);
        if (Quest1Succeed and not Quest2Succeed) or (not Quest1Succeed and Quest2Succeed) then
            return true;
        end
    end
    return false;
end

function B_Trigger_OnExactOneQuestIsLost:Debug(_Quest)
    if self.Quest1 == self.Quest2 then
        error(_Quest.Identifier.. ": " ..self.Name..": Both quests are identical!");
        return true;
    elseif not IsValidQuest(self.Quest1) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest1.."' does not exist!");
        return true;
    elseif not IsValidQuest(self.Quest2) then
        error(_Quest.Identifier.. ": " ..self.Name..": Quest '"..self.Quest2.."' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_OnExactOneQuestIsLost);

-- -------------------------------------------------------------------------- --

Lib.Register("module/quest/QuestBehavior_Behavior");

function Goal_MoveToPosition(...)
    return B_Goal_MoveToPosition:new(...);
end

B_Goal_MoveToPosition = {
    Name = "Goal_MoveToPosition",
    Description = {
        en = "Goal: A entity have to moved as close as the distance to another entity. The target can be marked with a static marker.",
        de = "Ziel: Ein Entity muss sich einer anderen bis auf eine bestimmte Distanz nähern. Die Lupe wird angezeigt, das Ziel kann markiert werden.",
        fr = "Objectif: une entité doit s'approcher d'une autre à une distance donnée. La loupe est affichée, la cible peut être marquée.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",   de = "Entity",         fr = "Entité" },
        { ParameterType.ScriptName, en = "Target",   de = "Ziel",           fr = "Cible" },
        { ParameterType.Number,     en = "Distance", de = "Entfernung",     fr = "Distance" },
        { ParameterType.Custom,     en = "Marker",   de = "Ziel markieren", fr = "Marquer la cible" },
    },
}

function B_Goal_MoveToPosition:GetGoalTable()
    return {Objective.Distance, self.Entity, self.Target, self.Distance, self.Marker}
end

function B_Goal_MoveToPosition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity = _Parameter
    elseif (_Index == 1) then
        self.Target = _Parameter
    elseif (_Index == 2) then
        self.Distance = _Parameter * 1
    elseif (_Index == 3) then
        self.Marker = ToBoolean(_Parameter)
    end
end

function B_Goal_MoveToPosition:GetCustomData( _Index )
    local Data = {};
    if _Index == 3 then
        Data = {"true", "false"}
    end
    return Data
end

RegisterBehavior(B_Goal_MoveToPosition);

-- -------------------------------------------------------------------------- --

function Goal_AmmunitionAmount(...)
    return B_Goal_AmmunitionAmount:new(...);
end

B_Goal_AmmunitionAmount = {
    Name = "Goal_AmmunitionAmount",
    Description = {
        en = "Goal: Reach a smaller or bigger value than the given amount of ammunition in a war machine.",
        de = "Ziel: Über- oder unterschreite die angegebene Anzahl Munition in einem Kriegsgerät.",
        fr = "Objectif : Dépasser ou ne pas dépasser le nombre de munitions indiqué dans un engin de guerre.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Script name", de = "Skriptname",  fr = "Nom de l'entité" },
        { ParameterType.Custom,     en = "Relation",    de = "Relation",    fr = "Relation" },
        { ParameterType.Number,     en = "Amount",      de = "Menge",       fr = "Quantité" },
    },
}

function B_Goal_AmmunitionAmount:GetGoalTable()
    return { Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_AmmunitionAmount:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    elseif (_Index == 1) then
        self.bRelSmallerThan = tostring(_Parameter) == "true" or _Parameter == "<"
    elseif (_Index == 2) then
        self.Amount = _Parameter * 1
    end
end

function B_Goal_AmmunitionAmount:CustomFunction()
    local EntityID = GetID(self.Scriptname);
    if not IsExisting(EntityID) then
        return false;
    end
    local HaveAmount = Logic.GetAmmunitionAmount(EntityID);
    if ( self.bRelSmallerThan and HaveAmount < self.Amount ) or ( not self.bRelSmallerThan and HaveAmount >= self.Amount ) then
        return true;
    end
    return nil;
end

function B_Goal_AmmunitionAmount:Debug(_Quest)
    if self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount is negative");
        return true
    end
end

function B_Goal_AmmunitionAmount:GetCustomData( _Index )
    if _Index == 1 then
        return {"<", ">="};
    end
end

RegisterBehavior(B_Goal_AmmunitionAmount);

-- -------------------------------------------------------------------------- --

function Goal_CityReputation(...)
    return B_Goal_CityReputation:new(...);
end

B_Goal_CityReputation = {
    Name = "Goal_CityReputation",
    Description = {
        en = "Goal: The reputation of the quest receivers city must at least reach the desired hight.",
        de = "Ziel: Der Ruf der Stadt des Empfängers muss mindestens so hoch sein, wie angegeben.",
        fr = "Objectif: la réputation de la ville du receveur doit être au moins aussi élevée que celle indiquée.",
    },
    Parameter = {
        { ParameterType.Number, en = "City reputation", de = "Ruf der Stadt", fr = "Réputation de la ville" },
    },
    Text = {
        de = "RUF DER STADT{cr}{cr}Hebe den Ruf der Stadt durch weise Herrschaft an!{cr}Benötigter Ruf: %d",
        en = "CITY REPUTATION{cr}{cr}Raise your reputation by fair rulership!{cr}Needed reputation: %d",
        fr = "RÉPUTATION DE LA VILLE{cr}{cr} Augmente la réputation de la ville en la gouvernant sagement!{cr}Réputation requise : %d",
    }
}

function B_Goal_CityReputation:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_CityReputation:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Reputation = _Parameter * 1;
    end
end

function B_Goal_CityReputation:CustomFunction(_Quest)
    self:SetCaption(_Quest);
    local CityReputation = Logic.GetCityReputation(_Quest.ReceivingPlayer) * 100;
    if CityReputation >= self.Reputation then
        return true;
    end
end

function B_Goal_CityReputation:SetCaption(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local Text = string.format(Localize(self.Text), self.Reputation);
        Lib.Core.Quest:ChangeCustomQuestCaptionText(Text .."%", _Quest);
    end
end

function B_Goal_CityReputation:GetIcon()
    return {5, 14};
end

function B_Goal_CityReputation:Debug(_Quest)
    if type(self.Reputation) ~= "number" or self.Reputation < 0 or self.Reputation > 100 then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Reputation must be between 0 and 100!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Goal_CityReputation);

-- -------------------------------------------------------------------------- --

function Goal_DestroySpawnedEntities(...)
    return B_Goal_DestroySpawnedEntities:new(...);
end

B_Goal_DestroySpawnedEntities = {
    Name = "Goal_DestroySpawnedEntities",
    Description = {
        en = "Goal: Destroy all entities spawned at the spawnpoint.",
        de = "Ziel: Zerstöre alle Entitäten, die bei dem Spawnpoint erzeugt wurde.",
        fr = "Objectif: Détruire toutes les entités créées au point d'apparition.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Spawnpoint",       de = "Spawnpoint",         fr = "Point d'émergence" },
        { ParameterType.Number,     en = "Amount",           de = "Menge",              fr = "Quantité" },
        { ParameterType.Custom,     en = "Name is prefixed", de = "Name ist Präfix",    fr = "Le nom est un préfixe" },
    },
};

function B_Goal_DestroySpawnedEntities:GetGoalTable()
    if self.Prefixed then
        local Parameter = table.remove(self.SpawnPoint);
        local i = 1;
        while (IsExisting(Parameter .. i)) do
            table.insert(self.SpawnPoint, Parameter .. i);
            i = i +1;
        end
        assert(#self.SpawnPoint > 0, "No spawnpoints found!");
    end
    return {Objective.DestroyEntities, 3, self.SpawnPoint, self.Amount};
end

function B_Goal_DestroySpawnedEntities:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.SpawnPoint = {_Parameter};
    elseif (_Index == 1) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or "false";
        self.Prefixed = ToBoolean(_Parameter);
    end
end

function B_Goal_DestroySpawnedEntities:GetMsgKey()
    local ID = GetID(self.SpawnPoint[1]);
    if ID ~= 0 then
        local TypeName = Logic.GetEntityTypeName(Logic.GetEntityType(ID));
        if Logic.IsEntityTypeInCategory( ID, EntityCategories.AttackableBuilding ) == 1 then
            return "Quest_Destroy_Leader";
        elseif TypeName:find("Bear") or TypeName:find("Lion") or TypeName:find("Tiger") or TypeName:find("Wolf") then
            return "Quest_DestroyEntities_Predators";
        elseif TypeName:find("Military") or TypeName:find("Cart") then
            return "Quest_DestroyEntities_Unit";
        end
    end
    return "Quest_DestroyEntities";
end

function B_Goal_DestroySpawnedEntities:GetCustomData(_Index)
    if _Index == 2 then
        return {"false", "true"};
    end
end

RegisterBehavior(B_Goal_DestroySpawnedEntities);

-- -------------------------------------------------------------------------- --

function Goal_StealGold(...)
    return B_Goal_StealGold:new(...)
end

B_Goal_StealGold = {
    Name = "Goal_StealGold",
    Description = {
        en = "Goal: Steal an explicit amount of gold from a players or any players city buildings.",
        de = "Ziel: Diebe sollen eine bestimmte Menge Gold aus feindlichen Stadtgebäuden stehlen.",
        fr = "Objectif: les voleurs doivent dérober une certaine quantité d'or dans les bâtiments urbains ennemis.",
    },
    Parameter = {
        { ParameterType.Number,   en = "Amount on Gold", de = "Zu stehlende Menge",             fr = "Quantité à voler" },
        { ParameterType.Custom,   en = "Target player",  de = "Spieler von dem gestohlen wird", fr = "Joueur à qui l'on vole" },
        { ParameterType.Custom,   en = "Cheat earnings", de = "Einnahmen generieren",           fr = "Générer des revenus" },
        { ParameterType.Custom,   en = "Print progress", de = "Fortschritt ausgeben",           fr = "Afficher les progrès" },
    },
}

function B_Goal_StealGold:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_StealGold:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Amount = _Parameter * 1;
    elseif (_Index == 1) then
        local PlayerID = tonumber(_Parameter) or -1;
        self.Target = PlayerID * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or "false"
        self.CheatEarnings = ToBoolean(_Parameter);
    elseif (_Index == 3) then
        _Parameter = _Parameter or "true"
        self.Printout = ToBoolean(_Parameter);
    end
    self.StohlenGold = 0;
end

function B_Goal_StealGold:GetCustomData(_Index)
    if _Index == 1 then
        return { "-", 1, 2, 3, 4, 5, 6, 7, 8 };
    elseif _Index == 2 then
        return { "true", "false" };
    end
end

function B_Goal_StealGold:SetDescriptionOverwrite(_Quest)
    local TargetPlayerName = Localize({
        de = " anderen Spielern ",
        en = " different parties ",
        fr = " d'autres joueurs ",
    });

    if self.Target ~= -1 then
        TargetPlayerName = GetPlayerName(self.Target);
        if TargetPlayerName == nil or TargetPlayerName == "" then
            TargetPlayerName = " PLAYER_NAME_MISSING ";
        end
    end

    -- Cheat earnings
    if self.CheatEarnings then
        local PlayerIDs = {self.Target};
        if self.Target == -1 then
            PlayerIDs = {1, 2, 3, 4, 5, 6, 7, 8};
        end
        for i= 1, #PlayerIDs, 1 do
            if i ~= _Quest.ReceivingPlayer and Logic.GetStoreHouse(i) ~= 0 then
                local CityBuildings = {Logic.GetPlayerEntitiesInCategory(i, EntityCategories.CityBuilding)};
                for j= 1, #CityBuildings, 1 do
                    local CurrentEarnings = Logic.GetBuildingProductEarnings(CityBuildings[j]);
                    if CurrentEarnings < 45 and Logic.GetTime() % 5 == 0 then
                        Logic.SetBuildingEarnings(CityBuildings[j], CurrentEarnings +1);
                    end
                end
            end
        end
    end

    local amount = self.Amount - self.StohlenGold;
    amount = (amount > 0 and amount) or 0;
    local text = {
        de = "Gold von %s stehlen {cr}{cr}Aus Stadtgebäuden zu stehlende Goldmenge: %d",
        en = "Steal gold from %s {cr}{cr}Amount on gold to steal from city buildings: %d",
        fr = "Voler l'or de %s {cr}{cr}Quantité d'or à voler dans les bâtiments de la ville : %d",
    };
    return "{center}" ..string.format(Localize(text), TargetPlayerName, amount);
end

function B_Goal_StealGold:CustomFunction(_Quest)
    if Lib.Core.Quest then
        Lib.Core.Quest:ChangeCustomQuestCaptionText(self:SetDescriptionOverwrite(_Quest), _Quest);
    end
    if self.StohlenGold >= self.Amount then
        return true;
    end
    return nil;
end

function B_Goal_StealGold:GetIcon()
    return {5,13};
end

function B_Goal_StealGold:Debug(_Quest)
    if tonumber(self.Amount) == nil and self.Amount < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": amount can not be negative!");
        return true;
    end
    return false;
end

function B_Goal_StealGold:Reset(_Quest)
    self.StohlenGold = 0;
end

RegisterBehavior(B_Goal_StealGold)

-- -------------------------------------------------------------------------- --

function Goal_StealFromBuilding(...)
    return B_Goal_StealFromBuilding:new(...)
end

B_Goal_StealFromBuilding = {
    Name = "Goal_StealFromBuilding",
    Description = {
        en = "Goal: The player has to steal from a building. Not a castle and not a village storehouse!",
        de = "Ziel: Der Spieler muss ein bestimmtes Gebäude bestehlen. Dies darf keine Burg und kein Dorflagerhaus sein!",
        fr = "Objectif: Le joueur doit voler un bâtiment spécifique. Il ne peut s'agir ni d'un château ni d'un entrepôt de village !",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Building",        de = "Gebäude",              fr = "Bâtiment" },
        { ParameterType.Custom,     en = "Cheat earnings",  de = "Einnahmen generieren", fr = "Générer des revenus" },
    },
}

function B_Goal_StealFromBuilding:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_StealFromBuilding:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Building = _Parameter
    elseif (_Index == 1) then
        _Parameter = _Parameter or "false"
        self.CheatEarnings = ToBoolean(_Parameter);
    end
    self.RobberList = {};
end

function B_Goal_StealFromBuilding:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" };
    end
end

function B_Goal_StealFromBuilding:SetDescriptionOverwrite(_Quest)
    local isCathedral = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Cathedrals) == 1;
    local isWarehouse = Logic.GetEntityType(GetID(self.Building)) == Entities.B_StoreHouse;
    local isCistern = Logic.GetEntityType(GetID(self.Building)) == Entities.B_Cistern;
    local text;

    if isCathedral then
        text = {
            de = "Sabotage {cr}{cr} Sendet einen Dieb und sabotiert die markierte Kirche.",
            en = "Sabotage {cr}{cr} Send a thief to sabotage the marked chapel.",
            fr = "Sabotage {cr}{cr} Envoyez un voleur pour saboter la chapelle marquée.",
        };
    elseif isWarehouse then
        text = {
            de = "Lagerhaus bestehlen {cr}{cr} Sendet einen Dieb in das markierte Lagerhaus.",
            en = "Steal from storehouse {cr}{cr} Steal from the marked storehouse.",
            fr = "Voler un entrepôt {cr}{cr} Envoie un voleur dans l'entrepôt marqué.",
        };
    elseif isCistern then
        text = {
            de = "Sabotage {cr}{cr} Sendet einen Dieb und sabotiert den markierten Brunnen.",
            en = "Sabotage {cr}{cr} Send a thief and break the marked well of the enemy.",
            fr = "Sabotage {cr}{cr} Envoie un voleur et sabote le puits marqué.",
        };
    else
        text = {
            de = "Gebäude bestehlen {cr}{cr} Sendet einen Dieb und bestehlt das markierte Gebäude.",
            en = "Steal from building {cr}{cr} Send a thief to steal from the marked building.",
            fr = "Voler un bâtiment {cr}{cr} Envoie un voleur et vole le bâtiment marqué.",
        };
    end
    return "{center}" .. Localize(text);
end

function B_Goal_StealFromBuilding:CustomFunction(_Quest)
    if not IsExisting(self.Building) then
        if self.Marker then
            Logic.DestroyEffect(self.Marker);
        end
        return false;
    end

    if not self.Marker then
        local pos = GetPosition(self.Building);
        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);
    end

    -- Cheat earnings
    if self.CheatEarnings then
        local BuildingID = GetID(self.Building);
        local CurrentEarnings = Logic.GetBuildingProductEarnings(BuildingID);
        if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1
        and CurrentEarnings < 45 and Logic.GetTime() % 5 == 0 then
            Logic.SetBuildingEarnings(BuildingID, CurrentEarnings +1);
        end
    end

    if self.SuccessfullyStohlen then
        Logic.DestroyEffect(self.Marker);
        return true;
    end
    return nil;
end

function B_Goal_StealFromBuilding:GetIcon()
    return {5,13};
end

function B_Goal_StealFromBuilding:Debug(_Quest)
    local eTypeName = Logic.GetEntityTypeName(Logic.GetEntityType(GetID(self.Building)));
    local IsHeadquarter = Logic.IsEntityInCategory(GetID(self.Building), EntityCategories.Headquarters) == 1;
    if Logic.IsBuilding(GetID(self.Building)) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is not a building");
        return true;
    elseif not IsExisting(self.Building) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is destroyed :(");
        return true;
    elseif string.find(eTypeName, "B_NPC_BanditsHQ") or string.find(eTypeName, "B_NPC_Cloister") or string.find(eTypeName, "B_NPC_StoreHouse") then
        error(_Quest.Identifier.. ": " ..self.Name .. ": village storehouses are not allowed!");
        return true;
    elseif IsHeadquarter then
        error(_Quest.Identifier.. ": " ..self.Name .. ": use Goal_StealInformation for headquarters!");
        return true;
    end
    return false;
end

function B_Goal_StealFromBuilding:Reset(_Quest)
    self.SuccessfullyStohlen = false;
    self.RobberList = {};
    self.Marker = nil;
end

function B_Goal_StealFromBuilding:Interrupt(_Quest)
    Logic.DestroyEffect(self.Marker);
end

RegisterBehavior(B_Goal_StealFromBuilding)

-- -------------------------------------------------------------------------- --

function Goal_SpyOnBuilding(...)
    return B_Goal_SpyOnBuilding:new(...)
end

B_Goal_SpyOnBuilding = {
    Name = "Goal_SpyOnBuilding",
    IconOverwrite = {5,13},
    Description = {
        en = "Goal: Infiltrate a building with a thief. A thief must be able to steal from the target building.",
        de = "Ziel: Infiltriere ein Gebäude mit einem Dieb. Nur mit Gebaueden möglich, die bestohlen werden koennen.",
        fr = "Objectif: Infiltrer un bâtiment avec un voleur. Seulement possible avec des bâtiments qui peuvent être volés.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Target Building", de = "Zielgebäude",           fr = "Bâtiment cible" },
        { ParameterType.Custom,     en = "Cheat earnings",  de = "Einnahmen generieren",  fr = "Générer des revenus" },
        { ParameterType.Custom,     en = "Destroy Thief",   de = "Dieb löschen",          fr = "Supprimer le voleur" },
    },
}

function B_Goal_SpyOnBuilding:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction}};
end

function B_Goal_SpyOnBuilding:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Building = _Parameter
    elseif (_Index == 1) then
        _Parameter = _Parameter or "false"
        self.CheatEarnings = ToBoolean(_Parameter);
    elseif (_Index == 2) then
        _Parameter = _Parameter or "true"
        self.Delete = ToBoolean(_Parameter)
    end
end

function B_Goal_SpyOnBuilding:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" };
    end
end

function B_Goal_SpyOnBuilding:SetDescriptionOverwrite(_Quest)
    if not _Quest.QuestDescription then
        local text = {
            de = "Gebäude infriltrieren {cr}{cr}Spioniere das markierte Gebäude mit einem Dieb aus!",
            en = "Infiltrate building {cr}{cr}Spy on the highlighted buildings with a thief!",
            fr = "Infiltrer un bâtiment {cr}{cr}Espionner le bâtiment marqué avec un voleur!",
        };
        return Localize(text);
    else
        return _Quest.QuestDescription;
    end
end

function B_Goal_SpyOnBuilding:CustomFunction(_Quest)
    if not IsExisting(self.Building) then
        if self.Marker then
            Logic.DestroyEffect(self.Marker);
        end
        return false;
    end

    if not self.Marker then
        local pos = GetPosition(self.Building);
        self.Marker = Logic.CreateEffect(EGL_Effects.E_Questmarker, pos.X, pos.Y, 0);
    end

    -- Cheat earnings
    if self.CheatEarnings then
        local BuildingID = GetID(self.Building);
        if  Logic.IsEntityInCategory(BuildingID, EntityCategories.CityBuilding) == 1
        and Logic.GetBuildingEarnings(BuildingID) < 5 then
            Logic.SetBuildingEarnings(BuildingID, 5);
        end
    end

    if self.Infiltrated then
        Logic.DestroyEffect(self.Marker);
        return true;
    end
    return nil;
end

function B_Goal_SpyOnBuilding:GetIcon()
    return self.IconOverwrite;
end

function B_Goal_SpyOnBuilding:Debug(_Quest)
    if Logic.IsBuilding(GetID(self.Building)) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is not a building");
        return true;
    elseif not IsExisting(self.Building) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": target is destroyed :(");
        return true;
    end
    return false;
end

function B_Goal_SpyOnBuilding:Reset(_Quest)
    self.Infiltrated = false;
    self.Marker = nil;
end

function B_Goal_SpyOnBuilding:Interrupt(_Quest)
    Logic.DestroyEffect(self.Marker);
end

RegisterBehavior(B_Goal_SpyOnBuilding);

-- -------------------------------------------------------------------------- --

function Goal_DestroySoldiers(...)
    return B_Goal_DestroySoldiers:new(...);
end

B_Goal_DestroySoldiers = {
    Name = "Goal_DestroySoldiers",
    Description = {
        en = "Goal: Destroy a given amount of enemy soldiers",
        de = "Ziel: Zerstöre eine Anzahl gegnerischer Soldaten",
        fr = "Objectif: Détruire un certain nombre de soldats ennemis",
    },
    Parameter = {
        {ParameterType.PlayerID, en = "Attacking Player",   de = "Angreifer",   fr = "Attaquant", },
        {ParameterType.PlayerID, en = "Defending Player",   de = "Verteidiger", fr = "Défenseur", },
        {ParameterType.Number,   en = "Amount",             de = "Anzahl",      fr = "Quantité", },
    },

    Text = {
        de = "{center}SOLDATEN ZERSTÖREN {cr}{cr}von der Partei: %s{cr}{cr}Anzahl: %d",
        en = "{center}DESTROY SOLDIERS {cr}{cr}from faction: %s{cr}{cr}Amount: %d",
        fr = "{center}DESTRUIRE DES SOLDATS {cr}{cr}de la faction: %s{cr}{cr}Nombre : %d",
    }
}

function B_Goal_DestroySoldiers:GetGoalTable()
    return {Objective.Custom2, {self, self.CustomFunction} }
end

function B_Goal_DestroySoldiers:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.AttackingPlayer = _Parameter * 1
    elseif (_Index == 1) then
        self.AttackedPlayer = _Parameter * 1
    elseif (_Index == 2) then
        self.KillsNeeded = _Parameter * 1
    end
end

function B_Goal_DestroySoldiers:CustomFunction(_Quest)
    if not _Quest.QuestDescription or _Quest.QuestDescription == "" then
        local PlayerName = GetPlayerName(self.AttackedPlayer) or
                           ("Player " ..self.AttackedPlayer);
        Lib.Core.Quest:ChangeCustomQuestCaptionText(
            string.format(
                Lib.Core.Text:Localize(self.Text),
                PlayerName, self.KillsNeeded
            ),
            _Quest
        );
    end

    local KillsCurrent = GetEnemySoldierKillsOfPlayer(
        self.AttackingPlayer,
        self.AttackedPlayer
    );
    if not self.KillstStart then
        self.KillstStart = KillsCurrent;
    end
    if self.KillsNeeded <= KillsCurrent - self.KillstStart then
        return true;
    end
end

function B_Goal_DestroySoldiers:Debug(_Quest)
    if Logic.GetStoreHouse(self.AttackingPlayer) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AttackinPlayer .. " is dead :-(")
        return true
    elseif Logic.GetStoreHouse(self.AttackedPlayer) == 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Player " .. self.AttackedPlayer .. " is dead :-(")
        return true
    elseif self.KillsNeeded < 0 then
        error(_Quest.Identifier.. ": " ..self.Name .. ": Amount negative")
        return true
    end
end

function B_Goal_DestroySoldiers:Reset()
    self.KillstStart = nil;
end

function B_Goal_DestroySoldiers:GetIcon()
    return {7,12}
end

RegisterBehavior(B_Goal_DestroySoldiers);

-- -------------------------------------------------------------------------- --

function Reprisal_SetPosition(...)
    return B_Reprisal_SetPosition:new(...);
end

B_Reprisal_SetPosition = {
    Name = "Reprisal_SetPosition",
    Description = {
        en = "Reprisal: Places an entity relative to the position of another. The entity can look the target.",
        de = "Vergeltung: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.",
        fr = "Rétribution: place une Entity vis-à-vis de l'emplacement d'une autre. L'entité peut être orientée vers la cible.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",          de = "Entity",          fr = "Entité", },
        { ParameterType.ScriptName, en = "Target position", de = "Zielposition",    fr = "Position cible", },
        { ParameterType.Custom,     en = "Face to face",    de = "Ziel ansehen",    fr = "Voir la cible", },
        { ParameterType.Number,     en = "Distance",        de = "Zielentfernung",  fr = "Distance de la cible", },
    },
}

function B_Reprisal_SetPosition:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetPosition:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Target = _Parameter;
    elseif (_Index == 2) then
        self.FaceToFace = ToBoolean(_Parameter)
    elseif (_Index == 3) then
        self.Distance = (_Parameter ~= nil and tonumber(_Parameter)) or 100;
    end
end

function B_Reprisal_SetPosition:CustomFunction(_Quest)
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        return;
    end

    local entity = GetID(self.Entity);
    local target = GetID(self.Target);
    local x,y,z = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x,y = Logic.GetBuildingApproachPosition(target);
    end
    local ori = Logic.GetEntityOrientation(target)+90;

    if self.FaceToFace then
        x = x + self.Distance * math.cos( math.rad(ori) );
        y = y + self.Distance * math.sin( math.rad(ori) );
        Logic.DEBUG_SetSettlerPosition(entity, x, y);
        LookAt(self.Entity, self.Target);
    else
        if Logic.IsBuilding(target) == 1 then
            x,y = Logic.GetBuildingApproachPosition(target);
        end
        Logic.DEBUG_SetSettlerPosition(entity, x, y);
    end
end

function B_Reprisal_SetPosition:GetCustomData(_Index)
    if _Index == 2 then
        return { "true", "false" }
    end
end

function B_Reprisal_SetPosition:Debug(_Quest)
    if self.FaceToFace then
        if tonumber(self.Distance) == nil or self.Distance < 50 then
            error(_Quest.Identifier.. ": " ..self.Name.. ": Distance is nil or to short!");
            return true;
        end
    end
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Mover entity or target entity does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_SetPosition);

-- -------------------------------------------------------------------------- --

function Reprisal_ChangePlayer(...)
    return B_Reprisal_ChangePlayer:new(...)
end

B_Reprisal_ChangePlayer = {
    Name = "Reprisal_ChangePlayer",
    Description = {
        en = "Reprisal: Changes the owner of the entity or a battalion.",
        de = "Vergeltung: Aendert den Besitzer einer Entity oder eines Battalions.",
        fr = "Rétribution : Change le propriétaire d'une entité ou d'un bataillon.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",     de = "Entity",   fr = "Entité", },
        { ParameterType.Custom,     en = "Player",     de = "Spieler",  fr = "Joueur", },
    },
}

function B_Reprisal_ChangePlayer:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_ChangePlayer:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Player = tostring(_Parameter);
    end
end

function B_Reprisal_ChangePlayer:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    if Logic.IsLeader(eID) == 1 then
        Logic.ChangeSettlerPlayerID(eID, self.Player);
    else
        Logic.ChangeEntityPlayerID(eID, self.Player);
    end
end

function B_Reprisal_ChangePlayer:GetCustomData(_Index)
    if _Index == 1 then
        return {"0", "1", "2", "3", "4", "5", "6", "7", "8"}
    end
end

function B_Reprisal_ChangePlayer:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_ChangePlayer);

-- -------------------------------------------------------------------------- --

function Reprisal_SetVisible(...)
    return B_Reprisal_SetVisible:new(...)
end

B_Reprisal_SetVisible = {
    Name = "Reprisal_SetVisible",
    Description = {
        en = "Reprisal: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.",
        de = "Vergeltung: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.",
        fr = "Rétribution: fixe la visibilité d'une Entité. S'il s'agit d'un spawn, les Entities spawnées sont également affectées.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",      de = "Entity",   fr = "Entité", },
        { ParameterType.Custom,     en = "Visible",     de = "Sichtbar", fr = "Visible", },
    },
}

function B_Reprisal_SetVisible:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetVisible:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Visible = ToBoolean(_Parameter)
    end
end

function B_Reprisal_SetVisible:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end

    local eID = GetID(self.Entity);
    local pID = Logic.EntityGetPlayer(eID);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);

    if string.find(tName, "^S_") or string.find(tName, "^B_NPC_Bandits")
    or string.find(tName, "^B_NPC_Barracks") then
        local spawned = {Logic.GetSpawnedEntities(eID)};
        for i=1, #spawned do
            if Logic.IsLeader(spawned[i]) == 1 then
                local soldiers = {Logic.GetSoldiersAttachedToLeader(spawned[i])};
                for j=2, #soldiers do
                    Logic.SetVisible(soldiers[j], self.Visible);
                end
            else
                Logic.SetVisible(spawned[i], self.Visible);
            end
        end
    else
        if Logic.IsLeader(eID) == 1 then
            local soldiers = {Logic.GetSoldiersAttachedToLeader(eID)};
            for j=2, #soldiers do
                Logic.SetVisible(soldiers[j], self.Visible);
            end
        else
            Logic.SetVisible(eID, self.Visible);
        end
    end
end

function B_Reprisal_SetVisible:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" }
    end
end

function B_Reprisal_SetVisible:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_SetVisible);

-- -------------------------------------------------------------------------- --

function Reprisal_SetVulnerability(...)
    return B_Reprisal_SetVulnerability:new(...);
end

B_Reprisal_SetVulnerability = {
    Name = "Reprisal_SetVulnerability",
    Description = {
        en = "Reprisal: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.",
        de = "Vergeltung: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen.",
        fr = "Rétribution: rend une Entité vulnérable ou invulnérable. S'il s'agit d'un spawn, les Entities spawnées sont affectées.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",             de = "Entity",     fr = "Entité", },
        { ParameterType.Custom,     en = "Vulnerability",      de = "Verwundbar", fr = "Vulnérabilité", },
    },
}

function B_Reprisal_SetVulnerability:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetVulnerability:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Vulnerability = ToBoolean(_Parameter)
    end
end

function B_Reprisal_SetVulnerability:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);
    local EntitiesToCheck = {eID};
    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        EntitiesToCheck = {Logic.GetSpawnedEntities(eID)};
    end
    local MethodToUse = "MakeInvulnerable";
    if self.Vulnerability then
        MethodToUse = "MakeVulnerable";
    end
    for i= 1, #EntitiesToCheck, 1 do
        if Logic.IsLeader(EntitiesToCheck[i]) == 1 then
            local Soldiers = {Logic.GetSoldiersAttachedToLeader(EntitiesToCheck[i])};
            for j=2, #Soldiers, 1 do
                _G[MethodToUse](Soldiers[j]);
            end
        end
        _G[MethodToUse](EntitiesToCheck[i]);
    end
end

function B_Reprisal_SetVulnerability:GetCustomData(_Index)
    if _Index == 1 then
        return { "true", "false" }
    end
end

function B_Reprisal_SetVulnerability:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_SetVulnerability);

-- -------------------------------------------------------------------------- --

function Reprisal_SetModel(...)
    return B_Reprisal_SetModel:new(...);
end

B_Reprisal_SetModel = {
    Name = "Reprisal_SetModel",
    Description = {
        en = "Reprisal: Changes the model of the entity. Be careful, some models crash the game.",
        de = "Vergeltung: Ändert das Model einer Entity. Achtung: Einige Modelle führen zum Absturz.",
        fr = "Rétribution: modifie le modèle d'une entité. Attention: certains modèles entraînent un crash.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",    de = "Entity", fr = "Entité", },
        { ParameterType.Custom,     en = "Model",     de = "Model",  fr = "Modèle", },
    },
}

function B_Reprisal_SetModel:GetReprisalTable()
    return { Reprisal.Custom, { self, self.CustomFunction } }
end

function B_Reprisal_SetModel:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Model = _Parameter;
    end
end

function B_Reprisal_SetModel:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    Logic.SetModel(eID, Models[self.Model]);
end

function B_Reprisal_SetModel:GetCustomData(_Index)
    if _Index == 1 then
        local Data = {};
        -- Add generic models
        for k, v in pairs(Models) do
            if  not string.find(k, "Animals_")
            and not string.find(k, "MissionMap_")
            and not string.find(k, "R_Fish")
            and not string.find(k, "^[GEHUVXYZgt][ADSTfm]*")
            and not string.find(string.lower(k), "goods|tools_") then
                table.insert(Data, k);
            end
        end
        -- Add specific models
        table.insert(Data, "Effects_Dust01");
        table.insert(Data, "Effects_E_DestructionSmoke");
        table.insert(Data, "Effects_E_DustLarge");
        table.insert(Data, "Effects_E_DustSmall");
        table.insert(Data, "Effects_E_Firebreath");
        table.insert(Data, "Effects_E_Fireworks01");
        table.insert(Data, "Effects_E_Flies01");
        table.insert(Data, "Effects_E_Grasshopper03");
        table.insert(Data, "Effects_E_HealingFX");
        table.insert(Data, "Effects_E_Knight_Chivalry_Aura");
        table.insert(Data, "Effects_E_Knight_Plunder_Aura");
        table.insert(Data, "Effects_E_Knight_Song_Aura");
        table.insert(Data, "Effects_E_Knight_Trader_Aura");
        table.insert(Data, "Effects_E_Knight_Wisdom_Aura");
        table.insert(Data, "Effects_E_KnightFight");
        table.insert(Data, "Effects_E_NA_BlowingSand01");
        table.insert(Data, "Effects_E_NE_BlowingSnow01");
        table.insert(Data, "Effects_E_Oillamp");
        table.insert(Data, "Effects_E_SickBuilding");
        table.insert(Data, "Effects_E_Splash");
        table.insert(Data, "Effects_E_Torch");
        table.insert(Data, "Effects_Fire01");
        table.insert(Data, "Effects_FX_Lantern");
        table.insert(Data, "Effects_FX_SmokeBIG");
        table.insert(Data, "Effects_XF_BuildingSmoke");
        table.insert(Data, "Effects_XF_BuildingSmokeLarge");
        table.insert(Data, "Effects_XF_BuildingSmokeMedium");
        table.insert(Data, "Effects_XF_HouseFire");
        table.insert(Data, "Effects_XF_HouseFireLo");
        table.insert(Data, "Effects_XF_HouseFireMedium");
        table.insert(Data, "Effects_XF_HouseFireSmall");
        if g_GameExtraNo > 0 then
            table.insert(Data, "Effects_E_KhanaTemple_Fire");
            table.insert(Data, "Effects_E_Knight_Saraya_Aura");
        end
        -- Sort list
        table.sort(Data);
        return Data;
    end
end

function B_Reprisal_SetModel:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    if not Models[self.Model] then
        error(_Quest.Identifier.. ": " ..self.Name .. ": model '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_SetModel);

-- -------------------------------------------------------------------------- --

function Reward_SetPosition(...)
    return B_Reward_SetPosition:new(...);
end

B_Reward_SetPosition = CopyTable(B_Reprisal_SetPosition);
B_Reward_SetPosition.Name = "Reward_SetPosition";
B_Reward_SetPosition.Description.en = "Reward: Places an entity relative to the position of another. The entity can look the target.";
B_Reward_SetPosition.Description.de = "Lohn: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.";
B_Reward_SetPosition.Description.fr = "Récompense: Définit une Entity vis-à-vis de la position d'une autre. L'entité peut être orientée vers la cible.";
B_Reward_SetPosition.GetReprisalTable = nil;

B_Reward_SetPosition.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

RegisterBehavior(B_Reward_SetPosition);

-- -------------------------------------------------------------------------- --

function Reward_ChangePlayer(...)
    return B_Reward_ChangePlayer:new(...);
end

B_Reward_ChangePlayer = CopyTable(B_Reprisal_ChangePlayer);
B_Reward_ChangePlayer.Name = "Reward_ChangePlayer";
B_Reward_ChangePlayer.Description.en = "Reward: Changes the owner of the entity or a battalion.";
B_Reward_ChangePlayer.Description.de = "Lohn: Ändert den Besitzer einer Entity oder eines Battalions.";
B_Reward_ChangePlayer.Description.fr = "Récompense: Change le propriétaire d'une entité ou d'un bataillon.";
B_Reward_ChangePlayer.GetReprisalTable = nil;

B_Reward_ChangePlayer.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } };
end

RegisterBehavior(B_Reward_ChangePlayer);

-- -------------------------------------------------------------------------- --

function Reward_MoveToPosition(...)
    return B_Reward_MoveToPosition:new(...);
end

B_Reward_MoveToPosition = {
    Name = "Reward_MoveToPosition",
    Description = {
        en = "Reward: Moves an entity relative to another entity. If angle is zero the entities will be standing directly face to face.",
        de = "Lohn: Bewegt eine Entity relativ zur Position einer anderen. Wenn Winkel 0 ist, stehen sich die Entities direkt gegenüber.",
        fr = "Récompense: Déplace une entité par rapport à la position d'une autre. Si l'angle est égal à 0, les entités sont directement opposées.",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Settler",     de = "Siedler",     fr = "Settler" },
        { ParameterType.ScriptName, en = "Destination", de = "Ziel",        fr = "Destination" },
        { ParameterType.Number,     en = "Distance",    de = "Entfernung",  fr = "Distance" },
        { ParameterType.Number,     en = "Angle",       de = "Winkel",      fr = "Angle" },
    },
}

function B_Reward_MoveToPosition:GetRewardTable()
    return { Reward.Custom, {self, self.CustomFunction} }
end

function B_Reward_MoveToPosition:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Target = _Parameter;
    elseif (_Index == 2) then
        self.Distance = _Parameter * 1;
    elseif (_Index == 3) then
        self.Angle = _Parameter * 1;
    end
end

function B_Reward_MoveToPosition:CustomFunction(_Quest)
    if not IsExisting(self.Entity) or not IsExisting(self.Target) then
        return;
    end
    self.Angle = self.Angle or 0;

    local entity = GetID(self.Entity);
    local target = GetID(self.Target);
    local orientation = Logic.GetEntityOrientation(target);
    local x,y,z = Logic.EntityGetPos(target);
    if Logic.IsBuilding(target) == 1 then
        x, y = Logic.GetBuildingApproachPosition(target);
        orientation = orientation -90;
    end
    x = x + self.Distance * math.cos(math.rad(orientation+self.Angle));
    y = y + self.Distance * math.sin(math.rad(orientation+self.Angle));
    Logic.MoveSettler(entity, x, y);
    self.EntityMovingJob = RequestJob( function(_entityID, _targetID)
        if Logic.IsEntityMoving(_entityID) == false then
            LookAt(_entityID, _targetID);
            return true;
        end
    end, entity, target);
end

function B_Reward_MoveToPosition:Reset(_Quest)
    if self.EntityMovingJob then
        EndJob(self.EntityMovingJob);
    end
end

function B_Reward_MoveToPosition:Debug(_Quest)
    if tonumber(self.Distance) == nil or self.Distance < 50 then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Distance is nil or to short!");
        return true;
    elseif not IsExisting(self.Entity) or not IsExisting(self.Target) then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Mover entity or target entity does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_MoveToPosition);

-- -------------------------------------------------------------------------- --

function Reward_VictoryWithParty()
    return B_Reward_VictoryWithParty:new();
end

B_Reward_VictoryWithParty = {
    Name = "Reward_VictoryWithParty",
    Description = {
        en = "Reward: (Singleplayer) The player wins the game with an animated festival on the market. Continue playing deleates the festival.",
        de = "Lohn: (Einzelspieler) Der Spieler gewinnt das Spiel mit einer animierten Siegesfeier. Bei weiterspielen wird das Fest gelöscht.",
        fr = "Récompense: (Joueur unique) Le joueur gagne la partie avec une fête de la victoire animée. Si le joueur continue à jouer, la fête est effacée.",
    },
    Parameter = {}
};

function B_Reward_VictoryWithParty:GetRewardTable()
    return {Reward.Custom, {self, self.CustomFunction}};
end

function B_Reward_VictoryWithParty:AddParameter(_Index, _Parameter)
end

function B_Reward_VictoryWithParty:CustomFunction(_Quest)
    if not Lib.QuestBehavior then
        return;
    end
    if Framework.IsNetworkGame() then
        error(_Quest.Identifier.. ": " ..self.Name.. ": Can not be used in multiplayer!");
        return;
    end
    Victory(g_VictoryAndDefeatType.VictoryMissionComplete);
    local PlayerID = _Quest.ReceivingPlayer;

    local MarketID = Logic.GetMarketplace(PlayerID);
    if IsExisting(MarketID) then
        local pos = GetPosition(MarketID);
        Logic.CreateEffect(EGL_Effects.FXFireworks01,pos.X,pos.Y,0);
        Logic.CreateEffect(EGL_Effects.FXFireworks02,pos.X,pos.Y,0);

        local Generated = self:GenerateParty(PlayerID);
        Lib.QuestBehavior.Global.VictoryWithPartyEntities[PlayerID] = Generated;

        Logic.ExecuteInLuaLocalState(string.format(
            [[
                local MarketID = %d
                if IsExisting(MarketID) then
                    CameraAnimation.AllowAbort = false
                    CameraAnimation.QueueAnimation(CameraAnimation.SetCameraToEntity, MarketID)
                    CameraAnimation.QueueAnimation(CameraAnimation.StartCameraRotation, 5)
                    CameraAnimation.QueueAnimation(CameraAnimation.Stay ,9999)
                end

                GUI_Window.ContinuePlayingClicked_Orig_Reward_VictoryWithParty = GUI_Window.ContinuePlayingClicked
                GUI_Window.ContinuePlayingClicked = function()
                    GUI_Window.ContinuePlayingClicked_Orig_Reward_VictoryWithParty()
                    
                    local PlayerID = GUI.GetPlayerID()
                    GUI.SendScriptCommand("B_Reward_VictoryWithParty:ClearParty(" ..PlayerID.. ")")

                    CameraAnimation.AllowAbort = true
                    CameraAnimation.Abort()
                end
            ]],
            MarketID
        ));
    end
end

function B_Reward_VictoryWithParty:ClearParty(_PlayerID)
    if Lib.QuestBehavior.Global.VictoryWithPartyEntities[_PlayerID] then
        for k, v in pairs(Lib.QuestBehavior.Global.VictoryWithPartyEntities[_PlayerID]) do
            DestroyEntity(v);
        end
        Lib.QuestBehavior.Global.VictoryWithPartyEntities[_PlayerID] = nil;
    end
end

function B_Reward_VictoryWithParty:GenerateParty(_PlayerID)
    local GeneratedEntities = {};
    local Marketplace = Logic.GetMarketplace(_PlayerID);
    if Marketplace ~= nil and Marketplace ~= 0 then
        local MarketX, MarketY = Logic.GetEntityPosition(Marketplace);
        local ID = Logic.CreateEntity(Entities.D_X_Garland, MarketX, MarketY, 0, _PlayerID)
        table.insert(GeneratedEntities, ID);
        for j=1, 10 do
            for k=1,10 do
                local SettlersX = MarketX -700+ (j*150);
                local SettlersY = MarketY -700+ (k*150);
                local rand = math.random(1, 100);
                if rand > 70 then
                    local SettlerType = GetRandomSettlerType();
                    local Orientation = math.random(1, 359);
                    local WorkerID = Logic.CreateEntityOnUnblockedLand(SettlerType, SettlersX, SettlersY, Orientation, _PlayerID);
                    Logic.SetTaskList(WorkerID, TaskLists.TL_WORKER_FESTIVAL_APPLAUD_SPEECH);
                    table.insert(GeneratedEntities, WorkerID);
                end
            end
        end
    end
    return GeneratedEntities;
end

function B_Reward_VictoryWithParty:Debug(_Quest)
    if Lib.QuestBehavior then
        if Lib.QuestBehavior.Global.VictoryWithPartyEntities[_Quest.ReceivingPlayer] then
            error(_Quest.Identifier.. ": " ..self.Name..": Victory festival already started for player ".._Quest.ReceivingPlayer.."!");
            return true;
        end
    end
    return false;
end

RegisterBehavior(B_Reward_VictoryWithParty);

-- -------------------------------------------------------------------------- --

function Reward_SetVisible(...)
    return B_Reward_SetVisible:new(...)
end

B_Reward_SetVisible = CopyTable(B_Reprisal_SetVisible);
B_Reward_SetVisible.Name = "Reward_SetVisible";
B_Reward_SetVisible.Description.en = "Reward: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.";
B_Reward_SetVisible.Description.de = "Lohn: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.";
B_Reward_SetVisible.Description.fr = "Récompense: Définit la visibilité d'une Entity. S'il s'agit d'un spawn, les entités spawnées sont également influencées.";
B_Reward_SetVisible.GetReprisalTable = nil;

B_Reward_SetVisible.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

RegisterBehavior(B_Reward_SetVisible);

-- -------------------------------------------------------------------------- --

function Reward_SetVulnerability(...)
    return B_Reward_SetVulnerability:new(...);
end

B_Reward_SetVulnerability = CopyTable(B_Reprisal_SetVulnerability);
B_Reward_SetVulnerability.Name = "Reward_SetVulnerability";
B_Reward_SetVulnerability.Description.en = "Reward: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.";
B_Reward_SetVulnerability.Description.de = "Lohn: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen.";
B_Reward_SetVulnerability.Description.fr = "Récompense: Rend une Entité vulnérable ou invulnérable. S'il s'agit d'un spawn, les entités spawnées sont affectées.";
B_Reward_SetVulnerability.GetReprisalTable = nil;

B_Reward_SetVulnerability.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

RegisterBehavior(B_Reward_SetVulnerability);

-- -------------------------------------------------------------------------- --

function Reward_SetModel(...)
    return B_Reward_SetModel:new(...);
end

B_Reward_SetModel = CopyTable(B_Reprisal_SetModel);
B_Reward_SetModel.Name = "Reward_SetModel";
B_Reward_SetModel.Description.en = "Reward: Changes the model of the entity. Be careful, some models crash the game.";
B_Reward_SetModel.Description.de = "Lohn: Ändert das Model einer Entity. Achtung: Einige Modelle führen zum Absturz.";
B_Reward_SetModel.Description.fr = "Récompense: Modifie le modèle d'une entité. Attention : certains modèles entraînent un plantage.";
B_Reward_SetModel.GetReprisalTable = nil;

B_Reward_SetModel.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, { self, self.CustomFunction } }
end

RegisterBehavior(B_Reward_SetModel);

-- -------------------------------------------------------------------------- --

function Reward_AI_SetEntityControlled(...)
    return B_Reward_AI_SetEntityControlled:new(...);
end

B_Reward_AI_SetEntityControlled = {
    Name = "Reward_AI_SetEntityControlled",
    Description = {
        en = "Reward: Bind or Unbind an entity or a battalion to/from an AI player. The AI player must be activated!",
        de = "Lohn: Die KI kontrolliert die Entity oder der KI die Kontrolle entziehen. Die KI muss aktiv sein!",
        fr = "Récompense: L'IA contrôle l'entité ou retirer le contrôle à l'IA. L'IA doit être active !",
    },
    Parameter = {
        { ParameterType.ScriptName, en = "Entity",            de = "Entity",                 fr = "Entité", },
        { ParameterType.Custom,     en = "AI control entity", de = "KI kontrolliert Entity", fr = "L'IA contrôle l'entité", },
    },
}

function B_Reward_AI_SetEntityControlled:GetRewardTable()
    return { Reward.Custom, { self, self.CustomFunction } }
end

function B_Reward_AI_SetEntityControlled:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Entity = _Parameter;
    elseif (_Index == 1) then
        self.Hidden = ToBoolean(_Parameter)
    end
end

function B_Reward_AI_SetEntityControlled:CustomFunction(_Quest)
    if not IsExisting(self.Entity) then
        return;
    end
    local eID = GetID(self.Entity);
    local pID = Logic.EntityGetPlayer(eID);
    local eType = Logic.GetEntityType(eID);
    local tName = Logic.GetEntityTypeName(eType);
    if string.find(tName, "S_") or string.find(tName, "B_NPC_Bandits")
    or string.find(tName, "B_NPC_Barracks") then
        local spawned = {Logic.GetSpawnedEntities(eID)};
        for i=1, #spawned do
            if Logic.IsLeader(spawned[i]) == 1 then
                AICore.HideEntityFromAI(pID, spawned[i], not self.Hidden);
            end
        end
    else
        AICore.HideEntityFromAI(pID, eID, not self.Hidden);
    end
end

function B_Reward_AI_SetEntityControlled:GetCustomData(_Index)
    if _Index == 1 then
        return { "false", "true" }
    end
end

function B_Reward_AI_SetEntityControlled:Debug(_Quest)
    if not IsExisting(self.Entity) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": entity '"..  self.Entity .. "' does not exist!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reward_AI_SetEntityControlled);

-- -------------------------------------------------------------------------- --

function Trigger_AmmunitionDepleted(...)
    return B_Trigger_AmmunitionDepleted:new(...);
end

B_Trigger_AmmunitionDepleted = {
    Name = "Trigger_AmmunitionDepleted",
    Description = {
        en = "Trigger: if the ammunition of the entity is depleted.",
        de = "Auslöser: wenn die Munition der Entity aufgebraucht ist.",
        fr = "Déclencheur: lorsque les munitions de l'entité sont épuisées.",
    },
    Parameter = {
        { ParameterType.Scriptname, en = "Script name", de = "Skriptname", fr = "Nom de l'entité" },
    },
}

function B_Trigger_AmmunitionDepleted:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_AmmunitionDepleted:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.Scriptname = _Parameter
    end
end

function B_Trigger_AmmunitionDepleted:CustomFunction()
    if not IsExisting(self.Scriptname) then
        return false;
    end

    local EntityID = GetID(self.Scriptname);
    if Logic.GetAmmunitionAmount(EntityID) > 0 then
        return false;
    end

    return true;
end

function B_Trigger_AmmunitionDepleted:Debug(_Quest)
    if not IsExisting(self.Scriptname) then
        error(_Quest.Identifier.. ": " ..self.Name .. ": '"..self.Scriptname.."' is destroyed!");
        return true
    end
    return false
end

RegisterBehavior(B_Trigger_AmmunitionDepleted);

-- -------------------------------------------------------------------------- --

Lib.Register("module/trade/Warehouse_Behavior");

B_Reward_TradePost.DEBUG_Orig_Warehouse = B_Reward_TradePost.DEBUG;
--- @diagnostic disable-next-line: duplicate-set-field
B_Reward_TradePost.DEBUG = function(self, _Quest)
    local Index = Lib.Warehouse.Global:GetIndex(self.ScriptName);
    if Index ~= 0 then
        debug(false, _Quest.Identifier .. ": Error in " .. self.Name ..": Can not use a tradepost that is already a warehouse!");
        return false;
    end
    return self:DEBUG_Orig_Warehouse(_Quest);
end

B_Reward_TradePost.CustomFunction_Orig_Warehouse = B_Reward_TradePost.CustomFunction;
--- @diagnostic disable-next-line: duplicate-set-field
B_Reward_TradePost.CustomFunction = function(self, _Quest)
    local Index = Lib.Warehouse.Global:GetIndex(self.ScriptName);
    if Index ~= 0 then
        debug(false, _Quest.Identifier .. ": Error in " .. self.Name ..": Can not use a tradepost that is already a warehouse!");
        return;
    end
    self:CustomFunction_Orig_Warehouse(_Quest);
end

-- -------------------------------------------------------------------------- --

Lib.Register("module/information/BriefingSystem_Behavior");

function Reprisal_Briefing(_Name, _Briefing)
    return B_Reprisal_Briefing:new(_Name, _Briefing);
end

B_Reprisal_Briefing = {
    Name = "Reprisal_Briefing",
    Description = {
        en = "Reprisal: Calls a function to start an new briefing.",
        de = "Vergeltung: Ruft die Funktion auf und startet das enthaltene Briefing.",
        fr = "Rétribution: Appelle la fonction et démarre le briefing qu'elle contient.",
    },
    Parameter = {
        { ParameterType.Default, en = "Briefing name",     de = "Name des Briefing",     fr = "Nom du briefing" },
        { ParameterType.Default, en = "Briefing function", de = "Funktion mit Briefing", fr = "Fonction avec briefing" },
    },
}

function B_Reprisal_Briefing:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_Briefing:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.BriefingName = _Parameter;
    elseif (_Index == 1) then
        self.Function = _Parameter;
    end
end

function B_Reprisal_Briefing:CustomFunction(_Quest)
    _G[self.Function](self.BriefingName, _Quest.ReceivingPlayer);
end

function B_Reprisal_Briefing:Debug(_Quest)
    if self.BriefingName == nil or self.BriefingName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    if not type(_G[self.Function]) == "function" then
        debug(false, _Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_Briefing);

-- -------------------------------------------------------------------------- --

function Reward_Briefing(_Name, _Briefing)
    return B_Reward_Briefing:new(_Name, _Briefing);
end

B_Reward_Briefing = CopyTable(B_Reprisal_Briefing);
B_Reward_Briefing.Name = "Reward_Briefing";
B_Reward_Briefing.Description.en = "Reward: Calls a function to start an new briefing.";
B_Reward_Briefing.Description.de = "Lohn: Ruft die Funktion auf und startet das enthaltene Briefing.";
B_Reward_Briefing.Description.fr = "Récompense: Appelle la fonction et démarre le briefing qu'elle contient.";
B_Reward_Briefing.GetReprisalTable = nil;

B_Reward_Briefing.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_Briefing);

-- -------------------------------------------------------------------------- --

function Trigger_Briefing(_Name, _PlayerID, _Waittime)
    return B_Trigger_Briefing:new(_Name, _PlayerID, _Waittime);
end

B_Trigger_Briefing = {
    Name = "Trigger_Briefing",
    Description = {
        en = "Trigger: Checks if an briefing has concluded and starts the quest if so.",
        de = "Auslöser: Prüft, ob ein Briefing beendet ist und startet dann den Quest.",
        fr = "Déclencheur: Vérifie si un briefing est terminé et lance ensuite la quête.",
    },
    Parameter = {
        { ParameterType.Default,  en = "Briefing name", de = "Name des Briefing", fr = "Nom du briefing" },
        { ParameterType.PlayerID, en = "Player ID",     de = "Player ID",         fr = "Player ID" },
        { ParameterType.Number,   en = "Wait time",     de = "Wartezeit",         fr = "Temps d'attente" },
    },
}

function B_Trigger_Briefing:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_Briefing:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.BriefingName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function B_Trigger_Briefing:CustomFunction(_Quest)
    if GetCinematicEvent(self.BriefingName, self.PlayerID) == CinematicEventState.Concluded then
        if self.WaitTime and self.WaitTime > 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function B_Trigger_Briefing:Debug(_Quest)
    if self.WaitTime < 0 then
        debug(false, string.format("%s: %s: Wait time must be 0 or greater!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, string.format("%s: %s: Player-ID must be between 1 and 8!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.BriefingName == nil or self.BriefingName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_Briefing);

-- -------------------------------------------------------------------------- --

Lib.Register("module/information/CutsceneSystem_Behavior");

function Reprisal_Cutscene(_Name, _Cutscene)
    return B_Reprisal_Cutscene:new(_Name, _Cutscene);
end

B_Reprisal_Cutscene = {
    Name = "Reprisal_Cutscene",
    Description = {
        en = "Reprisal: Calls a function to start an new Cutscene.",
        de = "Vergeltung: Ruft die Funktion auf und startet die enthaltene Cutscene.",
        fr = "Rétribution : Appelle la fonction et démarre la cutscene contenue.",
    },
    Parameter = {
        { ParameterType.Default, en = "Cutscene name",     de = "Name der Cutscene",     fr = "Nom de la cutscene", },
        { ParameterType.Default, en = "Cutscene function", de = "Funktion mit Cutscene", fr = "Fonction avec cutscene", },
    },
}

function B_Reprisal_Cutscene:GetReprisalTable()
    return { Reprisal.Custom, {self, self.CustomFunction} }
end

function B_Reprisal_Cutscene:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.CutsceneName = _Parameter;
    elseif (_Index == 1) then
        self.Function = _Parameter;
    end
end

function B_Reprisal_Cutscene:CustomFunction(_Quest)
    _G[self.Function](self.CutsceneName, _Quest.ReceivingPlayer);
end

function B_Reprisal_Cutscene:Debug(_Quest)
    if self.CutsceneName == nil or self.CutsceneName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    if not type(_G[self.Function]) == "function" then
        debug(false, _Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_Cutscene);

-- -------------------------------------------------------------------------- --

function Reward_Cutscene(_Name, _Cutscene)
    return B_Reward_Cutscene:new(_Name, _Cutscene);
end

B_Reward_Cutscene = CopyTable(B_Reprisal_Cutscene);
B_Reward_Cutscene.Name = "Reward_Cutscene";
B_Reward_Cutscene.Description.en = "Reward: Calls a function to start an new Cutscene.";
B_Reward_Cutscene.Description.de = "Lohn: Ruft die Funktion auf und startet die enthaltene Cutscene.";
B_Reward_Cutscene.Description.fr = "Récompense: Appelle la fonction et démarre la cutscene contenue.";
B_Reward_Cutscene.GetReprisalTable = nil;

B_Reward_Cutscene.GetRewardTable = function(self, _Quest)
    return { Reward.Custom, {self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_Cutscene);

-- -------------------------------------------------------------------------- --

function Trigger_Cutscene(_Name, _PlayerID, _Waittime)
    return B_Trigger_Cutscene:new(_Name, _PlayerID, _Waittime);
end

B_Trigger_Cutscene = {
    Name = "Trigger_Cutscene",
    Description = {
        en = "Trigger: Checks if an Cutscene has concluded and starts the quest if so.",
        de = "Auslöser: Prüft, ob eine Cutscene beendet ist und startet dann den Quest.",
        fr = "Déclencheur: Vérifie si une cutscene est terminée et démarre ensuite la quête.",
    },
    Parameter = {
        { ParameterType.Default,  en = "Cutscene name", de = "Name der Cutscene", fr  ="Nom de la cutscene" },
        { ParameterType.PlayerID, en = "Player ID",     de = "Player ID",         fr  ="Player ID" },
        { ParameterType.Number,   en = "Wait time",     de = "Wartezeit",         fr  ="Temps d'attente" },
    },
}

function B_Trigger_Cutscene:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_Cutscene:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.CutsceneName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function B_Trigger_Cutscene:CustomFunction(_Quest)
    if GetCinematicEvent(self.CutsceneName, self.PlayerID) == CinematicEventState.Concluded then
        if self.WaitTime and self.WaitTime > 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function B_Trigger_Cutscene:Debug(_Quest)
    if self.WaitTime < 0 then
        debug(false, string.format("%s: %s: Wait time must be 0 or greater!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, string.format("%s: %s: Player-ID must be between 1 and 8!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.CutsceneName == nil or self.CutsceneName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_Cutscene);

-- -------------------------------------------------------------------------- --

Lib.Register("module/information/DialogSystem_Behavior");

function Reprisal_Dialog(_Name, _Dialog)
    return B_Reprisal_Dialog:new(_Name, _Dialog);
end

B_Reprisal_Dialog = {
    Name = "Reprisal_Dialog",
    Description = {
        en = "Reprisal: Calls a function to start an new dialog.",
        de = "Vergeltung: Ruft die Funktion auf und startet das enthaltene Dialog.",
        fr = "Rétribution: Appelle la fonction et démarre le dialogue contenu.",
    },
    Parameter = {
        { ParameterType.Default, en = "Dialog name",     de = "Name des Dialog",     fr = "Nom du dialogue" },
        { ParameterType.Default, en = "Dialog function", de = "Funktion mit Dialog", fr = "Fonction du dialogue" },
    },
}

function B_Reprisal_Dialog:GetReprisalTable()
    return { Reprisal.Custom,{self, self.CustomFunction} }
end

function B_Reprisal_Dialog:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.DialogName = _Parameter;
    elseif (_Index == 1) then
        self.Function = _Parameter;
    end
end

function B_Reprisal_Dialog:CustomFunction(_Quest)
    _G[self.Function](self.DialogName, _Quest.ReceivingPlayer);
end

function B_Reprisal_Dialog:Debug(_Quest)
    if self.DialogName == nil or self.DialogName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    if not type(_G[self.Function]) == "function" then
        debug(false, _Quest.Identifier..": "..self.Name..": '"..self.Function.."' was not found!");
        return true;
    end
    return false;
end

RegisterBehavior(B_Reprisal_Dialog);

-- -------------------------------------------------------------------------- --

function Reward_Dialog(_Name, _Dialog)
    return B_Reward_Dialog:new(_Name, _Dialog);
end

B_Reward_Dialog = CopyTable(B_Reprisal_Dialog);
B_Reward_Dialog.Name = "Reward_Dialog";
B_Reward_Dialog.Description.en = "Reward: Calls a function to start an new dialog.";
B_Reward_Dialog.Description.de = "Lohn: Ruft die Funktion auf und startet das enthaltene Dialog.";
B_Reward_Dialog.Description.fr = "Récompense: Appelle la fonction et lance le dialogue qu'elle contient.";
B_Reward_Dialog.GetReprisalTable = nil;

B_Reward_Dialog.GetRewardTable = function(self, _Quest)
    return { Reward.Custom,{self, self.CustomFunction} }
end

RegisterBehavior(B_Reward_Dialog);

-- -------------------------------------------------------------------------- --

function Trigger_Dialog(_Name, _PlayerID, _Waittime)
    return B_Trigger_Dialog:new(_Name, _PlayerID, _Waittime);
end

B_Trigger_Dialog = {
    Name = "Trigger_Dialog",
    Description = {
        en = "Trigger: Checks if an dialog has concluded and starts the quest if so.",
        de = "Auslöser: Prüft, ob ein Dialog beendet ist und startet dann den Quest.",
        fr = "Déclencheur: Vérifie si un dialogue est terminé et démarre alors la quête.",
    },
    Parameter = {
        { ParameterType.Default,  en = "Dialog name", de = "Name des Dialog", fr = "Nom du dialogue" },
        { ParameterType.PlayerID, en = "Player ID",   de = "Player ID",       fr = "Player ID" },
        { ParameterType.Number,   en = "Wait time",   de = "Wartezeit",       fr = "Temps d'attente" },
    },
}

function B_Trigger_Dialog:GetTriggerTable()
    return { Triggers.Custom2,{self, self.CustomFunction} }
end

function B_Trigger_Dialog:AddParameter(_Index, _Parameter)
    if (_Index == 0) then
        self.DialogName = _Parameter;
    elseif (_Index == 1) then
        self.PlayerID = _Parameter * 1;
    elseif (_Index == 2) then
        _Parameter = _Parameter or 0;
        self.WaitTime = _Parameter * 1;
    end
end

function B_Trigger_Dialog:CustomFunction(_Quest)
    if GetCinematicEvent(self.DialogName, self.PlayerID) == CinematicEventState.Concluded then
        if self.WaitTime and self.WaitTime > 0 then
            self.WaitTimeTimer = self.WaitTimeTimer or Logic.GetTime();
            if Logic.GetTime() >= self.WaitTimeTimer + self.WaitTime then
                return true;
            end
        else
            return true;
        end
    end
    return false;
end

function B_Trigger_Dialog:Debug(_Quest)
    if self.WaitTime < 0 then
        debug(false, string.format("%s: %s: Wait time must be 0 or greater!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.PlayerID < 1 or self.PlayerID > 8 then
        debug(false, string.format("%s: %s: Player-ID must be between 1 and 8!", _Quest.Identifier, self.Name));
        return true;
    end
    if self.DialogName == nil or self.DialogName == "" then
        debug(false, string.format("%s: %s: Dialog name is invalid!", _Quest.Identifier, self.Name));
        return true;
    end
    return false;
end

RegisterBehavior(B_Trigger_Dialog);

-- -------------------------------------------------------------------------- --

Lib.Register("module/information/Requester_Behavior");

function Goal_Decide(...)
    return B_Goal_Decide:new(...);
end

g_GoalDecideDialogDisplayed = nil;
g_DecisionWindowResult = nil;

B_Goal_Decide = {
    Name = "Goal_Decide",
    Description = {
        en = "Goal: Opens a Yes/No Dialog. The decision dictates the quest result (yes=true, no=false).",
        de = "Ziel: Öffnet einen Ja/Nein-Dialog. Die Entscheidung bestimmt das Quest-Ergebnis (ja=true, nein=false).",
        fr = "Objectif: ouvre une fenêtre de dialogue oui/non. La décision détermine le résultat de la quête (oui=true, non=false).",
    },
    Parameter = {
        { ParameterType.Default, en = "Text",          de = "Text",                fr = "Text", },
        { ParameterType.Default, en = "Title",         de = "Titel",               fr = "Titre", },
        { ParameterType.Custom,  en = "Button labels", de = "Button Beschriftung", fr = "Inscription sur le bouton", },
    },
}

function B_Goal_Decide:GetGoalTable()
    return { Objective.Custom2, { self, self.CustomFunction } }
end

function B_Goal_Decide:AddParameter( _Index, _Parameter )
    if (_Index == 0) then
        self.Text = _Parameter
    elseif (_Index == 1) then
        self.Title = _Parameter
    elseif (_Index == 2) then
        self.Buttons = (_Parameter == "Ok/Cancel" or _Parameter == true)
    end
end

function B_Goal_Decide:CustomFunction(_Quest)
    if Framework.IsNetworkGame() then
        return false;
    end
    if IsCinematicEventActive and IsCinematicEventActive(_Quest.ReceivingPlayer) then
        return;
    end
    if g_GoalDecideDialogDisplayed == nil then
        g_GoalDecideDialogDisplayed = true;
        ExecuteLocal(
            [[DialogRequestBox("%s", "%s", function(_Yes) end, %s)]],
            self.Title,
            self.Text,
            (self.Buttons and "true") or "nil"
        );
    end
    local result = g_DecisionWindowResult
    if result ~= nil then
        g_GoalDecideDialogDisplayed = nil;
        g_DecisionWindowResult = nil;
        return result;
    end
end

function B_Goal_Decide:GetCustomData(_Index)
    if _Index == 2 then
        return {"Yes/No", "Ok/Cancel"};
    end
end

function B_Goal_Decide:Debug(_Quest)
    if Framework.IsNetworkGame() then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Can not be used in multiplayer!");
        return true;
    end
    if _Quest.Visible == true then
        debug(false, _Quest.Identifier.. ": " ..self.Name..": Is supposed to be used in invisible quests!");
        return true;
    end
    return false;
end

function B_Goal_Decide:Reset()
    g_GoalDecideDialogDisplayed = nil;
end

RegisterBehavior(B_Goal_Decide);

-- -------------------------------------------------------------------------- --

