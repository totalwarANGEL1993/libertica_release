ParameterType=ParameterType or{}Report=Report or{}g_QuestBehaviorVersion=1;g_QuestBehaviorTypes={}g_GameExtraNo=0;if Framework then g_GameExtraNo=Framework.GetGameExtraNo()elseif MapEditor then g_GameExtraNo=MapEditor.GetGameExtraNo()end;function LoadBehaviors()for a=1,#g_QuestBehaviorTypes,1 do local b=g_QuestBehaviorTypes[a]if not _G["B_"..b.Name].new then _G["B_"..b.Name].new=function(self,...)local c={...}local d=table.copy(self)d.i47ya_6aghw_frxil={}d.v12ya_gg56h_al125={}for e=1,#c,1 do table.insert(d.v12ya_gg56h_al125,c[e])if self.Parameter and self.Parameter[e]~=nil then d:AddParameter(e-1,c[e])else table.insert(d.i47ya_6aghw_frxil,c[e])end end;return d end end end end;function RegisterBehavior(f)if GUI~=nil then return end;if type(f)~="table"or f.Name==nil then assert(false,"Behavior is invalid!")return end;if f.RequiresExtraNo and f.RequiresExtraNo>g_GameExtraNo then return end;if not _G["B_"..f.Name]then error(string.format("Behavior %s does not exist!",f.Name))return end;for a=1,#g_QuestBehaviorTypes,1 do if g_QuestBehaviorTypes[a].Name==f.Name then return end end;table.insert(g_QuestBehaviorTypes,f)end;if not MapEditor and GUI then return end;function Reward_DEBUG(g,h,i,j,k)return B_Reward_DEBUG:new(g,h,i,j,k)end;B_Reward_DEBUG={Name="Reward_DEBUG",Description={en="Reward: Start the debug mode. See documentation for more information.",de="Lohn: Startet den Debug-Modus. Für mehr Informationen siehe Dokumentation.",fr="Récompense: Démarre le mode de débug. Pour plus d'informations, voir la documentation."},Parameter={{ParameterType.Custom,en="Activate script errors",de="Skriptfeleranzeige nutzen",fr="Afficher les erreurs de script"},{ParameterType.Custom,en="Check quest while runtime",de="Quests zur Laufzeit prüfen",fr="Vérifier les quêtes au cours de l'exécution"},{ParameterType.Custom,en="Activate developing cheats",de="Cheats aktivieren",fr="Activer les cheats"},{ParameterType.Custom,en="Activate developing shell",de="Eingabe aktivieren",fr="Activer la saisie"},{ParameterType.Custom,en="Use quest trace",de="Questverfolgung",fr="Suivi de quête"}}}function B_Reward_DEBUG:GetRewardTable(l)return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_DEBUG:AddParameter(m,n)if m==0 then self.DisplayScriptErrors=ToBoolean(n)elseif m==1 then self.CheckWhileRuntime=ToBoolean(n)elseif m==2 then self.DevelopingCheats=ToBoolean(n)elseif m==3 then self.DevelopingShell=ToBoolean(n)elseif m==4 then self.UseQuestTrace=ToBoolean(n)end end;function B_Reward_DEBUG:CustomFunction(l)ActivateDebugMode(self.DisplayScriptErrors,self.CheckWhileRuntime,self.DevelopingCheats,self.DevelopingShell,self.UseQuestTrace)end;function B_Reward_DEBUG:GetCustomData(m)return{"true","false"}end;RegisterBehavior(B_Reward_DEBUG)function Goal_ActivateObject(...)return B_Goal_ActivateObject:new(...)end;B_Goal_ActivateObject={Name="Goal_ActivateObject",Description={en="Goal: Activate an interactive object",de="Ziel: Aktiviere ein interaktives Objekt",fr="Objectif: activer un objet interactif"},Parameter={{ParameterType.ScriptName,en="Object name",de="Skriptname",fr="Nom de l'entité"}}}function B_Goal_ActivateObject:GetGoalTable()return{Objective.Object,{self.ScriptName}}end;function B_Goal_ActivateObject:AddParameter(m,n)if m==0 then self.ScriptName=n end end;function B_Goal_ActivateObject:GetMsgKey()return"Quest_Object_Activate"end;RegisterBehavior(B_Goal_ActivateObject)function Goal_Deliver(...)return B_Goal_Deliver:new(...)end;B_Goal_Deliver={Name="Goal_Deliver",Description={en="Goal: Deliver goods to quest giver or to another player.",de="Ziel: Liefere Waren zum Auftraggeber oder zu einem anderen Spieler.",fr="Objectif: livrer des marchandises au mandant ou à un autre joueur."},Parameter={{ParameterType.Custom,en="Type of good",de="Ressourcentyp",fr="Type de ressources"},{ParameterType.Number,en="Amount of good",de="Ressourcenmenge",fr="Quantité de ressources"},{ParameterType.Custom,en="To different player",de="Anderer Empfänger",fr="Autre bénéficiaire"},{ParameterType.Custom,en="Ignore capture",de="Abfangen ignorieren",fr="Ignorer une interception"}}}function B_Goal_Deliver:GetGoalTable()local o=Logic.GetGoodTypeID(self.GoodTypeName)return{Objective.Deliver,o,self.GoodAmount,self.OverrideTarget,self.IgnoreCapture}end;function B_Goal_Deliver:AddParameter(m,n)if m==0 then self.GoodTypeName=n elseif m==1 then self.GoodAmount=n*1 elseif m==2 then self.OverrideTarget=tonumber(n)elseif m==3 then self.IgnoreCapture=ToBoolean(n)end end;function B_Goal_Deliver:GetCustomData(m)local p={}if m==0 then for q,r in pairs(Goods)do if string.find(q,"^G_")then table.insert(p,q)end end;table.sort(p)elseif m==2 then table.insert(p,"-")for a=1,8 do table.insert(p,a)end elseif m==3 then table.insert(p,"true")table.insert(p,"false")else assert(false)end;return p end;function B_Goal_Deliver:GetMsgKey()local o=Logic.GetGoodTypeID(self.GoodTypeName)local s=Logic.GetGoodCategoryForGoodType(o)local t={[GoodCategories.GC_Clothes]="Quest_Deliver_GC_Clothes",[GoodCategories.GC_Entertainment]="Quest_Deliver_GC_Entertainment",[GoodCategories.GC_Food]="Quest_Deliver_GC_Food",[GoodCategories.GC_Gold]="Quest_Deliver_GC_Gold",[GoodCategories.GC_Hygiene]="Quest_Deliver_GC_Hygiene",[GoodCategories.GC_Medicine]="Quest_Deliver_GC_Medicine",[GoodCategories.GC_Water]="Quest_Deliver_GC_Water",[GoodCategories.GC_Weapon]="Quest_Deliver_GC_Weapon",[GoodCategories.GC_Resource]="Quest_Deliver_Resources"}if s then local u=t[s]if u then return u end end;return"Quest_Deliver_Goods"end;RegisterBehavior(B_Goal_Deliver)function Goal_Diplomacy(...)return B_Goal_Diplomacy:new(...)end;B_Goal_Diplomacy={Name="Goal_Diplomacy",Description={en="Goal: A diplomatic state must b reached. Can be lower than current state or higher.",de="Ziel: Die Beziehungen zu einem Spieler müssen entweder verbessert oder verschlechtert werden.",fr="Objectif: les relations avec un joueur doivent être soit améliorées, soit détériorées."},Parameter={{ParameterType.PlayerID,en="Party",de="Partei",fr="Faction"},{ParameterType.Custom,en="Relation",de="Relation",fr="Relation"},{ParameterType.Custom,en="Diplomacy state",de="Diplomatische Beziehung",fr="Relations diplomatiques"}},TextPattern={de="DIPLOMATIESTATUS ERREICHEN {cr}{cr}Status: %s{cr}Zur Partei: %s",en="DIPLOMATIC STATE {cr}{cr}State: %s{cr}To player: %s",fr="ATTEINDRE LE STATUT DE DIPLOMATIQUE {cr}{cr}Statut : %s{cr}Avec la faction : %s"}}function B_Goal_Diplomacy:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_Diplomacy:GetDiplomacyMapping()return{[DiplomacyStates.Allied]={de="Verbündeter",en="Allied",fr="Allié"},[DiplomacyStates.TradeContact]={de="Handelspartner",en="Trade Contact",fr="Partenaire commercial"},[DiplomacyStates.EstablishedContact]={de="Bekannt",en="Established Contact",fr="Contact établi"},[DiplomacyStates.Undecided]={de="Unbekannt",en="Undecided",fr="Inconnu"},[DiplomacyStates.Enemy]={de="Feind",en="Enemy",fr="Ennemi"}}end;function B_Goal_Diplomacy:ChangeCaption(l)local v=self:GetDiplomacyMapping()local w=GetPlayerName(self.PlayerID)or""local x=string.format(Localize(self.TextPattern),Localize(v[self.DiplState]),w)Lib.Core.Quest:ChangeCustomQuestCaptionText(x,l)end;function B_Goal_Diplomacy:CustomFunction(l)self:ChangeCaption(l)if self.Relation=="<="then if GetDiplomacyState(l.ReceivingPlayer,self.PlayerID)<=self.DiplState then return true end elseif self.Relation==">="then if GetDiplomacyState(l.ReceivingPlayer,self.PlayerID)>=self.DiplState then return true end else if GetDiplomacyState(l.ReceivingPlayer,self.PlayerID)==self.DiplState then return true end end end;function B_Goal_Diplomacy:AddParameter(m,n)if m==0 then self.PlayerID=n*1 elseif m==1 then self.Relation=n elseif m==2 then self.DiplState=DiplomacyStates[n]end end;function B_Goal_Diplomacy:GetIcon()return{6,3}end;function B_Goal_Diplomacy:GetCustomData(m)if m==1 then return{">=","<=","=="}elseif m==2 then return{"Allied","TradeContact","EstablishedContact","Undecided","Enemy"}end end;RegisterBehavior(B_Goal_Diplomacy)function Goal_DiscoverPlayer(...)return B_Goal_DiscoverPlayer:new(...)end;B_Goal_DiscoverPlayer={Name="Goal_DiscoverPlayer",Description={en="Goal: Discover the home territory of another player.",de="Ziel: Entdecke das Heimatterritorium eines Spielers.",fr="Objectif: Découvrir le territoire d'origine d'un joueur."},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"}}}function B_Goal_DiscoverPlayer:GetGoalTable()return{Objective.Discover,2,{self.PlayerID}}end;function B_Goal_DiscoverPlayer:AddParameter(m,n)if m==0 then self.PlayerID=n*1 end end;function B_Goal_DiscoverPlayer:GetMsgKey()local t={[PlayerCategories.BanditsCamp]="Quest_Discover",[PlayerCategories.City]="Quest_Discover_City",[PlayerCategories.Cloister]="Quest_Discover_Cloister",[PlayerCategories.Harbour]="Quest_Discover",[PlayerCategories.Village]="Quest_Discover_Village"}local y=GetPlayerCategoryType(self.PlayerID)if y then local u=t[y]if u then return u end end;return"Quest_Discover"end;RegisterBehavior(B_Goal_DiscoverPlayer)function Goal_DiscoverTerritory(...)return B_Goal_DiscoverTerritory:new(...)end;B_Goal_DiscoverTerritory={Name="Goal_DiscoverTerritory",Description={en="Goal: Discover a territory",de="Ziel: Entdecke ein Territorium",fr="Objectif : Découvrir un territoire"},Parameter={{ParameterType.TerritoryName,en="Territory",de="Territorium",fr="Territoire"}}}function B_Goal_DiscoverTerritory:GetGoalTable()return{Objective.Discover,1,{self.TerritoryID}}end;function B_Goal_DiscoverTerritory:AddParameter(m,n)if m==0 then self.TerritoryID=tonumber(n)if not self.TerritoryID then self.TerritoryID=GetTerritoryIDByName(n)end;assert(self.TerritoryID>0)end end;function B_Goal_DiscoverTerritory:GetMsgKey()return"Quest_Discover_Territory"end;RegisterBehavior(B_Goal_DiscoverTerritory)function Goal_DestroyPlayer(...)return B_Goal_DestroyPlayer:new(...)end;B_Goal_DestroyPlayer={Name="Goal_DestroyPlayer",Description={en="Goal: Destroy a player (destroy a main building)",de="Ziel: Zerstöre einen Spieler (ein Hauptgebäude muss zerstört werden).",fr="Objectif : Détruire un joueur (un bâtiment principal doit être détruit)."},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"}}}function B_Goal_DestroyPlayer:GetGoalTable()assert(self.PlayerID<=8 and self.PlayerID>=1,"Error in "..self.Name..": GetGoalTable: PlayerID is invalid")return{Objective.DestroyPlayers,self.PlayerID}end;function B_Goal_DestroyPlayer:AddParameter(m,n)if m==0 then self.PlayerID=n*1 end end;function B_Goal_DestroyPlayer:GetMsgKey()local t={[PlayerCategories.BanditsCamp]="Quest_DestroyPlayers_Bandits",[PlayerCategories.City]="Quest_DestroyPlayers_City",[PlayerCategories.Cloister]="Quest_DestroyPlayers_Cloister",[PlayerCategories.Harbour]="Quest_DestroyEntities_Building",[PlayerCategories.Village]="Quest_DestroyPlayers_Village"}local y=GetPlayerCategoryType(self.PlayerID)if y then local u=t[y]if u then return u end end;return"Quest_DestroyEntities_Building"end;RegisterBehavior(B_Goal_DestroyPlayer)function Goal_StealInformation(...)return B_Goal_StealInformation:new(...)end;B_Goal_StealInformation={Name="Goal_StealInformation",Description={en="Goal: Steal information from another players castle",de="Ziel: Stehle Informationen aus der Burg eines Spielers",fr="Objectif : voler des informations du château d'un joueur"},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"}}}function B_Goal_StealInformation:GetGoalTable()local z=Logic.GetHeadquarters(self.PlayerID)if not z or z==0 then z=Logic.GetStoreHouse(self.PlayerID)end;assert(z and z~=0)return{Objective.Steal,1,{z}}end;function B_Goal_StealInformation:AddParameter(m,n)if m==0 then self.PlayerID=n*1 end end;function B_Goal_StealInformation:GetMsgKey()return"Quest_Steal_Info"end;RegisterBehavior(B_Goal_StealInformation)function Goal_DestroyAllPlayerUnits(...)return B_Goal_DestroyAllPlayerUnits:new(...)end;B_Goal_DestroyAllPlayerUnits={Name="Goal_DestroyAllPlayerUnits",Description={en="Goal: Destroy all units owned by player (be careful with script entities)",de="Ziel: Zerstöre alle Einheiten eines Spielers (vorsicht mit Script-Entities)",fr="Objectif: Détruire toutes les unités d'un joueur (attention aux entités de script)"},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"}}}function B_Goal_DestroyAllPlayerUnits:GetGoalTable()return{Objective.DestroyAllPlayerUnits,self.PlayerID}end;function B_Goal_DestroyAllPlayerUnits:AddParameter(m,n)if m==0 then self.PlayerID=n*1 end end;function B_Goal_DestroyAllPlayerUnits:GetMsgKey()local t={[PlayerCategories.BanditsCamp]="Quest_DestroyPlayers_Bandits",[PlayerCategories.City]="Quest_DestroyPlayers_City",[PlayerCategories.Cloister]="Quest_DestroyPlayers_Cloister",[PlayerCategories.Harbour]="Quest_DestroyEntities_Building",[PlayerCategories.Village]="Quest_DestroyPlayers_Village"}local y=GetPlayerCategoryType(self.PlayerID)if y then local u=t[y]if u then return u end end;return"Quest_DestroyEntities"end;RegisterBehavior(B_Goal_DestroyAllPlayerUnits)function Goal_DestroyScriptEntity(...)return B_Goal_DestroyScriptEntity:new(...)end;B_Goal_DestroyScriptEntity={Name="Goal_DestroyScriptEntity",Description={en="Goal: Destroy an entity",de="Ziel: Zerstöre eine Entität",fr="Objectif : Détruire une entité"},Parameter={{ParameterType.ScriptName,en="Script name",de="Skriptname",fr="Nom de l'entité"}}}function B_Goal_DestroyScriptEntity:GetGoalTable()return{Objective.DestroyEntities,1,{self.ScriptName}}end;function B_Goal_DestroyScriptEntity:AddParameter(m,n)if m==0 then self.ScriptName=n end end;function B_Goal_DestroyScriptEntity:GetMsgKey()if Logic.IsEntityAlive(self.ScriptName)then local A=GetID(self.ScriptName)if A and A~=0 then A=Logic.GetEntityType(A)if A and A~=0 then if Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableBuilding)==1 then return"Quest_DestroyEntities_Building"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableAnimal)==1 then return"Quest_DestroyEntities_Predators"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.Hero)==1 then return"Quest_Destroy_Leader"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.Military)==1 or Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableSettler)==1 or Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableMerchant)==1 then return"Quest_DestroyEntities_Unit"end end end end;return"Quest_DestroyEntities"end;RegisterBehavior(B_Goal_DestroyScriptEntity)function Goal_DestroyType(...)return B_Goal_DestroyType:new(...)end;B_Goal_DestroyType={Name="Goal_DestroyType",Description={en="Goal: Destroy entity types",de="Ziel: Zerstöre Entitätstypen",fr="Objectif: Détruire les types d'entités"},Parameter={{ParameterType.Custom,en="Type name",de="Typbezeichnung",fr="Désignation du type"},{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"},{ParameterType.Custom,en="Player",de="Spieler",fr="Joueur"}}}function B_Goal_DestroyType:GetGoalTable()return{Objective.DestroyEntities,2,Entities[self.EntityName],self.Amount,self.PlayerID}end;function B_Goal_DestroyType:AddParameter(m,n)if m==0 then self.EntityName=n elseif m==1 then self.Amount=n*1;self.DestroyTypeAmount=self.Amount elseif m==2 then self.PlayerID=n*1 end end;function B_Goal_DestroyType:GetCustomData(m)local p={}if m==0 then for q,r in pairs(Entities)do if string.find(q,"^[ABU]_")then table.insert(p,q)end end;table.sort(p)elseif m==2 then for a=0,8 do table.insert(p,a)end else assert(false)end;return p end;function B_Goal_DestroyType:GetMsgKey()local A=self.EntityName;if Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableBuilding)==1 then return"Quest_DestroyEntities_Building"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableAnimal)==1 then return"Quest_DestroyEntities_Predators"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.Hero)==1 then return"Quest_Destroy_Leader"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.Military)==1 or Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableSettler)==1 or Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableMerchant)==1 then return"Quest_DestroyEntities_Unit"end;return"Quest_DestroyEntities"end;RegisterBehavior(B_Goal_DestroyType)function Goal_EntityDistance(...)return B_Goal_EntityDistance:new(...)end;B_Goal_EntityDistance={Name="Goal_EntityDistance",Description={en="Goal: Distance between two entities",de="Ziel: Zwei Entities sollen zueinander eine Entfernung über- oder unterschreiten.",fr="Objectif: deux entités doivent se trouver à une distance supérieure ou inférieure l'une de l'autre."},Parameter={{ParameterType.ScriptName,en="Entity 1",de="Entity 1",fr="Entité 1"},{ParameterType.ScriptName,en="Entity 2",de="Entity 2",fr="Entité 2"},{ParameterType.Custom,en="Relation",de="Relation",fr="Relation"},{ParameterType.Number,en="Distance",de="Entfernung",fr="Distance"}}}function B_Goal_EntityDistance:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_EntityDistance:AddParameter(m,n)if m==0 then self.Entity1=n elseif m==1 then self.Entity2=n elseif m==2 then self.bRelSmallerThan=n=="<"elseif m==3 then self.Distance=n*1 end end;function B_Goal_EntityDistance:CustomFunction(l)if Logic.IsEntityDestroyed(self.Entity1)or Logic.IsEntityDestroyed(self.Entity2)then return false end;local B=GetID(self.Entity1)local C=GetID(self.Entity2)local D=Logic.CheckEntitiesDistance(B,C,self.Distance)if self.bRelSmallerThan and D or not self.bRelSmallerThan and not D then return true end end;function B_Goal_EntityDistance:GetCustomData(m)local p={}if m==2 then table.insert(p,">")table.insert(p,"<")else assert(false)end;return p end;function B_Goal_EntityDistance:Debug(l)if not IsExisting(self.Entity1)or not IsExisting(self.Entity2)then debug(false,l.Identifier..": "..self.Name..": At least 1 of the entities for distance check don't exist!")return true end;return false end;RegisterBehavior(B_Goal_EntityDistance)function Goal_KnightDistance(...)return B_Goal_KnightDistance:new(...)end;B_Goal_KnightDistance={Name="Goal_KnightDistance",Description={en="Goal: Bring the knight close to a given entity. If the distance is left at 0 it will automatically set to 2500.",de="Ziel: Bringe den Ritter nah an eine bestimmte Entität. Wird die Entfernung 0 gelassen, ist sie automatisch 2500.",fr="Objectif : Rapproche le chevalier d'une entité donnée. Si la distance est laissée à 0, elle est automatiquement de 2500."},Parameter={{ParameterType.ScriptName,en="Target",de="Ziel",fr="Cible"},{ParameterType.Number,en="Distance",de="Entfernung",fr="Distance"}}}function B_Goal_KnightDistance:GetGoalTable()return{Objective.Distance,-65566,self.Target,self.Distance,true}end;function B_Goal_KnightDistance:AddParameter(m,n)if m==0 then self.Target=n elseif m==1 then if n==nil or n==""then n=0 end;self.Distance=n*1;if self.Distance==0 then self.Distance=2500 end end end;RegisterBehavior(B_Goal_KnightDistance)function Goal_UnitsOnTerritory(...)return B_Goal_UnitsOnTerritory:new(...)end;B_Goal_UnitsOnTerritory={Name="Goal_UnitsOnTerritory",Description={en="Goal: Place a certain amount of units on a territory",de="Ziel: Platziere eine bestimmte Anzahl Einheiten auf einem Gebiet",fr="Objectif: placer un certain nombre d'unités sur un territoire"},Parameter={{ParameterType.TerritoryNameWithUnknown,en="Territory",de="Territorium",fr="Territoire"},{ParameterType.Custom,en="Player",de="Spieler",fr="Joueur"},{ParameterType.Custom,en="Category",de="Kategorie",fr="Catégorie"},{ParameterType.Custom,en="Relation",de="Relation",fr="Relation"},{ParameterType.Number,en="Number of units",de="Anzahl Einheiten",fr="Quantité d'unitées"}}}function B_Goal_UnitsOnTerritory:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_UnitsOnTerritory:AddParameter(m,n)if m==0 then self.TerritoryID=tonumber(n)if self.TerritoryID==nil then self.TerritoryID=GetTerritoryIDByName(n)end elseif m==1 then self.PlayerID=tonumber(n)*1 elseif m==2 then self.Category=n elseif m==3 then self.bRelSmallerThan=tostring(n)=="true"or tostring(n)=="<"elseif m==4 then self.NumberOfUnits=n*1 end end;function B_Goal_UnitsOnTerritory:CustomFunction(l)local E=self:GetEntities(self.TerritoryID,self.PlayerID,EntityCategories[self.Category])if self.bRelSmallerThan==false and#E>=self.NumberOfUnits then return true elseif self.bRelSmallerThan==true and#E<self.NumberOfUnits then return true end end;function B_Goal_UnitsOnTerritory:GetEntities(F,G,H)local E={}local I={}if G==-1 then for a=0,8 do local J=0;repeat I={Logic.GetEntitiesOfCategoryInTerritory(F,a,G,J)}E=Array_Append(E,I)J=J+#I until#I==0 end else local J=0;repeat I={Logic.GetEntitiesOfCategoryInTerritory(F,G,H,J)}E=Array_Append(E,I)J=J+#I until#I==0 end;return E end;function B_Goal_UnitsOnTerritory:GetCustomData(m)local p={}if m==1 then table.insert(p,-1)for a=1,8 do table.insert(p,a)end elseif m==2 then for q,r in pairs(EntityCategories)do if not string.find(q,"^G_")and q~="SheepPasture"then table.insert(p,q)end end;table.sort(p)elseif m==3 then table.insert(p,">=")table.insert(p,"<")else assert(false)end;return p end;function B_Goal_UnitsOnTerritory:Debug(l)local K={Logic.GetTerritories()}if tonumber(self.TerritoryID)==nil or self.TerritoryID<0 or not table.contains(K,self.TerritoryID)then debug(false,l.Identifier..": "..self.Name..": got an invalid territoryID!")return true elseif tonumber(self.PlayerID)==nil or self.PlayerID<0 or self.PlayerID>8 then debug(false,l.Identifier..": "..self.Name..": got an invalid playerID!")return true elseif not EntityCategories[self.Category]then debug(false,l.Identifier..": "..self.Name..": got an invalid entity category!")return true elseif tonumber(self.NumberOfUnits)==nil or self.NumberOfUnits<0 then debug(false,l.Identifier..": "..self.Name..": amount is negative or nil!")return true end;return false end;RegisterBehavior(B_Goal_UnitsOnTerritory)function Goal_ActivateBuff(...)return B_Goal_ActivateBuff:new(...)end;B_Goal_ActivateBuff={Name="Goal_ActivateBuff",Description={en="Goal: Activate a buff",de="Ziel: Aktiviere einen Buff",fr="Objectif: Activer un bonus"},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.Custom,en="Buff",de="Buff",fr="Bonus"}}}function B_Goal_ActivateBuff:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_ActivateBuff:AddParameter(m,n)if m==0 then self.PlayerID=n*1 elseif m==1 then self.BuffName=n;self.Buff=Buffs[n]end end;function B_Goal_ActivateBuff:CustomFunction(l)if not l.QuestDescription or l.QuestDescription==""then local t=CopyTable(Lib.Core.Quest.Text.ActivateBuff.BuffsVanilla)if g_GameExtraNo>=1 then t=CopyTable(Lib.Core.Quest.Text.ActivateBuff.BuffsEx1,t)end;Lib.Core.Quest:ChangeCustomQuestCaptionText(string.format(Localize(Lib.Core.Quest.Text.ActivateBuff.Pattern),Localize(t[self.BuffName])),l)end;local L=Logic.GetBuff(self.PlayerID,self.Buff)if L and L~=0 then return true end end;function B_Goal_ActivateBuff:GetCustomData(m)local p={}if m==1 then p={"Buff_Spice","Buff_Colour","Buff_Entertainers","Buff_FoodDiversity","Buff_ClothesDiversity","Buff_HygieneDiversity","Buff_EntertainmentDiversity","Buff_Sermon","Buff_Festival","Buff_ExtraPayment","Buff_HighTaxes","Buff_NoPayment","Buff_NoTaxes"}if g_GameExtraNo>=1 then table.insert(p,"Buff_Gems")table.insert(p,"Buff_MusicalInstrument")table.insert(p,"Buff_Olibanum")end;table.sort(p)else assert(false)end;return p end;function B_Goal_ActivateBuff:GetIcon()local t={[Buffs.Buff_Spice]="Goods.G_Salt",[Buffs.Buff_Colour]="Goods.G_Dye",[Buffs.Buff_Entertainers]="Entities.U_Entertainer_NA_FireEater",[Buffs.Buff_FoodDiversity]="Needs.Nutrition",[Buffs.Buff_ClothesDiversity]="Needs.Clothes",[Buffs.Buff_HygieneDiversity]="Needs.Hygiene",[Buffs.Buff_EntertainmentDiversity]="Needs.Entertainment",[Buffs.Buff_Sermon]="Technologies.R_Sermon",[Buffs.Buff_Festival]="Technologies.R_Festival",[Buffs.Buff_ExtraPayment]={1,8},[Buffs.Buff_HighTaxes]={1,6},[Buffs.Buff_NoPayment]={1,8},[Buffs.Buff_NoTaxes]={1,6}}if g_GameExtraNo and g_GameExtraNo>=1 then t[Buffs.Buff_Gems]="Goods.G_Gems"t[Buffs.Buff_MusicalInstrument]="Goods.G_MusicalInstrument"t[Buffs.Buff_Olibanum]="Goods.G_Olibanum"end;return t[self.Buff]end;function B_Goal_ActivateBuff:Debug(l)if not self.Buff then debug(false,l.Identifier..": "..self.Name..": buff '"..self.BuffName.."' does not exist!")return true elseif not tonumber(self.PlayerID)or self.PlayerID<1 or self.PlayerID>8 then debug(false,l.Identifier..": "..self.Name..": got an invalid playerID!")return true end;return false end;RegisterBehavior(B_Goal_ActivateBuff)function Goal_BuildRoad(...)return B_Goal_BuildRoad:new(...)end;B_Goal_BuildRoad={Name="Goal_BuildRoad",Description={en="Goal: Connect two points with a street or a road",de="Ziel: Verbinde zwei Punkte mit einer Strasse oder einem Weg.",fr="Objectif: Relier deux points par une route ou un chemin."},Parameter={{ParameterType.ScriptName,en="Entity 1",de="Entity 1",fr="Entité 1"},{ParameterType.ScriptName,en="Entity 2",de="Entity 2",fr="Entité 2"},{ParameterType.Custom,en="Only roads",de="Nur Strassen",fr="Que des Routes"}}}function B_Goal_BuildRoad:GetGoalTable()return{Objective.BuildRoad,{GetID(self.Entity1),GetID(self.Entity2),false,0,self.bRoadsOnly}}end;function B_Goal_BuildRoad:AddParameter(m,n)if m==0 then self.Entity1=n elseif m==1 then self.Entity2=n elseif m==2 then self.bRoadsOnly=ToBoolean(n)end end;function B_Goal_BuildRoad:GetCustomData(m)local p;if m==2 then p={"true","false"}end;return p end;function B_Goal_BuildRoad:Debug(l)if not IsExisting(self.Entity1)or not IsExisting(self.Entity2)then debug(false,l.Identifier..": "..self.Name..": first or second entity does not exist!")return true end;return false end;RegisterBehavior(B_Goal_BuildRoad)function Goal_BuildWall(...)return B_Goal_BuildWall:new(...)end;B_Goal_BuildWall={Name="Goal_BuildWall",Description={en="Goal: Build a wall between 2 positions bo stop the movement of an (hostile) player.",de="Ziel: Baue eine Mauer zwischen 2 Punkten, die die Bewegung eines (feindlichen) Spielers zwischen den Punkten verhindert.",fr="Objectif: Construire un mur entre 2 points qui empêche le déplacement d'un joueur (ennemi) entre les points."},Parameter={{ParameterType.PlayerID,en="Enemy",de="Feind",fr="Ennemi"},{ParameterType.ScriptName,en="Entity 1",de="Entity 1",fr="Entité 1"},{ParameterType.ScriptName,en="Entity 2",de="Entity 2",fr="Entité 2"}}}function B_Goal_BuildWall:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_BuildWall:AddParameter(m,n)if m==0 then self.PlayerID=n*1 elseif m==1 then self.EntityName1=n elseif m==2 then self.EntityName2=n end end;function B_Goal_BuildWall:CustomFunction(l)local M=GetID(self.EntityName1)local N=GetID(self.EntityName2)if not IsExisting(M)then return false end;if not IsExisting(N)then return false end;local O,P,Q=Logic.EntityGetPos(M)if Logic.IsBuilding(M)==1 then O,P=Logic.GetBuildingApproachPosition(M)end;local R=Logic.GetPlayerSectorAtPosition(self.PlayerID,O,P)local O,P,Q=Logic.EntityGetPos(N)if Logic.IsBuilding(N)==1 then O,P=Logic.GetBuildingApproachPosition(N)end;local S=Logic.GetPlayerSectorAtPosition(self.PlayerID,O,P)if R~=S then return true end;return nil end;function B_Goal_BuildWall:GetMsgKey()return"Quest_Create_Wall"end;function B_Goal_BuildWall:GetIcon()return{3,9}end;function B_Goal_BuildWall:Debug(l)if not IsExisting(self.EntityName1)or not IsExisting(self.EntityName2)then debug(false,l.Identifier..": "..self.Name..": first or second entity does not exist!")return true elseif not tonumber(self.PlayerID)or self.PlayerID<1 or self.PlayerID>8 then debug(false,l.Identifier..": "..self.Name..": got an invalid playerID!")return true end;if GetDiplomacyState(l.ReceivingPlayer,self.PlayerID)>-1 and not self.WarningPrinted then warn(false,l.Identifier..": "..self.Name..": player %d is neighter enemy or unknown to quest receiver!")self.WarningPrinted=true end;return false end;RegisterBehavior(B_Goal_BuildWall)function Goal_Claim(...)return B_Goal_Claim:new(...)end;B_Goal_Claim={Name="Goal_Claim",Description={en="Goal: Claim a territory",de="Ziel: Erobere ein Territorium",fr="Objectif: Conquérir un territoire"},Parameter={{ParameterType.TerritoryName,en="Territory",de="Territorium",fr="Territoire"}}}function B_Goal_Claim:GetGoalTable()return{Objective.Claim,1,self.TerritoryID}end;function B_Goal_Claim:AddParameter(m,n)if m==0 then self.TerritoryID=tonumber(n)if not self.TerritoryID then self.TerritoryID=GetTerritoryIDByName(n)end end end;function B_Goal_Claim:GetMsgKey()return"Quest_Claim_Territory"end;RegisterBehavior(B_Goal_Claim)function Goal_ClaimXTerritories(...)return B_Goal_ClaimXTerritories:new(...)end;B_Goal_ClaimXTerritories={Name="Goal_ClaimXTerritories",Description={en="Goal: Claim the given number of territories, all player territories are counted",de="Ziel: Erobere die angegebene Anzahl Territorien, alle spielereigenen Territorien werden gezählt",fr="Objectif: conquérir le nombre de territoires indiqué, tous les territoires des joueurs sont comptabilisés."},Parameter={{ParameterType.Number,en="Territories",de="Territorien",fr="Territoire"}}}function B_Goal_ClaimXTerritories:GetGoalTable()return{Objective.Claim,2,self.TerritoriesToClaim}end;function B_Goal_ClaimXTerritories:AddParameter(m,n)if m==0 then self.TerritoriesToClaim=n*1 end end;function B_Goal_ClaimXTerritories:GetMsgKey()return"Quest_Claim_Territory"end;RegisterBehavior(B_Goal_ClaimXTerritories)function Goal_Create(...)return B_Goal_Create:new(...)end;B_Goal_Create={Name="Goal_Create",Description={en="Goal: Create Buildings/Units on a specified territory",de="Ziel: Erstelle Einheiten/Gebäude auf einem bestimmten Territorium.",fr="Objectif: créer des unités/bâtiments sur un territoire donné."},Parameter={{ParameterType.Entity,en="Type name",de="Typbezeichnung",fr="Désignation du type"},{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"},{ParameterType.TerritoryNameWithUnknown,en="Territory",de="Territorium",fr="Territoire"}}}function B_Goal_Create:GetGoalTable()return{Objective.Create,assert(Entities[self.EntityName]),self.Amount,self.TerritoryID}end;function B_Goal_Create:AddParameter(m,n)if m==0 then self.EntityName=n elseif m==1 then self.Amount=n*1 elseif m==2 then self.TerritoryID=tonumber(n)if not self.TerritoryID then self.TerritoryID=GetTerritoryIDByName(n)end end end;function B_Goal_Create:GetMsgKey()return Logic.IsEntityTypeInCategory(Entities[self.EntityName],EntityCategories.AttackableBuilding)==1 and"Quest_Create_Building"or"Quest_Create_Unit"end;RegisterBehavior(B_Goal_Create)function Goal_Produce(...)return B_Goal_Produce:new(...)end;B_Goal_Produce={Name="Goal_Produce",Description={en="Goal: Produce an amount of goods",de="Ziel: Produziere eine Anzahl einer bestimmten Ware.",fr="Objectif: produire un certain nombre d'une marchandise donnée."},Parameter={{ParameterType.RawGoods,en="Type of good",de="Ressourcentyp",fr="Type de ressources"},{ParameterType.Number,en="Amount of good",de="Anzahl der Ressource",fr="Quantité de ressources"}}}function B_Goal_Produce:GetGoalTable()local o=Logic.GetGoodTypeID(self.GoodTypeName)return{Objective.Produce,o,self.GoodAmount}end;function B_Goal_Produce:AddParameter(m,n)if m==0 then self.GoodTypeName=n elseif m==1 then self.GoodAmount=n*1 end end;function B_Goal_Produce:GetMsgKey()return"Quest_Produce"end;RegisterBehavior(B_Goal_Produce)function Goal_GoodAmount(...)return B_Goal_GoodAmount:new(...)end;B_Goal_GoodAmount={Name="Goal_GoodAmount",Description={en="Goal: Obtain an amount of goods - either by trading or producing them",de="Ziel: Beschaffe eine Anzahl Waren - entweder durch Handel oder durch eigene Produktion.",fr="Objectif: Se procurer un certain nombre de marchandises - soit par le commerce, soit par sa propre production."},Parameter={{ParameterType.Custom,en="Type of good",de="Warentyp",fr="TYpe de marchandises"},{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"},{ParameterType.Custom,en="Relation",de="Relation",fr="Relation"}}}function B_Goal_GoodAmount:GetGoalTable()local o=Logic.GetGoodTypeID(self.GoodTypeName)return{Objective.Produce,o,self.GoodAmount,self.bRelSmallerThan}end;function B_Goal_GoodAmount:AddParameter(m,n)if m==0 then self.GoodTypeName=n elseif m==1 then self.GoodAmount=n*1 elseif m==2 then self.bRelSmallerThan=n=="<"or tostring(n)=="true"end end;function B_Goal_GoodAmount:GetCustomData(m)local p={}if m==0 then for q,r in pairs(Goods)do if string.find(q,"^G_")then table.insert(p,q)end end;table.sort(p)elseif m==2 then table.insert(p,">=")table.insert(p,"<")else assert(false)end;return p end;RegisterBehavior(B_Goal_GoodAmount)function Goal_SatisfyNeed(...)return B_Goal_SatisfyNeed:new(...)end;B_Goal_SatisfyNeed={Name="Goal_SatisfyNeed",Description={en="Goal: Satisfy a need",de="Ziel: Erfuelle ein Beduerfnis",fr="Objectif: Répondre à un besoin"},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.Need,en="Need",de="Beduerfnis",fr="Besoin"}}}function B_Goal_SatisfyNeed:GetGoalTable()return{Objective.SatisfyNeed,Needs[self.Need],self.PlayerID}end;function B_Goal_SatisfyNeed:AddParameter(m,n)if m==0 then self.PlayerID=n*1 elseif m==1 then self.Need=n end end;function B_Goal_SatisfyNeed:GetMsgKey()local t={[Needs.Clothes]="Quest_SatisfyNeed_Clothes",[Needs.Entertainment]="Quest_SatisfyNeed_Entertainment",[Needs.Nutrition]="Quest_SatisfyNeed_Food",[Needs.Hygiene]="Quest_SatisfyNeed_Hygiene",[Needs.Medicine]="Quest_SatisfyNeed_Medicine"}local u=t[Needs[self.Need]]if u then return u end end;RegisterBehavior(B_Goal_SatisfyNeed)function Goal_SettlersNumber(...)return B_Goal_SettlersNumber:new(...)end;B_Goal_SettlersNumber={Name="Goal_SettlersNumber",Description={en="Goal: Get a given amount of settlers",de="Ziel: Erreiche eine bestimmte Anzahl Siedler.",fr="Objectif: atteindre un certain nombre de Settlers."},Parameter={{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"},{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"}}}function B_Goal_SettlersNumber:GetGoalTable()return{Objective.SettlersNumber,self.PlayerID or 1,self.SettlersAmount}end;function B_Goal_SettlersNumber:AddParameter(m,n)if m==0 then self.SettlersAmount=n*1 elseif m==1 then self.PlayerID=n*1 end end;function B_Goal_SettlersNumber:GetMsgKey()return"Quest_NumberSettlers"end;RegisterBehavior(B_Goal_SettlersNumber)function Goal_Spouses(...)return B_Goal_Spouses:new(...)end;B_Goal_Spouses={Name="Goal_Spouses",Description={en="Goal: Get a given amount of spouses",de="Ziel: Erreiche eine bestimmte Ehefrauenanzahl",fr="Objectif: Atteindre un certain nombre d'épouses"},Parameter={{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"}}}function B_Goal_Spouses:GetGoalTable()return{Objective.Spouses,self.SpousesAmount}end;function B_Goal_Spouses:AddParameter(m,n)if m==0 then self.SpousesAmount=n*1 end end;function B_Goal_Spouses:GetMsgKey()return"Quest_NumberSpouses"end;RegisterBehavior(B_Goal_Spouses)function Goal_SoldierCount(...)return B_Goal_SoldierCount:new(...)end;B_Goal_SoldierCount={Name="Goal_SoldierCount",Description={en="Goal: Create a specified number of soldiers",de="Ziel: Erreiche eine Anzahl grösser oder kleiner der angegebenen Menge Soldaten.",fr="Objectif: Atteindre un nombre de soldats supérieur ou inférieur à la quantité indiquée."},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.Custom,en="Relation",de="Relation",fr="Relation"},{ParameterType.Number,en="Number of soldiers",de="Anzahl Soldaten",fr="Nombre de soldats"}}}function B_Goal_SoldierCount:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_SoldierCount:AddParameter(m,n)if m==0 then self.PlayerID=n*1 elseif m==1 then self.bRelSmallerThan=tostring(n)=="true"or tostring(n)=="<"elseif m==2 then self.NumberOfUnits=n*1 end end;function B_Goal_SoldierCount:CustomFunction(l)if not l.QuestDescription or l.QuestDescription==""then local T=tostring(self.bRelSmallerThan)local w=GetPlayerName(self.PlayerID)or""Lib.Core.Quest:ChangeCustomQuestCaptionText(string.format(Localize(Lib.Core.Quest.Text.SoldierCount.Pattern),w,Localize(Lib.Core.Quest.Text.SoldierCount.Relation[T]),self.NumberOfUnits),l)end;local U=Logic.GetCurrentSoldierCount(self.PlayerID)if self.bRelSmallerThan and U<self.NumberOfUnits then return true elseif not self.bRelSmallerThan and U>=self.NumberOfUnits then return true end;return nil end;function B_Goal_SoldierCount:GetCustomData(m)local p={}if m==1 then table.insert(p,">=")table.insert(p,"<")else assert(false)end;return p end;function B_Goal_SoldierCount:GetIcon()return{7,11}end;function B_Goal_SoldierCount:GetMsgKey()return"Quest_Create_Unit"end;function B_Goal_SoldierCount:Debug(l)if tonumber(self.NumberOfUnits)==nil or self.NumberOfUnits<0 then debug(false,l.Identifier..": "..self.Name..": amount can not be below 0!")return true elseif tonumber(self.PlayerID)==nil or self.PlayerID<1 or self.PlayerID>8 then debug(false,l.Identifier..": "..self.Name..": got an invalid playerID!")return true end;return false end;RegisterBehavior(B_Goal_SoldierCount)function Goal_KnightTitle(...)return B_Goal_KnightTitle:new(...)end;B_Goal_KnightTitle={Name="Goal_KnightTitle",Description={en="Goal: Reach a specified knight title",de="Ziel: Erreiche einen vorgegebenen Titel",fr="Objectif: atteindre un titre donné"},Parameter={{ParameterType.Custom,en="Knight title",de="Titel",fr="Titre"}}}function B_Goal_KnightTitle:GetGoalTable()return{Objective.KnightTitle,assert(KnightTitles[self.KnightTitle])}end;function B_Goal_KnightTitle:AddParameter(m,n)if m==0 then self.KnightTitle=n end end;function B_Goal_KnightTitle:GetMsgKey()return"Quest_KnightTitle"end;function B_Goal_KnightTitle:GetCustomData(m)return{"Knight","Mayor","Baron","Earl","Marquees","Duke","Archduke"}end;RegisterBehavior(B_Goal_KnightTitle)function Goal_Festivals(...)return B_Goal_Festivals:new(...)end;B_Goal_Festivals={Name="Goal_Festivals",Description={en="Goal: The player has to start the given number of festivals.",de="Ziel: Der Spieler muss eine gewisse Anzahl Feste gestartet haben.",fr="Objectif: Le joueur doit avoir lancé un certain nombre de festivités."},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.Number,en="Number of festivals",de="Anzahl Feste",fr="Nombre de festivités"}}}function B_Goal_Festivals:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_Festivals:AddParameter(m,n)if m==0 then self.PlayerID=tonumber(n)else assert(m==1,"Error in "..self.Name..": AddParameter: Index is invalid.")self.NeededFestivals=tonumber(n)end end;function B_Goal_Festivals:CustomFunction(l)if not l.QuestDescription or l.QuestDescription==""then local w=GetPlayerName(self.PlayerID)or""Lib.Core.Quest:ChangeCustomQuestCaptionText(string.format(Localize(Lib.Core.Quest.Text.Festivals.Pattern),w,self.NeededFestivals),l)end;if Logic.GetStoreHouse(self.PlayerID)==0 then return false end;local V={Logic.GetPlayerEntities(self.PlayerID,Entities.B_TableBeer,5,0)}local W=0;for q=2,#V do local X=V[q]if Logic.GetIndexOnOutStockByGoodType(X,Goods.G_Beer)~=-1 then local Y=Logic.GetAmountOnOutStockByGoodType(X,Goods.G_Beer)W=W+Y end end;if not self.FestivalStarted and W>0 then self.FestivalStarted=true;self.FestivalCounter=self.FestivalCounter and self.FestivalCounter+1 or 1;if self.FestivalCounter>=self.NeededFestivals then self.FestivalCounter=nil;return true end elseif W==0 then self.FestivalStarted=false end end;function B_Goal_Festivals:Debug(l)if Logic.GetStoreHouse(self.PlayerID)==0 then debug(false,l.Identifier..": "..self.Name..": Player "..self.PlayerID.." is dead :-(")return true elseif GetPlayerCategoryType(self.PlayerID)~=PlayerCategories.City then debug(false,l.Identifier..": "..self.Name..":  Player "..self.PlayerID.." is no city")return true elseif self.NeededFestivals<0 then debug(false,l.Identifier..": "..self.Name..": Number of Festivals is negative")return true end;return false end;function B_Goal_Festivals:Reset()self.FestivalCounter=nil;self.FestivalStarted=nil end;function B_Goal_Festivals:GetIcon()return{4,15}end;RegisterBehavior(B_Goal_Festivals)function Goal_Capture(...)return B_Goal_Capture:new(...)end;B_Goal_Capture={Name="Goal_Capture",Description={en="Goal: Capture a cart.",de="Ziel: Ein Karren muss erobert werden.",fr="Objectif: un chariot doit être conquis."},Parameter={{ParameterType.ScriptName,en="Script name",de="Skriptname",fr="Nom de l'entité"}}}function B_Goal_Capture:GetGoalTable()return{Objective.Capture,1,{self.ScriptName}}end;function B_Goal_Capture:AddParameter(m,n)if m==0 then self.ScriptName=n end end;function B_Goal_Capture:GetMsgKey()local A=GetID(self.ScriptName)if Logic.IsEntityAlive(A)then A=Logic.GetEntityType(A)if A and A~=0 then if Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableMerchant)==1 then return"Quest_Capture_Cart"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.SiegeEngine)==1 then return"Quest_Capture_SiegeEngine"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.Worker)==1 or Logic.IsEntityTypeInCategory(A,EntityCategories.Spouse)==1 or Logic.IsEntityTypeInCategory(A,EntityCategories.Hero)==1 then return"Quest_Capture_VIPOfPlayer"end end end end;RegisterBehavior(B_Goal_Capture)function Goal_CaptureType(...)return B_Goal_CaptureType:new(...)end;B_Goal_CaptureType={Name="Goal_CaptureType",Description={en="Goal: Capture specified entity types",de="Ziel: Nimm bestimmte Entitätstypen gefangen",fr="Objectif: capturer certains types d'entités"},Parameter={{ParameterType.Custom,en="Type name",de="Typbezeichnung",fr="Désignation du type"},{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"},{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"}}}function B_Goal_CaptureType:GetGoalTable()return{Objective.Capture,2,Entities[self.EntityName],self.Amount,self.PlayerID}end;function B_Goal_CaptureType:AddParameter(m,n)if m==0 then self.EntityName=n elseif m==1 then self.Amount=n*1 elseif m==2 then self.PlayerID=n*1 end end;function B_Goal_CaptureType:GetCustomData(m)local p={}if m==0 then for q,r in pairs(Entities)do if string.find(q,"^U_.+Cart")or Logic.IsEntityTypeInCategory(r,EntityCategories.AttackableMerchant)==1 then table.insert(p,q)end end;table.sort(p)elseif m==2 then for a=0,8 do table.insert(p,a)end else assert(false)end;return p end;function B_Goal_CaptureType:GetMsgKey()local A=self.EntityName;if Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableMerchant)==1 then return"Quest_Capture_Cart"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.SiegeEngine)==1 then return"Quest_Capture_SiegeEngine"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.Worker)==1 or Logic.IsEntityTypeInCategory(A,EntityCategories.Spouse)==1 or Logic.IsEntityTypeInCategory(A,EntityCategories.Hero)==1 then return"Quest_Capture_VIPOfPlayer"end end;RegisterBehavior(B_Goal_CaptureType)function Goal_Protect(...)return B_Goal_Protect:new(...)end;B_Goal_Protect={Name="Goal_Protect",Description={en="Goal: Protect an entity (entity needs a script name",de="Ziel: Beschütze eine Entität (Entität benötigt einen Skriptnamen)",fr="Objectif : Protéger une entité (l'entité nécessite un nom de script)"},Parameter={{ParameterType.ScriptName,en="Script name",de="Skriptname",fr="Nom de l'entité"}}}function B_Goal_Protect:GetGoalTable()return{Objective.Protect,{self.ScriptName}}end;function B_Goal_Protect:AddParameter(m,n)if m==0 then self.ScriptName=n end end;function B_Goal_Protect:GetMsgKey()if Logic.IsEntityAlive(self.ScriptName)then local A=GetID(self.ScriptName)if A and A~=0 then A=Logic.GetEntityType(A)if A and A~=0 then if Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableBuilding)==1 then return"Quest_Protect_Building"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.SpecialBuilding)==1 then local t={[PlayerCategories.City]="Quest_Protect_City",[PlayerCategories.Cloister]="Quest_Protect_Cloister",[PlayerCategories.Village]="Quest_Protect_Village"}local y=GetPlayerCategoryType(Logic.EntityGetPlayer(GetID(self.ScriptName)))if y then local u=t[y]if u then return u end end;return"Quest_Protect_Building"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.Hero)==1 then return"Quest_Protect_Knight"elseif Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableMerchant)==1 then return"Quest_Protect_Cart"end end end end;return"Quest_Protect"end;RegisterBehavior(B_Goal_Protect)function Goal_Refill(...)return B_Goal_Refill:new(...)end;B_Goal_Refill={Name="Goal_Refill",Description={en="Goal: Refill an object using a geologist",de="Ziel: Eine Mine soll durch einen Geologen wieder aufgefuellt werden.",fr="Objectif: Une mine doit être réalimentée par un géologue."},Parameter={{ParameterType.ScriptName,en="Script name",de="Skriptname",fr="Nom de l'entité"}},RequiresExtraNo=1}function B_Goal_Refill:GetGoalTable()return{Objective.Refill,{GetID(self.ScriptName)}}end;function B_Goal_Refill:GetIcon()return{8,1,1}end;function B_Goal_Refill:AddParameter(m,n)if m==0 then self.ScriptName=n end end;if g_GameExtraNo>0 then RegisterBehavior(B_Goal_Refill)end;function Goal_ResourceAmount(...)return B_Goal_ResourceAmount:new(...)end;B_Goal_ResourceAmount={Name="Goal_ResourceAmount",Description={en="Goal: Reach a specified amount of resources in a doodad",de="Ziel: In einer Mine soll weniger oder mehr als eine angegebene Anzahl an Rohstoffen sein.",fr="Objectif: Dans une mine, il doit y avoir moins ou plus de matières premières qu'un nombre indiqué."},Parameter={{ParameterType.ScriptName,en="Script name",de="Skriptname",fr="Nom de l'entité"},{ParameterType.Custom,en="Relation",de="Relation",fr="Relation"},{ParameterType.Number,en="Amount",de="Menge",fr="Quantité"}}}function B_Goal_ResourceAmount:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_ResourceAmount:AddParameter(m,n)if m==0 then self.ScriptName=n elseif m==1 then self.bRelSmallerThan=n=="<"elseif m==2 then self.Amount=n*1 end end;function B_Goal_ResourceAmount:CustomFunction(l)local A=GetID(self.ScriptName)if A and A~=0 and Logic.GetResourceDoodadGoodType(A)~=0 then local Z=Logic.GetResourceDoodadGoodAmount(A)if self.bRelSmallerThan and Z<self.Amount or not self.bRelSmallerThan and Z>=self.Amount then return true end end;return nil end;function B_Goal_ResourceAmount:GetCustomData(m)local p={}if m==1 then table.insert(p,">=")table.insert(p,"<")else assert(false)end;return p end;function B_Goal_ResourceAmount:Debug(l)if not IsExisting(self.ScriptName)then debug(false,l.Identifier..": "..self.Name..": entity '"..self.ScriptName.."' does not exist!")return true elseif tonumber(self.Amount)==nil or self.Amount<0 then debug(false,l.Identifier..": "..self.Name..": error at amount! (nil or below 0)")return true end;return false end;RegisterBehavior(B_Goal_ResourceAmount)function Goal_InstantFailure()return B_Goal_InstantFailure:new()end;B_Goal_InstantFailure={Name="Goal_InstantFailure",Description={en="Goal: Instant failure, the goal returns false.",de="Ziel: Direkter Misserfolg, das Goal sendet false.",fr="Objectif: échec direct, le goal envoie false."}}function B_Goal_InstantFailure:GetGoalTable()return{Objective.DummyFail}end;RegisterBehavior(B_Goal_InstantFailure)function Goal_InstantSuccess()return B_Goal_InstantSuccess:new()end;B_Goal_InstantSuccess={Name="Goal_InstantSuccess",Description={en="Goal: Instant success, the goal returns true.",de="Ziel: Direkter Erfolg, das Goal sendet true.",fr="Objectif: succès direct, le goal envoie false."}}function B_Goal_InstantSuccess:GetGoalTable()return{Objective.Dummy}end;RegisterBehavior(B_Goal_InstantSuccess)function Goal_NoChange()return B_Goal_NoChange:new()end;B_Goal_NoChange={Name="Goal_NoChange",Description={en="Goal: The quest state doesn't change. Use reward functions of other quests to change the state of this quest.",de="Ziel: Der Questzustand wird nicht verändert. Ein Reward einer anderen Quest sollte den Zustand dieser Quest verändern.",fr="Objectif: L'état de la quête n'est pas modifié. Une récompense d'une autre quête doit modifier l'état de cette quête."}}function B_Goal_NoChange:GetGoalTable()return{Objective.NoChange}end;RegisterBehavior(B_Goal_NoChange)function Goal_MapScriptFunction(...)return B_Goal_MapScriptFunction:new(...)end;B_Goal_MapScriptFunction={Name="Goal_MapScriptFunction",Description={en="Goal: Calls a function within the global map script. Return 'true' means success, 'false' means failure and 'nil' doesn't change anything.",de="Ziel: Ruft eine Funktion im globalen Skript auf, die einen Wahrheitswert zurueckgibt. Rueckgabe 'true' gilt als erfuellt, 'false' als gescheitert und 'nil' ändert nichts.",fr="Objectif: Appelle une fonction dans le script global qui renvoie une valeur de vérité. Le retour 'true' est considéré comme rempli, 'false' comme échoué et 'nil' ne change rien."},Parameter={{ParameterType.Default,en="Function name",de="Funktionsname",fr="Nom de la fonction"}}}function B_Goal_MapScriptFunction:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_MapScriptFunction:AddParameter(m,n)if m==0 then self.FuncName=n end end;function B_Goal_MapScriptFunction:CustomFunction(l)if type(self.FuncName)=="function"then return self.FuncName(unpack(self.i47ya_6aghw_frxil))end;return _G[self.FuncName](self,l)end;function B_Goal_MapScriptFunction:Debug(l)if not self.FuncName then debug(false,l.Identifier..": "..self.Name..": function reference is invalid!")return true end;if type(self.FuncName)~="function"and not _G[self.FuncName]then debug(false,l.Identifier..": "..self.Name..": function does not exist!")return true end;return false end;RegisterBehavior(B_Goal_MapScriptFunction)function Goal_CustomVariables(...)return B_Goal_CustomVariables:new(...)end;B_Goal_CustomVariables={Name="Goal_CustomVariables",Description={en="Goal: A customised variable has to assume a certain value.",de="Ziel: Eine benutzerdefinierte Variable muss einen bestimmten Wert annehmen.",fr="Objectif: une variable définie par l'utilisateur doit prendre une certaine valeur."},Parameter={{ParameterType.Default,en="Name of Variable",de="Variablenname",fr="Nom de la variable"},{ParameterType.Custom,en="Relation",de="Relation",fr="Relation"},{ParameterType.Default,en="Value or variable",de="Wert oder Variable",fr="Valeur ou variable"}}}function B_Goal_CustomVariables:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_CustomVariables:AddParameter(m,n)if m==0 then self.VariableName=n elseif m==1 then self.Relation=n elseif m==2 then local _=tonumber(n)self.Value=_==nil and tostring(n)or _ end end;function B_Goal_CustomVariables:CustomFunction()local a0=ObtainCustomVariable("BehaviorVariable_"..self.VariableName,0)local a1=self.Value;if type(self.Value)=="string"then a1=ObtainCustomVariable("BehaviorVariable_"..self.Value,0)end;if self.Relation=="=="then if a0==a1 then return true end elseif self.Relation=="~="then if a0==a1 then return true end elseif self.Relation=="<"then if a0<a1 then return true end elseif self.Relation=="<="then if a0<=a1 then return true end elseif self.Relation==">="then if a0>=a1 then return true end else if a0>a1 then return true end end;return nil end;function B_Goal_CustomVariables:GetCustomData(m)return{"==","~=","<=","<",">",">="}end;function B_Goal_CustomVariables:Debug(l)local a2={"==","~=","<=","<",">",">="}local a3={true,false,nil}if not ObtainCustomVariable("BehaviorVariable_"..self.VariableName)then warn(false,l.Identifier..": "..self.Name..": variable '"..self.VariableName.."' do not exist!")end;if not table.contains(a2,self.Relation)then debug(false,l.Identifier..": "..self.Name..": '"..self.Relation.."' is an invalid relation!")return true end;return false end;RegisterBehavior(B_Goal_CustomVariables)function Goal_TributeDiplomacy(...)return B_Goal_TributeDiplomacy:new(...)end;B_Goal_TributeDiplomacy={Name="Goal_TributeDiplomacy",Description={en="Goal: AI requests periodical tribute for better Diplomacy",de="Ziel: Die KI fordert einen regelmässigen Tribut fuer bessere Diplomatie. Der Questgeber ist der fordernde Spieler.",fr="Objectif: L'IA demande un tribut régulier pour une meilleure diplomatie. Le donneur de quête est le joueur qui exige."},Parameter={{ParameterType.Number,en="Amount",de="Menge",fr="Quantité"},{ParameterType.Number,en="Time till next peyment in seconds",de="Zeit bis zur Forderung in Sekunden",fr="Temps jusqu'à la demande en secondes"},{ParameterType.Number,en="Time to pay tribute in seconds",de="Zeit bis zur Zahlung in Sekunden",fr="Délai avant paiement en secondes"},{ParameterType.Default,en="Start Message for TributQuest",de="Startnachricht der Tributquest",fr="Message de début de quête de tribut"},{ParameterType.Default,en="Success Message for TributQuest",de="Erfolgsnachricht der Tributquest",fr="Message de réussite de la quête de tribut"},{ParameterType.Default,en="Failure Message for TributQuest",de="Niederlagenachricht der Tributquest",fr="Message de défaite de la quête de tribut"},{ParameterType.Custom,en="Restart if failed to pay",de="Nicht-bezahlen beendet die Quest",fr="Ne pas payer met fin à la quête"}}}function B_Goal_TributeDiplomacy:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_TributeDiplomacy:AddParameter(m,n)if m==0 then self.Amount=n*1 elseif m==1 then self.PeriodLength=n*1 elseif m==2 then self.TributTime=n*1 elseif m==3 then self.StartMsg=n elseif m==4 then self.SuccessMsg=n elseif m==5 then self.FailureMsg=n elseif m==6 then self.RestartAtFailure=ToBoolean(n)end end;function B_Goal_TributeDiplomacy:GetTributeQuest(l)if not self.InternTributeQuest then local a4=CONST_LANGUAGE;local a5=self.StartMsg;if type(a5)=="table"then a5=a5[a4]end;local a6=self.SuccessMsg;if type(a6)=="table"then a6=a6[a4]end;local a7=self.FailureMsg;if type(a7)=="table"then a7=a7[a4]end;Lib.Core.Quest.QuestCounter=Lib.Core.Quest.QuestCounter+1;local a8,a9=QuestTemplate:New(l.Identifier.."_TributeDiplomacyQuest_"..Lib.Core.Quest.QuestCounter,l.SendingPlayer,l.ReceivingPlayer,{{Objective.Deliver,{Goods.G_Gold,self.Amount}}},{{Triggers.Time,0}},self.TributTime,nil,nil,nil,nil,true,true,nil,a5,a6,a7)self.InternTributeQuest=a9 end end;function B_Goal_TributeDiplomacy:CheckTributeQuest(l)if self.InternTributeQuest and self.InternTributeQuest.State==QuestState.Over and not self.RestartQuest then if self.InternTributeQuest.Result~=QuestResult.Success then SetDiplomacyState(l.ReceivingPlayer,l.SendingPlayer,DiplomacyStates.Enemy)if not self.RestartAtFailure then return false end else SetDiplomacyState(l.ReceivingPlayer,l.SendingPlayer,DiplomacyStates.TradeContact)end;self.RestartQuest=true;self.Time=Logic.GetTime()end end;function B_Goal_TributeDiplomacy:CheckTributePlayer(l)local aa=Logic.GetStoreHouse(l.SendingPlayer)if aa==0 or Logic.IsEntityDestroyed(aa)then if self.InternTributeQuest and self.InternTributeQuest.State==QuestState.Active then self.InternTributeQuest:Interrupt()end;return true end end;function B_Goal_TributeDiplomacy:TributQuestRestarter(l)if self.InternTributeQuest and self.Time and self.RestartQuest and Logic.GetTime()-self.Time>=self.PeriodLength then self.InternTributeQuest.Objectives[1].Completed=nil;self.InternTributeQuest.Objectives[1].Data[3]=nil;self.InternTributeQuest.Objectives[1].Data[4]=nil;self.InternTributeQuest.Objectives[1].Data[5]=nil;self.InternTributeQuest.Result=nil;self.InternTributeQuest.State=QuestState.NotTriggered;Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")")StartSimpleJobEx(_G[QuestTemplate.Loop],self.InternTributeQuest.QueueID)self.RestartQuest=nil end end;function B_Goal_TributeDiplomacy:CustomFunction(l)self:GetTributeQuest(l)if self:CheckTributeQuest(l)==false then return false end;if self:CheckTributePlayer(l)==true then return true end;self:TributQuestRestarter(l)end;function B_Goal_TributeDiplomacy:Debug(l)if self.Amount<0 then debug(false,l.Identifier..": "..self.Name..": Amount is negative!")return true end;if self.PeriodLength<self.TributTime then debug(false,l.Identifier..": "..self.Name..": TributTime too long!")return true end end;function B_Goal_TributeDiplomacy:Reset(l)self.Time=nil;self.InternTributeQuest=nil;self.RestartQuest=nil end;function B_Goal_TributeDiplomacy:Interrupt(l)if self.InternTributeQuest~=nil then if self.InternTributeQuest.State==QuestState.Active then self.InternTributeQuest:Interrupt()end end end;function B_Goal_TributeDiplomacy:GetCustomData(m)if m==6 then return{"true","false"}end end;RegisterBehavior(B_Goal_TributeDiplomacy)function Goal_TributeClaim(...)return B_Goal_TributeClaim:new(...)end;B_Goal_TributeClaim={Name="Goal_TributeClaim",Description={en="Goal: AI requests periodical tribute for a specified territory. The quest sender is the demanding player.",de="Ziel: Die KI fordert einen regelmässigen Tribut fuer ein Territorium. Der Questgeber ist der fordernde Spieler.",fr="Objectif: L'IA demande un tribut régulier pour un territoire. Le donneur de quête est le joueur qui exige."},Parameter={{ParameterType.TerritoryName,en="Territory",de="Territorium",fr="Territoire"},{ParameterType.PlayerID,en="PlayerID",de="PlayerID",fr="PlayerID"},{ParameterType.Custom,en="Good Type",de="Warentyp",fr="Type de biens"},{ParameterType.Number,en="Amount",de="Menge",fr="Quantité"},{ParameterType.Number,en="Length of Period in seconds",de="Sekunden bis zur nächsten Forderung",fr="secondes jusqu'à la prochaine demande"},{ParameterType.Number,en="Time to pay Tribut in seconds",de="Zeit bis zur Zahlung in Sekunden",fr="Délai avant paiement en secondes"},{ParameterType.Default,en="Start Message for TributQuest",de="Startnachricht der Tributquest",fr="Message de début de quête de tribut"},{ParameterType.Default,en="Success Message for TributQuest",de="Erfolgsnachricht der Tributquest",fr="Message de réussite de la quête de tribut"},{ParameterType.Default,en="Failure Message for TributQuest",de="Niederlagenachricht der Tributquest",fr="Message de défaite de la quête de tribut"},{ParameterType.Number,en="How often to pay (0 = forerver)",de="Anzahl der Tributquests (0 = unendlich)",fr="Nombre de quêtes de tribut (0 = infini)"},{ParameterType.Custom,en="Other Owner cancels the Quest",de="Anderer Spieler kann Quest beenden",fr="Un autre joueur peut terminer une quête"},{ParameterType.Custom,en="About if a rate is not payed",de="Nicht-bezahlen beendet die Quest",fr="Ne pas payer met fin à la quête"}}}function B_Goal_TributeClaim:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_TributeClaim:AddParameter(m,n)if m==0 then if type(n)=="string"then n=GetTerritoryIDByName(n)end;self.TerritoryID=n elseif m==1 then self.PlayerID=n*1 elseif m==2 then self.GoodType=Goods[n or"G_Gold"]elseif m==3 then self.Amount=n*1 elseif m==4 then self.PeriodLength=n*1 elseif m==5 then self.TributTime=n*1 elseif m==6 then self.StartMsg=n elseif m==7 then self.SuccessMsg=n elseif m==8 then self.FailureMsg=n elseif m==9 then self.HowOften=n*1 elseif m==10 then self.OtherOwnerCancels=ToBoolean(n)elseif m==11 then self.DontPayCancels=ToBoolean(n)end end;function B_Goal_TributeClaim:CureOutpost(l)local ab=Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID)if IsExisting(ab)and GetHealth(ab)<25 and Logic.IsBuildingBeingKnockedDown(ab)==false then while Logic.GetEntityHealth(ab)<Logic.GetEntityMaxHealth(ab)*0.6 do Logic.HealEntity(ab,1)end end end;function B_Goal_TributeClaim:RestartTributeQuest(l)if self.InternTributeQuest then self.InternTributeQuest.Objectives[1].Completed=nil;self.InternTributeQuest.Objectives[1].Data[3]=nil;self.InternTributeQuest.Objectives[1].Data[4]=nil;self.InternTributeQuest.Objectives[1].Data[5]=nil;self.InternTributeQuest.Result=nil;self.InternTributeQuest.State=QuestState.NotTriggered;Logic.ExecuteInLuaLocalState("LocalScriptCallback_OnQuestStatusChanged("..self.InternTributeQuest.Index..")")StartSimpleJobEx(_G[QuestTemplate.Loop],self.InternTributeQuest.QueueID)end end;function B_Goal_TributeClaim:CreateTributeQuest(l)if not self.InternTributeQuest then local a4=CONST_LANGUAGE;local a5=self.StartMsg;if type(a5)=="table"then a5=a5[a4]end;local a6=self.SuccessMsg;if type(a6)=="table"then a6=a6[a4]end;local a7=self.FailureMsg;if type(a7)=="table"then a7=a7[a4]end;Lib.Core.Quest.QuestCounter=Lib.Core.Quest.QuestCounter+1;local ac=function()self.Time=Logic.GetTime()end;local a8,a9=QuestTemplate:New(l.Identifier.."_TributeClaimQuest"..Lib.Core.Quest.QuestCounter,self.PlayerID,l.ReceivingPlayer,{{Objective.Deliver,{self.GoodType,self.Amount}}},{{Triggers.Time,0}},self.TributTime,nil,nil,ac,nil,true,true,nil,a5,a6,a7)self.InternTributeQuest=a9 end end;function B_Goal_TributeClaim:OnTributeFailed(l)local ab=Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID)if IsExisting(ab)then Logic.ChangeEntityPlayerID(ab,self.PlayerID)end;Logic.SetTerritoryPlayerID(self.TerritoryID,self.PlayerID)self.InternTributeQuest.State=false;self.Time=nil;if self.DontPayCancels then l:Interrupt()end end;function B_Goal_TributeClaim:OnTributePaid(l)local ab=Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID)if self.InternTributeQuest.Result==QuestResult.Success then if Logic.GetTerritoryPlayerID(self.TerritoryID)==self.PlayerID then if IsExisting(ab)then Logic.ChangeEntityPlayerID(ab,l.ReceivingPlayer)end;Logic.SetTerritoryPlayerID(self.TerritoryID,l.ReceivingPlayer)end end;if self.Time and Logic.GetTime()>=self.Time+self.PeriodLength then if self.HowOften and self.HowOften~=0 then self.TributeCounter=(self.TributeCounter or 0)+1;if self.TributeCounter>=self.HowOften then return false end end;self:RestartTributeQuest()self.Time=nil end end;function B_Goal_TributeClaim:CustomFunction(l)self:CreateTributeQuest(l)self:CureOutpost(l)if Logic.GetTerritoryPlayerID(self.TerritoryID)==l.ReceivingPlayer or Logic.GetTerritoryPlayerID(self.TerritoryID)==self.PlayerID then if self.OtherOwner then self:RestartTributeQuest()self.OtherOwner=nil end;if self.InternTributeQuest.State==QuestState.Over then if self.InternTributeQuest.Result==QuestResult.Failure then self:OnTributeFailed(l)else self:OnTributePaid(l)end elseif self.InternTributeQuest.State==false then if self.Time and Logic.GetTime()>=self.Time+self.PeriodLength then self:RestartTributeQuest(l)end end elseif Logic.GetTerritoryPlayerID(self.TerritoryID)==0 and self.InternTributeQuest then if self.InternTributeQuest.State==QuestState.Active then self.InternTributeQuest:Interrupt()end elseif Logic.GetTerritoryPlayerID(self.TerritoryID)~=self.PlayerID then if self.InternTributeQuest.State==QuestState.Active then self.InternTributeQuest:Interrupt()end;if self.OtherOwnerCancels then l:Interrupt()end;self.OtherOwner=true end;local aa=Logic.GetStoreHouse(self.PlayerID)if aa==0 or Logic.IsEntityDestroyed(aa)then if self.InternTributeQuest and self.InternTributeQuest.State==QuestState.Active then self.InternTributeQuest:Interrupt()end;return true end end;function B_Goal_TributeClaim:Debug(l)if self.TerritoryID==0 then debug(false,l.Identifier..": "..self.Name..": Unknown Territory")return true end;if not self.Quest and Logic.GetStoreHouse(self.PlayerID)==0 then debug(false,l.Identifier..": "..self.Name..": Player "..self.PlayerID.." is dead. :-(")return true end;if self.Amount<0 then debug(false,l.Identifier..": "..self.Name..": Amount is negative")return true end;if self.PeriodLength<self.TributTime or self.PeriodLength<1 then debug(false,l.Identifier..": "..self.Name..": Period Length is wrong")return true end;if self.HowOften<0 then debug(false,l.Identifier..": "..self.Name..": HowOften is negative")return true end end;function B_Goal_TributeClaim:Reset(l)self.InternTributeQuest=nil;self.Time=nil;self.OtherOwner=nil end;function B_Goal_TributeClaim:Interrupt(l)if type(self.InternTributeQuest)=="table"then if self.InternTributeQuest.State==QuestState.Active then self.InternTributeQuest:Interrupt()end end end;function B_Goal_TributeClaim:GetCustomData(m)if m==2 then local p={}for q,r in pairs(Goods)do if string.find(q,"^G_")then table.insert(p,q)end end;table.sort(p)return p elseif m==10 or m==11 then return{"false","true"}end end;RegisterBehavior(B_Goal_TributeClaim)function Reprisal_ObjectDeactivate(...)return B_Reprisal_InteractiveObjectDeactivate:new(...)end;B_Reprisal_InteractiveObjectDeactivate={Name="Reprisal_InteractiveObjectDeactivate",Description={en="Reprisal: Deactivates an interactive object",de="Vergeltung: Deaktiviert ein interaktives Objekt",fr="Rétribution: désactive un objet interactif"},Parameter={{ParameterType.ScriptName,en="Interactive object",de="Interaktives Objekt",fr="Object interactif"}}}function B_Reprisal_InteractiveObjectDeactivate:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_InteractiveObjectDeactivate:AddParameter(m,n)if m==0 then self.ScriptName=n end end;function B_Reprisal_InteractiveObjectDeactivate:CustomFunction(l)InteractiveObjectDeactivate(self.ScriptName)end;function B_Reprisal_InteractiveObjectDeactivate:Debug(l)if not Logic.IsInteractiveObject(GetID(self.ScriptName))then warn(false,l.Identifier..": "..self.Name..": '"..self.ScriptName.."' is not a interactive object!")self.WarningPrinted=true end;local ad=GetID(self.ScriptName)if CONST_INITIALIZED_OBJECTS[ad]and CONST_INITIALIZED_OBJECTS[ad]==l.Identifier then debug(false,l.Identifier..": "..self.Name..": you can not deactivate in the same quest the object is initalized!")return true end;return false end;RegisterBehavior(B_Reprisal_InteractiveObjectDeactivate)function Reprisal_ObjectActivate(...)return B_Reprisal_InteractiveObjectActivate:new(...)end;B_Reprisal_InteractiveObjectActivate={Name="Reprisal_InteractiveObjectActivate",Description={en="Reprisal: Activates an interactive object",de="Vergeltung: Aktiviert ein interaktives Objekt",fr="Retribution : active un objet interactif"},Parameter={{ParameterType.ScriptName,en="Interactive object",de="Interaktives Objekt",fr="Object interactif"},{ParameterType.Custom,en="Availability",de="Nutzbarkeit",fr="Utilisabilité"}}}function B_Reprisal_InteractiveObjectActivate:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_InteractiveObjectActivate:AddParameter(m,n)if m==0 then self.ScriptName=n elseif m==1 then local c=0;if n=="Always"or 1 then c=1 end;self.UsingState=c*1 end end;function B_Reprisal_InteractiveObjectActivate:CustomFunction(l)InteractiveObjectActivate(self.ScriptName,self.UsingState)end;function B_Reprisal_InteractiveObjectActivate:GetCustomData(m)if m==1 then return{"Knight only","Always"}end end;function B_Reprisal_InteractiveObjectActivate:Debug(l)if not Logic.IsInteractiveObject(GetID(self.ScriptName))then warn(false,l.Identifier..": "..self.Name..": '"..self.ScriptName.."' is not a interactive object!")self.WarningPrinted=true end;local ad=GetID(self.ScriptName)if CONST_INITIALIZED_OBJECTS[ad]and CONST_INITIALIZED_OBJECTS[ad]==l.Identifier then debug(false,l.Identifier..": "..self.Name..": you can not activate in the same quest the object is initalized!")return true end;return false end;RegisterBehavior(B_Reprisal_InteractiveObjectActivate)function Reprisal_DiplomacyDecrease()return B_Reprisal_SlightlyDiplomacyDecrease:new()end;B_Reprisal_SlightlyDiplomacyDecrease={Name="Reprisal_SlightlyDiplomacyDecrease",Description={en="Reprisal: Diplomacy decreases slightly to another player.",de="Vergeltung: Der Diplomatiestatus zum Auftraggeber wird um eine Stufe verringert.",fr="Rétribution: le statut diplomatique avec le mandant est réduit d'un niveau."}}function B_Reprisal_SlightlyDiplomacyDecrease:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_SlightlyDiplomacyDecrease:CustomFunction(l)local ae=l.SendingPlayer;local af=l.ReceivingPlayer;local ag=GetDiplomacyState(af,ae)if ag>-2 then SetDiplomacyState(af,ae,ag-1)end end;function B_Reprisal_SlightlyDiplomacyDecrease:AddParameter(m,n)if m==0 then self.PlayerID=n*1 end end;RegisterBehavior(B_Reprisal_SlightlyDiplomacyDecrease)function Reprisal_Diplomacy(...)return B_Reprisal_Diplomacy:new(...)end;B_Reprisal_Diplomacy={Name="Reprisal_Diplomacy",Description={en="Reprisal: Sets Diplomacy state of two Players to a stated value.",de="Vergeltung: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert.",fr="Rétribution: Définit le statut diplomatique de deux joueurs sur la valeur indiquée."},Parameter={{ParameterType.PlayerID,en="PlayerID 1",de="Spieler 1",fr="Joueur 1"},{ParameterType.PlayerID,en="PlayerID 2",de="Spieler 2",fr="Joueur 2"},{ParameterType.DiplomacyState,en="Relation",de="Beziehung",fr="Relation diplomatique"}}}function B_Reprisal_Diplomacy:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_Diplomacy:AddParameter(m,n)if m==0 then self.PlayerID1=n*1 elseif m==1 then self.PlayerID2=n*1 elseif m==2 then self.Relation=DiplomacyStates[n]end end;function B_Reprisal_Diplomacy:CustomFunction(l)SetDiplomacyState(self.PlayerID1,self.PlayerID2,self.Relation)end;function B_Reprisal_Diplomacy:Debug(l)if not tonumber(self.PlayerID1)or self.PlayerID1<1 or self.PlayerID1>8 then debug(false,l.Identifier..": "..self.Name..": PlayerID 1 is invalid!")return true elseif not tonumber(self.PlayerID2)or self.PlayerID2<1 or self.PlayerID2>8 then debug(false,l.Identifier..": "..self.Name..": PlayerID 2 is invalid!")return true elseif not tonumber(self.Relation)or self.Relation<-2 or self.Relation>2 then debug(false,l.Identifier..": "..self.Name..": '"..self.Relation.."' is a invalid diplomacy state!")return true end;return false end;RegisterBehavior(B_Reprisal_Diplomacy)function Reprisal_DestroyEntity(...)return B_Reprisal_DestroyEntity:new(...)end;B_Reprisal_DestroyEntity={Name="Reprisal_DestroyEntity",Description={en="Reprisal: Replaces an entity with an invisible script entity, which retains the entities name.",de="Vergeltung: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt.",fr="Rétribution: remplace une entité par une entité de script invisible qui prend son nom."},Parameter={{ParameterType.ScriptName,en="Entity",de="Entity",fr="Entité"}}}function B_Reprisal_DestroyEntity:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_DestroyEntity:AddParameter(m,n)if m==0 then self.ScriptName=n end end;function B_Reprisal_DestroyEntity:CustomFunction(l)ReplaceEntity(self.ScriptName,Entities.XD_ScriptEntity)end;function B_Reprisal_DestroyEntity:Debug(l)if not IsExisting(self.ScriptName)then warn(false,l.Identifier..": "..self.Name..": '"..self.ScriptName.."' is already destroyed!")self.WarningPrinted=true end;return false end;RegisterBehavior(B_Reprisal_DestroyEntity)function Reprisal_DestroyEffect(...)return B_Reprisal_DestroyEffect:new(...)end;B_Reprisal_DestroyEffect={Name="Reprisal_DestroyEffect",Description={en="Reprisal: Destroys an effect",de="Vergeltung: Zerstört einen Effekt",fr="Rétribution: détruit un effet"},Parameter={{ParameterType.Default,en="Effect name",de="Effektname",fr="Nom de l'effet"}}}function B_Reprisal_DestroyEffect:AddParameter(m,n)if m==0 then self.EffectName=n end end;function B_Reprisal_DestroyEffect:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_DestroyEffect:CustomFunction(l)if not CONST_EFFECT_NAME_TO_ID[self.EffectName]or not Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName])then return end;Logic.DestroyEffect(CONST_EFFECT_NAME_TO_ID[self.EffectName])end;function B_Reprisal_DestroyEffect:Debug(l)if not CONST_EFFECT_NAME_TO_ID[self.EffectName]then debug(false,l.Identifier..": "..self.Name..": Effect "..self.EffectName.." never created")end;return false end;RegisterBehavior(B_Reprisal_DestroyEffect)function Reprisal_Defeat()return B_Reprisal_Defeat:new()end;B_Reprisal_Defeat={Name="Reprisal_Defeat",Description={en="Reprisal: The player loses the game.",de="Vergeltung: Der Spieler verliert das Spiel.",fr="Rétribution: le joueur perd la partie."}}function B_Reprisal_Defeat:GetReprisalTable()return{Reprisal.Defeat}end;RegisterBehavior(B_Reprisal_Defeat)function Reprisal_FakeDefeat()return B_Reprisal_FakeDefeat:new()end;B_Reprisal_FakeDefeat={Name="Reprisal_FakeDefeat",Description={en="Reprisal: Displays a defeat icon for a quest",de="Vergeltung: Zeigt ein Niederlage Icon fuer eine Quest an",fr="Rétribution: affiche une icône de défaite pour une quête"}}function B_Reprisal_FakeDefeat:GetReprisalTable()return{Reprisal.FakeDefeat}end;RegisterBehavior(B_Reprisal_FakeDefeat)function Reprisal_ReplaceEntity(...)return B_Reprisal_ReplaceEntity:new(...)end;B_Reprisal_ReplaceEntity={Name="Reprisal_ReplaceEntity",Description={en="Reprisal: Replaces an entity with a new one of a different type. The playerID can be changed too.",de="Vergeltung: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden.",fr="Rétribution: remplace une entité par une nouvelle entité d'un autre type. Il est également possible de changer l'appartenance d'un joueur."},Parameter={{ParameterType.ScriptName,en="Target",de="Ziel",fr="Cible"},{ParameterType.Custom,en="New Type",de="Neuer Typ",fr="Nouveau type"},{ParameterType.Custom,en="New playerID",de="Neue Spieler ID",fr="Nouvelle ID de joueur"}}}function B_Reprisal_ReplaceEntity:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_ReplaceEntity:AddParameter(m,n)if m==0 then self.ScriptName=n elseif m==1 then self.NewType=n elseif m==2 then self.PlayerID=tonumber(n)end end;function B_Reprisal_ReplaceEntity:CustomFunction(l)local ad=GetID(self.ScriptName)local ah=self.PlayerID;if ah==Logic.EntityGetPlayer(ad)then ah=nil end;ReplaceEntity(self.ScriptName,Entities[self.NewType],ah)end;function B_Reprisal_ReplaceEntity:GetCustomData(m)local p={}if m==1 then for q,r in pairs(Entities)do local ai={"^M_","^XS_","^X_","^XT_","^Z_","^XB_"}local aj=false;for a=1,#ai do if q:find(ai[a])then aj=true;break end end;if not aj then table.insert(p,q)end end;table.sort(p)elseif m==2 then p={"-","0","1","2","3","4","5","6","7","8"}end;return p end;function B_Reprisal_ReplaceEntity:Debug(l)if not Entities[self.NewType]then debug(false,l.Identifier..": "..self.Name..": got an invalid entity type!")return true elseif self.PlayerID~=nil and(self.PlayerID<1 or self.PlayerID>8)then debug(false,l.Identifier..": "..self.Name..": got an invalid playerID!")return true end;if not IsExisting(self.ScriptName)then self.WarningPrinted=true;warn(false,l.Identifier..": "..self.Name..": '"..self.ScriptName.."' does not exist!")end;return false end;RegisterBehavior(B_Reprisal_ReplaceEntity)function Reprisal_QuestRestart(...)return B_Reprisal_QuestRestart:new(...)end;B_Reprisal_QuestRestart={Name="Reprisal_QuestRestart",Description={en="Reprisal: Restarts a (completed) quest so it can be triggered and completed again",de="Vergeltung: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann",fr="Rétribution : relance une quête (terminée) pour qu'elle puisse être redéclenchée et terminée à nouveau"},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la Quête"}}}function B_Reprisal_QuestRestart:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_QuestRestart:AddParameter(m,n)if m==0 then self.QuestName=n end end;function B_Reprisal_QuestRestart:CustomFunction(l)RestartQuest(self.QuestName,true)end;function B_Reprisal_QuestRestart:Debug(l)if not Quests[GetQuestID(self.QuestName)]then debug(false,l.Identifier..": "..self.Name..": quest "..self.QuestName.." does not exist!")return true end;return false end;RegisterBehavior(B_Reprisal_QuestRestart)function Reprisal_QuestFailure(...)return B_Reprisal_QuestFailure:new(...)end;B_Reprisal_QuestFailure={Name="Reprisal_QuestFailure",Description={en="Reprisal: Lets another active quest fail",de="Vergeltung: Lässt eine andere aktive Quest fehlschlagen",fr="Rétribution: fait échouer une autre quête active"},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la Quête"}}}function B_Reprisal_QuestFailure:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_QuestFailure:AddParameter(m,n)if m==0 then self.QuestName=n end end;function B_Reprisal_QuestFailure:CustomFunction(l)FailQuest(self.QuestName,true)end;function B_Reprisal_QuestFailure:Debug(l)if not Quests[GetQuestID(self.QuestName)]then debug(false,l.Identifier..": "..self.Name..": got an invalid quest!")return true end;return false end;RegisterBehavior(B_Reprisal_QuestFailure)function Reprisal_QuestSuccess(...)return B_Reprisal_QuestSuccess:new(...)end;B_Reprisal_QuestSuccess={Name="Reprisal_QuestSuccess",Description={en="Reprisal: Completes another active quest successfully",de="Vergeltung: Beendet eine andere aktive Quest erfolgreich",fr="Rétribution: Réussir une autre quête active"},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la Quête"}}}function B_Reprisal_QuestSuccess:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_QuestSuccess:AddParameter(m,n)if m==0 then self.QuestName=n end end;function B_Reprisal_QuestSuccess:CustomFunction(l)WinQuest(self.QuestName,true)end;function B_Reprisal_QuestSuccess:Debug(l)if not Quests[GetQuestID(self.QuestName)]then debug(false,l.Identifier..": "..self.Name..": quest "..self.QuestName.." does not exist!")return true end;return false end;RegisterBehavior(B_Reprisal_QuestSuccess)function Reprisal_QuestActivate(...)return B_Reprisal_QuestActivate:new(...)end;B_Reprisal_QuestActivate={Name="Reprisal_QuestActivate",Description={en="Reprisal: Activates another quest that is not triggered yet.",de="Vergeltung: Aktiviert eine andere Quest die noch nicht ausgelöst wurde.",fr="Rétribution: Active une autre quête qui n'a pas encore été déclenchée."},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la Quête"}}}function B_Reprisal_QuestActivate:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_QuestActivate:AddParameter(m,n)if m==0 then self.QuestName=n else assert(false,"Error in "..self.Name..": AddParameter: Index is invalid")end end;function B_Reprisal_QuestActivate:CustomFunction(l)StartQuest(self.QuestName,true)end;function B_Reprisal_QuestActivate:Debug(l)if not IsValidQuest(self.QuestName)then debug(false,l.Identifier..": "..self.Name..": Quest: "..self.QuestName.." does not exist")return true end;return false end;RegisterBehavior(B_Reprisal_QuestActivate)function Reprisal_QuestInterrupt(...)return B_Reprisal_QuestInterrupt:new(...)end;B_Reprisal_QuestInterrupt={Name="Reprisal_QuestInterrupt",Description={en="Reprisal: Interrupts another active quest without success or failure",de="Vergeltung: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg",fr="Rétribution : termine une autre quête active sans succès ni échec"},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la Quête"}}}function B_Reprisal_QuestInterrupt:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_QuestInterrupt:AddParameter(m,n)if m==0 then self.QuestName=n end end;function B_Reprisal_QuestInterrupt:CustomFunction(l)if GetQuestID(self.QuestName)~=nil then local a8=GetQuestID(self.QuestName)local a9=Quests[a8]if a9.State==QuestState.Active then StopQuest(self.QuestName,true)end end end;function B_Reprisal_QuestInterrupt:Debug(l)if not Quests[GetQuestID(self.QuestName)]then debug(false,l.Identifier..": "..self.Name..": quest "..self.QuestName.." does not exist!")return true end;return false end;RegisterBehavior(B_Reprisal_QuestInterrupt)function Reprisal_QuestForceInterrupt(...)return B_Reprisal_QuestForceInterrupt:new(...)end;B_Reprisal_QuestForceInterrupt={Name="Reprisal_QuestForceInterrupt",Description={en="Reprisal: Interrupts another quest (even when it isn't active yet) without success or failure",de="Vergeltung: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg",fr="Rétribution: Termine une autre quête, même si elle n'est pas encore active, sans succès ni échec."},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la Quête"},{ParameterType.Custom,en="Ended quests",de="Beendete Quests",fr="Quêtes terminées"}}}function B_Reprisal_QuestForceInterrupt:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_QuestForceInterrupt:AddParameter(m,n)if m==0 then self.QuestName=n elseif m==1 then self.InterruptEnded=ToBoolean(n)end end;function B_Reprisal_QuestForceInterrupt:GetCustomData(m)local p={}if m==1 then table.insert(p,"false")table.insert(p,"true")else assert(false)end;return p end;function B_Reprisal_QuestForceInterrupt:CustomFunction(l)if GetQuestID(self.QuestName)~=nil then local a8=GetQuestID(self.QuestName)local a9=Quests[a8]if self.InterruptEnded or a9.State~=QuestState.Over then a9:Interrupt()end end end;function B_Reprisal_QuestForceInterrupt:Debug(l)if not Quests[GetQuestID(self.QuestName)]then debug(false,l.Identifier..": "..self.Name..": quest "..self.QuestName.." does not exist!")return true end;return false end;RegisterBehavior(B_Reprisal_QuestForceInterrupt)function Reprisal_CustomVariables(...)return B_Reprisal_CustomVariables:new(...)end;B_Reprisal_CustomVariables={Name="Reprisal_CustomVariables",Description={en="Reprisal: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable.",de="Vergeltung: Führt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein.",fr="Rétribution: effectue une opération mathématique sur la variable. L'autre opérateur peut être un nombre ou une variable personnalisée."},Parameter={{ParameterType.Default,en="Name of variable",de="Variablenname",fr="Nom de la variable"},{ParameterType.Custom,en="Operator",de="Operator",fr="Operateur"},{ParameterType.Default,en="Value or variable",de="Wert oder Variable",fr="Valeur ou variable"}}}function B_Reprisal_CustomVariables:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_CustomVariables:AddParameter(m,n)if m==0 then self.VariableName=n elseif m==1 then self.Operator=n elseif m==2 then local _=tonumber(n)self.Value=_==nil and tostring(n)or _ end end;function B_Reprisal_CustomVariables:CustomFunction()local a0=ObtainCustomVariable("BehaviorVariable_"..self.VariableName,0)local a1=self.Value;if type(self.Value)=="string"then a1=ObtainCustomVariable("BehaviorVariable_"..self.Value,0)end;if self.Operator=="="then a0=a1 elseif self.Operator=="+"then a0=a0+a1 elseif self.Operator=="-"then a0=a0-a1 elseif self.Operator=="*"then a0=a0*a1 elseif self.Operator=="/"then a0=a0/a1 elseif self.Operator=="^"then a0=a0%a1 end;SaveCustomVariable("BehaviorVariable_"..self.VariableName,a0)end;function B_Reprisal_CustomVariables:GetCustomData(m)return{"=","+","-","*","/","^"}end;function B_Reprisal_CustomVariables:Debug(l)local ak={"=","+","-","*","/","^"}if not table.contains(ak,self.Operator)then debug(false,l.Identifier..": "..self.Name..": got an invalid operator!")return true elseif self.VariableName==""then debug(false,l.Identifier..": "..self.Name..": missing name for variable!")return true end;return false end;RegisterBehavior(B_Reprisal_CustomVariables)function Reprisal_MapScriptFunction(...)return B_Reprisal_MapScriptFunction:new(...)end;B_Reprisal_MapScriptFunction={Name="Reprisal_MapScriptFunction",Description={en="Reprisal: Calls a function within the global map script if the quest has failed.",de="Vergeltung: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt.",fr="Rétribution: lance une fonction dans le script global de la carte en cas d'échec de la quête."},Parameter={{ParameterType.Default,en="Function name",de="Funktionsname",fr="Nom de la fonction"}}}function B_Reprisal_MapScriptFunction:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_MapScriptFunction:AddParameter(m,n)if m==0 then self.FuncName=n end end;function B_Reprisal_MapScriptFunction:CustomFunction(l)if type(self.FuncName)=="function"then self.FuncName(unpack(self.i47ya_6aghw_frxil))return end;_G[self.FuncName](self,l)end;function B_Reprisal_MapScriptFunction:Debug(l)if not self.FuncName then debug(false,l.Identifier..": "..self.Name..": function reference is invalid!")return true end;if type(self.FuncName)~="function"and not _G[self.FuncName]then debug(false,l.Identifier..": "..self.Name..": function does not exist!")return true end;return false end;RegisterBehavior(B_Reprisal_MapScriptFunction)function Reprisal_Technology(...)return B_Reprisal_Technology:new(...)end;B_Reprisal_Technology={Name="Reprisal_Technology",Description={en="Reprisal: Locks or unlocks a technology for the given player",de="Vergeltung: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player",fr="Rétribution: bloque ou autorise une technologie pour le joueur spécifié"},Parameter={{ParameterType.PlayerID,en="PlayerID",de="SpielerID",fr="PlayerID"},{ParameterType.Custom,en="Un / Lock",de="Sperren/Erlauben",fr="Bloquer/Autoriser"},{ParameterType.Custom,en="Technology",de="Technologie",fr="Technologie"}}}function B_Reprisal_Technology:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_Technology:AddParameter(m,n)if m==0 then self.PlayerID=n*1 elseif m==1 then self.LockType=n=="Lock"elseif m==2 then self.Technology=n end end;function B_Reprisal_Technology:CustomFunction(l)if self.PlayerID and Logic.GetStoreHouse(self.PlayerID)~=0 and Technologies[self.Technology]then if self.LockType then LockFeaturesForPlayer(self.PlayerID,Technologies[self.Technology])else UnLockFeaturesForPlayer(self.PlayerID,Technologies[self.Technology])end else return false end end;function B_Reprisal_Technology:GetCustomData(m)local p={}if m==1 then p[1]="Lock"p[2]="UnLock"elseif m==2 then for q,r in pairs(Technologies)do table.insert(p,q)end end;return p end;function B_Reprisal_Technology:Debug(l)if not Technologies[self.Technology]then debug(false,l.Identifier..": "..self.Name..": got an invalid technology type!")return true elseif tonumber(self.PlayerID)==nil or self.PlayerID<1 or self.PlayerID>8 then debug(false,l.Identifier..": "..self.Name..": got an invalid playerID!")return true end;return false end;RegisterBehavior(B_Reprisal_Technology)function Reward_ObjectDeactivate(...)return B_Reward_InteractiveObjectDeactivate:new(...)end;B_Reward_InteractiveObjectDeactivate=CopyTable(B_Reprisal_InteractiveObjectDeactivate)B_Reward_InteractiveObjectDeactivate.Name="Reward_InteractiveObjectDeactivate"B_Reward_InteractiveObjectDeactivate.Description.en="Reward: Deactivates an interactive object"B_Reward_InteractiveObjectDeactivate.Description.de="Lohn: Deaktiviert ein interaktives Objekt"B_Reward_InteractiveObjectDeactivate.Description.fr="Récompense: Désactive un objet interactif"B_Reward_InteractiveObjectDeactivate.GetReprisalTable=nil;B_Reward_InteractiveObjectDeactivate.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_InteractiveObjectDeactivate)function Reward_ObjectActivate(...)return B_Reward_InteractiveObjectActivate:new(...)end;B_Reward_InteractiveObjectActivate=CopyTable(B_Reprisal_InteractiveObjectActivate)B_Reward_InteractiveObjectActivate.Name="Reward_InteractiveObjectActivate"B_Reward_InteractiveObjectActivate.Description.en="Reward: Activates an interactive object"B_Reward_InteractiveObjectActivate.Description.de="Lohn: Aktiviert ein interaktives Objekt"B_Reward_InteractiveObjectActivate.Description.fr="Récompense: Active un objet interactif"B_Reward_InteractiveObjectActivate.GetReprisalTable=nil;B_Reward_InteractiveObjectActivate.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_InteractiveObjectActivate)function Reward_ObjectInit(...)return B_Reward_ObjectInit:new(...)end;B_Reward_ObjectInit={Name="Reward_ObjectInit",Description={en="Reward: Setup an interactive object with costs and rewards.",de="Lohn: Initialisiert ein interaktives Objekt mit seinen Kosten und Schätzen.",fr="Récompense: Initialise un objet interactif avec ses coûts et ses trésors."},Parameter={{ParameterType.ScriptName,en="Interactive object",de="Interaktives Objekt",fr="Obejct interactif"},{ParameterType.Number,en="Distance to use",de="Nutzungsentfernung",fr="Distance d'utilisation"},{ParameterType.Number,en="Waittime",de="Wartezeit",fr="Temps d'attente"},{ParameterType.Custom,en="Reward good",de="Belohnungsware",fr="Produits de récompense"},{ParameterType.Number,en="Reward amount",de="Anzahl",fr="Quantité"},{ParameterType.Custom,en="Cost good 1",de="Kostenware 1",fr="Marchandise de coût 1"},{ParameterType.Number,en="Cost amount 1",de="Anzahl 1",fr="Quantité 1"},{ParameterType.Custom,en="Cost good 2",de="Kostenware 2",fr="Marchandise de coût 2"},{ParameterType.Number,en="Cost amount 2",de="Anzahl 2",fr="Quantité 2"},{ParameterType.Custom,en="Availability",de="Verfügbarkeit",fr="Disponibilité"}}}function B_Reward_ObjectInit:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_ObjectInit:AddParameter(m,n)if m==0 then self.ScriptName=n elseif m==1 then self.Distance=n*1 elseif m==2 then self.Waittime=n*1 elseif m==3 then self.RewardType=n elseif m==4 then self.RewardAmount=n*1 elseif m==5 then self.FirstCostType=n elseif m==6 then self.FirstCostAmount=n*1 elseif m==7 then self.SecondCostType=n elseif m==8 then self.SecondCostAmount=n*1 elseif m==9 then local c=nil;if n=="Always"or n==1 then c=1 elseif n=="Never"or n==2 then c=2 elseif n=="Knight only"or n==0 then c=0 end;self.UsingState=c end end;function B_Reward_ObjectInit:CustomFunction(l)local ad=GetID(self.ScriptName)if ad==0 then return end;CONST_INITIALIZED_OBJECTS[ad]=l.Identifier;Logic.InteractiveObjectClearCosts(ad)Logic.InteractiveObjectClearRewards(ad)Logic.InteractiveObjectSetInteractionDistance(ad,self.Distance)Logic.InteractiveObjectSetTimeToOpen(ad,self.Waittime)if self.RewardType and self.RewardType~="-"then Logic.InteractiveObjectAddRewards(ad,Goods[self.RewardType],self.RewardAmount)end;if self.FirstCostType and self.FirstCostType~="-"then Logic.InteractiveObjectAddCosts(ad,Goods[self.FirstCostType],self.FirstCostAmount)end;if self.SecondCostType and self.SecondCostType~="-"then Logic.InteractiveObjectAddCosts(ad,Goods[self.SecondCostType],self.SecondCostAmount)end;Logic.InteractiveObjectSetAvailability(ad,true)if self.UsingState then for a=1,8 do Logic.InteractiveObjectSetPlayerState(ad,a,self.UsingState)end end;Logic.InteractiveObjectSetRewardResourceCartType(ad,Entities.U_ResourceMerchant)Logic.InteractiveObjectSetRewardGoldCartType(ad,Entities.U_GoldCart)Logic.InteractiveObjectSetCostResourceCartType(ad,Entities.U_ResourceMerchant)Logic.InteractiveObjectSetCostGoldCartType(ad,Entities.U_GoldCart)RemoveInteractiveObjectFromOpenedList(ad)table.insert(HiddenTreasures,ad)end;function B_Reward_ObjectInit:GetCustomData(m)if m==3 or m==5 or m==7 then local p={"-","G_Beer","G_Bread","G_Broom","G_Carcass","G_Cheese","G_Clothes","G_Dye","G_Gold","G_Grain","G_Herb","G_Honeycomb","G_Iron","G_Leather","G_Medicine","G_Milk","G_RawFish","G_Salt","G_Sausage","G_SmokedFish","G_Soap","G_Stone","G_Water","G_Wood","G_Wool"}if g_GameExtraNo>=1 then p[#p+1]="G_Gems"p[#p+1]="G_MusicalInstrument"p[#p+1]="G_Olibanum"end;return p elseif m==9 then return{"-","Knight only","Always","Never"}end end;function B_Reward_ObjectInit:Debug(l)if Logic.IsInteractiveObject(GetID(self.ScriptName))==false then debug(false,l.Identifier..": "..self.Name..": '"..self.ScriptName.."' is not a interactive object!")return true end;if self.UsingState~=1 and self.Distance<50 then warn(false,l.Identifier..": "..self.Name..": distance is maybe too short!")end;if self.Waittime<0 then debug(false,l.Identifier..": "..self.Name..": waittime must be equal or greater than 0!")return true end;if self.RewardType and self.RewardType~="-"then if not Goods[self.RewardType]then debug(false,l.Identifier..": "..self.Name..": '"..self.RewardType.."' is invalid good type!")return true elseif self.RewardAmount<1 then debug(false,l.Identifier..": "..self.Name..": amount can not be 0 or negative!")return true end end;if self.FirstCostType and self.FirstCostType~="-"then if not Goods[self.FirstCostType]then debug(false,l.Identifier..": "..self.Name..": '"..self.FirstCostType.."' is invalid good type!")return true elseif self.FirstCostAmount<1 then debug(false,l.Identifier..": "..self.Name..": amount can not be 0 or negative!")return true end end;if self.SecondCostType and self.SecondCostType~="-"then if not Goods[self.SecondCostType]then debug(false,l.Identifier..": "..self.Name..": '"..self.SecondCostType.."' is invalid good type!")return true elseif self.SecondCostAmount<1 then debug(false,l.Identifier..": "..self.Name..": amount can not be 0 or negative!")return true end end;return false end;RegisterBehavior(B_Reward_ObjectInit)function Reward_Diplomacy(...)return B_Reward_Diplomacy:new(...)end;B_Reward_Diplomacy=CopyTable(B_Reprisal_Diplomacy)B_Reward_Diplomacy.Name="Reward_Diplomacy"B_Reward_Diplomacy.Description.en="Reward: Sets Diplomacy state of two Players to a stated value."B_Reward_Diplomacy.Description.de="Lohn: Setzt den Diplomatiestatus zweier Spieler auf den angegebenen Wert."B_Reward_Diplomacy.Description.fr="Récompense: Définit le statut diplomatique de deux joueurs sur la valeur indiquée."B_Reward_Diplomacy.GetReprisalTable=nil;B_Reward_Diplomacy.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_Diplomacy)function Reward_DiplomacyIncrease()return B_Reward_SlightlyDiplomacyIncrease:new()end;B_Reward_SlightlyDiplomacyIncrease={Name="Reward_SlightlyDiplomacyIncrease",Description={en="Reward: Diplomacy increases slightly to another player",de="Lohn: Verbesserung des Diplomatiestatus zu einem anderen Spieler",fr="Récompense: Amélioration du statut diplomatique avec un autre joueur"}}function B_Reward_SlightlyDiplomacyIncrease:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_SlightlyDiplomacyIncrease:CustomFunction(l)local ae=l.SendingPlayer;local af=l.ReceivingPlayer;local ag=GetDiplomacyState(af,ae)if ag<2 then SetDiplomacyState(af,ae,ag+1)end end;function B_Reward_SlightlyDiplomacyIncrease:AddParameter(m,n)if m==0 then self.PlayerID=n*1 end end;RegisterBehavior(B_Reward_SlightlyDiplomacyIncrease)function Reward_TradePost(...)return B_Reward_TradePost:new(...)end;B_Reward_TradePost={Name="B_Reward_TradePost",Description={en="Sets options for a Tradepost and deactivates it.",de="Stellt einen Handelsposten ein und deaktiviert ihn.",fr=""},Parameter={{ParameterType.ScriptName,en="ScriptName",de="ScriptName"},{ParameterType.PlayerID,en="PlayerID",de="PlayerID"},{ParameterType.Custom,en="Type of good to pay 1",de="Resourcentyp Bezahlung 1",fr=""},{ParameterType.Number,en="Amount of good",de="Anzahl der Resource",fr=""},{ParameterType.Custom,en="Type of good to get 1",de="Resourcentyp Angebot 1",fr=""},{ParameterType.Number,en="Amount of good",de="Anzahl der Resource"},{ParameterType.Custom,en="Type of good to pay 2",de="Resourcentyp Bezahlung 2",fr=""},{ParameterType.Number,en="Amount of good",de="Anzahl der Resource",fr=""},{ParameterType.Custom,en="Type of good to get 2",de="Resourcentyp Angebot 2",fr=""},{ParameterType.Number,en="Amount of good",de="Anzahl der Resource",fr=""},{ParameterType.Custom,en="Type of good to pay 3",de="Resourcentyp Bezahlung 3",fr=""},{ParameterType.Number,en="Amount of good",de="Anzahl der Resource",fr=""},{ParameterType.Custom,en="Type of good to get 3",de="Resourcentyp Angebot 3",fr=""},{ParameterType.Number,en="Amount of good",de="Anzahl der Resource",fr=""},{ParameterType.Custom,en="Type of good to pay 4",de="Resourcentyp Bezahlung 4",fr=""},{ParameterType.Number,en="Amount of good",de="Anzahl der Resource",fr=""},{ParameterType.Custom,en="Type of good to get 4",de="Resourcentyp Angebot 4",fr=""},{ParameterType.Number,en="Amount of good",de="Anzahl der Resource",fr=""}}}function B_Reward_TradePost:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_TradePost:AddParameter(m,n)if m==0 then self.ScriptName=n elseif m==1 then self.PlayerID=n*1 elseif m==3 then self.PayType1=n elseif m==4 then self.PayAmount1=n*1 elseif m==5 then self.OfferType1=n elseif m==6 then self.OfferAmount1=n*1 elseif m==7 then self.PayType2=n elseif m==8 then self.PayAmount2=n*1 elseif m==9 then self.OfferType2=n elseif m==10 then self.OfferAmount2=n*1 elseif m==11 then self.PayType3=n elseif m==12 then self.PayAmount3=n*1 elseif m==13 then self.OfferType3=n elseif m==14 then self.OfferAmount3=n*1 elseif m==15 then self.PayType4=n elseif m==16 then self.PayAmount4=n*1 elseif m==17 then self.OfferType4=n elseif m==18 then self.OfferAmount4=n*1 end end;function B_Reward_TradePost:CustomFunction(l)local al=0;for a=1,4 do if self["PayAmount"..a]and self["PayAmount"..a]>0 and self["OfferAmount"..a]and self["OfferAmount"..a]>0 then al=a else break end end;debug(IsExisting(self.ScriptName),l.Identifier..": Error in "..self.Name..": CustomFunction: Tradepost is missing")local am=GetID(self.ScriptName)if al>0 then Logic.TradePost_SetTradePartnerGenerateGoodsFlag(am,true)Logic.TradePost_SetTradePartnerPlayerID(am,self.PlayerID)for a=1,al do for e=1,al do Logic.TradePost_SetTradeDefinition(am,e-1,Goods[self["PayType"..e]],self["PayAmount"..e],Goods[self["OfferType"..e]],self["OfferAmount"..e])end end;Logic.TradePost_SetActiveTradeSlot(am,0)Logic.InteractiveObjectSetAvailability(am,false)for an=1,8 do Logic.InteractiveObjectSetPlayerState(am,an,2)end end end;function B_Reward_TradePost:DEBUG(l)if Logic.GetStoreHouse(self.PlayerID)==0 then debug(false,l.Identifier..":  Error in "..self.Name..": Player "..self.PlayerID.." is dead :-(")return true elseif not IsExisting(self.ScriptName)then debug(false,l.Identifier..":  Error in "..self.Name..": No TradePost found")return true end;for a=1,4 do if self["PayAmount"..a]and self["OfferAmount"..a]and self["PayAmount"..a]>0 and self["OfferAmount"..a]>0 and(not Goods[self["PayType"..a]]or not Goods[self["OfferType"..a]])then debug(false,l.Identifier..":  Error in "..self.Name..": Offer type or pay type in Slot "..a.." is wrong")return true end end end;function B_Reward_TradePost:GetCustomData(ao)if ao>=2 and ao<=16 and ao%2==0 then return{"G_Carcass","G_Grain","G_Herb","G_Honeycomb","G_Iron","G_Milk","G_RawFish","G_Stone","G_Wood","G_Wool","G_Salt","G_Dye","G_Olibanum","G_Gems","G_MusicalInstrument"}end end;if g_GameExtraNo and g_GameExtraNo>=1 then RegisterBehavior(B_Reward_TradePost)end;function Reward_TradeOffers(...)return B_Reward_Merchant:new(...)end;B_Reward_Merchant={Name="Reward_Merchant",Description={en="Reward: Deletes all existing offers for a merchant and sets new offers, if given",de="Lohn: Löscht alle Angebote eines Händlers und setzt neue, wenn angegeben",fr="Récompense: Supprime toutes les offres d'un commerçant et en place de nouvelles si elles sont indiquées."},Parameter={{ParameterType.Custom,en="PlayerID",de="PlayerID",fr="PlayerID"},{ParameterType.Custom,en="Amount 1",de="Menge 1",fr="Quantité 1"},{ParameterType.Custom,en="Offer 1",de="Angebot 1",fr="Offre 1"},{ParameterType.Custom,en="Amount 2",de="Menge 2",fr="Quantité 2"},{ParameterType.Custom,en="Offer 2",de="Angebot 2",fr="Offre 2"},{ParameterType.Custom,en="Amount 3",de="Menge 3",fr="Quantité 3"},{ParameterType.Custom,en="Offer 3",de="Angebot 3",fr="Offr 3e"},{ParameterType.Custom,en="Amount 4",de="Menge 4",fr="Quantité 4"},{ParameterType.Custom,en="Offer 4",de="Angebot 4",fr="Offre 4"}}}function B_Reward_Merchant:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_Merchant:AddParameter(m,n)if m==0 then self.PlayerID=n*1 elseif m==1 then n=n or 0;self.AmountOffer1=n*1 elseif m==2 then self.Offer1=n elseif m==3 then n=n or 0;self.AmountOffer2=n*1 elseif m==4 then self.Offer2=n elseif m==5 then n=n or 0;self.AmountOffer3=n*1 elseif m==6 then self.Offer3=n elseif m==7 then n=n or 0;self.AmountOffer4=n*1 elseif m==8 then self.Offer4=n end end;function B_Reward_Merchant:CustomFunction()if self.PlayerID>1 and self.PlayerID<9 then local ap=Logic.GetStoreHouse(self.PlayerID)Logic.RemoveAllOffers(ap)for a=1,4 do if self["Offer"..a]and self["Offer"..a]~="-"then if Goods[self["Offer"..a]]then AddOffer(ap,self["AmountOffer"..a],Goods[self["Offer"..a]])elseif Logic.IsEntityTypeInCategory(Entities[self["Offer"..a]],EntityCategories.Military)==1 then AddMercenaryOffer(ap,self["AmountOffer"..a],Entities[self["Offer"..a]])else AddEntertainerOffer(ap,Entities[self["Offer"..a]])end end end end end;function B_Reward_Merchant:Debug(l)if Logic.GetStoreHouse(self.PlayerID)==0 then debug(false,l.Identifier..": "..self.Name..": Player "..self.PlayerID.." is dead. :-(")return true end end;function B_Reward_Merchant:GetCustomData(m)local aq={1,2,3,4,5,6,7,8}local ar={"1","2","3","4","5","6","7","8","9"}local as={"-","G_Beer","G_Bow","G_Bread","G_Broom","G_Candle","G_Carcass","G_Cheese","G_Clothes","G_Cow","G_Grain","G_Herb","G_Honeycomb","G_Iron","G_Leather","G_Medicine","G_Milk","G_RawFish","G_Sausage","G_Sheep","G_SmokedFish","G_Soap","G_Stone","G_Sword","G_Wood","G_Wool","G_Salt","G_Dye","U_AmmunitionCart","U_BatteringRamCart","U_CatapultCart","U_SiegeTowerCart","U_MilitaryBandit_Melee_ME","U_MilitaryBandit_Melee_SE","U_MilitaryBandit_Melee_NA","U_MilitaryBandit_Melee_NE","U_MilitaryBandit_Ranged_ME","U_MilitaryBandit_Ranged_NA","U_MilitaryBandit_Ranged_NE","U_MilitaryBandit_Ranged_SE","U_MilitaryBow_RedPrince","U_MilitaryBow","U_MilitarySword_RedPrince","U_MilitarySword","U_Entertainer_NA_FireEater","U_Entertainer_NA_StiltWalker","U_Entertainer_NE_StrongestMan_Barrel","U_Entertainer_NE_StrongestMan_Stone"}if g_GameExtraNo and g_GameExtraNo>=1 then table.insert(as,"G_Gems")table.insert(as,"G_Olibanum")table.insert(as,"G_MusicalInstrument")table.insert(as,"G_MilitaryBandit_Ranged_AS")table.insert(as,"G_MilitaryBandit_Melee_AS")table.insert(as,"U_MilitarySword_Khana")table.insert(as,"U_MilitaryBow_Khana")end;if m==0 then return aq elseif m==1 or m==3 or m==5 or m==7 then return ar elseif m==2 or m==4 or m==6 or m==8 then return as end end;RegisterBehavior(B_Reward_Merchant)function Reward_DestroyEntity(...)return B_Reward_DestroyEntity:new(...)end;B_Reward_DestroyEntity=CopyTable(B_Reprisal_DestroyEntity)B_Reward_DestroyEntity.Name="Reward_DestroyEntity"B_Reward_DestroyEntity.Description.en="Reward: Replaces an entity with an invisible script entity, which retains the entities name."B_Reward_DestroyEntity.Description.de="Lohn: Ersetzt eine Entity mit einer unsichtbaren Script-Entity, die den Namen übernimmt."B_Reward_DestroyEntity.Description.fr="Récompense: Remplace une entité par une entité de script invisible qui prend le nom."B_Reward_DestroyEntity.GetReprisalTable=nil;B_Reward_DestroyEntity.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_DestroyEntity)function Reward_DestroyEffect(...)return B_Reward_DestroyEffect:new(...)end;B_Reward_DestroyEffect=CopyTable(B_Reprisal_DestroyEffect)B_Reward_DestroyEffect.Name="Reward_DestroyEffect"B_Reward_DestroyEffect.Description.en="Reward: Destroys an effect."B_Reward_DestroyEffect.Description.de="Lohn: Zerstört einen Effekt."B_Reward_DestroyEffect.Description.fr="Récompense: Détruit un effet."B_Reward_DestroyEffect.GetReprisalTable=nil;B_Reward_DestroyEffect.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_DestroyEffect)function Reward_CreateBattalion(...)return B_Reward_CreateBattalion:new(...)end;B_Reward_CreateBattalion={Name="Reward_CreateBattalion",Description={en="Reward: Replaces a script entity with a battalion, which retains the entities name",de="Lohn: Ersetzt eine Script-Entity durch ein Bataillon, welches den Namen der Script-Entity übernimmt",fr="Récompense: Remplace une entité de script par un bataillon qui prend le nom de l'entité de script."},Parameter={{ParameterType.ScriptName,en="Script entity",de="Script Entity",fr="Entité de script"},{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.Custom,en="Type name",de="Typbezeichnung",fr="Désignation du type"},{ParameterType.Number,en="Orientation (in degrees)",de="Ausrichtung (in Grad)",fr="Orientation (en degrés)"},{ParameterType.Number,en="Number of soldiers",de="Anzahl Soldaten",fr="Nombre de Soldats"},{ParameterType.Custom,en="Hide from AI",de="Vor KI verstecken",fr="Cacher de l'IA"}}}function B_Reward_CreateBattalion:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_CreateBattalion:AddParameter(m,n)if m==0 then self.ScriptNameEntity=n elseif m==1 then self.PlayerID=n*1 elseif m==2 then self.UnitKey=n elseif m==3 then self.Orientation=n*1 elseif m==4 then self.SoldierCount=n*1 elseif m==5 then self.HideFromAI=ToBoolean(n)end end;function B_Reward_CreateBattalion:CustomFunction(l)if not IsExisting(self.ScriptNameEntity)then return false end;local at=GetPosition(self.ScriptNameEntity)local au=Logic.CreateBattalionOnUnblockedLand(Entities[self.UnitKey],at.X,at.Y,self.Orientation,self.PlayerID,self.SoldierCount)local av=GetID(self.ScriptNameEntity)if Logic.IsBuilding(av)==0 then DestroyEntity(self.ScriptNameEntity)Logic.SetEntityName(au,self.ScriptNameEntity)end;if self.HideFromAI then AICore.HideEntityFromAI(self.PlayerID,au,true)end end;function B_Reward_CreateBattalion:GetCustomData(m)local p={}if m==2 then for q,r in pairs(Entities)do if Logic.IsEntityTypeInCategory(r,EntityCategories.Soldier)==1 then table.insert(p,q)end end;table.sort(p)elseif m==5 then table.insert(p,"false")table.insert(p,"true")else assert(false)end;return p end;function B_Reward_CreateBattalion:Debug(l)if not Entities[self.UnitKey]then debug(false,l.Identifier..": "..self.Name..": got an invalid entity type!")return true elseif not IsExisting(self.ScriptNameEntity)then debug(false,l.Identifier..": "..self.Name..": spawnpoint does not exist!")return true elseif tonumber(self.PlayerID)==nil or self.PlayerID<1 or self.PlayerID>8 then debug(false,l.Identifier..": "..self.Name..": playerID is wrong!")return true elseif tonumber(self.Orientation)==nil then debug(false,l.Identifier..": "..self.Name..": orientation must be a number!")return true elseif tonumber(self.SoldierCount)==nil or self.SoldierCount<1 then debug(false,l.Identifier..": "..self.Name..": you can not create a empty batallion!")return true end;return false end;RegisterBehavior(B_Reward_CreateBattalion)function Reward_CreateSeveralBattalions(...)return B_Reward_CreateSeveralBattalions:new(...)end;B_Reward_CreateSeveralBattalions={Name="Reward_CreateSeveralBattalions",Description={en="Reward: Creates a given amount of battalions",de="Lohn: Erstellt eine gegebene Anzahl Bataillone",fr="Récompense: Crée un nombre donné de bataillons"},Parameter={{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"},{ParameterType.ScriptName,en="Script entity",de="Script Entity",fr="Quentité de Script"},{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.Custom,en="Type name",de="Typbezeichnung",fr="Désignation de type"},{ParameterType.Number,en="Orientation (in degrees)",de="Ausrichtung (in Grad)",fr="Orientation (en degrés)"},{ParameterType.Number,en="Number of soldiers",de="Anzahl Soldaten",fr="Nombre de soldats"},{ParameterType.Custom,en="Hide from AI",de="Vor KI verstecken",fr="Cacher de l'AI"}}}function B_Reward_CreateSeveralBattalions:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_CreateSeveralBattalions:AddParameter(m,n)if m==0 then self.Amount=n*1 elseif m==1 then self.ScriptNameEntity=n elseif m==2 then self.PlayerID=n*1 elseif m==3 then self.UnitKey=n elseif m==4 then self.Orientation=n*1 elseif m==5 then self.SoldierCount=n*1 elseif m==6 then self.HideFromAI=ToBoolean(n)end end;function B_Reward_CreateSeveralBattalions:CustomFunction(l)if not IsExisting(self.ScriptNameEntity)then return false end;local aw=GetID(self.ScriptNameEntity)local O,P,Q=Logic.EntityGetPos(aw)if Logic.IsBuilding(aw)==1 then O,P=Logic.GetBuildingApproachPosition(aw)end;for a=1,self.Amount do local au=Logic.CreateBattalionOnUnblockedLand(Entities[self.UnitKey],O,P,self.Orientation,self.PlayerID,self.SoldierCount)Logic.SetEntityName(au,self.ScriptNameEntity.."_"..a)if self.HideFromAI then AICore.HideEntityFromAI(self.PlayerID,au,true)end end end;function B_Reward_CreateSeveralBattalions:GetCustomData(m)local p={}if m==3 then for q,r in pairs(Entities)do if Logic.IsEntityTypeInCategory(r,EntityCategories.Soldier)==1 then table.insert(p,q)end end;table.sort(p)elseif m==6 then table.insert(p,"false")table.insert(p,"true")else assert(false)end;return p end;function B_Reward_CreateSeveralBattalions:Debug(l)if not Entities[self.UnitKey]then debug(false,l.Identifier..": "..self.Name..": got an invalid entity type!")return true elseif not IsExisting(self.ScriptNameEntity)then debug(false,l.Identifier..": "..self.Name..": spawnpoint does not exist!")return true elseif tonumber(self.PlayerID)==nil or self.PlayerID<1 or self.PlayerID>8 then debug(false,l.Identifier..": "..self.Name..": playerDI is wrong!")return true elseif tonumber(self.Orientation)==nil then debug(false,l.Identifier..": "..self.Name..": orientation must be a number!")return true elseif tonumber(self.SoldierCount)==nil or self.SoldierCount<1 then debug(false,l.Identifier..": "..self.Name..": you can not create a empty batallion!")return true elseif tonumber(self.Amount)==nil or self.Amount<0 then debug(false,l.Identifier..": "..self.Name..": amount can not be negative!")return true end;return false end;RegisterBehavior(B_Reward_CreateSeveralBattalions)function Reward_CreateEffect(...)return B_Reward_CreateEffect:new(...)end;B_Reward_CreateEffect={Name="Reward_CreateEffect",Description={en="Reward: Creates an effect at a specified position",de="Lohn: Erstellt einen Effekt an der angegebenen Position",fr="Récompense: Crée un effet à la position indiquée"},Parameter={{ParameterType.Default,en="Effect name",de="Effektname",fr="Nom de l'effet"},{ParameterType.Custom,en="Type name",de="Typbezeichnung",fr="Designation de type"},{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.ScriptName,en="Location",de="Ort",fr="Lieu"},{ParameterType.Number,en="Orientation (in degrees)(-1: from locating entity)",de="Ausrichtung (in Grad)(-1: von Positionseinheit)",fr="Orientation (en degrés)(-1 : de l'unité de position)"}}}function B_Reward_CreateEffect:AddParameter(m,n)if m==0 then self.EffectName=n elseif m==1 then self.Type=EGL_Effects[n]elseif m==2 then self.PlayerID=n*1 elseif m==3 then self.Location=n elseif m==4 then self.Orientation=n*1 end end;function B_Reward_CreateEffect:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_CreateEffect:CustomFunction(l)if Logic.IsEntityDestroyed(self.Location)then return end;local ax=assert(GetID(self.Location),l.Identifier.."Error in "..self.Name..": CustomFunction: Entity is invalid")if CONST_EFFECT_NAME_TO_ID[self.EffectName]and Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName])then return end;local ay,az=Logic.GetEntityPosition(ax)local aA=tonumber(self.Orientation)local aB=Logic.CreateEffectWithOrientation(self.Type,ay,az,aA,self.PlayerID)if self.EffectName~=""then CONST_EFFECT_NAME_TO_ID[self.EffectName]=aB end end;function B_Reward_CreateEffect:Debug(l)if CONST_EFFECT_NAME_TO_ID[self.EffectName]and Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName])then debug(false,l.Identifier..": "..self.Name..": effect already exists!")return true elseif not IsExisting(self.Location)then debug(false,l.Identifier..": "..self.Name..": location '"..self.Location.."' is missing!")return true elseif self.PlayerID and(self.PlayerID<0 or self.PlayerID>8)then debug(false,l.Identifier..": "..self.Name..": invalid playerID!")return true elseif tonumber(self.Orientation)==nil then debug(false,l.Identifier..": "..self.Name..": invalid orientation!")return true end end;function B_Reward_CreateEffect:GetCustomData(m)assert(m==1,"Error in "..self.Name..": GetCustomData: Index is invalid.")local aC={}for q,r in pairs(EGL_Effects)do table.insert(aC,q)end;table.sort(aC)return aC end;RegisterBehavior(B_Reward_CreateEffect)function Reward_CreateEntity(...)return B_Reward_CreateEntity:new(...)end;B_Reward_CreateEntity={Name="Reward_CreateEntity",Description={en="Reward: Replaces an entity by a new one of a given type",de="Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs",fr="Récompense: Remplace une entité par une nouvelle entité de type donné"},Parameter={{ParameterType.ScriptName,en="Script entity",de="Script Entity",fr="Entité de script"},{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.Custom,en="Type name",de="Typbezeichnung",fr="Désignation de type"},{ParameterType.Number,en="Orientation (in degrees)",de="Ausrichtung (in Grad)",fr="Orientation (en degrés)"},{ParameterType.Custom,en="Hide from AI",de="Vor KI verstecken",fr="Cacher de l'AI"}}}function B_Reward_CreateEntity:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_CreateEntity:AddParameter(m,n)if m==0 then self.ScriptNameEntity=n elseif m==1 then self.PlayerID=n*1 elseif m==2 then self.UnitKey=n elseif m==3 then self.Orientation=n*1 elseif m==4 then self.HideFromAI=ToBoolean(n)end end;function B_Reward_CreateEntity:CustomFunction(l)if not IsExisting(self.ScriptNameEntity)then return false end;local at=GetPosition(self.ScriptNameEntity)local au;if Logic.IsEntityTypeInCategory(self.UnitKey,EntityCategories.Soldier)==1 then au=Logic.CreateBattalionOnUnblockedLand(Entities[self.UnitKey],at.X,at.Y,self.Orientation,self.PlayerID,1)local aD,aE=Logic.GetSoldiersAttachedToLeader(au)Logic.SetOrientation(aE,math.floor(self.Orientation+0.5))else au=Logic.CreateEntityOnUnblockedLand(Entities[self.UnitKey],at.X,at.Y,self.Orientation,self.PlayerID)end;local av=GetID(self.ScriptNameEntity)if Logic.IsBuilding(av)==0 then DestroyEntity(self.ScriptNameEntity)Logic.SetEntityName(au,self.ScriptNameEntity)end;if self.HideFromAI then AICore.HideEntityFromAI(self.PlayerID,au,true)end end;function B_Reward_CreateEntity:GetCustomData(m)local p={}if m==2 then for q,r in pairs(Entities)do local ai={"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}local aj=false;for a=1,#ai do if q:find(ai[a])then aj=true;break end end;if not aj then table.insert(p,q)end end;table.sort(p)elseif m==4 or m==5 then table.insert(p,"false")table.insert(p,"true")else assert(false)end;return p end;function B_Reward_CreateEntity:Debug(l)if not Entities[self.UnitKey]then debug(false,l.Identifier..": "..self.Name..": got an invalid entity type!")return true elseif not IsExisting(self.ScriptNameEntity)then debug(false,l.Identifier..": "..self.Name..": spawnpoint does not exist!")return true elseif tonumber(self.PlayerID)==nil or self.PlayerID<0 or self.PlayerID>8 then debug(false,l.Identifier..": "..self.Name..": playerID is not valid!")return true elseif tonumber(self.Orientation)==nil then debug(false,l.Identifier..": "..self.Name..": orientation must be a number!")return true end;return false end;RegisterBehavior(B_Reward_CreateEntity)B_Reward_CreateSettler=CopyTable(B_Reward_CreateEntity)B_Reward_CreateSettler.Name="Reward_CreateSettler"B_Reward_CreateSettler.Description.en="Reward: Replaces an entity by a new one of a given type"B_Reward_CreateSettler.Description.de="Lohn: Ersetzt eine Entity durch eine neue gegebenen Typs"B_Reward_CreateSettler.Description.fr="Récompense: Remplace une entité par une nouvelle entité de type donné"RegisterBehavior(B_Reward_CreateSettler)function Reward_CreateSeveralEntities(...)return B_Reward_CreateSeveralEntities:new(...)end;B_Reward_CreateSeveralEntities={Name="Reward_CreateSeveralEntities",Description={en="Reward: Creating serveral battalions at the position of a entity. They retains the entities name and a _[index] suffix",de="Lohn: Erzeugt mehrere Entities an der Position der Entity. Sie übernimmt den Namen der Script Entity und den Suffix _[index]",fr="Récompense: Crée plusieurs Entities à la position de l'Entity. Elle reprend le nom de l'entité script et le suffixe _[index]."},Parameter={{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"},{ParameterType.ScriptName,en="Script entity",de="Script Entity",fr="Entité de script"},{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.Custom,en="Type name",de="Typbezeichnung",fr="Designation de type"},{ParameterType.Number,en="Orientation (in degrees)",de="Ausrichtung (in Grad)",fr="Orientation (en degrés)"},{ParameterType.Custom,en="Hide from AI",de="Vor KI verstecken",fr="Cacher de l'AI"}}}function B_Reward_CreateSeveralEntities:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_CreateSeveralEntities:AddParameter(m,n)if m==0 then self.Amount=n*1 elseif m==1 then self.ScriptNameEntity=n elseif m==2 then self.PlayerID=n*1 elseif m==3 then self.UnitKey=n elseif m==4 then self.Orientation=n*1 elseif m==5 then self.HideFromAI=ToBoolean(n)end end;function B_Reward_CreateSeveralEntities:CustomFunction(l)if not IsExisting(self.ScriptNameEntity)then return false end;local at=GetPosition(self.ScriptNameEntity)local au;for a=1,self.Amount do if Logic.IsEntityTypeInCategory(self.UnitKey,EntityCategories.Soldier)==1 then au=Logic.CreateBattalionOnUnblockedLand(Entities[self.UnitKey],at.X,at.Y,self.Orientation,self.PlayerID,1)local aD,aE=Logic.GetSoldiersAttachedToLeader(au)Logic.SetOrientation(aE,math.floor(self.Orientation+0.5))else au=Logic.CreateEntityOnUnblockedLand(Entities[self.UnitKey],at.X,at.Y,self.Orientation,self.PlayerID)end;Logic.SetEntityName(au,self.ScriptNameEntity.."_"..a)if self.HideFromAI then AICore.HideEntityFromAI(self.PlayerID,au,true)end end end;function B_Reward_CreateSeveralEntities:GetCustomData(m)local p={}if m==3 then for q,r in pairs(Entities)do local ai={"^M_*","^XS_*","^X_*","^XT_*","^Z_*"}local aj=false;for a=1,#ai do if q:find(ai[a])then aj=true;break end end;if not aj then table.insert(p,q)end end;table.sort(p)elseif m==5 or m==6 then table.insert(p,"false")table.insert(p,"true")else assert(false)end;return p end;function B_Reward_CreateSeveralEntities:Debug(l)if not Entities[self.UnitKey]then debug(false,l.Identifier..": "..self.Name..": got an invalid entity type!")return true elseif not IsExisting(self.ScriptNameEntity)then debug(false,l.Identifier..": "..self.Name..": spawnpoint does not exist!")return true elseif tonumber(self.PlayerID)==nil or self.PlayerID<1 or self.PlayerID>8 then debug(false,l.Identifier..": "..self.Name..": spawnpoint does not exist!")return true elseif tonumber(self.Orientation)==nil then debug(false,l.Identifier..": "..self.Name..": orientation must be a number!")return true elseif tonumber(self.Amount)==nil or self.Amount<0 then debug(false,l.Identifier..": "..self.Name..": amount can not be negative!")return true end;return false end;RegisterBehavior(B_Reward_CreateSeveralEntities)function Reward_MoveSettler(...)return B_Reward_MoveSettler:new(...)end;B_Reward_MoveSettler={Name="Reward_MoveSettler",Description={en="Reward: Moves a (NPC) settler to a destination. Must not be AI controlled, or it won't move",de="Lohn: Bewegt einen (NPC) Siedler zu einem Zielort. Darf keinem KI Spieler gehören, ansonsten wird sich der Siedler nicht bewegen",fr="Récompense: Déplace un settler (NPC) vers une destination. Ne doit pas appartenir à un joueur IA, sinon le settler ne se déplacera pas."},Parameter={{ParameterType.ScriptName,en="Settler",de="Siedler",fr="Settler"},{ParameterType.ScriptName,en="Destination",de="Ziel",fr="Destination"}}}function B_Reward_MoveSettler:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_MoveSettler:AddParameter(m,n)if m==0 then self.ScriptNameUnit=n elseif m==1 then self.ScriptNameDest=n end end;function B_Reward_MoveSettler:CustomFunction(l)if Logic.IsEntityDestroyed(self.ScriptNameUnit)or Logic.IsEntityDestroyed(self.ScriptNameDest)then return false end;local aF=GetID(self.ScriptNameDest)local aG,aH=Logic.GetEntityPosition(aF)if Logic.IsBuilding(aF)==1 then aG,aH=Logic.GetBuildingApproachPosition(aF)end;Logic.MoveSettler(GetID(self.ScriptNameUnit),aG,aH)end;function B_Reward_MoveSettler:Debug(l)if not IsExisting(self.ScriptNameUnit)then debug(false,l.Identifier..": "..self.Name..": mover entity does not exist!")return true elseif not IsExisting(self.ScriptNameDest)then debug(false,l.Identifier..": "..self.Name..": destination does not exist!")return true end;return false end;RegisterBehavior(B_Reward_MoveSettler)function Reward_Victory()return B_Reward_Victory:new()end;B_Reward_Victory={Name="Reward_Victory",Description={en="Reward: The player wins the game.",de="Lohn: Der Spieler gewinnt das Spiel.",fr="Récompense: Le Joueur gagne la partie."}}function B_Reward_Victory:GetRewardTable()return{Reward.Victory}end;RegisterBehavior(B_Reward_Victory)function Reward_Defeat()return B_Reward_Defeat:new()end;B_Reward_Defeat={Name="Reward_Defeat",Description={en="Reward: The player loses the game.",de="Lohn: Der Spieler verliert das Spiel.",fr="Récompense: le Joueur perd la partie."}}function B_Reward_Defeat:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_Defeat:CustomFunction(l)l:TerminateEventsAndStuff()Logic.ExecuteInLuaLocalState("GUI_Window.MissionEndScreenSetVictoryReasonText("..g_VictoryAndDefeatType.DefeatMissionFailed..")")Defeated(l.ReceivingPlayer)end;RegisterBehavior(B_Reward_Defeat)function Reward_FakeVictory()return B_Reward_FakeVictory:new()end;B_Reward_FakeVictory={Name="Reward_FakeVictory",Description={en="Reward: Display a victory icon for a quest",de="Lohn: Zeigt ein Siegesicon fuer diese Quest",fr="Récompense: Affiche une icône de victoire pour cette quête"}}function B_Reward_FakeVictory:GetRewardTable()return{Reward.FakeVictory}end;RegisterBehavior(B_Reward_FakeVictory)function Reward_AI_SpawnAndAttackTerritory(...)return B_Reward_AI_SpawnAndAttackTerritory:new(...)end;B_Reward_AI_SpawnAndAttackTerritory={Name="Reward_AI_SpawnAndAttackTerritory",Description={en="Reward: Spawns AI troops and attacks a territory (Hint: Use for hidden quests as a surprise)",de="Lohn: Erstellt KI Truppen und greift ein Territorium an (Tipp: Fuer eine versteckte Quest als Ueberraschung verwenden)",fr="Récompense: Créez des troupes d'IA et attaquez un territoire (astuce : utilisez une surprise pour une quête cachée)."},Parameter={{ParameterType.PlayerID,en="AI Player",de="KI Spieler",fr="Joueur AI"},{ParameterType.ScriptName,en="Spawn point",de="Erstellungsort",fr="Lieu de création"},{ParameterType.TerritoryName,en="Territory",de="Territorium",fr="Territoire"},{ParameterType.Number,en="Sword",de="Schwert",fr="Épéiste"},{ParameterType.Number,en="Bow",de="Bogen",fr="Archer"},{ParameterType.Number,en="Catapults",de="Katapulte",fr="Catapultes"},{ParameterType.Number,en="Siege towers",de="Belagerungstuerme",fr="Tours de siège"},{ParameterType.Number,en="Rams",de="Rammen",fr="Bélier"},{ParameterType.Number,en="Ammo carts",de="Munitionswagen",fr="Chariot à munitions"},{ParameterType.Custom,en="Soldier type",de="Soldatentyp",fr="Type de soldat"},{ParameterType.Custom,en="Reuse troops",de="Verwende bestehende Truppen",fr="Utiliser les troupes existantes"}}}function B_Reward_AI_SpawnAndAttackTerritory:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_AI_SpawnAndAttackTerritory:AddParameter(m,n)if m==0 then self.AIPlayerID=n*1 elseif m==1 then self.Spawnpoint=n elseif m==2 then self.TerritoryID=tonumber(n)if not self.TerritoryID then self.TerritoryID=GetTerritoryIDByName(n)end elseif m==3 then self.NumSword=n*1 elseif m==4 then self.NumBow=n*1 elseif m==5 then self.NumCatapults=n*1 elseif m==6 then self.NumSiegeTowers=n*1 elseif m==7 then self.NumRams=n*1 elseif m==8 then self.NumAmmoCarts=n*1 elseif m==9 then if n=="Normal"or n==false then self.TroopType=false elseif n=="RedPrince"or n==true then self.TroopType=true elseif n=="Bandit"or n==2 then self.TroopType=2 elseif n=="Cultist"or n==3 then self.TroopType=3 else assert(false)end elseif m==10 then self.ReuseTroops=ToBoolean(n)end end;function B_Reward_AI_SpawnAndAttackTerritory:GetCustomData(m)local p={}if m==9 then table.insert(p,"Normal")table.insert(p,"RedPrince")table.insert(p,"Bandit")if g_GameExtraNo>=1 then table.insert(p,"Cultist")end elseif m==10 then table.insert(p,"false")table.insert(p,"true")else assert(false)end;return p end;function B_Reward_AI_SpawnAndAttackTerritory:CustomFunction(l)local aI=Logic.GetTerritoryAcquiringBuildingID(self.TerritoryID)if aI~=0 then AIScript_SpawnAndAttackCity(self.AIPlayerID,aI,self.Spawnpoint,self.NumSword,self.NumBow,self.NumCatapults,self.NumSiegeTowers,self.NumRams,self.NumAmmoCarts,self.TroopType,self.ReuseTroops)end end;function B_Reward_AI_SpawnAndAttackTerritory:Debug(l)if self.AIPlayerID<2 then debug(false,l.Identifier..": "..self.Name..": Player "..self.AIPlayerID.." is wrong")return true elseif Logic.IsEntityDestroyed(self.Spawnpoint)then debug(false,l.Identifier..": "..self.Name..": Entity "..self.SpawnPoint.." is missing")return true elseif self.TerritoryID==0 then debug(false,l.Identifier..": "..self.Name..": Territory unknown")return true elseif self.NumSword<0 then debug(false,l.Identifier..": "..self.Name..": Number of Swords is negative")return true elseif self.NumBow<0 then debug(false,l.Identifier..": "..self.Name..": Number of Bows is negative")return true elseif self.NumBow+self.NumSword<1 then debug(false,l.Identifier..": "..self.Name..": No Soldiers?")return true elseif self.NumCatapults<0 then debug(false,l.Identifier..": "..self.Name..": Catapults is negative")return true elseif self.NumSiegeTowers<0 then debug(false,l.Identifier..": "..self.Name..": SiegeTowers is negative")return true elseif self.NumRams<0 then debug(false,l.Identifier..": "..self.Name..": Rams is negative")return true elseif self.NumAmmoCarts<0 then debug(false,l.Identifier..": "..self.Name..": AmmoCarts is negative")return true end;return false end;RegisterBehavior(B_Reward_AI_SpawnAndAttackTerritory)function Reward_AI_SpawnAndAttackArea(...)return B_Reward_AI_SpawnAndAttackArea:new(...)end;B_Reward_AI_SpawnAndAttackArea={Name="Reward_AI_SpawnAndAttackArea",Description={en="Reward: Spawns AI troops and attacks everything within the specified area, except the players main buildings",de="Lohn: Erstellt KI Truppen und greift ein angegebenes Gebiet an, aber nicht die Hauptgebauede eines Spielers",fr="Récompense: Crée des troupes IA et attaque une zone spécifiée, mais pas les bâtiments principaux d'un joueur."},Parameter={{ParameterType.PlayerID,en="AI Player",de="KI Spieler",fr="Joueur AI"},{ParameterType.ScriptName,en="Spawn point",de="Erstellungsort",fr="Lieu de création"},{ParameterType.ScriptName,en="Target",de="Ziel",fr="Cible"},{ParameterType.Number,en="Radius",de="Radius",fr="Rayon"},{ParameterType.Number,en="Sword",de="Schwert",fr="Épéiste"},{ParameterType.Number,en="Bow",de="Bogen",fr="Archer"},{ParameterType.Custom,en="Soldier type",de="Soldatentyp",fr="Type de soldats"},{ParameterType.Custom,en="Reuse troops",de="Verwende bestehende Truppen",fr="Utiliser des troupes existantes"}}}function B_Reward_AI_SpawnAndAttackArea:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_AI_SpawnAndAttackArea:AddParameter(m,n)if m==0 then self.AIPlayerID=n*1 elseif m==1 then self.Spawnpoint=n elseif m==2 then self.TargetName=n elseif m==3 then self.Radius=n*1 elseif m==4 then self.NumSword=n*1 elseif m==5 then self.NumBow=n*1 elseif m==6 then if n=="Normal"or n==false then self.TroopType=false elseif n=="RedPrince"or n==true then self.TroopType=true elseif n=="Bandit"or n==2 then self.TroopType=2 elseif n=="Cultist"or n==3 then self.TroopType=3 else assert(false)end elseif m==7 then self.ReuseTroops=ToBoolean(n)end end;function B_Reward_AI_SpawnAndAttackArea:GetCustomData(m)local p={}if m==6 then table.insert(p,"Normal")table.insert(p,"RedPrince")table.insert(p,"Bandit")if g_GameExtraNo>=1 then table.insert(p,"Cultist")end elseif m==7 then table.insert(p,"false")table.insert(p,"true")else assert(false)end;return p end;function B_Reward_AI_SpawnAndAttackArea:CustomFunction(l)if Logic.IsEntityAlive(self.TargetName)and Logic.IsEntityAlive(self.Spawnpoint)then local aI=GetID(self.TargetName)AIScript_SpawnAndRaidSettlement(self.AIPlayerID,aI,self.Spawnpoint,self.Radius,self.NumSword,self.NumBow,self.TroopType,self.ReuseTroops)end end;function B_Reward_AI_SpawnAndAttackArea:Debug(l)if self.AIPlayerID<2 then debug(false,l.Identifier..": "..self.Name..": Player "..self.AIPlayerID.." is wrong")return true elseif Logic.IsEntityDestroyed(self.Spawnpoint)then debug(false,l.Identifier..": "..self.Name..": Entity "..self.SpawnPoint.." is missing")return true elseif Logic.IsEntityDestroyed(self.TargetName)then debug(false,l.Identifier..": "..self.Name..": Entity "..self.TargetName.." is missing")return true elseif self.Radius<1 then debug(false,l.Identifier..": "..self.Name..": Radius is to small or negative")return true elseif self.NumSword<0 then debug(false,l.Identifier..": "..self.Name..": Number of Swords is negative")return true elseif self.NumBow<0 then debug(false,l.Identifier..": "..self.Name..": Number of Bows is negative")return true elseif self.NumBow+self.NumSword<1 then debug(false,l.Identifier..": "..self.Name..": No Soldiers?")return true end;return false end;RegisterBehavior(B_Reward_AI_SpawnAndAttackArea)function Reward_AI_SpawnAndProtectArea(...)return B_Reward_AI_SpawnAndProtectArea:new(...)end;B_Reward_AI_SpawnAndProtectArea={Name="Reward_AI_SpawnAndProtectArea",Description={en="Reward: Spawns AI troops and defends a specified area",de="Lohn: Erstellt KI Truppen und verteidigt ein angegebenes Gebiet",fr="Récompense: Crée des troupes d'IA et défend un territoire donné"},Parameter={{ParameterType.PlayerID,en="AI Player",de="KI Spieler",fr="Joueur AI"},{ParameterType.ScriptName,en="Spawn point",de="Erstellungsort",fr="Lieu de création"},{ParameterType.ScriptName,en="Target",de="Ziel",fr="Cible"},{ParameterType.Number,en="Radius",de="Radius",fr="Rayon"},{ParameterType.Number,en="Time (-1 for infinite)",de="Zeit (-1 fuer unendlich)",fr="Temps (-1 pour infini)"},{ParameterType.Number,en="Sword",de="Schwert",fr="Épéiste"},{ParameterType.Number,en="Bow",de="Bogen",fr="Archer"},{ParameterType.Custom,en="Capture tradecarts",de="Handelskarren angreifen",fr="Attaquer les chariots de commerce"},{ParameterType.Custom,en="Soldier type",de="Soldatentyp",fr="Type de soldat"},{ParameterType.Custom,en="Reuse troops",de="Verwende bestehende Truppen",fr="Utiliser les troupes existantes"}}}function B_Reward_AI_SpawnAndProtectArea:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_AI_SpawnAndProtectArea:AddParameter(m,n)if m==0 then self.AIPlayerID=n*1 elseif m==1 then self.Spawnpoint=n elseif m==2 then self.TargetName=n elseif m==3 then self.Radius=n*1 elseif m==4 then self.Time=n*1 elseif m==5 then self.NumSword=n*1 elseif m==6 then self.NumBow=n*1 elseif m==7 then self.CaptureTradeCarts=ToBoolean(n)elseif m==8 then if n=="Normal"or n==true then self.TroopType=false elseif n=="RedPrince"or n==false then self.TroopType=true elseif n=="Bandit"or n==2 then self.TroopType=2 elseif n=="Cultist"or n==3 then self.TroopType=3 else assert(false)end elseif m==9 then self.ReuseTroops=ToBoolean(n)end end;function B_Reward_AI_SpawnAndProtectArea:GetCustomData(m)local p={}if m==7 then table.insert(p,"false")table.insert(p,"true")elseif m==8 then table.insert(p,"Normal")table.insert(p,"RedPrince")table.insert(p,"Bandit")if g_GameExtraNo>=1 then table.insert(p,"Cultist")end elseif m==9 then table.insert(p,"false")table.insert(p,"true")else assert(false)end;return p end;function B_Reward_AI_SpawnAndProtectArea:CustomFunction(l)if Logic.IsEntityAlive(self.TargetName)and Logic.IsEntityAlive(self.Spawnpoint)then local aI=GetID(self.TargetName)AIScript_SpawnAndProtectArea(self.AIPlayerID,aI,self.Spawnpoint,self.Radius,self.NumSword,self.NumBow,self.Time,self.TroopType,self.ReuseTroops,self.CaptureTradeCarts)end end;function B_Reward_AI_SpawnAndProtectArea:Debug(l)if self.AIPlayerID<2 then debug(false,l.Identifier..": "..self.Name..": Player "..self.AIPlayerID.." is wrong")return true elseif Logic.IsEntityDestroyed(self.Spawnpoint)then debug(false,l.Identifier..": "..self.Name..": Entity "..self.SpawnPoint.." is missing")return true elseif Logic.IsEntityDestroyed(self.TargetName)then debug(false,l.Identifier..": "..self.Name..": Entity "..self.TargetName.." is missing")return true elseif self.Radius<1 then debug(false,l.Identifier..": "..self.Name..": Radius is to small or negative")return true elseif self.Time<-1 then debug(false,l.Identifier..": "..self.Name..": Time is smaller than -1")return true elseif self.NumSword<0 then debug(false,l.Identifier..": "..self.Name..": Number of Swords is negative")return true elseif self.NumBow<0 then debug(false,l.Identifier..": "..self.Name..": Number of Bows is negative")return true elseif self.NumBow+self.NumSword<1 then debug(false,l.Identifier..": "..self.Name..": No Soldiers?")return true end;return false end;RegisterBehavior(B_Reward_AI_SpawnAndProtectArea)function Reward_AI_SetNumericalFact(...)return B_Reward_AI_SetNumericalFact:new(...)end;B_Reward_AI_SetNumericalFact={Name="Reward_AI_SetNumericalFact",Description={en="Reward: Sets a numerical fact for the AI player",de="Lohn: Setzt eine Verhaltensregel fuer den KI-Spieler. ",fr="Récompense: Définit une règle de comportement pour le joueur IA."},Parameter={{ParameterType.PlayerID,en="AI Player",de="KI Spieler",fr="Joueur AI"},{ParameterType.Custom,en="Numerical Fact",de="Verhaltensregel",fr="Règle de conduite"},{ParameterType.Number,en="Value",de="Wert",fr="Valeur"}}}function B_Reward_AI_SetNumericalFact:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_AI_SetNumericalFact:AddParameter(m,n)if m==0 then self.AIPlayerID=n*1 elseif m==1 then local aJ={["Courage"]="FEAR",["Reconstruction"]="BARB",["Build Order"]="BPMX",["Conquer Outposts"]="FCOP",["Mount Outposts"]="FMOP",["max. Bowmen"]="FMBM",["max. Swordmen"]="FMSM",["max. Rams"]="FMRA",["max. Catapults"]="FMCA",["max. Ammunition Carts"]="FMAC",["max. Siege Towers"]="FMST",["max. Wall Catapults"]="FMBA",["FEAR"]="FEAR",["BARB"]="BARB",["BPMX"]="BPMX",["FCOP"]="FCOP",["FMOP"]="FMOP",["FMBM"]="FMBM",["FMSM"]="FMSM",["FMRA"]="FMRA",["FMCA"]="FMCA",["FMAC"]="FMAC",["FMST"]="FMST",["FMBA"]="FMBA"}self.NumericalFact=aJ[n]elseif m==2 then self.Value=n*1 end end;function B_Reward_AI_SetNumericalFact:CustomFunction(l)if self.NumericalFact~=nil then AICore.SetNumericalFact(self.AIPlayerID,self.NumericalFact,self.Value)end end;function B_Reward_AI_SetNumericalFact:GetCustomData(m)if m==1 then return{"Courage","Reconstruction","Build Order","Conquer Outposts","Mount Outposts","max. Bowmen","max. Swordmen","max. Rams","max. Catapults","max. Ammunition Carts","max. Siege Towers","max. Wall Catapults"}end end;function B_Reward_AI_SetNumericalFact:Debug(l)if Logic.GetStoreHouse(self.AIPlayerID)==0 then debug(false,l.Identifier..": "..self.Name..": Player "..self.AIPlayerID.." is wrong or dead!")return true elseif not self.NumericalFact then debug(false,l.Identifier..": "..self.Name..": invalid numerical fact choosen!")return true else if self.NumericalFact=="BARB"or self.NumericalFact=="FCOP"or self.NumericalFact=="FMOP"then if self.Value~=0 and self.Value~=1 then debug(false,l.Identifier..": "..self.Name..": BARB, FCOP, FMOP: value must be 1 or 0!")return true end elseif self.NumericalFact=="FEAR"then if self.Value<=0 then debug(false,l.Identifier..": "..self.Name..": FEAR: value must greater than 0!")return true end else if self.Value<0 then debug(false,l.Identifier..": "..self.Name..": value must always greater than or equal 0!")return true end end end;return false end;RegisterBehavior(B_Reward_AI_SetNumericalFact)function Reward_AI_Aggressiveness(...)return B_Reward_AI_Aggressiveness:new(...)end;B_Reward_AI_Aggressiveness={Name="Reward_AI_Aggressiveness",Description={en="Reward: Sets the AI player's aggressiveness.",de="Lohn: Setzt die Aggressivität des KI-Spielers fest.",fr="Récompense: Définit l'agressivité du joueur IA."},Parameter={{ParameterType.PlayerID,en="AI player",de="KI-Spieler",fr="Joueur AI"},{ParameterType.Custom,en="Aggressiveness (1-3)",de="Aggressivität (1-3)",fr="Agressivité (1-3)"}}}function B_Reward_AI_Aggressiveness:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_AI_Aggressiveness:AddParameter(m,n)if m==0 then self.AIPlayer=n*1 elseif m==1 then self.Aggressiveness=tonumber(n)end end;function B_Reward_AI_Aggressiveness:CustomFunction()local aK=PlayerAIs[self.AIPlayer]or AIPlayerTable[self.AIPlayer]or AIPlayer:new(self.AIPlayer,AIPlayerProfile_City)assert(aK~=nil)PlayerAIs[self.AIPlayer]=aK;if self.Aggressiveness>=2 then aK.ProfileLoop=AIProfile_Skirmish;aK.Skirmish=aK.Skirmish or{}aK.Skirmish.Claim_MinTime=SkirmishDefault.Claim_MinTime+(self.Aggressiveness-2)*390;aK.Skirmish.Claim_MaxTime=aK.Skirmish.Claim_MinTime*2 else aK.ProfileLoop=AIPlayerProfile_City end end;function B_Reward_AI_Aggressiveness:Debug(l)if self.AIPlayer<1 or Logic.GetStoreHouse(self.AIPlayer)==0 then debug(false,l.Identifier..": "..self.Name..": Player "..self.AIPlayer.." is wrong")return true end end;function B_Reward_AI_Aggressiveness:GetCustomData(m)return{"1","2","3"}end;RegisterBehavior(B_Reward_AI_Aggressiveness)function Reward_AI_SetEnemy(...)return B_Reward_AI_SetEnemy:new(...)end;B_Reward_AI_SetEnemy={Name="Reward_AI_SetEnemy",Description={en="Reward:Sets the enemy of an AI player (the AI only handles one enemy properly).",de="Lohn: Legt den Feind eines KI-Spielers fest (die KI behandelt nur einen Feind korrekt).",fr="Récompense: Définit l'ennemi d'un joueur IA (l'IA ne traite correctement qu'un seul ennemi)."},Parameter={{ParameterType.PlayerID,en="AI player",de="KI-Spieler",fr="Joueur AI"},{ParameterType.PlayerID,en="Enemy",de="Feind",fr="Ennemi"}}}function B_Reward_AI_SetEnemy:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_AI_SetEnemy:AddParameter(m,n)if m==0 then self.AIPlayer=n*1 elseif m==1 then self.Enemy=n*1 end end;function B_Reward_AI_SetEnemy:CustomFunction()local aK=PlayerAIs[self.AIPlayer]if aK and aK.Skirmish then aK.Skirmish.Enemy=self.Enemy end end;function B_Reward_AI_SetEnemy:Debug(l)if self.AIPlayer<1 or self.AIPlayer>8 or Logic.PlayerGetIsHumanFlag(self.AIPlayer)then debug(false,l.Identifier..": "..self.Name..": Player "..self.AIPlayer.." is wrong")return true end;return false end;RegisterBehavior(B_Reward_AI_SetEnemy)function Reward_ReplaceEntity(...)return B_Reward_ReplaceEntity:new(...)end;B_Reward_ReplaceEntity=CopyTable(B_Reprisal_ReplaceEntity)B_Reward_ReplaceEntity.Name="Reward_ReplaceEntity"B_Reward_ReplaceEntity.Description.en="Reward: Replaces an entity with a new one of a different type. The playerID can be changed too."B_Reward_ReplaceEntity.Description.de="Lohn: Ersetzt eine Entity durch eine neue anderen Typs. Es kann auch die Spielerzugehörigkeit geändert werden."B_Reward_ReplaceEntity.Description.fr="Récompense: Remplace une entité par une nouvelle entité d'un autre type. Il est également possible de changer l'appartenance d'un joueur."B_Reward_ReplaceEntity.GetReprisalTable=nil;B_Reward_ReplaceEntity.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_ReplaceEntity)function Reward_SetResourceAmount(...)return B_Reward_SetResourceAmount:new(...)end;B_Reward_SetResourceAmount={Name="Reward_SetResourceAmount",Description={en="Reward: Set the current and maximum amount of a resource doodad (the amount can also set to 0)",de="Lohn: Setzt die aktuellen sowie maximalen Resourcen in einem Doodad (auch 0 ist möglich)",fr="Récompense: Définit les ressources actuelles ainsi que les ressources maximales dans un Doodad (0 est également possible)"},Parameter={{ParameterType.ScriptName,en="Ressource",de="Resource",fr="Ressources"},{ParameterType.Number,en="Amount",de="Menge",fr="Quantité"}}}function B_Reward_SetResourceAmount:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_SetResourceAmount:AddParameter(m,n)if m==0 then self.ScriptName=n elseif m==1 then self.Amount=n*1 end end;function B_Reward_SetResourceAmount:CustomFunction(l)if Logic.IsEntityDestroyed(self.ScriptName)then return false end;local aL=GetID(self.ScriptName)if Logic.GetResourceDoodadGoodType(aL)==0 then return false end;Logic.SetResourceDoodadGoodAmount(aL,self.Amount)end;function B_Reward_SetResourceAmount:Debug(l)if not IsExisting(self.ScriptName)then debug(false,l.Identifier..": "..self.Name..": resource entity does not exist!")return true elseif not type(self.Amount)=="number"or self.Amount<0 then debug(false,l.Identifier..": "..self.Name..": resource amount can not be negative!")return true end;return false end;RegisterBehavior(B_Reward_SetResourceAmount)function Reward_Resources(...)return B_Reward_Resources:new(...)end;B_Reward_Resources={Name="Reward_Resources",Description={en="Reward: The player receives a given amount of Goods in his store.",de="Lohn: Legt der Partei die angegebenen Rohstoffe ins Lagerhaus.",fr="Récompense: Placez les matières premières indiquées dans l'entrepôt de la faction."},Parameter={{ParameterType.RawGoods,en="Type of good",de="Resourcentyp",fr="Type de ressources"},{ParameterType.Number,en="Amount of good",de="Anzahl der Resource",fr="Nombre de ressources"}}}function B_Reward_Resources:AddParameter(m,n)if m==0 then self.GoodTypeName=n elseif m==1 then self.GoodAmount=n*1 end end;function B_Reward_Resources:GetRewardTable()local o=Logic.GetGoodTypeID(self.GoodTypeName)return{Reward.Resources,o,self.GoodAmount}end;RegisterBehavior(B_Reward_Resources)function Reward_SendCart(...)return B_Reward_SendCart:new(...)end;B_Reward_SendCart={Name="Reward_SendCart",Description={en="Reward: Sends a cart to a player. It spawns at a building or by replacing an entity. The cart can replace the entity if it's not a building.",de="Lohn: Sendet einen Karren zu einem Spieler. Der Karren wird an einem Gebäude oder einer Entity erstellt. Er ersetzt die Entity, wenn diese kein Gebäude ist.",fr="Récompense: Envoie un chariot à un joueur. Le chariot est créé sur un bâtiment ou une entité. Elle remplace l'entité si celle-ci n'est pas un bâtiment."},Parameter={{ParameterType.ScriptName,en="Script entity",de="Script Entity",fr="Entité de Script"},{ParameterType.PlayerID,en="Owning player",de="Besitzer",fr="Propriétaire"},{ParameterType.Custom,en="Type name",de="Typbezeichnung",fr="Désignation du type"},{ParameterType.Custom,en="Good type",de="Warentyp",fr="Type de marchandise"},{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"},{ParameterType.Custom,en="Override target player",de="Anderer Zielspieler",fr="Autre joueur destinataire"},{ParameterType.Custom,en="Ignore reservations",de="Ignoriere Reservierungen",fr="Ignorer les réservations"},{ParameterType.Custom,en="Replace entity",de="Entity ersetzen",fr="Remplacer une entité"}}}function B_Reward_SendCart:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_SendCart:AddParameter(m,n)if m==0 then self.ScriptNameEntity=n elseif m==1 then self.PlayerID=n*1 elseif m==2 then self.UnitKey=n elseif m==3 then self.GoodType=n elseif m==4 then self.GoodAmount=n*1 elseif m==5 then self.OverrideTargetPlayer=tonumber(n)elseif m==6 then self.IgnoreReservation=ToBoolean(n)elseif m==7 then self.ReplaceEntity=ToBoolean(n)end end;function B_Reward_SendCart:CustomFunction(l)if not IsExisting(self.ScriptNameEntity)then return false end;local A=SendCart(self.ScriptNameEntity,self.PlayerID,Goods[self.GoodType],self.GoodAmount,Entities[self.UnitKey],self.IgnoreReservation)if self.ReplaceEntity and Logic.IsBuilding(GetID(self.ScriptNameEntity))==0 then DestroyEntity(self.ScriptNameEntity)Logic.SetEntityName(A,self.ScriptNameEntity)end;if self.OverrideTargetPlayer then Logic.ResourceMerchant_OverrideTargetPlayerID(A,self.OverrideTargetPlayer)end end;function B_Reward_SendCart:GetCustomData(m)local p={}if m==2 then p={"U_ResourceMerchant","U_Medicus","U_Marketer","U_ThiefCart","U_GoldCart","U_Noblemen_Cart","U_RegaliaCart"}elseif m==3 then for q,r in pairs(Goods)do if string.find(q,"^G_")then table.insert(p,q)end end;table.sort(p)elseif m==5 then table.insert(p,"-")for a=1,8 do table.insert(p,a)end elseif m==6 then table.insert(p,"false")table.insert(p,"true")elseif m==7 then table.insert(p,"false")table.insert(p,"true")end;return p end;function B_Reward_SendCart:Debug(l)if not IsExisting(self.ScriptNameEntity)then debug(false,l.Identifier..": "..self.Name..": spawnpoint does not exist!")return true elseif not tonumber(self.PlayerID)or self.PlayerID<1 or self.PlayerID>8 then debug(false,l.Identifier..": "..self.Name..": got a invalid playerID!")return true elseif not Entities[self.UnitKey]then debug(false,l.Identifier..": "..self.Name..": entity type '"..self.UnitKey.."' is invalid!")return true elseif not Goods[self.GoodType]then debug(false,l.Identifier..": "..self.Name..": good type '"..self.GoodType.."' is invalid!")return true elseif not tonumber(self.GoodAmount)or self.GoodAmount<1 then debug(false,l.Identifier..": "..self.Name..": good amount can not be below 1!")return true elseif tonumber(self.OverrideTargetPlayer)and(self.OverrideTargetPlayer<1 or self.OverrideTargetPlayer>8)then debug(false,l.Identifier..": "..self.Name..": overwrite target player with invalid playerID!")return true end;return false end;RegisterBehavior(B_Reward_SendCart)function Reward_Units(...)return B_Reward_Units:new(...)end;B_Reward_Units={Name="Reward_Units",Description={en="Reward: Creates units for the quest receiver.",de="Lohn: Erzeugt einige Einheiten für den Auftragnehmer.",fr="Récompense: Unités"},Parameter={{ParameterType.Entity,en="Type name",de="Typbezeichnung",fr="Désignation de type"},{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"}}}function B_Reward_Units:AddParameter(m,n)if m==0 then self.EntityName=n elseif m==1 then self.Amount=n*1 end end;function B_Reward_Units:GetRewardTable()return{Reward.Units,assert(Entities[self.EntityName]),self.Amount}end;RegisterBehavior(B_Reward_Units)function Reward_QuestRestart(...)return B_Reward_QuestRestart:new(...)end;B_Reward_QuestRestart=CopyTable(B_Reprisal_QuestRestart)B_Reward_QuestRestart.Name="Reward_QuestRestart"B_Reward_QuestRestart.Description.en="Reward: Restarts a (completed) quest so it can be triggered and completed again."B_Reward_QuestRestart.Description.de="Lohn: Startet eine (beendete) Quest neu, damit diese neu ausgelöst und beendet werden kann."B_Reward_QuestRestart.Description.fr="Récompense: Redémarre une quête (terminée) pour qu'elle puisse être redéclenchée et terminée."B_Reward_QuestRestart.GetReprisalTable=nil;B_Reward_QuestRestart.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_QuestRestart)function Reward_QuestFailure(...)return B_Reward_QuestFailure:new(...)end;B_Reward_QuestFailure=CopyTable(B_Reprisal_QuestFailure)B_Reward_QuestFailure.Name="Reward_QuestFailure"B_Reward_QuestFailure.Description.en="Reward: Lets another active quest fail."B_Reward_QuestFailure.Description.de="Lohn: Lässt eine andere aktive Quest fehlschlagen."B_Reward_QuestFailure.Description.fr="Récompense: Fait échouer une autre quête active."B_Reward_QuestFailure.GetReprisalTable=nil;B_Reward_QuestFailure.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_QuestFailure)function Reward_QuestSuccess(...)return B_Reward_QuestSuccess:new(...)end;B_Reward_QuestSuccess=CopyTable(B_Reprisal_QuestSuccess)B_Reward_QuestSuccess.Name="Reward_QuestSuccess"B_Reward_QuestSuccess.Description.en="Reward: Completes another active quest successfully."B_Reward_QuestSuccess.Description.de="Lohn: Beendet eine andere aktive Quest erfolgreich."B_Reward_QuestSuccess.Description.fr="Récompense: Termine avec succès une autre quête active."B_Reward_QuestSuccess.GetReprisalTable=nil;B_Reward_QuestSuccess.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_QuestSuccess)function Reward_QuestActivate(...)return B_Reward_QuestActivate:new(...)end;B_Reward_QuestActivate=CopyTable(B_Reprisal_QuestActivate)B_Reward_QuestActivate.Name="Reward_QuestActivate"B_Reward_QuestActivate.Description.en="Reward: Activates another quest that is not triggered yet."B_Reward_QuestActivate.Description.de="Lohn: Aktiviert eine andere Quest die noch nicht ausgelöst wurde."B_Reward_QuestActivate.Description.fr="Récompense: Active une autre quête qui n'a pas encore été déclenchée."B_Reward_QuestActivate.GetReprisalTable=nil;B_Reward_QuestActivate.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_QuestActivate)function Reward_QuestInterrupt(...)return B_Reward_QuestInterrupt:new(...)end;B_Reward_QuestInterrupt=CopyTable(B_Reprisal_QuestInterrupt)B_Reward_QuestInterrupt.Name="Reward_QuestInterrupt"B_Reward_QuestInterrupt.Description.en="Reward: Interrupts another active quest without success or failure."B_Reward_QuestInterrupt.Description.de="Lohn: Beendet eine andere aktive Quest ohne Erfolg oder Misserfolg."B_Reward_QuestInterrupt.Description.fr="Récompense: Termine une autre quête active sans succès ni échec."B_Reward_QuestInterrupt.GetReprisalTable=nil;B_Reward_QuestInterrupt.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_QuestInterrupt)function Reward_QuestForceInterrupt(...)return B_Reward_QuestForceInterrupt:new(...)end;B_Reward_QuestForceInterrupt=CopyTable(B_Reprisal_QuestForceInterrupt)B_Reward_QuestForceInterrupt.Name="Reward_QuestForceInterrupt"B_Reward_QuestForceInterrupt.Description.en="Reward: Interrupts another quest (even when it isn't active yet) without success or failure."B_Reward_QuestForceInterrupt.Description.de="Lohn: Beendet eine andere Quest, auch wenn diese noch nicht aktiv ist ohne Erfolg oder Misserfolg."B_Reward_QuestForceInterrupt.Description.fr="Récompense: Termine une autre quête, même si elle n'est pas encore active, sans succès ni échec."B_Reward_QuestForceInterrupt.GetReprisalTable=nil;B_Reward_QuestForceInterrupt.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_QuestForceInterrupt)function Reward_CustomVariables(...)return B_Reward_CustomVariables:new(...)end;B_Reward_CustomVariables=CopyTable(B_Reprisal_CustomVariables)B_Reward_CustomVariables.Name="Reward_CustomVariables"B_Reward_CustomVariables.Description.en="Reward: Executes a mathematical operation with this variable. The other operand can be a number or another custom variable."B_Reward_CustomVariables.Description.de="Lohn: Führt eine mathematische Operation mit der Variable aus. Der andere Operand kann eine Zahl oder eine Custom-Varible sein."B_Reward_CustomVariables.Description.fr="Récompense: Effectue une opération mathématique sur la variable. L'autre opérateur peut être un nombre ou une variable personnalisée."B_Reward_CustomVariables.GetReprisalTable=nil;B_Reward_CustomVariables.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_CustomVariables)function Reward_MapScriptFunction(...)return B_Reward_MapScriptFunction:new(...)end;B_Reward_MapScriptFunction=CopyTable(B_Reprisal_MapScriptFunction)B_Reward_MapScriptFunction.Name="Reward_MapScriptFunction"B_Reward_MapScriptFunction.Description.en="Reward: Calls a function within the global map script if the quest has failed."B_Reward_MapScriptFunction.Description.de="Lohn: Ruft eine Funktion im globalen Kartenskript auf, wenn die Quest fehlschlägt."B_Reward_MapScriptFunction.Description.fr="Récompense: Invoque une fonction dans le script global de la carte en cas d'échec de la quête."B_Reward_MapScriptFunction.GetReprisalTable=nil;B_Reward_MapScriptFunction.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_MapScriptFunction)function Reward_Technology(...)return B_Reward_Technology:new(...)end;B_Reward_Technology=CopyTable(B_Reprisal_Technology)B_Reward_Technology.Name="Reward_Technology"B_Reward_Technology.Description.en="Reward: Locks or unlocks a technology for the given player."B_Reward_Technology.Description.de="Lohn: Sperrt oder erlaubt eine Technolgie fuer den angegebenen Player."B_Reward_Technology.Description.fr="Récompense: Bloque ou autorise une technologie pour le joueur spécifié."B_Reward_Technology.GetReprisalTable=nil;B_Reward_Technology.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_Technology)function Reward_PrestigePoints(...)return B_Reward_PrestigePoints:mew(...)end;B_Reward_PrestigePoints={Name="Reward_PrestigePoints",Description={en="Reward: Gives the quest receiver prestige.",de="Lohn: Gibt dem Auftragnehmer Prestige.",fr="Récompense: Prestige"},Parameter={{ParameterType.Number,en="Points",de="Punkte",fr="Points"}}}function B_Reward_PrestigePoints:AddParameter(m,n)if m==0 then self.Points=n end end;function B_Reward_PrestigePoints:GetRewardTable()return{Reward.PrestigePoints,self.Points}end;RegisterBehavior(B_Reward_PrestigePoints)function Reward_AI_MountOutpost(...)return B_Reward_AI_MountOutpost:new(...)end;B_Reward_AI_MountOutpost={Name="Reward_AI_MountOutpost",Description={en="Reward: Places a troop of soldiers on a named outpost.",de="Lohn: Platziert einen Trupp Soldaten auf einem Aussenposten der KI.",fr="Récompense: Place un groupe de soldats sur un avant-poste de l'IA."},Parameter={{ParameterType.ScriptName,en="Script name",de="Skriptname",fr="Nom de l'entité"},{ParameterType.Custom,en="Soldiers type",de="Soldatentyp",fr="Type de soldat"}}}function B_Reward_AI_MountOutpost:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_AI_MountOutpost:AddParameter(m,n)if m==0 then self.Scriptname=n else self.SoldiersType=n end end;function B_Reward_AI_MountOutpost:CustomFunction(l)local aM=assert(not Logic.IsEntityDestroyed(self.Scriptname)and GetID(self.Scriptname),l.Identifier..": Error in "..self.Name..": CustomFunction: Outpost is invalid")local aN=Logic.EntityGetPlayer(aM)local aO,aP=Logic.GetBuildingApproachPosition(aM)local aQ=Logic.CreateBattalionOnUnblockedLand(Entities[self.SoldiersType],aO,aP,0,aN,0)AICore.HideEntityFromAI(aN,aQ,true)Logic.CommandEntityToMountBuilding(aQ,aM)end;function B_Reward_AI_MountOutpost:GetCustomData(m)if m==1 then local p={}for q,r in pairs(Entities)do if string.find(q,"U_MilitaryBandit")or string.find(q,"U_MilitarySword")or string.find(q,"U_MilitaryBow")then p[#p+1]=q end end;return p end end;function B_Reward_AI_MountOutpost:Debug(l)if Logic.IsEntityDestroyed(self.Scriptname)then debug(false,l.Identifier..": "..self.Name..": Outpost "..self.Scriptname.." is missing")return true end end;RegisterBehavior(B_Reward_AI_MountOutpost)function Reward_QuestRestartForceActive(...)return B_Reward_QuestRestartForceActive:new(...)end;B_Reward_QuestRestartForceActive={Name="Reward_QuestRestartForceActive",Description={en="Reward: Restarts a (completed) quest and triggers it immediately.",de="Lohn: Startet eine (beendete) Quest neu und triggert sie sofort.",fr="Récompense: Redémarre une quête (terminée) et la déclenche immédiatement."},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"}}}function B_Reward_QuestRestartForceActive:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_QuestRestartForceActive:AddParameter(m,n)self.QuestName=n end;function B_Reward_QuestRestartForceActive:CustomFunction(l)local a8,a9=self:ResetQuest(l)if a8 then a9:SetMsgKeyOverride()a9:SetIconOverride()a9:Trigger()end end;B_Reward_QuestRestartForceActive.ResetQuest=B_Reward_QuestRestart.CustomFunction;function B_Reward_QuestRestartForceActive:Debug(l)if not Quests[GetQuestID(self.QuestName)]then debug(false,l.Identifier..": "..self.Name..": Quest: "..self.QuestName.." does not exist")return true end;return false end;RegisterBehavior(B_Reward_QuestRestartForceActive)function Reward_UpgradeBuilding(...)return B_Reward_UpgradeBuilding:new(...)end;B_Reward_UpgradeBuilding={Name="Reward_UpgradeBuilding",Description={en="Reward: Upgrades a building",de="Lohn: Baut ein Gebäude aus",fr="Récompense: Améliore un Bâtiment"},Parameter={{ParameterType.ScriptName,en="Building",de="Gebäude",fr="Bâtiment"}}}function B_Reward_UpgradeBuilding:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_UpgradeBuilding:AddParameter(m,n)if m==0 then self.Building=n end end;function B_Reward_UpgradeBuilding:CustomFunction(l)local aR=GetID(self.Building)if aR~=0 and Logic.IsBuilding(aR)==1 and Logic.IsBuildingUpgradable(aR,true)and Logic.IsBuildingUpgradable(aR,false)then Logic.UpgradeBuilding(aR)end end;function B_Reward_UpgradeBuilding:Debug(l)local aR=GetID(self.Building)if not(aR~=0 and Logic.IsBuilding(aR)==1 and Logic.IsBuildingUpgradable(aR,true)and Logic.IsBuildingUpgradable(aR,false))then debug(false,l.Identifier..": "..self.Name..": Building is wrong")return true end end;RegisterBehavior(B_Reward_UpgradeBuilding)function Reward_SetBuildingUpgradeLevel(...)return B_Reward_SetBuildingUpgradeLevel:new(...)end;B_Reward_SetBuildingUpgradeLevel={Name="Reward_SetBuildingUpgradeLevel",Description={en="Reward: Sets the upgrade level of the specified building.",de="Lohn: Legt das Upgrade-Level eines Gebaeudes fest.",fr="Récompense: Définit le niveau d'amélioration d'un bâtiment."},Parameter={{ParameterType.ScriptName,en="Building",de="Gebäude",fr="Bâtiment"},{ParameterType.Custom,en="Upgrade level",de="Upgrade-Level",fr="Niveau d'amélioration"}}}function B_Reward_SetBuildingUpgradeLevel:GetRewardTable()return{Reward.Custom,self,self.CustomFunction}end;function B_Reward_SetBuildingUpgradeLevel:AddParameter(m,n)if m==0 then self.Building=n elseif m==1 then self.UpgradeLevel=tonumber(n)end end;function B_Reward_SetBuildingUpgradeLevel:CustomFunction()local aR=Logic.GetEntityIDByName(self.Building)local aS=Logic.GetUpgradeLevel(aR)local aT=Logic.GetMaxUpgradeLevel(aR)if aR~=0 and Logic.IsBuilding(aR)==1 and(Logic.IsBuildingUpgradable(aR,true)or aT~=0 and aT==aS)then Logic.SetUpgradableBuildingState(aR,math.min(self.UpgradeLevel,aT),0)end end;function B_Reward_SetBuildingUpgradeLevel:Debug(l)local aR=Logic.GetEntityIDByName(self.Building)if not aR or Logic.IsBuilding(aR)==0 then debug(false,l.Identifier..": "..self.Name..": Building "..self.Building.." is missing or no building.")return true elseif not self.UpgradeLevel or self.UpgradeLevel<0 then debug(false,l.Identifier..": "..self.Name..": Upgrade level is wrong")return true end end;function B_Reward_SetBuildingUpgradeLevel:GetCustomData(m)if m==1 then return{"0","1","2","3"}end end;RegisterBehavior(B_Reward_SetBuildingUpgradeLevel)function Trigger_PlayerDiscovered(...)return B_Trigger_PlayerDiscovered:new(...)end;B_Trigger_PlayerDiscovered={Name="Trigger_PlayerDiscovered",Description={en="Trigger: if a given player has been discovered",de="Auslöser: wenn ein angegebener Spieler entdeckt wurde",fr="Déclencheur: lorsqu'un joueur spécifié est découvert"},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"}}}function B_Trigger_PlayerDiscovered:GetTriggerTable()return{Triggers.PlayerDiscovered,self.PlayerID}end;function B_Trigger_PlayerDiscovered:AddParameter(m,n)if m==0 then self.PlayerID=n*1 end end;RegisterBehavior(B_Trigger_PlayerDiscovered)function Trigger_OnDiplomacy(...)return B_Trigger_OnDiplomacy:new(...)end;B_Trigger_OnDiplomacy={Name="Trigger_OnDiplomacy",Description={en="Trigger: if diplomatic relations have been established with a player",de="Auslöser: wenn ein angegebener Diplomatie-Status mit einem Spieler erreicht wurde.",fr="Déclencheur: lorsqu'un statut diplomatique spécifié a été atteint avec un joueur."},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.DiplomacyState,en="Relation",de="Beziehung",fr="Relation diplomatique"}}}function B_Trigger_OnDiplomacy:GetTriggerTable()return{Triggers.Diplomacy,self.PlayerID,assert(DiplomacyStates[self.DiplState])}end;function B_Trigger_OnDiplomacy:AddParameter(m,n)if m==0 then self.PlayerID=n*1 elseif m==1 then self.DiplState=n end end;RegisterBehavior(B_Trigger_OnDiplomacy)function Trigger_OnNeedUnsatisfied(...)return B_Trigger_OnNeedUnsatisfied:new(...)end;B_Trigger_OnNeedUnsatisfied={Name="Trigger_OnNeedUnsatisfied",Description={en="Trigger: if a specified need is unsatisfied",de="Auslöser: wenn ein bestimmtes Beduerfnis nicht befriedigt ist.",fr="Déclencheur: lorsqu'un certain besoin n'est pas satisfait."},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.Need,en="Need",de="Beduerfnis",fr="Besoin"},{ParameterType.Number,en="Workers on strike",de="Streikende Arbeiter",fr="Travailleurs en grève"}}}function B_Trigger_OnNeedUnsatisfied:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnNeedUnsatisfied:AddParameter(m,n)if m==0 then self.PlayerID=n*1 elseif m==1 then self.Need=n elseif m==2 then self.WorkersOnStrike=n*1 end end;function B_Trigger_OnNeedUnsatisfied:CustomFunction(l)return Logic.GetNumberOfStrikingWorkersPerNeed(self.PlayerID,Needs[self.Need])>=self.WorkersOnStrike end;function B_Trigger_OnNeedUnsatisfied:Debug(l)if Logic.GetStoreHouse(self.PlayerID)==0 then debug(false,l.Identifier..": "..self.Name..": "..self.PlayerID.." does not exist.")return true elseif not Needs[self.Need]then debug(false,l.Identifier..": "..self.Name..": "..self.Need.." does not exist.")return true elseif self.WorkersOnStrike<0 then debug(false,l.Identifier..": "..self.Name..": WorkersOnStrike value negative")return true end;return false end;RegisterBehavior(B_Trigger_OnNeedUnsatisfied)function Trigger_OnResourceDepleted(...)return B_Trigger_OnResourceDepleted:new(...)end;B_Trigger_OnResourceDepleted={Name="Trigger_OnResourceDepleted",Description={en="Trigger: if a resource is (temporarily) depleted",de="Auslöser: wenn eine Ressource (zeitweilig) verbraucht ist",fr="Déclencheur: lorsqu'une ressource est (temporairement) consommée"},Parameter={{ParameterType.ScriptName,en="Script name",de="Skriptname",fr="Nom de script"}}}function B_Trigger_OnResourceDepleted:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnResourceDepleted:AddParameter(m,n)if m==0 then self.ScriptName=n end end;function B_Trigger_OnResourceDepleted:CustomFunction(l)local A=GetID(self.ScriptName)return not A or A==0 or Logic.GetResourceDoodadGoodType(A)==0 or Logic.GetResourceDoodadGoodAmount(A)==0 end;RegisterBehavior(B_Trigger_OnResourceDepleted)function Trigger_OnAmountOfGoods(...)return B_Trigger_OnAmountOfGoods:new(...)end;B_Trigger_OnAmountOfGoods={Name="Trigger_OnAmountOfGoods",Description={en="Trigger: if the player has gathered a given amount of resources in his storehouse",de="Auslöser: wenn der Spieler eine bestimmte Menge einer Ressource in seinem Lagerhaus hat",fr="Déclencheur: lorsque le joueur a une certaine quantité d'une ressource dans son entrepôt"},Parameter={{ParameterType.PlayerID,en="Player",de="Spieler",fr="Joueur"},{ParameterType.RawGoods,en="Type of good",de="Resourcentyp",fr="Type de ressources"},{ParameterType.Number,en="Amount of good",de="Anzahl der Resource",fr="Quantité de ressources"}}}function B_Trigger_OnAmountOfGoods:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnAmountOfGoods:AddParameter(m,n)if m==0 then self.PlayerID=n*1 elseif m==1 then self.GoodTypeName=n elseif m==2 then self.GoodAmount=n*1 end end;function B_Trigger_OnAmountOfGoods:CustomFunction(l)local aU=Logic.GetStoreHouse(self.PlayerID)if aU==0 then return false end;local o=Logic.GetGoodTypeID(self.GoodTypeName)local aV=Logic.GetAmountOnOutStockByGoodType(aU,o)if aV>=self.GoodAmount then return true end;return false end;function B_Trigger_OnAmountOfGoods:Debug(l)if Logic.GetStoreHouse(self.PlayerID)==0 then debug(false,l.Identifier..": "..self.Name..": "..self.PlayerID.." does not exist.")return true elseif not Goods[self.GoodTypeName]then debug(false,l.Identifier..": "..self.Name..": Good type is wrong.")return true elseif self.GoodAmount<0 then debug(false,l.Identifier..": "..self.Name..": Good amount is negative.")return true end;return false end;RegisterBehavior(B_Trigger_OnAmountOfGoods)function Trigger_OnQuestActive(...)return B_Trigger_OnQuestActiveWait:new(...)end;Trigger_OnQuestActiveWait=Trigger_OnQuestActive;B_Trigger_OnQuestActiveWait={Name="Trigger_OnQuestActiveWait",Description={en="Trigger: if a given quest has been activated. Waiting time optional",de="Auslöser: wenn eine angegebene Quest aktiviert wurde. Optional mit Wartezeit",fr="Déclencheur: lorsqu'une quête indiquée a été activée. En option avec délai d'attente"},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"},{ParameterType.Number,en="Waiting time",de="Wartezeit",fr="Temps d'attente"}}}function B_Trigger_OnQuestActiveWait:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnQuestActiveWait:AddParameter(m,n)if m==0 then self.QuestName=n elseif m==1 then self.WaitTime=n~=nil and tonumber(n)or 0 end end;function B_Trigger_OnQuestActiveWait:CustomFunction(l)local a8=GetQuestID(self.QuestName)if a8~=nil then assert(type(a8)=="number")if Quests[a8].State==QuestState.Active then self.WasActivated=self.WasActivated or true end;if self.WasActivated then if self.WaitTime and self.WaitTime>0 then self.WaitTimeTimer=self.WaitTimeTimer or Logic.GetTime()if Logic.GetTime()>=self.WaitTimeTimer+self.WaitTime then return true end else return true end end end;return false end;function B_Trigger_OnQuestActiveWait:Debug(l)if type(self.QuestName)~="string"then debug(false,l.Identifier..": "..self.Name..": invalid quest name!")return true elseif self.WaitTime and(type(self.WaitTime)~="number"or self.WaitTime<0)then debug(false,l.Identifier..": "..self.Name..": waitTime must be a number!")return true end;return false end;function B_Trigger_OnQuestActiveWait:Interrupt(l)end;function B_Trigger_OnQuestActiveWait:Reset(l)self.WaitTimeTimer=nil;self.WasActivated=nil end;RegisterBehavior(B_Trigger_OnQuestActiveWait)B_Trigger_OnQuestActive=CopyTable(B_Trigger_OnQuestActiveWait)B_Trigger_OnQuestActive.Name="Trigger_OnQuestActive"B_Trigger_OnQuestActive.Description.en="Trigger: Starts the quest after another has been activated."B_Trigger_OnQuestActive.Description.de="Auslöser: Startet den Quest, wenn ein anderer aktiviert wird."B_Trigger_OnQuestActive.Description.fr="Déclencheur: Démarre la quête lorsqu'une autre est activée."B_Trigger_OnQuestActive.Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"}}function B_Trigger_OnQuestActive:AddParameter(m,n)if m==0 then self.QuestName=n;self.WaitTime=0 end end;RegisterBehavior(B_Trigger_OnQuestActive)function Trigger_OnQuestFailure(...)return B_Trigger_OnQuestFailureWait:new(...)end;Trigger_OnQuestFailureWait=Trigger_OnQuestFailure;B_Trigger_OnQuestFailureWait={Name="Trigger_OnQuestFailureWait",Description={en="Trigger: if a given quest has failed. Waiting time optional",de="Auslöser: wenn eine angegebene Quest fehlgeschlagen ist. Optional mit Wartezeit",fr="Déclencheur: lorsqu'une quête indiquée a échoué. En option avec délai d'attente"},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"},{ParameterType.Number,en="Waiting time",de="Wartezeit",fr="Temps d'attente"}}}function B_Trigger_OnQuestFailureWait:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnQuestFailureWait:AddParameter(m,n)if m==0 then self.QuestName=n elseif m==1 then self.WaitTime=n~=nil and tonumber(n)or 0 end end;function B_Trigger_OnQuestFailureWait:CustomFunction(l)if GetQuestID(self.QuestName)~=nil then local a8=GetQuestID(self.QuestName)if Quests[a8].Result==QuestResult.Failure then if self.WaitTime and self.WaitTime>0 then self.WaitTimeTimer=self.WaitTimeTimer or Logic.GetTime()if Logic.GetTime()>=self.WaitTimeTimer+self.WaitTime then return true end else return true end end end;return false end;function B_Trigger_OnQuestFailureWait:Debug(l)if type(self.QuestName)~="string"then debug(false,l.Identifier..": "..self.Name..": invalid quest name!")return true elseif self.WaitTime and(type(self.WaitTime)~="number"or self.WaitTime<0)then debug(false,l.Identifier..": "..self.Name..": waitTime must be a number!")return true end;return false end;function B_Trigger_OnQuestFailureWait:Interrupt(l)self.WaitTimeTimer=nil end;function B_Trigger_OnQuestFailureWait:Reset(l)self.WaitTimeTimer=nil end;RegisterBehavior(B_Trigger_OnQuestFailureWait)B_Trigger_OnQuestFailure=CopyTable(B_Trigger_OnQuestFailureWait)B_Trigger_OnQuestFailure.Name="Trigger_OnQuestFailure"B_Trigger_OnQuestFailure.Description.en="Trigger: Starts the quest after another has failed."B_Trigger_OnQuestFailure.Description.de="Auslöser: Startet den Quest, wenn ein anderer fehlschlägt."B_Trigger_OnQuestFailure.Description.fr="Déclencheur: Lance la quête lorsqu'une autre échoue."B_Trigger_OnQuestFailure.Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"}}function B_Trigger_OnQuestFailure:AddParameter(m,n)if m==0 then self.QuestName=n;self.WaitTime=0 end end;RegisterBehavior(B_Trigger_OnQuestFailure)function Trigger_OnQuestNotTriggered(...)return B_Trigger_OnQuestNotTriggered:new(...)end;B_Trigger_OnQuestNotTriggered={Name="Trigger_OnQuestNotTriggered",Description={en="Trigger: if a given quest is not yet active. Should be used in combination with other triggers.",de="Auslöser: wenn eine angegebene Quest noch inaktiv ist. Sollte mit weiteren Triggern kombiniert werden.",fr="Déclencheur: lorsqu'une quête indiquée est encore inactive. Doit être combiné avec d'autres déclencheurs."},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"}}}function B_Trigger_OnQuestNotTriggered:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnQuestNotTriggered:AddParameter(m,n)if m==0 then self.QuestName=n end end;function B_Trigger_OnQuestNotTriggered:CustomFunction(l)if GetQuestID(self.QuestName)~=nil then local a8=GetQuestID(self.QuestName)if Quests[a8].State==QuestState.NotTriggered then return true end end;return false end;function B_Trigger_OnQuestNotTriggered:Debug(l)if type(self.QuestName)~="string"then debug(false,l.Identifier..": "..self.Name..": invalid quest name!")return true end;return false end;RegisterBehavior(B_Trigger_OnQuestNotTriggered)function Trigger_OnQuestInterrupted(...)return B_Trigger_OnQuestInterruptedWait:new(...)end;Trigger_OnQuestInterruptedWait=Trigger_OnQuestInterrupted;B_Trigger_OnQuestInterruptedWait={Name="Trigger_OnQuestInterruptedWait",Description={en="Trigger: if a given quest has been interrupted. Should be used in combination with other triggers.",de="Auslöser: wenn eine angegebene Quest abgebrochen wurde. Sollte mit weiteren Triggern kombiniert werden.",fr="Déclencheur: lorsqu'une quête indiquée a été interrompue. Doit être combiné avec d'autres déclencheurs."},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"},{ParameterType.Number,en="Waiting time",de="Wartezeit",fr="Temps d'attente"}}}function B_Trigger_OnQuestInterruptedWait:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnQuestInterruptedWait:AddParameter(m,n)if m==0 then self.QuestName=n elseif m==1 then self.WaitTime=n~=nil and tonumber(n)or 0 end end;function B_Trigger_OnQuestInterruptedWait:CustomFunction(l)if GetQuestID(self.QuestName)~=nil then local a8=GetQuestID(self.QuestName)if Quests[a8].State==QuestState.Over and Quests[a8].Result==QuestResult.Interrupted then if self.WaitTime and self.WaitTime>0 then self.WaitTimeTimer=self.WaitTimeTimer or Logic.GetTime()if Logic.GetTime()>=self.WaitTimeTimer+self.WaitTime then return true end else return true end end end;return false end;function B_Trigger_OnQuestInterruptedWait:Debug(l)if type(self.QuestName)~="string"then debug(false,l.Identifier..": "..self.Name..": invalid quest name!")return true elseif self.WaitTime and(type(self.WaitTime)~="number"or self.WaitTime<0)then debug(false,l.Identifier..": "..self.Name..": waitTime must be a number!")return true end;return false end;function B_Trigger_OnQuestInterruptedWait:Interrupt(l)self.WaitTimeTimer=nil end;function B_Trigger_OnQuestInterruptedWait:Reset(l)self.WaitTimeTimer=nil end;RegisterBehavior(B_Trigger_OnQuestInterruptedWait)B_Trigger_OnQuestInterrupted=CopyTable(B_Trigger_OnQuestInterruptedWait)B_Trigger_OnQuestInterrupted.Name="Trigger_OnQuestInterrupted"B_Trigger_OnQuestInterrupted.Description.en="Trigger: Starts the quest after another is interrupted."B_Trigger_OnQuestInterrupted.Description.de="Auslöser: Startet den Quest, wenn ein anderer abgebrochen wurde."B_Trigger_OnQuestInterrupted.Description.fr="Déclencheur: Démarre la quête lorsqu'une autre a été annulée."B_Trigger_OnQuestInterrupted.Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"}}function B_Trigger_OnQuestInterrupted:AddParameter(m,n)if m==0 then self.QuestName=n;self.WaitTime=0 end end;RegisterBehavior(B_Trigger_OnQuestInterrupted)function Trigger_OnQuestOver(...)return B_Trigger_OnQuestOverWait:new(...)end;Trigger_OnQuestOverWait=Trigger_OnQuestOver;B_Trigger_OnQuestOverWait={Name="Trigger_OnQuestOverWait",Description={en="Trigger: if a given quest has been finished, regardless of its result. Waiting time optional",de="Auslöser: wenn eine angegebene Quest beendet wurde, unabhängig von deren Ergebnis. Wartezeit optional",fr="Déclencheur: lorsqu'une quête indiquée est terminée, indépendamment de son résultat. Délai d'attente optionnel"},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"},{ParameterType.Number,en="Waiting time",de="Wartezeit",fr="Temps d'attente"}}}function B_Trigger_OnQuestOverWait:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnQuestOverWait:AddParameter(m,n)if m==0 then self.QuestName=n elseif m==1 then self.WaitTime=n~=nil and tonumber(n)or 0 end end;function B_Trigger_OnQuestOverWait:CustomFunction(l)if GetQuestID(self.QuestName)~=nil then local a8=GetQuestID(self.QuestName)if Quests[a8].State==QuestState.Over and Quests[a8].Result~=QuestResult.Interrupted then if self.WaitTime and self.WaitTime>0 then self.WaitTimeTimer=self.WaitTimeTimer or Logic.GetTime()if Logic.GetTime()>=self.WaitTimeTimer+self.WaitTime then return true end else return true end end end;return false end;function B_Trigger_OnQuestOverWait:Debug(l)if type(self.QuestName)~="string"then debug(false,l.Identifier..": "..self.Name..": invalid quest name!")return true elseif self.WaitTime and(type(self.WaitTime)~="number"or self.WaitTime<0)then debug(false,l.Identifier..": "..self.Name..": waitTime must be a number!")return true end;return false end;function B_Trigger_OnQuestOverWait:Interrupt(l)self.WaitTimeTimer=nil end;function B_Trigger_OnQuestOverWait:Reset(l)self.WaitTimeTimer=nil end;RegisterBehavior(B_Trigger_OnQuestOverWait)B_Trigger_OnQuestOver=CopyTable(B_Trigger_OnQuestOverWait)B_Trigger_OnQuestOver.Name="Trigger_OnQuestOver"B_Trigger_OnQuestOver.Description.en="Trigger: Starts the quest after another finished."B_Trigger_OnQuestOver.Description.de="Auslöser: Startet den Quest, wenn ein anderer abgeschlossen wurde."B_Trigger_OnQuestOver.Description.fr="Déclencheur: Démarre la quête lorsqu'une autre est terminée."B_Trigger_OnQuestOver.Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"}}function B_Trigger_OnQuestOver:AddParameter(m,n)if m==0 then self.QuestName=n;self.WaitTime=0 end end;RegisterBehavior(B_Trigger_OnQuestOver)function Trigger_OnQuestSuccess(...)return B_Trigger_OnQuestSuccessWait:new(...)end;Trigger_OnQuestSuccessWait=Trigger_OnQuestSuccess;B_Trigger_OnQuestSuccessWait={Name="Trigger_OnQuestSuccessWait",Description={en="Trigger: if a given quest has been finished successfully. Waiting time optional",de="Auslöser: wenn eine angegebene Quest erfolgreich abgeschlossen wurde. Wartezeit optional",fr="Déclencheur: lorsqu'une quête indiquée a été accomplie avec succès. Délai d'attente optionnel"},Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"},{ParameterType.Number,en="Waiting time",de="Wartezeit",fr="Temps d'attente"}}}function B_Trigger_OnQuestSuccessWait:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnQuestSuccessWait:AddParameter(m,n)if m==0 then self.QuestName=n elseif m==1 then self.WaitTime=n~=nil and tonumber(n)or 0 end end;function B_Trigger_OnQuestSuccessWait:CustomFunction()if GetQuestID(self.QuestName)~=nil then local a8=GetQuestID(self.QuestName)if Quests[a8].Result==QuestResult.Success then if self.WaitTime and self.WaitTime>0 then self.WaitTimeTimer=self.WaitTimeTimer or Logic.GetTime()if Logic.GetTime()>=self.WaitTimeTimer+self.WaitTime then return true end else return true end end end;return false end;function B_Trigger_OnQuestSuccessWait:Debug(l)if type(self.QuestName)~="string"then debug(false,l.Identifier..": "..self.Name..": invalid quest name!")return true elseif self.WaitTime and(type(self.WaitTime)~="number"or self.WaitTime<0)then debug(false,l.Identifier..": "..self.Name..": waittime must be a number!")return true end;return false end;function B_Trigger_OnQuestSuccessWait:Interrupt(l)self.WaitTimeTimer=nil end;function B_Trigger_OnQuestSuccessWait:Reset(l)self.WaitTimeTimer=nil end;RegisterBehavior(B_Trigger_OnQuestSuccessWait)B_Trigger_OnQuestSuccess=CopyTable(B_Trigger_OnQuestSuccessWait)B_Trigger_OnQuestSuccess.Name="Trigger_OnQuestSuccess"B_Trigger_OnQuestSuccess.Description.en="Trigger: Starts the quest after another finished successfully."B_Trigger_OnQuestSuccess.Description.de="Auslöser: Startet den Quest, wenn ein anderer erfolgreich abgeschlossen wurde."B_Trigger_OnQuestSuccess.Description.de="Déclencheur: Démarre la quête lorsqu'une autre a été accomplie avec succès."B_Trigger_OnQuestSuccess.Parameter={{ParameterType.QuestName,en="Quest name",de="Questname",fr="Nom de la quête"}}function B_Trigger_OnQuestSuccess:AddParameter(m,n)if m==0 then self.QuestName=n;self.WaitTime=0 end end;RegisterBehavior(B_Trigger_OnQuestSuccess)function Trigger_CustomVariables(...)return B_Trigger_CustomVariables:new(...)end;B_Trigger_CustomVariables={Name="Trigger_CustomVariables",Description={en="Trigger: if the variable has a certain value.",de="Auslöser: wenn die Variable einen bestimmen Wert eingenommen hat.",fr="Déclencheur: lorsque la variable a pris une valeur déterminée."},Parameter={{ParameterType.Default,en="Name of Variable",de="Variablennamen",fr="Noms de variables"},{ParameterType.Custom,en="Relation",de="Relation",fr="Relation"},{ParameterType.Default,en="Value",de="Wert",fr="Valeur"}}}function B_Trigger_CustomVariables:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_CustomVariables:AddParameter(m,n)if m==0 then self.VariableName=n elseif m==1 then self.Relation=n elseif m==2 then local _=tonumber(n)_=_~=nil and _ or n;self.Value=_ end end;function B_Trigger_CustomVariables:CustomFunction()local a0=ObtainCustomVariable("BehaviorVariable_"..self.VariableName,0)local a1=self.Value;if type(self.Value)=="string"then a1=ObtainCustomVariable("BehaviorVariable_"..self.Value,0)end;if self.Relation=="=="then return a0==a1 elseif self.Relation~="~="then return a0~=a1 elseif self.Relation==">"then return a0>a1 elseif self.Relation==">="then return a0>=a1 elseif self.Relation=="<="then return a0<=a1 else return a0<a1 end;return false end;function B_Trigger_CustomVariables:GetCustomData(m)if m==1 then return{"==","~=","<=","<",">",">="}end end;function B_Trigger_CustomVariables:Debug(l)local a2={"==","~=","<=","<",">",">="}local a3={true,false,nil}if not ObtainCustomVariable("BehaviorVariable_"..self.VariableName)then warn(false,l.Identifier..": "..self.Name..": variable '"..self.VariableName.."' do not exist!")end;if not table.contains(a2,self.Relation)then debug(false,l.Identifier..": "..self.Name..": '"..self.Relation.."' is an invalid relation!")return true end;return false end;RegisterBehavior(B_Trigger_CustomVariables)function Trigger_AlwaysActive()return B_Trigger_AlwaysActive:new()end;B_Trigger_AlwaysActive={Name="Trigger_AlwaysActive",Description={en="Trigger: the map has been started.",de="Auslöser: Start der Karte.",fr="Déclencheur: Démarrage de la carte."}}function B_Trigger_AlwaysActive:GetTriggerTable()return{Triggers.Time,0}end;RegisterBehavior(B_Trigger_AlwaysActive)function Trigger_OnMonth(...)return B_Trigger_OnMonth:new(...)end;B_Trigger_OnMonth={Name="Trigger_OnMonth",Description={en="Trigger: a specified month",de="Auslöser: ein bestimmter Monat",fr="Déclencheur: un mois donné"},Parameter={{ParameterType.Custom,en="Month",de="Monat",fr="Mois"}}}function B_Trigger_OnMonth:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnMonth:AddParameter(m,n)if m==0 then self.Month=n*1 end end;function B_Trigger_OnMonth:CustomFunction(l)return self.Month==Logic.GetCurrentMonth()end;function B_Trigger_OnMonth:GetCustomData(m)local p={}if m==0 then for a=1,12 do table.insert(p,a)end else assert(false)end;return p end;function B_Trigger_OnMonth:Debug(l)if self.Month<1 or self.Month>12 then debug(false,l.Identifier..": "..self.Name..": Month has the wrong value")return true end;return false end;RegisterBehavior(B_Trigger_OnMonth)function Trigger_OnMonsoon()return B_Trigger_OnMonsoon:new()end;B_Trigger_OnMonsoon={Name="Trigger_OnMonsoon",Description={en="Trigger: on monsoon.",de="Auslöser: wenn der Monsun beginnt.",fr="Déclencheur: lorsque la mousson commence."},RequiresExtraNo=1}function B_Trigger_OnMonsoon:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnMonsoon:CustomFunction(l)if Logic.GetWeatherDoesShallowWaterFlood(0)then return true end end;RegisterBehavior(B_Trigger_OnMonsoon)function Trigger_Time(...)return B_Trigger_Time:new(...)end;B_Trigger_Time={Name="Trigger_Time",Description={en="Trigger: a given amount of time since map start",de="Auslöser: eine gewisse Anzahl Sekunden nach Spielbeginn",fr="Déclencheur: un certain nombre de secondes après le début du jeu"},Parameter={{ParameterType.Number,en="Time (sec.)",de="Zeit (Sek.)",fr="Temps (sec.)"}}}function B_Trigger_Time:GetTriggerTable()return{Triggers.Time,self.Time}end;function B_Trigger_Time:AddParameter(m,n)if m==0 then self.Time=n*1 end end;RegisterBehavior(B_Trigger_Time)function Trigger_OnWaterFreezes()return B_Trigger_OnWaterFreezes:new()end;B_Trigger_OnWaterFreezes={Name="Trigger_OnWaterFreezes",Description={en="Trigger: if the water starts freezing",de="Auslöser: wenn die Gewässer gefrieren",fr="Déclencheur: lorsque les eaux gèlent"}}function B_Trigger_OnWaterFreezes:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnWaterFreezes:CustomFunction(l)if Logic.GetWeatherDoesWaterFreeze(0)then return true end end;RegisterBehavior(B_Trigger_OnWaterFreezes)function Trigger_NeverTriggered()return B_Trigger_NeverTriggered:new()end;B_Trigger_NeverTriggered={Name="Trigger_NeverTriggered",Description={en="Trigger: Never triggers a Quest. The quest may be set active by Reward_QuestActivate or Reward_QuestRestartForceActive",de="Auslöser: Löst nie eine Quest aus. Die Quest kann von Reward_QuestActivate oder Reward_QuestRestartForceActive aktiviert werden.",fr="Déclencheur: Ne déclenche jamais de quête. La quête peut être activée par Reward_QuestActivate ou Reward_QuestRestartForceActive."}}function B_Trigger_NeverTriggered:GetTriggerTable()return{Triggers.Custom2,{self,function()end}}end;RegisterBehavior(B_Trigger_NeverTriggered)function Trigger_OnAtLeastOneQuestFailure(...)return B_Trigger_OnAtLeastOneQuestFailure:new(...)end;B_Trigger_OnAtLeastOneQuestFailure={Name="Trigger_OnAtLeastOneQuestFailure",Description={en="Trigger: if one or both of the given quests have failed.",de="Auslöser: wenn einer oder beide der angegebenen Aufträge fehlgeschlagen sind.",fr="Déclencheur: si l'une des quêtes indiquées ou les deux ont échoué."},Parameter={{ParameterType.QuestName,en="Quest Name 1",de="Questname 1",fr="Nom de la quête 1"},{ParameterType.QuestName,en="Quest Name 2",de="Questname 2",fr="Nom de la quête 2"}}}function B_Trigger_OnAtLeastOneQuestFailure:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnAtLeastOneQuestFailure:AddParameter(m,n)self.QuestTable={}if m==0 then self.Quest1=n elseif m==1 then self.Quest2=n end end;function B_Trigger_OnAtLeastOneQuestFailure:CustomFunction(l)local aW=Quests[GetQuestID(self.Quest1)]local aX=Quests[GetQuestID(self.Quest2)]if aW.State==QuestState.Over and aW.Result==QuestResult.Failure or aX.State==QuestState.Over and aX.Result==QuestResult.Failure then return true end;return false end;function B_Trigger_OnAtLeastOneQuestFailure:Debug(l)if self.Quest1==self.Quest2 then debug(false,l.Identifier..": "..self.Name..": Both quests are identical!")return true elseif not IsValidQuest(self.Quest1)then debug(false,l.Identifier..": "..self.Name..": Quest '"..self.Quest1 .."' does not exist!")return true elseif not IsValidQuest(self.Quest2)then debug(false,l.Identifier..": "..self.Name..": Quest '"..self.Quest2 .."' does not exist!")return true end;return false end;RegisterBehavior(B_Trigger_OnAtLeastOneQuestFailure)function Trigger_OnAtLeastOneQuestSuccess(...)return B_Trigger_OnAtLeastOneQuestSuccess:new(...)end;B_Trigger_OnAtLeastOneQuestSuccess={Name="Trigger_OnAtLeastOneQuestSuccess",Description={en="Trigger: if one or both of the given quests are won.",de="Auslöser: wenn einer oder beide der angegebenen Aufträge gewonnen wurden.",fr="Déclencheur : si une ou les deux missions indiquées ont été gagnées."},Parameter={{ParameterType.QuestName,en="Quest Name 1",de="Questname 1",fr="Nom de la quête 1"},{ParameterType.QuestName,en="Quest Name 2",de="Questname 2",fr="Nom de la quête 2"}}}function B_Trigger_OnAtLeastOneQuestSuccess:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnAtLeastOneQuestSuccess:AddParameter(m,n)self.QuestTable={}if m==0 then self.Quest1=n elseif m==1 then self.Quest2=n end end;function B_Trigger_OnAtLeastOneQuestSuccess:CustomFunction(l)local aW=Quests[GetQuestID(self.Quest1)]local aX=Quests[GetQuestID(self.Quest2)]if aW.State==QuestState.Over and aW.Result==QuestResult.Success or aX.State==QuestState.Over and aX.Result==QuestResult.Success then return true end;return false end;function B_Trigger_OnAtLeastOneQuestSuccess:Debug(l)if self.Quest1==self.Quest2 then debug(false,l.Identifier..": "..self.Name..": Both quests are identical!")return true elseif not IsValidQuest(self.Quest1)then debug(false,l.Identifier..": "..self.Name..": Quest '"..self.Quest1 .."' does not exist!")return true elseif not IsValidQuest(self.Quest2)then debug(false,l.Identifier..": "..self.Name..": Quest '"..self.Quest2 .."' does not exist!")return true end;return false end;RegisterBehavior(B_Trigger_OnAtLeastOneQuestSuccess)function Trigger_OnAtLeastXOfYQuestsSuccess(...)return B_Trigger_OnAtLeastXOfYQuestsSuccess:new(...)end;B_Trigger_OnAtLeastXOfYQuestsSuccess={Name="Trigger_OnAtLeastXOfYQuestsSuccess",Description={en="Trigger: if at least X of Y given quests has been finished successfully.",de="Auslöser: wenn X von Y angegebener Quests erfolgreich abgeschlossen wurden.",fr="Déclencheur: lorsque X des Y quêtes indiquées ont été accomplies avec succès."},Parameter={{ParameterType.Custom,en="Least Amount",de="Mindest Anzahl",fr="Nombre minimum"},{ParameterType.Custom,en="Quest Amount",de="Quest Anzahl",fr="Nombre de quêtes"},{ParameterType.QuestName,en="Quest name 1",de="Questname 1",fr="Nom de la quête 1"},{ParameterType.QuestName,en="Quest name 2",de="Questname 2",fr="Nom de la quête 2"},{ParameterType.QuestName,en="Quest name 3",de="Questname 3",fr="Nom de la quête 3"},{ParameterType.QuestName,en="Quest name 4",de="Questname 4",fr="Nom de la quête 4"},{ParameterType.QuestName,en="Quest name 5",de="Questname 5",fr="Nom de la quête 5"}}}function B_Trigger_OnAtLeastXOfYQuestsSuccess:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnAtLeastXOfYQuestsSuccess:AddParameter(m,n)if m==0 then self.LeastAmount=tonumber(n)elseif m==1 then self.QuestAmount=tonumber(n)elseif m==2 then self.QuestName1=n elseif m==3 then self.QuestName2=n elseif m==4 then self.QuestName3=n elseif m==5 then self.QuestName4=n elseif m==6 then self.QuestName5=n end end;function B_Trigger_OnAtLeastXOfYQuestsSuccess:CustomFunction()local aY=0;for a=1,self.QuestAmount do local a8=GetQuestID(self["QuestName"..a])if IsValidQuest(a8)then if Quests[a8].Result==QuestResult.Success then aY=aY+1;if aY>=self.LeastAmount then return true end end end end;return false end;function B_Trigger_OnAtLeastXOfYQuestsSuccess:Debug(l)local aZ=self.LeastAmount;local a_=self.QuestAmount;if aZ<=0 or aZ>5 then debug(false,l.Identifier..": "..self.Name..": LeastAmount is wrong")return true elseif a_<=0 or a_>5 then debug(false,l.Identifier..": "..self.Name..": QuestAmount is wrong")return true elseif aZ>a_ then debug(false,l.Identifier..": "..self.Name..": LeastAmount is greater than QuestAmount")return true end;for a=1,a_ do if not IsValidQuest(self["QuestName"..a])then debug(false,l.Identifier..": "..self.Name..": Quest "..self["QuestName"..a].." not found")return true end end;return false end;function B_Trigger_OnAtLeastXOfYQuestsSuccess:GetCustomData(m)if m==0 or m==1 then return{"1","2","3","4","5"}end end;RegisterBehavior(B_Trigger_OnAtLeastXOfYQuestsSuccess)function Trigger_MapScriptFunction(...)return B_Trigger_MapScriptFunction:new(...)end;B_Trigger_MapScriptFunction={Name="Trigger_MapScriptFunction",Description={en="Trigger: Calls a function within the global map script. If the function returns true the quest will be started",de="Auslöser: Ruft eine Funktion im globalen Skript auf. Wenn sie true sendet, wird die Quest gestartet.",fr="Déclencheur: Appelle une fonction dans le script global. Si elle envoie true, la quête est lancée."},Parameter={{ParameterType.Default,en="Function name",de="Funktionsname",fr="Nom de la fonction"}}}function B_Trigger_MapScriptFunction:GetTriggerTable(l)return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_MapScriptFunction:AddParameter(m,n)if m==0 then self.FuncName=n end end;function B_Trigger_MapScriptFunction:CustomFunction(l)if type(self.FuncName)=="function"then return self.FuncName(unpack(self.i47ya_6aghw_frxil))end;return _G[self.FuncName](self,l)end;function B_Trigger_MapScriptFunction:Debug(l)if not self.FuncName then debug(false,l.Identifier..": "..self.Name..": function reference is invalid!")return true end;if type(self.FuncName)~="function"and not _G[self.FuncName]then debug(false,l.Identifier..": "..self.Name..": function does not exist!")return true end;return false end;RegisterBehavior(B_Trigger_MapScriptFunction)function Trigger_OnEffectDestroyed(...)return B_Trigger_OnEffectDestroyed:new(...)end;B_Trigger_OnEffectDestroyed={Name="Trigger_OnEffectDestroyed",Description={en="Trigger: Starts a quest after an effect was destroyed",de="Auslöser: Startet eine Quest, nachdem ein Effekt zerstoert wurde",fr="Déclencheur: Démarre une quête après la destruction d'un effet."},Parameter={{ParameterType.Default,en="Effect name",de="Effektname",fr="Nom de l'effet"}}}function B_Trigger_OnEffectDestroyed:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnEffectDestroyed:AddParameter(m,n)if m==0 then self.EffectName=n end end;function B_Trigger_OnEffectDestroyed:CustomFunction()return not CONST_EFFECT_NAME_TO_ID[self.EffectName]or not Logic.IsEffectRegistered(CONST_EFFECT_NAME_TO_ID[self.EffectName])end;function B_Trigger_OnEffectDestroyed:Debug(l)if not CONST_EFFECT_NAME_TO_ID[self.EffectName]then debug(false,l.Identifier..": "..self.Name..": Effect has never existed")return true end end;RegisterBehavior(B_Trigger_OnEffectDestroyed)function Goal_NPC(b0,b1)return B_Goal_NPC:new(b0,b1)end;B_Goal_NPC={Name="Goal_NPC",Description={en="Goal: The hero has to talk to a non-player character.",de="Ziel: Der Held muss einen Nichtspielercharakter ansprechen.",fr="Objectif: le héros doit interpeller un personnage non joueur."},Parameter={{ParameterType.ScriptName,en="NPC",de="NPC",fr="NPC"},{ParameterType.ScriptName,en="Hero",de="Held",fr="Héro"}}}function B_Goal_NPC:GetGoalTable()return{Objective.Distance,-65565,self.Hero,self.NPC,self}end;function B_Goal_NPC:AddParameter(m,n)if m==0 then self.NPC=n elseif m==1 then self.Hero=n;if self.Hero=="-"then self.Hero=nil end end end;function B_Goal_NPC:GetIcon()return{14,10}end;RegisterBehavior(B_Goal_NPC)function Goal_ActivateSeveralObjects(...)return B_Goal_ActivateSeveralObjects:new(...)end;B_Goal_ActivateSeveralObjects={Name="Goal_ActivateSeveralObjects",Description={en="Goal: Activate an interactive object",de="Ziel: Aktiviere ein interaktives Objekt",fr="Objectif: activer un objet interactif"},Parameter={{ParameterType.Default,en="Object name 1",de="Skriptname 1",fr="Nom de l'entité 1"},{ParameterType.Default,en="Object name 2",de="Skriptname 2",fr="Nom de l'entité 2"},{ParameterType.Default,en="Object name 3",de="Skriptname 3",fr="Nom de l'entité 3"},{ParameterType.Default,en="Object name 4",de="Skriptname 4",fr="Nom de l'entité 4"}},ScriptNames={}}function B_Goal_ActivateSeveralObjects:GetGoalTable()return{Objective.Object,{unpack(self.ScriptNames)}}end;function B_Goal_ActivateSeveralObjects:AddParameter(m,n)if m==0 then assert(n~=nil and n~="","Goal_ActivateSeveralObjects: At least one IO needed!")end;if n~=nil and n~=""then table.insert(self.ScriptNames,n)end end;function B_Goal_ActivateSeveralObjects:GetMsgKey()return"Quest_Object_Activate"end;RegisterBehavior(B_Goal_ActivateSeveralObjects)B_Reward_ObjectInit.CustomFunction=function(self,l)local aL=GetID(self.ScriptName)if aL==0 then return end;CONST_INITIALIZED_OBJECTS[aL]=l.Identifier;local b2;if self.RewardType and self.RewardType~="-"then b2={Goods[self.RewardType],self.RewardAmount}end;local b3;if self.FirstCostType and self.FirstCostType~="-"then b3=b2 or{}table.insert(b3,Goods[self.FirstCostType])table.insert(b3,Goods[self.FirstCostAmount])end;if self.SecondCostType and self.SecondCostType~="-"then b3=b2 or{}table.insert(b3,Goods[self.SecondCostType])table.insert(b3,Goods[self.SecondCostAmount])end;SetupObject{Name=self.ScriptName,Distance=self.Distance,Waittime=self.Waittime,Reward=b2,Costs=b3}InteractiveObjectActivate(self.ScriptName,self.UsingState)end;function Goal_WinQuest(...)return B_Goal_WinQuest:new(...)end;B_Goal_WinQuest={Name="Goal_WinQuest",Description={en="Goal: The player has to win a given quest.",de="Ziel: Der Spieler muss eine angegebene Quest erfolgreich abschliessen.",fr="Objectif: Le joueur doit réussir une quête indiquée."},Parameter={{ParameterType.QuestName,en="Quest Name",de="Questname",fr="Nom de la quête"}}}function B_Goal_WinQuest:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_WinQuest:AddParameter(m,n)if m==0 then self.Quest=n end end;function B_Goal_WinQuest:CustomFunction(l)local b4=Quests[GetQuestID(self.Quest)]if b4 then if b4.Result==QuestResult.Failure then return false end;if b4.Result==QuestResult.Success then return true end end;return nil end;function B_Goal_WinQuest:Debug(l)if Quests[GetQuestID(self.Quest)]==nil then error(l.Identifier..": "..self.Name..": Quest '"..self.Quest.."' does not exist!")return true end;return false end;RegisterBehavior(B_Goal_WinQuest)function Trigger_OnAtLeastXOfYQuestsFailed(...)return B_Trigger_OnAtLeastXOfYQuestsFailed:new(...)end;B_Trigger_OnAtLeastXOfYQuestsFailed={Name="Trigger_OnAtLeastXOfYQuestsFailed",Description={en="Trigger: if at least X of Y given quests has been finished successfully.",de="Auslöser: wenn X von Y angegebener Quests fehlgeschlagen sind.",fr="Déclencheur: lorsque X des Y quêtes indiquées ont échoué."},Parameter={{ParameterType.Custom,en="Least Amount",de="Mindest Anzahl",fr="Nombre minimum"},{ParameterType.Custom,en="Quest Amount",de="Quest Anzahl",fr="Nombre de quêtes"},{ParameterType.QuestName,en="Quest name 1",de="Questname 1",fr="Nom de la quête 1"},{ParameterType.QuestName,en="Quest name 2",de="Questname 2",fr="Nom de la quête 2"},{ParameterType.QuestName,en="Quest name 3",de="Questname 3",fr="Nom de la quête 3"},{ParameterType.QuestName,en="Quest name 4",de="Questname 4",fr="Nom de la quête 4"},{ParameterType.QuestName,en="Quest name 5",de="Questname 5",fr="Nom de la quête 5"}}}function B_Trigger_OnAtLeastXOfYQuestsFailed:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnAtLeastXOfYQuestsFailed:AddParameter(m,n)if m==0 then self.LeastAmount=tonumber(n)elseif m==1 then self.QuestAmount=tonumber(n)elseif m==2 then self.QuestName1=n elseif m==3 then self.QuestName2=n elseif m==4 then self.QuestName3=n elseif m==5 then self.QuestName4=n elseif m==6 then self.QuestName5=n end end;function B_Trigger_OnAtLeastXOfYQuestsFailed:CustomFunction()local aY=0;for a=1,self.QuestAmount do local a8=GetQuestID(self["QuestName"..a])if IsValidQuest(a8)then if Quests[a8].Result==QuestResult.Failure then aY=aY+1;if aY>=self.LeastAmount then return true end end end end;return false end;function B_Trigger_OnAtLeastXOfYQuestsFailed:Debug(l)local aZ=self.LeastAmount;local a_=self.QuestAmount;if aZ<=0 or aZ>5 then error(l.Identifier..":"..self.Name..": LeastAmount is wrong")return true elseif a_<=0 or a_>5 then error(l.Identifier..": "..self.Name..": QuestAmount is wrong")return true elseif aZ>a_ then error(l.Identifier..": "..self.Name..": LeastAmount is greater than QuestAmount")return true end;for a=1,a_ do if not IsValidQuest(self["QuestName"..a])then error(l.Identifier..": "..self.Name..": Quest "..self["QuestName"..a].." not found")return true end end;return false end;function B_Trigger_OnAtLeastXOfYQuestsFailed:GetCustomData(m)if m==0 or m==1 then return{"1","2","3","4","5"}end end;RegisterBehavior(B_Trigger_OnAtLeastXOfYQuestsFailed)function Trigger_OnExactOneQuestIsWon(...)return B_Trigger_OnExactOneQuestIsWon:new(...)end;B_Trigger_OnExactOneQuestIsWon={Name="Trigger_OnExactOneQuestIsWon",Description={en="Trigger: if one of two given quests has been finished successfully, but NOT both.",de="Auslöser: wenn eine von zwei angegebenen Quests (aber NICHT beide) erfolgreich abgeschlossen wurde.",fr="Déclencheur: lorsque l'une des deux quêtes indiquées (mais PAS les deux) a été accomplie avec succès."},Parameter={{ParameterType.QuestName,en="Quest Name 1",de="Questname 1",fr="Nom de la quête 1"},{ParameterType.QuestName,en="Quest Name 2",de="Questname 2",fr="Nom de la quête 2"}}}function B_Trigger_OnExactOneQuestIsWon:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnExactOneQuestIsWon:AddParameter(m,n)self.QuestTable={}if m==0 then self.Quest1=n elseif m==1 then self.Quest2=n end end;function B_Trigger_OnExactOneQuestIsWon:CustomFunction(l)local aW=Quests[GetQuestID(self.Quest1)]local aX=Quests[GetQuestID(self.Quest2)]if aX and aW then local b5=aW.State==QuestState.Over and aW.Result==QuestResult.Success;local b6=aX.State==QuestState.Over and aX.Result==QuestResult.Success;if b5 and not b6 or not b5 and b6 then return true end end;return false end;function B_Trigger_OnExactOneQuestIsWon:Debug(l)if self.Quest1==self.Quest2 then error(l.Identifier..": "..self.Name..": Both quests are identical!")return true elseif not IsValidQuest(self.Quest1)then error(l.Identifier..": "..self.Name..": Quest '"..self.Quest1 .."' does not exist!")return true elseif not IsValidQuest(self.Quest2)then error(l.Identifier..": "..self.Name..": Quest '"..self.Quest2 .."' does not exist!")return true end;return false end;RegisterBehavior(B_Trigger_OnExactOneQuestIsWon)function Trigger_OnExactOneQuestIsLost(...)return B_Trigger_OnExactOneQuestIsLost:new(...)end;B_Trigger_OnExactOneQuestIsLost={Name="Trigger_OnExactOneQuestIsLost",Description={en="Trigger: If one of two given quests has been lost, but NOT both.",de="Auslöser: Wenn einer von zwei angegebenen Quests (aber NICHT beide) fehlschlägt.",fr="Déclencheur: Si l'une des deux quêtes indiquées (mais PAS les deux) échoue."},Parameter={{ParameterType.QuestName,en="Quest Name 1",de="Questname 1",fr="Nom de la quête 1"},{ParameterType.QuestName,en="Quest Name 2",de="Questname 2",fr="Nom de la quête 2"}}}function B_Trigger_OnExactOneQuestIsLost:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_OnExactOneQuestIsLost:AddParameter(m,n)self.QuestTable={}if m==0 then self.Quest1=n elseif m==1 then self.Quest2=n end end;function B_Trigger_OnExactOneQuestIsLost:CustomFunction(l)local aW=Quests[GetQuestID(self.Quest1)]local aX=Quests[GetQuestID(self.Quest2)]if aX and aW then local b5=aW.State==QuestState.Over and aW.Result==QuestResult.Failure;local b6=aX.State==QuestState.Over and aX.Result==QuestResult.Failure;if b5 and not b6 or not b5 and b6 then return true end end;return false end;function B_Trigger_OnExactOneQuestIsLost:Debug(l)if self.Quest1==self.Quest2 then error(l.Identifier..": "..self.Name..": Both quests are identical!")return true elseif not IsValidQuest(self.Quest1)then error(l.Identifier..": "..self.Name..": Quest '"..self.Quest1 .."' does not exist!")return true elseif not IsValidQuest(self.Quest2)then error(l.Identifier..": "..self.Name..": Quest '"..self.Quest2 .."' does not exist!")return true end;return false end;RegisterBehavior(B_Trigger_OnExactOneQuestIsLost)function Goal_MoveToPosition(...)return B_Goal_MoveToPosition:new(...)end;B_Goal_MoveToPosition={Name="Goal_MoveToPosition",Description={en="Goal: A entity have to moved as close as the distance to another entity. The target can be marked with a static marker.",de="Ziel: Ein Entity muss sich einer anderen bis auf eine bestimmte Distanz nähern. Die Lupe wird angezeigt, das Ziel kann markiert werden.",fr="Objectif: une entité doit s'approcher d'une autre à une distance donnée. La loupe est affichée, la cible peut être marquée."},Parameter={{ParameterType.ScriptName,en="Entity",de="Entity",fr="Entité"},{ParameterType.ScriptName,en="Target",de="Ziel",fr="Cible"},{ParameterType.Number,en="Distance",de="Entfernung",fr="Distance"},{ParameterType.Custom,en="Marker",de="Ziel markieren",fr="Marquer la cible"}}}function B_Goal_MoveToPosition:GetGoalTable()return{Objective.Distance,self.Entity,self.Target,self.Distance,self.Marker}end;function B_Goal_MoveToPosition:AddParameter(m,n)if m==0 then self.Entity=n elseif m==1 then self.Target=n elseif m==2 then self.Distance=n*1 elseif m==3 then self.Marker=ToBoolean(n)end end;function B_Goal_MoveToPosition:GetCustomData(m)local p={}if m==3 then p={"true","false"}end;return p end;RegisterBehavior(B_Goal_MoveToPosition)function Goal_AmmunitionAmount(...)return B_Goal_AmmunitionAmount:new(...)end;B_Goal_AmmunitionAmount={Name="Goal_AmmunitionAmount",Description={en="Goal: Reach a smaller or bigger value than the given amount of ammunition in a war machine.",de="Ziel: Über- oder unterschreite die angegebene Anzahl Munition in einem Kriegsgerät.",fr="Objectif : Dépasser ou ne pas dépasser le nombre de munitions indiqué dans un engin de guerre."},Parameter={{ParameterType.ScriptName,en="Script name",de="Skriptname",fr="Nom de l'entité"},{ParameterType.Custom,en="Relation",de="Relation",fr="Relation"},{ParameterType.Number,en="Amount",de="Menge",fr="Quantité"}}}function B_Goal_AmmunitionAmount:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_AmmunitionAmount:AddParameter(m,n)if m==0 then self.Scriptname=n elseif m==1 then self.bRelSmallerThan=tostring(n)=="true"or n=="<"elseif m==2 then self.Amount=n*1 end end;function B_Goal_AmmunitionAmount:CustomFunction()local aL=GetID(self.Scriptname)if not IsExisting(aL)then return false end;local Z=Logic.GetAmmunitionAmount(aL)if self.bRelSmallerThan and Z<self.Amount or not self.bRelSmallerThan and Z>=self.Amount then return true end;return nil end;function B_Goal_AmmunitionAmount:Debug(l)if self.Amount<0 then error(l.Identifier..": "..self.Name..": Amount is negative")return true end end;function B_Goal_AmmunitionAmount:GetCustomData(m)if m==1 then return{"<",">="}end end;RegisterBehavior(B_Goal_AmmunitionAmount)function Goal_CityReputation(...)return B_Goal_CityReputation:new(...)end;B_Goal_CityReputation={Name="Goal_CityReputation",Description={en="Goal: The reputation of the quest receivers city must at least reach the desired hight.",de="Ziel: Der Ruf der Stadt des Empfängers muss mindestens so hoch sein, wie angegeben.",fr="Objectif: la réputation de la ville du receveur doit être au moins aussi élevée que celle indiquée."},Parameter={{ParameterType.Number,en="City reputation",de="Ruf der Stadt",fr="Réputation de la ville"}},Text={de="RUF DER STADT{cr}{cr}Hebe den Ruf der Stadt durch weise Herrschaft an!{cr}Benötigter Ruf: %d",en="CITY REPUTATION{cr}{cr}Raise your reputation by fair rulership!{cr}Needed reputation: %d",fr="RÉPUTATION DE LA VILLE{cr}{cr} Augmente la réputation de la ville en la gouvernant sagement!{cr}Réputation requise : %d"}}function B_Goal_CityReputation:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_CityReputation:AddParameter(m,n)if m==0 then self.Reputation=n*1 end end;function B_Goal_CityReputation:CustomFunction(l)self:SetCaption(l)local b7=Logic.GetCityReputation(l.ReceivingPlayer)*100;if b7>=self.Reputation then return true end end;function B_Goal_CityReputation:SetCaption(l)if not l.QuestDescription or l.QuestDescription==""then local x=string.format(Localize(self.Text),self.Reputation)Lib.Core.Quest:ChangeCustomQuestCaptionText(x.."%",l)end end;function B_Goal_CityReputation:GetIcon()return{5,14}end;function B_Goal_CityReputation:Debug(l)if type(self.Reputation)~="number"or self.Reputation<0 or self.Reputation>100 then error(l.Identifier..": "..self.Name..": Reputation must be between 0 and 100!")return true end;return false end;RegisterBehavior(B_Goal_CityReputation)function Goal_DestroySpawnedEntities(...)return B_Goal_DestroySpawnedEntities:new(...)end;B_Goal_DestroySpawnedEntities={Name="Goal_DestroySpawnedEntities",Description={en="Goal: Destroy all entities spawned at the spawnpoint.",de="Ziel: Zerstöre alle Entitäten, die bei dem Spawnpoint erzeugt wurde.",fr="Objectif: Détruire toutes les entités créées au point d'apparition."},Parameter={{ParameterType.ScriptName,en="Spawnpoint",de="Spawnpoint",fr="Point d'émergence"},{ParameterType.Number,en="Amount",de="Menge",fr="Quantité"},{ParameterType.Custom,en="Name is prefixed",de="Name ist Präfix",fr="Le nom est un préfixe"}}}function B_Goal_DestroySpawnedEntities:GetGoalTable()if self.Prefixed then local b8=table.remove(self.SpawnPoint)local a=1;while IsExisting(b8 ..a)do table.insert(self.SpawnPoint,b8 ..a)a=a+1 end;assert(#self.SpawnPoint>0,"No spawnpoints found!")end;return{Objective.DestroyEntities,3,self.SpawnPoint,self.Amount}end;function B_Goal_DestroySpawnedEntities:AddParameter(m,n)if m==0 then self.SpawnPoint={n}elseif m==1 then self.Amount=n*1 elseif m==2 then n=n or"false"self.Prefixed=ToBoolean(n)end end;function B_Goal_DestroySpawnedEntities:GetMsgKey()local A=GetID(self.SpawnPoint[1])if A~=0 then local b9=Logic.GetEntityTypeName(Logic.GetEntityType(A))if Logic.IsEntityTypeInCategory(A,EntityCategories.AttackableBuilding)==1 then return"Quest_Destroy_Leader"elseif b9:find("Bear")or b9:find("Lion")or b9:find("Tiger")or b9:find("Wolf")then return"Quest_DestroyEntities_Predators"elseif b9:find("Military")or b9:find("Cart")then return"Quest_DestroyEntities_Unit"end end;return"Quest_DestroyEntities"end;function B_Goal_DestroySpawnedEntities:GetCustomData(m)if m==2 then return{"false","true"}end end;RegisterBehavior(B_Goal_DestroySpawnedEntities)function Goal_StealGold(...)return B_Goal_StealGold:new(...)end;B_Goal_StealGold={Name="Goal_StealGold",Description={en="Goal: Steal an explicit amount of gold from a players or any players city buildings.",de="Ziel: Diebe sollen eine bestimmte Menge Gold aus feindlichen Stadtgebäuden stehlen.",fr="Objectif: les voleurs doivent dérober une certaine quantité d'or dans les bâtiments urbains ennemis."},Parameter={{ParameterType.Number,en="Amount on Gold",de="Zu stehlende Menge",fr="Quantité à voler"},{ParameterType.Custom,en="Target player",de="Spieler von dem gestohlen wird",fr="Joueur à qui l'on vole"},{ParameterType.Custom,en="Cheat earnings",de="Einnahmen generieren",fr="Générer des revenus"},{ParameterType.Custom,en="Print progress",de="Fortschritt ausgeben",fr="Afficher les progrès"}}}function B_Goal_StealGold:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_StealGold:AddParameter(m,n)if m==0 then self.Amount=n*1 elseif m==1 then local an=tonumber(n)or-1;self.Target=an*1 elseif m==2 then n=n or"false"self.CheatEarnings=ToBoolean(n)elseif m==3 then n=n or"true"self.Printout=ToBoolean(n)end;self.StohlenGold=0 end;function B_Goal_StealGold:GetCustomData(m)if m==1 then return{"-",1,2,3,4,5,6,7,8}elseif m==2 then return{"true","false"}end end;function B_Goal_StealGold:SetDescriptionOverwrite(l)local ba=Localize({de=" anderen Spielern ",en=" different parties ",fr=" d'autres joueurs "})if self.Target~=-1 then ba=GetPlayerName(self.Target)if ba==nil or ba==""then ba=" PLAYER_NAME_MISSING "end end;if self.CheatEarnings then local bb={self.Target}if self.Target==-1 then bb={1,2,3,4,5,6,7,8}end;for a=1,#bb,1 do if a~=l.ReceivingPlayer and Logic.GetStoreHouse(a)~=0 then local bc={Logic.GetPlayerEntitiesInCategory(a,EntityCategories.CityBuilding)}for e=1,#bc,1 do local bd=Logic.GetBuildingProductEarnings(bc[e])if bd<45 and Logic.GetTime()%5==0 then Logic.SetBuildingEarnings(bc[e],bd+1)end end end end end;local W=self.Amount-self.StohlenGold;W=W>0 and W or 0;local be={de="Gold von %s stehlen {cr}{cr}Aus Stadtgebäuden zu stehlende Goldmenge: %d",en="Steal gold from %s {cr}{cr}Amount on gold to steal from city buildings: %d",fr="Voler l'or de %s {cr}{cr}Quantité d'or à voler dans les bâtiments de la ville : %d"}return"{center}"..string.format(Localize(be),ba,W)end;function B_Goal_StealGold:CustomFunction(l)Lib.Core.Quest:ChangeCustomQuestCaptionText(self:SetDescriptionOverwrite(l),l)if self.StohlenGold>=self.Amount then return true end;return nil end;function B_Goal_StealGold:GetIcon()return{5,13}end;function B_Goal_StealGold:Debug(l)if tonumber(self.Amount)==nil and self.Amount<0 then error(l.Identifier..": "..self.Name..": amount can not be negative!")return true end;return false end;function B_Goal_StealGold:Reset(l)self.StohlenGold=0 end;RegisterBehavior(B_Goal_StealGold)function Goal_StealFromBuilding(...)return B_Goal_StealFromBuilding:new(...)end;B_Goal_StealFromBuilding={Name="Goal_StealFromBuilding",Description={en="Goal: The player has to steal from a building. Not a castle and not a village storehouse!",de="Ziel: Der Spieler muss ein bestimmtes Gebäude bestehlen. Dies darf keine Burg und kein Dorflagerhaus sein!",fr="Objectif: Le joueur doit voler un bâtiment spécifique. Il ne peut s'agir ni d'un château ni d'un entrepôt de village !"},Parameter={{ParameterType.ScriptName,en="Building",de="Gebäude",fr="Bâtiment"},{ParameterType.Custom,en="Cheat earnings",de="Einnahmen generieren",fr="Générer des revenus"}}}function B_Goal_StealFromBuilding:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_StealFromBuilding:AddParameter(m,n)if m==0 then self.Building=n elseif m==1 then n=n or"false"self.CheatEarnings=ToBoolean(n)end;self.RobberList={}end;function B_Goal_StealFromBuilding:GetCustomData(m)if m==1 then return{"true","false"}end end;function B_Goal_StealFromBuilding:SetDescriptionOverwrite(l)local bf=Logic.IsEntityInCategory(GetID(self.Building),EntityCategories.Cathedrals)==1;local bg=Logic.GetEntityType(GetID(self.Building))==Entities.B_StoreHouse;local bh=Logic.GetEntityType(GetID(self.Building))==Entities.B_Cistern;local be;if bf then be={de="Sabotage {cr}{cr} Sendet einen Dieb und sabotiert die markierte Kirche.",en="Sabotage {cr}{cr} Send a thief to sabotage the marked chapel.",fr="Sabotage {cr}{cr} Envoyez un voleur pour saboter la chapelle marquée."}elseif bg then be={de="Lagerhaus bestehlen {cr}{cr} Sendet einen Dieb in das markierte Lagerhaus.",en="Steal from storehouse {cr}{cr} Steal from the marked storehouse.",fr="Voler un entrepôt {cr}{cr} Envoie un voleur dans l'entrepôt marqué."}elseif bh then be={de="Sabotage {cr}{cr} Sendet einen Dieb und sabotiert den markierten Brunnen.",en="Sabotage {cr}{cr} Send a thief and break the marked well of the enemy.",fr="Sabotage {cr}{cr} Envoie un voleur et sabote le puits marqué."}else be={de="Gebäude bestehlen {cr}{cr} Sendet einen Dieb und bestehlt das markierte Gebäude.",en="Steal from building {cr}{cr} Send a thief to steal from the marked building.",fr="Voler un bâtiment {cr}{cr} Envoie un voleur et vole le bâtiment marqué."}end;return"{center}"..Localize(be)end;function B_Goal_StealFromBuilding:CustomFunction(l)if not IsExisting(self.Building)then if self.Marker then Logic.DestroyEffect(self.Marker)end;return false end;if not self.Marker then local at=GetPosition(self.Building)self.Marker=Logic.CreateEffect(EGL_Effects.E_Questmarker,at.X,at.Y,0)end;if self.CheatEarnings then local bi=GetID(self.Building)local bd=Logic.GetBuildingProductEarnings(bi)if Logic.IsEntityInCategory(bi,EntityCategories.CityBuilding)==1 and bd<45 and Logic.GetTime()%5==0 then Logic.SetBuildingEarnings(bi,bd+1)end end;if self.SuccessfullyStohlen then Logic.DestroyEffect(self.Marker)return true end;return nil end;function B_Goal_StealFromBuilding:GetIcon()return{5,13}end;function B_Goal_StealFromBuilding:Debug(l)local bj=Logic.GetEntityTypeName(Logic.GetEntityType(GetID(self.Building)))local bk=Logic.IsEntityInCategory(GetID(self.Building),EntityCategories.Headquarters)==1;if Logic.IsBuilding(GetID(self.Building))==0 then error(l.Identifier..": "..self.Name..": target is not a building")return true elseif not IsExisting(self.Building)then error(l.Identifier..": "..self.Name..": target is destroyed :(")return true elseif string.find(bj,"B_NPC_BanditsHQ")or string.find(bj,"B_NPC_Cloister")or string.find(bj,"B_NPC_StoreHouse")then error(l.Identifier..": "..self.Name..": village storehouses are not allowed!")return true elseif bk then error(l.Identifier..": "..self.Name..": use Goal_StealInformation for headquarters!")return true end;return false end;function B_Goal_StealFromBuilding:Reset(l)self.SuccessfullyStohlen=false;self.RobberList={}self.Marker=nil end;function B_Goal_StealFromBuilding:Interrupt(l)Logic.DestroyEffect(self.Marker)end;RegisterBehavior(B_Goal_StealFromBuilding)function Goal_SpyOnBuilding(...)return B_Goal_SpyOnBuilding:new(...)end;B_Goal_SpyOnBuilding={Name="Goal_SpyOnBuilding",IconOverwrite={5,13},Description={en="Goal: Infiltrate a building with a thief. A thief must be able to steal from the target building.",de="Ziel: Infiltriere ein Gebäude mit einem Dieb. Nur mit Gebaueden möglich, die bestohlen werden koennen.",fr="Objectif: Infiltrer un bâtiment avec un voleur. Seulement possible avec des bâtiments qui peuvent être volés."},Parameter={{ParameterType.ScriptName,en="Target Building",de="Zielgebäude",fr="Bâtiment cible"},{ParameterType.Custom,en="Cheat earnings",de="Einnahmen generieren",fr="Générer des revenus"},{ParameterType.Custom,en="Destroy Thief",de="Dieb löschen",fr="Supprimer le voleur"}}}function B_Goal_SpyOnBuilding:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_SpyOnBuilding:AddParameter(m,n)if m==0 then self.Building=n elseif m==1 then n=n or"false"self.CheatEarnings=ToBoolean(n)elseif m==2 then n=n or"true"self.Delete=ToBoolean(n)end end;function B_Goal_SpyOnBuilding:GetCustomData(m)if m==1 then return{"true","false"}end end;function B_Goal_SpyOnBuilding:SetDescriptionOverwrite(l)if not l.QuestDescription then local be={de="Gebäude infriltrieren {cr}{cr}Spioniere das markierte Gebäude mit einem Dieb aus!",en="Infiltrate building {cr}{cr}Spy on the highlighted buildings with a thief!",fr="Infiltrer un bâtiment {cr}{cr}Espionner le bâtiment marqué avec un voleur!"}return Localize(be)else return l.QuestDescription end end;function B_Goal_SpyOnBuilding:CustomFunction(l)if not IsExisting(self.Building)then if self.Marker then Logic.DestroyEffect(self.Marker)end;return false end;if not self.Marker then local at=GetPosition(self.Building)self.Marker=Logic.CreateEffect(EGL_Effects.E_Questmarker,at.X,at.Y,0)end;if self.CheatEarnings then local bi=GetID(self.Building)if Logic.IsEntityInCategory(bi,EntityCategories.CityBuilding)==1 and Logic.GetBuildingEarnings(bi)<5 then Logic.SetBuildingEarnings(bi,5)end end;if self.Infiltrated then Logic.DestroyEffect(self.Marker)return true end;return nil end;function B_Goal_SpyOnBuilding:GetIcon()return self.IconOverwrite end;function B_Goal_SpyOnBuilding:Debug(l)if Logic.IsBuilding(GetID(self.Building))==0 then error(l.Identifier..": "..self.Name..": target is not a building")return true elseif not IsExisting(self.Building)then error(l.Identifier..": "..self.Name..": target is destroyed :(")return true end;return false end;function B_Goal_SpyOnBuilding:Reset(l)self.Infiltrated=false;self.Marker=nil end;function B_Goal_SpyOnBuilding:Interrupt(l)Logic.DestroyEffect(self.Marker)end;RegisterBehavior(B_Goal_SpyOnBuilding)function Goal_DestroySoldiers(...)return B_Goal_DestroySoldiers:new(...)end;B_Goal_DestroySoldiers={Name="Goal_DestroySoldiers",Description={en="Goal: Destroy a given amount of enemy soldiers",de="Ziel: Zerstöre eine Anzahl gegnerischer Soldaten",fr="Objectif: Détruire un certain nombre de soldats ennemis"},Parameter={{ParameterType.PlayerID,en="Attacking Player",de="Angreifer",fr="Attaquant"},{ParameterType.PlayerID,en="Defending Player",de="Verteidiger",fr="Défenseur"},{ParameterType.Number,en="Amount",de="Anzahl",fr="Quantité"}},Text={de="{center}SOLDATEN ZERSTÖREN {cr}{cr}von der Partei: %s{cr}{cr}Anzahl: %d",en="{center}DESTROY SOLDIERS {cr}{cr}from faction: %s{cr}{cr}Amount: %d",fr="{center}DESTRUIRE DES SOLDATS {cr}{cr}de la faction: %s{cr}{cr}Nombre : %d"}}function B_Goal_DestroySoldiers:GetGoalTable()return{Objective.Custom2,{self,self.CustomFunction}}end;function B_Goal_DestroySoldiers:AddParameter(m,n)if m==0 then self.AttackingPlayer=n*1 elseif m==1 then self.AttackedPlayer=n*1 elseif m==2 then self.KillsNeeded=n*1 end end;function B_Goal_DestroySoldiers:CustomFunction(l)if not l.QuestDescription or l.QuestDescription==""then local w=GetPlayerName(self.AttackedPlayer)or"Player "..self.AttackedPlayer;Lib.Core.Quest:ChangeCustomQuestCaptionText(string.format(Swift.Text:Localize(self.Text),w,self.KillsNeeded),l)end;local bl=Lib.QuestBehavior.Global:GetEnemySoldierKillsOfPlayer(self.AttackingPlayer,self.AttackedPlayer)if self.KillsNeeded<=bl then return true end end;function B_Goal_DestroySoldiers:Debug(l)if Logic.GetStoreHouse(self.AttackingPlayer)==0 then error(l.Identifier..": "..self.Name..": Player "..self.AttackinPlayer.." is dead :-(")return true elseif Logic.GetStoreHouse(self.AttackedPlayer)==0 then error(l.Identifier..": "..self.Name..": Player "..self.AttackedPlayer.." is dead :-(")return true elseif self.KillsNeeded<0 then error(l.Identifier..": "..self.Name..": Amount negative")return true end end;function B_Goal_DestroySoldiers:GetIcon()return{7,12}end;RegisterBehavior(B_Goal_DestroySoldiers)function Reprisal_SetPosition(...)return B_Reprisal_SetPosition:new(...)end;B_Reprisal_SetPosition={Name="Reprisal_SetPosition",Description={en="Reprisal: Places an entity relative to the position of another. The entity can look the target.",de="Vergeltung: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden.",fr="Rétribution: place une Entity vis-à-vis de l'emplacement d'une autre. L'entité peut être orientée vers la cible."},Parameter={{ParameterType.ScriptName,en="Entity",de="Entity",fr="Entité"},{ParameterType.ScriptName,en="Target position",de="Zielposition",fr="Position cible"},{ParameterType.Custom,en="Face to face",de="Ziel ansehen",fr="Voir la cible"},{ParameterType.Number,en="Distance",de="Zielentfernung",fr="Distance de la cible"}}}function B_Reprisal_SetPosition:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_SetPosition:AddParameter(m,n)if m==0 then self.Entity=n elseif m==1 then self.Target=n elseif m==2 then self.FaceToFace=ToBoolean(n)elseif m==3 then self.Distance=n~=nil and tonumber(n)or 100 end end;function B_Reprisal_SetPosition:CustomFunction(l)if not IsExisting(self.Entity)or not IsExisting(self.Target)then return end;local ax=GetID(self.Entity)local bm=GetID(self.Target)local O,P,Q=Logic.EntityGetPos(bm)if Logic.IsBuilding(bm)==1 then O,P=Logic.GetBuildingApproachPosition(bm)end;local bn=Logic.GetEntityOrientation(bm)+90;if self.FaceToFace then O=O+self.Distance*math.cos(math.rad(bn))P=P+self.Distance*math.sin(math.rad(bn))Logic.DEBUG_SetSettlerPosition(ax,O,P)LookAt(self.Entity,self.Target)else if Logic.IsBuilding(bm)==1 then O,P=Logic.GetBuildingApproachPosition(bm)end;Logic.DEBUG_SetSettlerPosition(ax,O,P)end end;function B_Reprisal_SetPosition:GetCustomData(m)if m==2 then return{"true","false"}end end;function B_Reprisal_SetPosition:Debug(l)if self.FaceToFace then if tonumber(self.Distance)==nil or self.Distance<50 then error(l.Identifier..": "..self.Name..": Distance is nil or to short!")return true end end;if not IsExisting(self.Entity)or not IsExisting(self.Target)then error(l.Identifier..": "..self.Name..": Mover entity or target entity does not exist!")return true end;return false end;RegisterBehavior(B_Reprisal_SetPosition)function Reprisal_ChangePlayer(...)return B_Reprisal_ChangePlayer:new(...)end;B_Reprisal_ChangePlayer={Name="Reprisal_ChangePlayer",Description={en="Reprisal: Changes the owner of the entity or a battalion.",de="Vergeltung: Aendert den Besitzer einer Entity oder eines Battalions.",fr="Rétribution : Change le propriétaire d'une entité ou d'un bataillon."},Parameter={{ParameterType.ScriptName,en="Entity",de="Entity",fr="Entité"},{ParameterType.Custom,en="Player",de="Spieler",fr="Joueur"}}}function B_Reprisal_ChangePlayer:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_ChangePlayer:AddParameter(m,n)if m==0 then self.Entity=n elseif m==1 then self.Player=tostring(n)end end;function B_Reprisal_ChangePlayer:CustomFunction(l)if not IsExisting(self.Entity)then return end;local ad=GetID(self.Entity)if Logic.IsLeader(ad)==1 then Logic.ChangeSettlerPlayerID(ad,self.Player)else Logic.ChangeEntityPlayerID(ad,self.Player)end end;function B_Reprisal_ChangePlayer:GetCustomData(m)if m==1 then return{"0","1","2","3","4","5","6","7","8"}end end;function B_Reprisal_ChangePlayer:Debug(l)if not IsExisting(self.Entity)then error(l.Identifier..": "..self.Name..": entity '"..self.Entity.."' does not exist!")return true end;return false end;RegisterBehavior(B_Reprisal_ChangePlayer)function Reprisal_SetVisible(...)return B_Reprisal_SetVisible:new(...)end;B_Reprisal_SetVisible={Name="Reprisal_SetVisible",Description={en="Reprisal: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected.",de="Vergeltung: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst.",fr="Rétribution: fixe la visibilité d'une Entité. S'il s'agit d'un spawn, les Entities spawnées sont également affectées."},Parameter={{ParameterType.ScriptName,en="Entity",de="Entity",fr="Entité"},{ParameterType.Custom,en="Visible",de="Sichtbar",fr="Visible"}}}function B_Reprisal_SetVisible:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_SetVisible:AddParameter(m,n)if m==0 then self.Entity=n elseif m==1 then self.Visible=ToBoolean(n)end end;function B_Reprisal_SetVisible:CustomFunction(l)if not IsExisting(self.Entity)then return end;local ad=GetID(self.Entity)local ah=Logic.EntityGetPlayer(ad)local bo=Logic.GetEntityType(ad)local bp=Logic.GetEntityTypeName(bo)if string.find(bp,"^S_")or string.find(bp,"^B_NPC_Bandits")or string.find(bp,"^B_NPC_Barracks")then local bq={Logic.GetSpawnedEntities(ad)}for a=1,#bq do if Logic.IsLeader(bq[a])==1 then local br={Logic.GetSoldiersAttachedToLeader(bq[a])}for e=2,#br do Logic.SetVisible(br[e],self.Visible)end else Logic.SetVisible(bq[a],self.Visible)end end else if Logic.IsLeader(ad)==1 then local br={Logic.GetSoldiersAttachedToLeader(ad)}for e=2,#br do Logic.SetVisible(br[e],self.Visible)end else Logic.SetVisible(ad,self.Visible)end end end;function B_Reprisal_SetVisible:GetCustomData(m)if m==1 then return{"true","false"}end end;function B_Reprisal_SetVisible:Debug(l)if not IsExisting(self.Entity)then error(l.Identifier..": "..self.Name..": entity '"..self.Entity.."' does not exist!")return true end;return false end;RegisterBehavior(B_Reprisal_SetVisible)function Reprisal_SetVulnerability(...)return B_Reprisal_SetVulnerability:new(...)end;B_Reprisal_SetVulnerability={Name="Reprisal_SetVulnerability",Description={en="Reprisal: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected.",de="Vergeltung: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen.",fr="Rétribution: rend une Entité vulnérable ou invulnérable. S'il s'agit d'un spawn, les Entities spawnées sont affectées."},Parameter={{ParameterType.ScriptName,en="Entity",de="Entity",fr="Entité"},{ParameterType.Custom,en="Vulnerability",de="Verwundbar",fr="Vulnérabilité"}}}function B_Reprisal_SetVulnerability:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_SetVulnerability:AddParameter(m,n)if m==0 then self.Entity=n elseif m==1 then self.Vulnerability=ToBoolean(n)end end;function B_Reprisal_SetVulnerability:CustomFunction(l)if not IsExisting(self.Entity)then return end;local ad=GetID(self.Entity)local bo=Logic.GetEntityType(ad)local bp=Logic.GetEntityTypeName(bo)local bs={ad}if string.find(bp,"S_")or string.find(bp,"B_NPC_Bandits")or string.find(bp,"B_NPC_Barracks")then bs={Logic.GetSpawnedEntities(ad)}end;local bt="MakeInvulnerable"if self.Vulnerability then bt="MakeVulnerable"end;for a=1,#bs,1 do if Logic.IsLeader(bs[a])==1 then local bu={Logic.GetSoldiersAttachedToLeader(bs[a])}for e=2,#bu,1 do _G[bt](bu[e])end end;_G[bt](bs[a])end end;function B_Reprisal_SetVulnerability:GetCustomData(m)if m==1 then return{"true","false"}end end;function B_Reprisal_SetVulnerability:Debug(l)if not IsExisting(self.Entity)then error(l.Identifier..": "..self.Name..": entity '"..self.Entity.."' does not exist!")return true end;return false end;RegisterBehavior(B_Reprisal_SetVulnerability)function Reprisal_SetModel(...)return B_Reprisal_SetModel:new(...)end;B_Reprisal_SetModel={Name="Reprisal_SetModel",Description={en="Reprisal: Changes the model of the entity. Be careful, some models crash the game.",de="Vergeltung: Ändert das Model einer Entity. Achtung: Einige Modelle führen zum Absturz.",fr="Rétribution: modifie le modèle d'une entité. Attention: certains modèles entraînent un crash."},Parameter={{ParameterType.ScriptName,en="Entity",de="Entity",fr="Entité"},{ParameterType.Custom,en="Model",de="Model",fr="Modèle"}}}function B_Reprisal_SetModel:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_SetModel:AddParameter(m,n)if m==0 then self.Entity=n elseif m==1 then self.Model=n end end;function B_Reprisal_SetModel:CustomFunction(l)if not IsExisting(self.Entity)then return end;local ad=GetID(self.Entity)Logic.SetModel(ad,Models[self.Model])end;function B_Reprisal_SetModel:GetCustomData(m)if m==1 then return Lib.QuestBehavior.Global:GetPossibleModels()end end;function B_Reprisal_SetModel:Debug(l)if not IsExisting(self.Entity)then error(l.Identifier..": "..self.Name..": entity '"..self.Entity.."' does not exist!")return true end;if not Models[self.Model]then error(l.Identifier..": "..self.Name..": model '"..self.Entity.."' does not exist!")return true end;return false end;RegisterBehavior(B_Reprisal_SetModel)function Reward_SetPosition(...)return B_Reward_SetPosition:new(...)end;B_Reward_SetPosition=CopyTable(B_Reprisal_SetPosition)B_Reward_SetPosition.Name="Reward_SetPosition"B_Reward_SetPosition.Description.en="Reward: Places an entity relative to the position of another. The entity can look the target."B_Reward_SetPosition.Description.de="Lohn: Setzt eine Entity relativ zur Position einer anderen. Die Entity kann zum Ziel ausgerichtet werden."B_Reward_SetPosition.Description.fr="Récompense: Définit une Entity vis-à-vis de la position d'une autre. L'entité peut être orientée vers la cible."B_Reward_SetPosition.GetReprisalTable=nil;B_Reward_SetPosition.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_SetPosition)function Reward_ChangePlayer(...)return B_Reward_ChangePlayer:new(...)end;B_Reward_ChangePlayer=CopyTable(B_Reprisal_ChangePlayer)B_Reward_ChangePlayer.Name="Reward_ChangePlayer"B_Reward_ChangePlayer.Description.en="Reward: Changes the owner of the entity or a battalion."B_Reward_ChangePlayer.Description.de="Lohn: Ändert den Besitzer einer Entity oder eines Battalions."B_Reward_ChangePlayer.Description.fr="Récompense: Change le propriétaire d'une entité ou d'un bataillon."B_Reward_ChangePlayer.GetReprisalTable=nil;B_Reward_ChangePlayer.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_ChangePlayer)function Reward_MoveToPosition(...)return B_Reward_MoveToPosition:new(...)end;B_Reward_MoveToPosition={Name="Reward_MoveToPosition",Description={en="Reward: Moves an entity relative to another entity. If angle is zero the entities will be standing directly face to face.",de="Lohn: Bewegt eine Entity relativ zur Position einer anderen. Wenn Winkel 0 ist, stehen sich die Entities direkt gegenüber.",fr="Récompense: Déplace une entité par rapport à la position d'une autre. Si l'angle est égal à 0, les entités sont directement opposées."},Parameter={{ParameterType.ScriptName,en="Settler",de="Siedler",fr="Settler"},{ParameterType.ScriptName,en="Destination",de="Ziel",fr="Destination"},{ParameterType.Number,en="Distance",de="Entfernung",fr="Distance"},{ParameterType.Number,en="Angle",de="Winkel",fr="Angle"}}}function B_Reward_MoveToPosition:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_MoveToPosition:AddParameter(m,n)if m==0 then self.Entity=n elseif m==1 then self.Target=n elseif m==2 then self.Distance=n*1 elseif m==3 then self.Angle=n*1 end end;function B_Reward_MoveToPosition:CustomFunction(l)if not IsExisting(self.Entity)or not IsExisting(self.Target)then return end;self.Angle=self.Angle or 0;local ax=GetID(self.Entity)local bm=GetID(self.Target)local aA=Logic.GetEntityOrientation(bm)local O,P,Q=Logic.EntityGetPos(bm)if Logic.IsBuilding(bm)==1 then O,P=Logic.GetBuildingApproachPosition(bm)aA=aA-90 end;O=O+self.Distance*math.cos(math.rad(aA+self.Angle))P=P+self.Distance*math.sin(math.rad(aA+self.Angle))Logic.MoveSettler(ax,O,P)self.EntityMovingJob=RequestJob(function(bv,bw)if Logic.IsEntityMoving(bv)==false then LookAt(bv,bw)return true end end,ax,bm)end;function B_Reward_MoveToPosition:Reset(l)if self.EntityMovingJob then EndJob(self.EntityMovingJob)end end;function B_Reward_MoveToPosition:Debug(l)if tonumber(self.Distance)==nil or self.Distance<50 then error(l.Identifier..": "..self.Name..": Distance is nil or to short!")return true elseif not IsExisting(self.Entity)or not IsExisting(self.Target)then error(l.Identifier..": "..self.Name..": Mover entity or target entity does not exist!")return true end;return false end;RegisterBehavior(B_Reward_MoveToPosition)function Reward_VictoryWithParty()return B_Reward_VictoryWithParty:new()end;B_Reward_VictoryWithParty={Name="Reward_VictoryWithParty",Description={en="Reward: (Singleplayer) The player wins the game with an animated festival on the market. Continue playing deleates the festival.",de="Lohn: (Einzelspieler) Der Spieler gewinnt das Spiel mit einer animierten Siegesfeier. Bei weiterspielen wird das Fest gelöscht.",fr="Récompense: (Joueur unique) Le joueur gagne la partie avec une fête de la victoire animée. Si le joueur continue à jouer, la fête est effacée."},Parameter={}}function B_Reward_VictoryWithParty:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_VictoryWithParty:AddParameter(m,n)end;function B_Reward_VictoryWithParty:CustomFunction(l)if Framework.IsNetworkGame()then error(l.Identifier..": "..self.Name..": Can not be used in multiplayer!")return end;Victory(g_VictoryAndDefeatType.VictoryMissionComplete)local an=l.ReceivingPlayer;local bx=Logic.GetMarketplace(an)if IsExisting(bx)then local at=GetPosition(bx)Logic.CreateEffect(EGL_Effects.FXFireworks01,at.X,at.Y,0)Logic.CreateEffect(EGL_Effects.FXFireworks02,at.X,at.Y,0)local by=self:GenerateParty(an)Lib.QuestBehavior.Global.VictoryWithPartyEntities[an]=by;Logic.ExecuteInLuaLocalState(string.format([[
                local MarketID = %d
                if IsExisting(MarketID) then
                    CameraAnimation.AllowAbort = false
                    CameraAnimation.QueueAnimation(CameraAnimation.SetCameraToEntity, MarketID)
                    CameraAnimation.QueueAnimation(CameraAnimation.StartCameraRotation, 5)
                    CameraAnimation.QueueAnimation(CameraAnimation.Stay ,9999)
                end

                GUI_Window.ContinuePlayingClicked_Orig_Reward_VictoryWithParty = GUI_Window.ContinuePlayingClicked
                GUI_Window.ContinuePlayingClicked = function()
                    GUI_Window.ContinuePlayingClicked_Orig_Reward_VictoryWithParty()
                    
                    local PlayerID = GUI.GetPlayerID()
                    GUI.SendScriptCommand("B_Reward_VictoryWithParty:ClearParty(" ..PlayerID.. ")")

                    CameraAnimation.AllowAbort = true
                    CameraAnimation.Abort()
                end
            ]],bx))end end;function B_Reward_VictoryWithParty:ClearParty(G)if Lib.QuestBehavior.Global.VictoryWithPartyEntities[G]then for q,r in pairs(Lib.QuestBehavior.Global.VictoryWithPartyEntities[G])do DestroyEntity(r)end;Lib.QuestBehavior.Global.VictoryWithPartyEntities[G]=nil end end;function B_Reward_VictoryWithParty:GenerateParty(G)local bz={}local bA=Logic.GetMarketplace(G)if bA~=nil and bA~=0 then local bB,bC=Logic.GetEntityPosition(bA)local A=Logic.CreateEntity(Entities.D_X_Garland,bB,bC,0,G)table.insert(bz,A)for e=1,10 do for q=1,10 do local bD=bB-700+e*150;local bE=bC-700+q*150;local bF=math.random(1,100)if bF>70 then local bG=GetRandomSettlerType()local bH=math.random(1,359)local bI=Logic.CreateEntityOnUnblockedLand(bG,bD,bE,bH,G)Logic.SetTaskList(bI,TaskLists.TL_WORKER_FESTIVAL_APPLAUD_SPEECH)table.insert(bz,bI)end end end end;return bz end;function B_Reward_VictoryWithParty:Debug(l)if Lib.QuestBehavior.Global.VictoryWithPartyEntities[l.ReceivingPlayer]then error(l.Identifier..": "..self.Name..": Victory festival already started for player "..l.ReceivingPlayer.."!")return true end;return false end;RegisterBehavior(B_Reward_VictoryWithParty)function Reward_SetVisible(...)return B_Reward_SetVisible:new(...)end;B_Reward_SetVisible=CopyTable(B_Reprisal_SetVisible)B_Reward_SetVisible.Name="Reward_SetVisible"B_Reward_SetVisible.Description.en="Reward: Changes the visibility of an entity. If the entity is a spawner the spawned entities will be affected."B_Reward_SetVisible.Description.de="Lohn: Setzt die Sichtbarkeit einer Entity. Handelt es sich um einen Spawner werden auch die gespawnten Entities beeinflusst."B_Reward_SetVisible.Description.fr="Récompense: Définit la visibilité d'une Entity. S'il s'agit d'un spawn, les entités spawnées sont également influencées."B_Reward_SetVisible.GetReprisalTable=nil;B_Reward_SetVisible.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_SetVisible)function Reward_SetVulnerability(...)return B_Reward_SetVulnerability:new(...)end;B_Reward_SetVulnerability=CopyTable(B_Reprisal_SetVulnerability)B_Reward_SetVulnerability.Name="Reward_SetVulnerability"B_Reward_SetVulnerability.Description.en="Reward: Changes the vulnerability of the entity. If the entity is a spawner the spawned entities will be affected."B_Reward_SetVulnerability.Description.de="Lohn: Macht eine Entity verwundbar oder unverwundbar. Handelt es sich um einen Spawner, sind die gespawnten Entities betroffen."B_Reward_SetVulnerability.Description.fr="Récompense: Rend une Entité vulnérable ou invulnérable. S'il s'agit d'un spawn, les entités spawnées sont affectées."B_Reward_SetVulnerability.GetReprisalTable=nil;B_Reward_SetVulnerability.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_SetVulnerability)function Reward_SetModel(...)return B_Reward_SetModel:new(...)end;B_Reward_SetModel=CopyTable(B_Reprisal_SetModel)B_Reward_SetModel.Name="Reward_SetModel"B_Reward_SetModel.Description.en="Reward: Changes the model of the entity. Be careful, some models crash the game."B_Reward_SetModel.Description.de="Lohn: Ändert das Model einer Entity. Achtung: Einige Modelle führen zum Absturz."B_Reward_SetModel.Description.fr="Récompense: Modifie le modèle d'une entité. Attention : certains modèles entraînent un plantage."B_Reward_SetModel.GetReprisalTable=nil;B_Reward_SetModel.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;RegisterBehavior(B_Reward_SetModel)function Reward_AI_SetEntityControlled(...)return B_Reward_AI_SetEntityControlled:new(...)end;B_Reward_AI_SetEntityControlled={Name="Reward_AI_SetEntityControlled",Description={en="Reward: Bind or Unbind an entity or a battalion to/from an AI player. The AI player must be activated!",de="Lohn: Die KI kontrolliert die Entity oder der KI die Kontrolle entziehen. Die KI muss aktiv sein!",fr="Récompense: L'IA contrôle l'entité ou retirer le contrôle à l'IA. L'IA doit être active !"},Parameter={{ParameterType.ScriptName,en="Entity",de="Entity",fr="Entité"},{ParameterType.Custom,en="AI control entity",de="KI kontrolliert Entity",fr="L'IA contrôle l'entité"}}}function B_Reward_AI_SetEntityControlled:GetRewardTable()return{Reward.Custom,{self,self.CustomFunction}}end;function B_Reward_AI_SetEntityControlled:AddParameter(m,n)if m==0 then self.Entity=n elseif m==1 then self.Hidden=ToBoolean(n)end end;function B_Reward_AI_SetEntityControlled:CustomFunction(l)if not IsExisting(self.Entity)then return end;local ad=GetID(self.Entity)local ah=Logic.EntityGetPlayer(ad)local bo=Logic.GetEntityType(ad)local bp=Logic.GetEntityTypeName(bo)if string.find(bp,"S_")or string.find(bp,"B_NPC_Bandits")or string.find(bp,"B_NPC_Barracks")then local bq={Logic.GetSpawnedEntities(ad)}for a=1,#bq do if Logic.IsLeader(bq[a])==1 then AICore.HideEntityFromAI(ah,bq[a],not self.Hidden)end end else AICore.HideEntityFromAI(ah,ad,not self.Hidden)end end;function B_Reward_AI_SetEntityControlled:GetCustomData(m)if m==1 then return{"false","true"}end end;function B_Reward_AI_SetEntityControlled:Debug(l)if not IsExisting(self.Entity)then error(l.Identifier..": "..self.Name..": entity '"..self.Entity.."' does not exist!")return true end;return false end;RegisterBehavior(B_Reward_AI_SetEntityControlled)function Trigger_AmmunitionDepleted(...)return B_Trigger_AmmunitionDepleted:new(...)end;B_Trigger_AmmunitionDepleted={Name="Trigger_AmmunitionDepleted",Description={en="Trigger: if the ammunition of the entity is depleted.",de="Auslöser: wenn die Munition der Entity aufgebraucht ist.",fr="Déclencheur: lorsque les munitions de l'entité sont épuisées."},Parameter={{ParameterType.Scriptname,en="Script name",de="Skriptname",fr="Nom de l'entité"}}}function B_Trigger_AmmunitionDepleted:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_AmmunitionDepleted:AddParameter(m,n)if m==0 then self.Scriptname=n end end;function B_Trigger_AmmunitionDepleted:CustomFunction()if not IsExisting(self.Scriptname)then return false end;local aL=GetID(self.Scriptname)if Logic.GetAmmunitionAmount(aL)>0 then return false end;return true end;function B_Trigger_AmmunitionDepleted:Debug(l)if not IsExisting(self.Scriptname)then error(l.Identifier..": "..self.Name..": '"..self.Scriptname.."' is destroyed!")return true end;return false end;RegisterBehavior(B_Trigger_AmmunitionDepleted)B_Reward_TradePost.DEBUG_Orig_Warehouse=B_Reward_TradePost.DEBUG;B_Reward_TradePost.DEBUG=function(self,l)local bJ=Lib.Warehouse.Global:GetIndex(self.ScriptName)if bJ~=0 then debug(false,l.Identifier..": Error in "..self.Name..": Can not use a tradepost that is already a warehouse!")return false end;return self:DEBUG_Orig_Warehouse(l)end;B_Reward_TradePost.CustomFunction_Orig_Warehouse=B_Reward_TradePost.CustomFunction;B_Reward_TradePost.CustomFunction=function(self,l)local bJ=Lib.Warehouse.Global:GetIndex(self.ScriptName)if bJ~=0 then debug(false,l.Identifier..": Error in "..self.Name..": Can not use a tradepost that is already a warehouse!")return end;self:CustomFunction_Orig_Warehouse(l)end;function Reprisal_Briefing(bK,bL)return B_Reprisal_Briefing:new(bK,bL)end;B_Reprisal_Briefing={Name="Reprisal_Briefing",Description={en="Reprisal: Calls a function to start an new briefing.",de="Vergeltung: Ruft die Funktion auf und startet das enthaltene Briefing.",fr="Rétribution: Appelle la fonction et démarre le briefing qu'elle contient."},Parameter={{ParameterType.Default,en="Briefing name",de="Name des Briefing",fr="Nom du briefing"},{ParameterType.Default,en="Briefing function",de="Funktion mit Briefing",fr="Fonction avec briefing"}}}function B_Reprisal_Briefing:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_Briefing:AddParameter(m,n)if m==0 then self.BriefingName=n elseif m==1 then self.Function=n end end;function B_Reprisal_Briefing:CustomFunction(l)_G[self.Function](self.BriefingName,l.ReceivingPlayer)end;function B_Reprisal_Briefing:Debug(l)if self.BriefingName==nil or self.BriefingName==""then debug(false,string.format("%s: %s: Dialog name is invalid!",l.Identifier,self.Name))return true end;if not type(_G[self.Function])=="function"then debug(false,l.Identifier..": "..self.Name..": '"..self.Function.."' was not found!")return true end;return false end;if MapEditor or Lib.BriefingSystem then RegisterBehavior(B_Reprisal_Briefing)end;function Reward_Briefing(bK,bL)return B_Reward_Briefing:new(bK,bL)end;B_Reward_Briefing=CopyTable(B_Reprisal_Briefing)B_Reward_Briefing.Name="Reward_Briefing"B_Reward_Briefing.Description.en="Reward: Calls a function to start an new briefing."B_Reward_Briefing.Description.de="Lohn: Ruft die Funktion auf und startet das enthaltene Briefing."B_Reward_Briefing.Description.fr="Récompense: Appelle la fonction et démarre le briefing qu'elle contient."B_Reward_Briefing.GetReprisalTable=nil;B_Reward_Briefing.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;if MapEditor or Lib.BriefingSystem then RegisterBehavior(B_Reward_Briefing)end;function Trigger_Briefing(bK,G,bM)return B_Trigger_Briefing:new(bK,G,bM)end;B_Trigger_Briefing={Name="Trigger_Briefing",Description={en="Trigger: Checks if an briefing has concluded and starts the quest if so.",de="Auslöser: Prüft, ob ein Briefing beendet ist und startet dann den Quest.",fr="Déclencheur: Vérifie si un briefing est terminé et lance ensuite la quête."},Parameter={{ParameterType.Default,en="Briefing name",de="Name des Briefing",fr="Nom du briefing"},{ParameterType.PlayerID,en="Player ID",de="Player ID",fr="Player ID"},{ParameterType.Number,en="Wait time",de="Wartezeit",fr="Temps d'attente"}}}function B_Trigger_Briefing:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_Briefing:AddParameter(m,n)if m==0 then self.BriefingName=n elseif m==1 then self.PlayerID=n*1 elseif m==2 then n=n or 0;self.WaitTime=n*1 end end;function B_Trigger_Briefing:CustomFunction(l)if GetCinematicEvent(self.BriefingName,self.PlayerID)==CinematicEventState.Concluded then if self.WaitTime and self.WaitTime>0 then self.WaitTimeTimer=self.WaitTimeTimer or Logic.GetTime()if Logic.GetTime()>=self.WaitTimeTimer+self.WaitTime then return true end else return true end end;return false end;function B_Trigger_Briefing:Debug(l)if self.WaitTime<0 then debug(false,string.format("%s: %s: Wait time must be 0 or greater!",l.Identifier,self.Name))return true end;if self.PlayerID<1 or self.PlayerID>8 then debug(false,string.format("%s: %s: Player-ID must be between 1 and 8!",l.Identifier,self.Name))return true end;if self.BriefingName==nil or self.BriefingName==""then debug(false,string.format("%s: %s: Dialog name is invalid!",l.Identifier,self.Name))return true end;return false end;if MapEditor or Lib.BriefingSystem then RegisterBehavior(B_Trigger_Briefing)end;function Reprisal_Cutscene(bK,bN)return B_Reprisal_Cutscene:new(bK,bN)end;B_Reprisal_Cutscene={Name="Reprisal_Cutscene",Description={en="Reprisal: Calls a function to start an new Cutscene.",de="Vergeltung: Ruft die Funktion auf und startet die enthaltene Cutscene.",fr="Rétribution : Appelle la fonction et démarre la cutscene contenue."},Parameter={{ParameterType.Default,en="Cutscene name",de="Name der Cutscene",fr="Nom de la cutscene"},{ParameterType.Default,en="Cutscene function",de="Funktion mit Cutscene",fr="Fonction avec cutscene"}}}function B_Reprisal_Cutscene:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_Cutscene:AddParameter(m,n)if m==0 then self.CutsceneName=n elseif m==1 then self.Function=n end end;function B_Reprisal_Cutscene:CustomFunction(l)_G[self.Function](self.CutsceneName,l.ReceivingPlayer)end;function B_Reprisal_Cutscene:Debug(l)if self.CutsceneName==nil or self.CutsceneName==""then debug(false,string.format("%s: %s: Dialog name is invalid!",l.Identifier,self.Name))return true end;if not type(_G[self.Function])=="function"then debug(false,l.Identifier..": "..self.Name..": '"..self.Function.."' was not found!")return true end;return false end;if MapEditor or Lib.CutsceneSystem then RegisterBehavior(B_Reprisal_Cutscene)end;function Reward_Cutscene(bK,bN)return B_Reward_Cutscene:new(bK,bN)end;B_Reward_Cutscene=CopyTable(B_Reprisal_Cutscene)B_Reward_Cutscene.Name="Reward_Cutscene"B_Reward_Cutscene.Description.en="Reward: Calls a function to start an new Cutscene."B_Reward_Cutscene.Description.de="Lohn: Ruft die Funktion auf und startet die enthaltene Cutscene."B_Reward_Cutscene.Description.fr="Récompense: Appelle la fonction et démarre la cutscene contenue."B_Reward_Cutscene.GetReprisalTable=nil;B_Reward_Cutscene.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;if MapEditor or Lib.CutsceneSystem then RegisterBehavior(B_Reward_Cutscene)end;function Trigger_Cutscene(bK,G,bM)return B_Trigger_Cutscene:new(bK,G,bM)end;B_Trigger_Cutscene={Name="Trigger_Cutscene",Description={en="Trigger: Checks if an Cutscene has concluded and starts the quest if so.",de="Auslöser: Prüft, ob eine Cutscene beendet ist und startet dann den Quest.",fr="Déclencheur: Vérifie si une cutscene est terminée et démarre ensuite la quête."},Parameter={{ParameterType.Default,en="Cutscene name",de="Name der Cutscene",fr="Nom de la cutscene"},{ParameterType.PlayerID,en="Player ID",de="Player ID",fr="Player ID"},{ParameterType.Number,en="Wait time",de="Wartezeit",fr="Temps d'attente"}}}function B_Trigger_Cutscene:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_Cutscene:AddParameter(m,n)if m==0 then self.CutsceneName=n elseif m==1 then self.PlayerID=n*1 elseif m==2 then n=n or 0;self.WaitTime=n*1 end end;function B_Trigger_Cutscene:CustomFunction(l)if GetCinematicEvent(self.CutsceneName,self.PlayerID)==CinematicEventState.Concluded then if self.WaitTime and self.WaitTime>0 then self.WaitTimeTimer=self.WaitTimeTimer or Logic.GetTime()if Logic.GetTime()>=self.WaitTimeTimer+self.WaitTime then return true end else return true end end;return false end;function B_Trigger_Cutscene:Debug(l)if self.WaitTime<0 then debug(false,string.format("%s: %s: Wait time must be 0 or greater!",l.Identifier,self.Name))return true end;if self.PlayerID<1 or self.PlayerID>8 then debug(false,string.format("%s: %s: Player-ID must be between 1 and 8!",l.Identifier,self.Name))return true end;if self.CutsceneName==nil or self.CutsceneName==""then debug(false,string.format("%s: %s: Dialog name is invalid!",l.Identifier,self.Name))return true end;return false end;if MapEditor or Lib.CutsceneSystem then RegisterBehavior(B_Trigger_Cutscene)end;function Reprisal_Dialog(bK,bO)return B_Reprisal_Dialog:new(bK,bO)end;B_Reprisal_Dialog={Name="Reprisal_Dialog",Description={en="Reprisal: Calls a function to start an new dialog.",de="Vergeltung: Ruft die Funktion auf und startet das enthaltene Dialog.",fr="Rétribution: Appelle la fonction et démarre le dialogue contenu."},Parameter={{ParameterType.Default,en="Dialog name",de="Name des Dialog",fr="Nom du dialogue"},{ParameterType.Default,en="Dialog function",de="Funktion mit Dialog",fr="Fonction du dialogue"}}}function B_Reprisal_Dialog:GetReprisalTable()return{Reprisal.Custom,{self,self.CustomFunction}}end;function B_Reprisal_Dialog:AddParameter(m,n)if m==0 then self.DialogName=n elseif m==1 then self.Function=n end end;function B_Reprisal_Dialog:CustomFunction(l)_G[self.Function](self.DialogName,l.ReceivingPlayer)end;function B_Reprisal_Dialog:Debug(l)if self.DialogName==nil or self.DialogName==""then debug(false,string.format("%s: %s: Dialog name is invalid!",l.Identifier,self.Name))return true end;if not type(_G[self.Function])=="function"then debug(false,l.Identifier..": "..self.Name..": '"..self.Function.."' was not found!")return true end;return false end;if MapEditor or Lib.DialogSystem then RegisterBehavior(B_Reprisal_Dialog)end;function Reward_Dialog(bK,bO)return B_Reward_Dialog:new(bK,bO)end;B_Reward_Dialog=CopyTable(B_Reprisal_Dialog)B_Reward_Dialog.Name="Reward_Dialog"B_Reward_Dialog.Description.en="Reward: Calls a function to start an new dialog."B_Reward_Dialog.Description.de="Lohn: Ruft die Funktion auf und startet das enthaltene Dialog."B_Reward_Dialog.Description.fr="Récompense: Appelle la fonction et lance le dialogue qu'elle contient."B_Reward_Dialog.GetReprisalTable=nil;B_Reward_Dialog.GetRewardTable=function(self,l)return{Reward.Custom,{self,self.CustomFunction}}end;if MapEditor or Lib.DialogSystem then RegisterBehavior(B_Reward_Dialog)end;function Trigger_Dialog(bK,G,bM)return B_Trigger_Dialog:new(bK,G,bM)end;B_Trigger_Dialog={Name="Trigger_Dialog",Description={en="Trigger: Checks if an dialog has concluded and starts the quest if so.",de="Auslöser: Prüft, ob ein Dialog beendet ist und startet dann den Quest.",fr="Déclencheur: Vérifie si un dialogue est terminé et démarre alors la quête."},Parameter={{ParameterType.Default,en="Dialog name",de="Name des Dialog",fr="Nom du dialogue"},{ParameterType.PlayerID,en="Player ID",de="Player ID",fr="Player ID"},{ParameterType.Number,en="Wait time",de="Wartezeit",fr="Temps d'attente"}}}function B_Trigger_Dialog:GetTriggerTable()return{Triggers.Custom2,{self,self.CustomFunction}}end;function B_Trigger_Dialog:AddParameter(m,n)if m==0 then self.DialogName=n elseif m==1 then self.PlayerID=n*1 elseif m==2 then n=n or 0;self.WaitTime=n*1 end end;function B_Trigger_Dialog:CustomFunction(l)if GetCinematicEvent(self.DialogName,self.PlayerID)==CinematicEventState.Concluded then if self.WaitTime and self.WaitTime>0 then self.WaitTimeTimer=self.WaitTimeTimer or Logic.GetTime()if Logic.GetTime()>=self.WaitTimeTimer+self.WaitTime then return true end else return true end end;return false end;function B_Trigger_Dialog:Debug(l)if self.WaitTime<0 then debug(false,string.format("%s: %s: Wait time must be 0 or greater!",l.Identifier,self.Name))return true end;if self.PlayerID<1 or self.PlayerID>8 then debug(false,string.format("%s: %s: Player-ID must be between 1 and 8!",l.Identifier,self.Name))return true end;if self.DialogName==nil or self.DialogName==""then debug(false,string.format("%s: %s: Dialog name is invalid!",l.Identifier,self.Name))return true end;return false end;if MapEditor or Lib.DialogSystem then RegisterBehavior(B_Trigger_Dialog)end